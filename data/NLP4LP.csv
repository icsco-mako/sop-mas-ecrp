description,solution,problem_info,parameters,optimus_code
"Mrs. Watson wants to invest in the real-estate market and has a total budget of at most $760000. She has two choices which include condos and detached houses. Each dollar invested in condos yields a $0.50 profit and each dollar invested in detached houses yields a $1 profit. A minimum of 20% of all money invested must be in condos, and at least $20000 must be in detached houses. Formulate an LP that can be used to maximize total profit earned from Mrs. Watson's investment.","{""variables"": {""InvestmentCondos"": 152000.0, ""InvestmentDetachedHouses"": 608000.0}, ""objective"": 684000.0}","{""parametrized_description"": ""Maximize the sum of ProfitPerDollarCondos multiplied by the investment in condos and ProfitPerDollarDetachedHouses multiplied by the investment in detached houses. The total investment must not exceed TotalBudget. The investment in condos must be at least MinimumPercentageCondos of the total investment. The investment in detached houses must be at least MinimumInvestmentDetachedHouses. All investment amounts must be non-negative."", ""keywords"": [""N.A.""], ""parameters"": {""TotalBudget"": {""description"": ""Total budget available for investment"", ""shape"": []}, ""ProfitPerDollarCondos"": {""description"": ""Profit per dollar invested in condos"", ""shape"": []}, ""ProfitPerDollarDetachedHouses"": {""description"": ""Profit per dollar invested in detached houses"", ""shape"": []}, ""MinimumPercentageCondos"": {""description"": ""Minimum percentage of total investment that must be in condos"", ""shape"": []}, ""MinimumInvestmentDetachedHouses"": {""description"": ""Minimum investment required in detached houses"", ""shape"": []}}, ""variables"": {""InvestmentCondos"": {""description"": ""The amount invested in condos"", ""type"": ""continuous"", ""shape"": []}, ""InvestmentDetachedHouses"": {""description"": ""The amount invested in detached houses"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total investment must not exceed TotalBudget."", ""formulation"": ""InvestmentCondos + InvestmentDetachedHouses \\leq TotalBudget"", ""code"": {""gurobipy"": ""model.addConstr(InvestmentCondos + InvestmentDetachedHouses <= TotalBudget)""}}, {""description"": ""The investment in condos must be at least MinimumPercentageCondos of the total investment."", ""formulation"": ""InvestmentCondos \\geq MinimumPercentageCondos \\left( InvestmentCondos + InvestmentDetachedHouses \\right)"", ""code"": {""gurobipy"": ""model.addConstr(InvestmentCondos >= MinimumPercentageCondos * (InvestmentCondos + InvestmentDetachedHouses))""}}, {""description"": ""The investment in detached houses must be at least MinimumInvestmentDetachedHouses."", ""formulation"": ""InvestmentDetachedHouses \\geq MinimumInvestmentDetachedHouses"", ""code"": {""gurobipy"": ""model.addConstr(InvestmentDetachedHouses >= MinimumInvestmentDetachedHouses)""}}, {""description"": ""All investment amounts must be non-negative."", ""formulation"": ""InvestmentCondos \\geq 0 \\n InvestmentDetachedHouses \\geq 0"", ""code"": {""gurobipy"": ""model.addConstr(InvestmentCondos >= 0)\nmodel.addConstr(InvestmentDetachedHouses >= 0)""}}], ""objective"": {""description"": ""Maximize the sum of ProfitPerDollarCondos multiplied by the investment in condos and ProfitPerDollarDetachedHouses multiplied by the investment in detached houses."", ""formulation"": ""Max \\ ProfitPerDollarCondos \\times InvestmentCondos + ProfitPerDollarDetachedHouses \\times InvestmentDetachedHouses"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPerDollarCondos * InvestmentCondos + ProfitPerDollarDetachedHouses * InvestmentDetachedHouses, GRB.MAXIMIZE)""}}}","{""TotalBudget"": 760000, ""ProfitPerDollarCondos"": 0.5, ""ProfitPerDollarDetachedHouses"": 1.0, ""MinimumPercentageCondos"": 0.2, ""MinimumInvestmentDetachedHouses"": 20000}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Maximize the sum of ProfitPerDollarCondos multiplied by the investment in condos
and ProfitPerDollarDetachedHouses multiplied by the investment in detached
houses. The total investment must not exceed TotalBudget. The investment in
condos must be at least MinimumPercentageCondos of the total investment. The
investment in detached houses must be at least MinimumInvestmentDetachedHouses.
All investment amounts must be non-negative.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/1/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalBudget @Def: Total budget available for investment @Shape: [] 
TotalBudget = data['TotalBudget']
# @Parameter ProfitPerDollarCondos @Def: Profit per dollar invested in condos @Shape: [] 
ProfitPerDollarCondos = data['ProfitPerDollarCondos']
# @Parameter ProfitPerDollarDetachedHouses @Def: Profit per dollar invested in detached houses @Shape: [] 
ProfitPerDollarDetachedHouses = data['ProfitPerDollarDetachedHouses']
# @Parameter MinimumPercentageCondos @Def: Minimum percentage of total investment that must be in condos @Shape: [] 
MinimumPercentageCondos = data['MinimumPercentageCondos']
# @Parameter MinimumInvestmentDetachedHouses @Def: Minimum investment required in detached houses @Shape: [] 
MinimumInvestmentDetachedHouses = data['MinimumInvestmentDetachedHouses']

# Variables 
# @Variable InvestmentCondos @Def: The amount invested in condos @Shape: [] 
InvestmentCondos = model.addVar(vtype=GRB.CONTINUOUS, name=""InvestmentCondos"")
# @Variable InvestmentDetachedHouses @Def: The amount invested in detached houses @Shape: [] 
InvestmentDetachedHouses = model.addVar(vtype=GRB.CONTINUOUS, lb=MinimumInvestmentDetachedHouses, name=""InvestmentDetachedHouses"")

# Constraints 
# @Constraint Constr_1 @Def: The total investment must not exceed TotalBudget.
model.addConstr(InvestmentCondos + InvestmentDetachedHouses <= TotalBudget)
# @Constraint Constr_2 @Def: The investment in condos must be at least MinimumPercentageCondos of the total investment.
model.addConstr(InvestmentCondos >= MinimumPercentageCondos * (InvestmentCondos + InvestmentDetachedHouses))
# @Constraint Constr_3 @Def: The investment in detached houses must be at least MinimumInvestmentDetachedHouses.
model.addConstr(InvestmentDetachedHouses >= MinimumInvestmentDetachedHouses)
# @Constraint Constr_4 @Def: All investment amounts must be non-negative.
model.addConstr(InvestmentCondos >= 0)
model.addConstr(InvestmentDetachedHouses >= 0)

# Objective 
# @Objective Objective @Def: Maximize the sum of ProfitPerDollarCondos multiplied by the investment in condos and ProfitPerDollarDetachedHouses multiplied by the investment in detached houses.
model.setObjective(ProfitPerDollarCondos * InvestmentCondos + ProfitPerDollarDetachedHouses * InvestmentDetachedHouses, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['InvestmentCondos'] = InvestmentCondos.x
variables['InvestmentDetachedHouses'] = InvestmentDetachedHouses.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
A breakfast joint makes two different sandwiches: a regular and a special. Both need eggs and bacon. Each regular sandwich requires 2 eggs and 3 slices of bacon. Each special sandwich requires 3 eggs and 5 slices of bacon. The joint has a total of 40 eggs and 70 slices of bacon. It makes a profit of $3 per regular sandwich and a profit of $4 per special sandwich. How many of each sandwich should be made to maximize profit?,"{""variables"": {""NumSandwiches"": {""0"": 20.0, ""1"": 0.0}}, ""objective"": 60.0}","{""parametrized_description"": ""A breakfast joint produces NumSandwichTypes different types of sandwiches using NumIngredients different ingredients. The amount of each ingredient required for each sandwich type is specified by Required. The total availability of each ingredient is given by TotalAvailable. The profit earned per unit of each sandwich type is defined by ProfitPerSandwich. The objective is to determine the number of each sandwich type to produce in order to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""NumSandwichTypes"": {""description"": ""Number of different sandwich types"", ""shape"": []}, ""NumIngredients"": {""description"": ""Number of different ingredients"", ""shape"": []}, ""Required"": {""description"": ""Amount of ingredient j required to produce one unit of sandwich i"", ""shape"": [""NumIngredients"", ""NumSandwichTypes""]}, ""TotalAvailable"": {""description"": ""Total availability of ingredient j"", ""shape"": [""NumIngredients""]}, ""ProfitPerSandwich"": {""description"": ""Profit per unit of sandwich i"", ""shape"": [""NumSandwichTypes""]}}, ""variables"": {""NumSandwiches"": {""description"": ""The number of sandwiches to produce for each sandwich type"", ""type"": ""continuous"", ""shape"": [""NumSandwichTypes""]}}, ""constraints"": [{""description"": ""The total usage of eggs for producing regular and special sandwiches does not exceed the total available eggs."", ""formulation"": ""\\sum_{i=1}^{NumSandwichTypes} Required_{eggs,i} \\cdot NumSandwiches_i \\leq TotalAvailable_{eggs}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(Required[0, i] * NumSandwiches[i] for i in range(NumSandwichTypes)) <= TotalAvailable[0])""}}, {""description"": ""The total usage of bacon for producing regular and special sandwiches does not exceed the total available bacon."", ""formulation"": ""\\sum_{i=1}^{\\text{NumSandwichTypes}} \\text{Required}_{j,i} \\cdot \\text{NumSandwiches}_i \\leq \\text{TotalAvailable}_j"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(Required[j, i] * NumSandwiches[i] for i in range(NumSandwichTypes)) <= TotalAvailable[j])""}}, {""description"": ""The number of regular and special sandwiches produced is non-negative."", ""formulation"": ""NumSandwiches \\geq 0"", ""code"": {""gurobipy"": ""model.addConstrs((NumSandwiches[i] >= 0 for i in range(NumSandwichTypes)), 'NumSandwichesNonNegative')""}}], ""objective"": {""description"": ""The total profit is the sum of the profit per sandwich type multiplied by the number of sandwiches produced. The objective is to maximize the total profit."", ""formulation"": ""Max \\sum_{i=1}^{NumSandwichTypes} ProfitPerSandwich_{i} \\times NumSandwiches_{i}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(NumSandwiches[i] * ProfitPerSandwich[i] for i in range(NumSandwichTypes)), GRB.MAXIMIZE)""}}}","{""NumSandwichTypes"": 2, ""NumIngredients"": 2, ""Required"": [[2, 3], [3, 5]], ""TotalAvailable"": [40, 70], ""ProfitPerSandwich"": [3, 4]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A breakfast joint produces NumSandwichTypes different types of sandwiches using
NumIngredients different ingredients. The amount of each ingredient required for
each sandwich type is specified by Required. The total availability of each
ingredient is given by TotalAvailable. The profit earned per unit of each
sandwich type is defined by ProfitPerSandwich. The objective is to determine the
number of each sandwich type to produce in order to maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/2/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumSandwichTypes @Def: Number of different sandwich types @Shape: [] 
NumSandwichTypes = data['NumSandwichTypes']
# @Parameter NumIngredients @Def: Number of different ingredients @Shape: [] 
NumIngredients = data['NumIngredients']
# @Parameter Required @Def: Amount of ingredient j required to produce one unit of sandwich i @Shape: ['NumIngredients', 'NumSandwichTypes'] 
Required = data['Required']
# @Parameter TotalAvailable @Def: Total availability of ingredient j @Shape: ['NumIngredients'] 
TotalAvailable = data['TotalAvailable']
# @Parameter ProfitPerSandwich @Def: Profit per unit of sandwich i @Shape: ['NumSandwichTypes'] 
ProfitPerSandwich = data['ProfitPerSandwich']

# Variables 
# @Variable NumSandwiches @Def: The number of sandwiches to produce for each sandwich type @Shape: ['NumSandwichTypes'] 
NumSandwiches = model.addVars(NumSandwichTypes, vtype=GRB.CONTINUOUS, name=""NumSandwiches"")

# Constraints 
# @Constraint Constr_1 @Def: The total usage of eggs for producing regular and special sandwiches does not exceed the total available eggs.
model.addConstr(quicksum(Required[0][i] * NumSandwiches[i] for i in range(NumSandwichTypes)) <= TotalAvailable[0], ""Constr_1"")
# @Constraint Constr_2 @Def: The total usage of bacon for producing regular and special sandwiches does not exceed the total available bacon.
model.addConstr(quicksum(Required[1][i] * NumSandwiches[i] for i in range(NumSandwichTypes)) <= TotalAvailable[1], ""Constr_2"")
# @Constraint Constr_3 @Def: The number of regular and special sandwiches produced is non-negative.
model.addConstrs((NumSandwiches[i] >= 0 for i in range(NumSandwichTypes)), 'NumSandwichesNonNegative')

# Objective 
# @Objective Objective @Def: The total profit is the sum of the profit per sandwich type multiplied by the number of sandwiches produced. The objective is to maximize the total profit.
model.setObjective(quicksum(NumSandwiches[i] * ProfitPerSandwich[i] for i in range(NumSandwichTypes)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumSandwiches'] = {i: NumSandwiches[i].X for i in range(NumSandwichTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A cleaning company located in Edmonton wants to get the best exposure possible for promoting their new dishwashing detergent without exceeding their $250,000 advertising budget. To do so, the company decides to spend their money on two forms of advertising: (1) radio ads and (2) social media ads. Each radio ad costs $5,000; each social media ad costs $9,150. The expected exposure, based on industry ratings, is 60,500 viewers for each radio ad. Additionally, the expected exposure for each social media ad is 50,000 viewers. The company decides that at least 15 but no more than 40 radio ads should be ordered, and that at least 35 social media ads should be contracted. How many ads of each type should be run to obtain maximum exposure while staying within the budget?",{},"{""parametrized_description"": ""A cleaning company aims to maximize exposure for promoting a new product without exceeding AdvertisingBudget. They allocate funds to two advertising methods: radio ads and social media ads. Each radio ad incurs a cost of CostRadioAd and yields ExposureRadioAd expected viewers. Each social media ad costs CostSocialMediaAd and generates ExposureSocialMediaAd expected viewers. The company decides that the number of radio ads must be at least MinRadioAds and at most MaxRadioAds, and that at least MinSocialMediaAds social media ads should be contracted. Determine the number of each type of advertisement to maximize total exposure while remaining within the advertising budget."", ""keywords"": [""N.A.""], ""parameters"": {""AdvertisingBudget"": {""description"": ""The total advertising budget available"", ""shape"": []}, ""CostRadioAd"": {""description"": ""Cost of one radio advertisement"", ""shape"": []}, ""CostSocialMediaAd"": {""description"": ""Cost of one social media advertisement"", ""shape"": []}, ""ExposureRadioAd"": {""description"": ""Expected exposure (viewers) for each radio advertisement"", ""shape"": []}, ""ExposureSocialMediaAd"": {""description"": ""Expected exposure (viewers) for each social media advertisement"", ""shape"": []}, ""MinRadioAds"": {""description"": ""Minimum number of radio advertisements to be ordered"", ""shape"": []}, ""MaxRadioAds"": {""description"": ""Maximum number of radio advertisements to be ordered"", ""shape"": []}, ""MinSocialMediaAds"": {""description"": ""Minimum number of social media advertisements to be contracted"", ""shape"": []}}, ""variables"": {""NumberRadioAds"": {""description"": ""The number of radio advertisements to be ordered"", ""type"": ""continuous"", ""shape"": []}, ""NumberSocialMediaAds"": {""description"": ""The number of social media advertisements to be contracted"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total cost of radio ads and social media ads cannot exceed the AdvertisingBudget."", ""formulation"": ""CostRadioAd \\cdot NumberRadioAds + CostSocialMediaAd \\cdot NumberSocialMediaAds \\leq AdvertisingBudget"", ""code"": {""gurobipy"": ""model.addConstr(CostRadioAd * NumberRadioAds + CostSocialMediaAd * NumberSocialMediaAds <= AdvertisingBudget)""}}, {""description"": ""The number of radio ads must be at least MinRadioAds and at most MaxRadioAds."", ""formulation"": ""MinRadioAds \\leq NumberRadioAds \\n NumberRadioAds \\leq MaxRadioAds"", ""code"": {""gurobipy"": ""model.addConstr(NumberRadioAds >= MinRadioAds)\nmodel.addConstr(NumberRadioAds <= MaxRadioAds)""}}, {""description"": ""At least MinSocialMediaAds social media ads must be contracted."", ""formulation"": ""NumberSocialMediaAds \\geq MinSocialMediaAds"", ""code"": {""gurobipy"": ""model.addConstr(NumberSocialMediaAds >= MinSocialMediaAds)""}}], ""objective"": {""description"": ""Maximize total exposure, which is the sum of expected viewers from radio ads and social media ads, while remaining within the advertising budget and satisfying constraints on the number of each type of advertisement."", ""formulation"": ""Max \\ ExposureRadioAd \\times NumberRadioAds + ExposureSocialMediaAd \\times NumberSocialMediaAds"", ""code"": {""gurobipy"": ""model.setObjective(ExposureRadioAd * NumberRadioAds + ExposureSocialMediaAd * NumberSocialMediaAds, GRB.MAXIMIZE)""}}}","{""AdvertisingBudget"": 250000, ""CostRadioAd"": 5000, ""CostSocialMediaAd"": 9150, ""ExposureRadioAd"": 60500, ""ExposureSocialMediaAd"": 50000, ""MinRadioAds"": 15, ""MaxRadioAds"": 40, ""MinSocialMediaAds"": 35}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A cleaning company aims to maximize exposure for promoting a new product without
exceeding AdvertisingBudget. They allocate funds to two advertising methods:
radio ads and social media ads. Each radio ad incurs a cost of CostRadioAd and
yields ExposureRadioAd expected viewers. Each social media ad costs
CostSocialMediaAd and generates ExposureSocialMediaAd expected viewers. The
company decides that the number of radio ads must be at least MinRadioAds and at
most MaxRadioAds, and that at least MinSocialMediaAds social media ads should be
contracted. Determine the number of each type of advertisement to maximize total
exposure while remaining within the advertising budget.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/3/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter AdvertisingBudget @Def: The total advertising budget available @Shape: [] 
AdvertisingBudget = data['AdvertisingBudget']
# @Parameter CostRadioAd @Def: Cost of one radio advertisement @Shape: [] 
CostRadioAd = data['CostRadioAd']
# @Parameter CostSocialMediaAd @Def: Cost of one social media advertisement @Shape: [] 
CostSocialMediaAd = data['CostSocialMediaAd']
# @Parameter ExposureRadioAd @Def: Expected exposure (viewers) for each radio advertisement @Shape: [] 
ExposureRadioAd = data['ExposureRadioAd']
# @Parameter ExposureSocialMediaAd @Def: Expected exposure (viewers) for each social media advertisement @Shape: [] 
ExposureSocialMediaAd = data['ExposureSocialMediaAd']
# @Parameter MinRadioAds @Def: Minimum number of radio advertisements to be ordered @Shape: [] 
MinRadioAds = data['MinRadioAds']
# @Parameter MaxRadioAds @Def: Maximum number of radio advertisements to be ordered @Shape: [] 
MaxRadioAds = data['MaxRadioAds']
# @Parameter MinSocialMediaAds @Def: Minimum number of social media advertisements to be contracted @Shape: [] 
MinSocialMediaAds = data['MinSocialMediaAds']

# Variables 
# @Variable NumberRadioAds @Def: The number of radio advertisements to be ordered @Shape: [] 
NumberRadioAds = model.addVar(vtype=GRB.INTEGER, lb=MinRadioAds, ub=MaxRadioAds, name=""NumberRadioAds"")
# @Variable NumberSocialMediaAds @Def: The number of social media advertisements to be contracted @Shape: [] 
NumberSocialMediaAds = model.addVar(vtype=GRB.INTEGER, lb=MinSocialMediaAds, name=""NumberSocialMediaAds"")

# Constraints 
# @Constraint Constr_1 @Def: The total cost of radio ads and social media ads cannot exceed the AdvertisingBudget.
model.addConstr(CostRadioAd * NumberRadioAds + CostSocialMediaAd * NumberSocialMediaAds <= AdvertisingBudget)
# @Constraint Constr_2 @Def: The number of radio ads must be at least MinRadioAds and at most MaxRadioAds.
model.addConstr(NumberRadioAds >= MinRadioAds)
model.addConstr(NumberRadioAds <= MaxRadioAds)
# @Constraint Constr_3 @Def: At least MinSocialMediaAds social media ads must be contracted.
model.addConstr(NumberSocialMediaAds >= MinSocialMediaAds)

# Objective 
# @Objective Objective @Def: Maximize total exposure, which is the sum of expected viewers from radio ads and social media ads, while remaining within the advertising budget and satisfying constraints on the number of each type of advertisement.
model.setObjective(ExposureRadioAd * NumberRadioAds + ExposureSocialMediaAd * NumberSocialMediaAds, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberRadioAds'] = NumberRadioAds.x
variables['NumberSocialMediaAds'] = NumberSocialMediaAds.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"There is 1000 mg of gold available that is needed to make long and short cables. Long cables require 10 mg of gold while short cables require 7 mg of gold. Because of their compact size, at least 5 times the number of short cables are needed than the long cables. In addition, there needs to be at least 10 long cables made. If each long cable sold results in a $12 profit and each short cable sold results in a $5 profit, how many of each type of cable should be made to maximize profit?","{""variables"": {""NumberLongCables"": 22.0, ""NumberShortCables"": 111.0}, ""objective"": 819.0}","{""parametrized_description"": ""There is TotalGold available to produce long and short cables. Each long cable requires GoldPerLong amount of gold, while each short cable requires GoldPerShort amount of gold. At least MinShortToLongRatio times the number of long cables must be produced as short cables. Additionally, a minimum of MinLongCables long cables must be made. Each long cable sold generates a ProfitPerLong profit, and each short cable sold generates a ProfitPerShort profit. Determine the number of each type of cable to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""TotalGold"": {""description"": ""Total amount of gold available"", ""shape"": []}, ""GoldPerLong"": {""description"": ""Amount of gold required to produce one long cable"", ""shape"": []}, ""GoldPerShort"": {""description"": ""Amount of gold required to produce one short cable"", ""shape"": []}, ""MinShortToLongRatio"": {""description"": ""Minimum ratio of the number of short cables to long cables"", ""shape"": []}, ""MinLongCables"": {""description"": ""Minimum number of long cables to be made"", ""shape"": []}, ""ProfitPerLong"": {""description"": ""Profit earned per long cable sold"", ""shape"": []}, ""ProfitPerShort"": {""description"": ""Profit earned per short cable sold"", ""shape"": []}}, ""variables"": {""NumberLongCables"": {""description"": ""The number of long cables to produce"", ""type"": ""continuous"", ""shape"": []}, ""NumberShortCables"": {""description"": ""The number of short cables to produce"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""Each long cable requires GoldPerLong amount of gold, and each short cable requires GoldPerShort amount of gold. The total amount of gold used cannot exceed TotalGold."", ""formulation"": ""NumberLongCables \\cdot GoldPerLong + NumberShortCables \\cdot GoldPerShort \\leq TotalGold"", ""code"": {""gurobipy"": ""model.addConstr(NumberLongCables * GoldPerLong + NumberShortCables * GoldPerShort <= TotalGold)""}}, {""description"": ""At least MinShortToLongRatio times the number of long cables must be produced as short cables. Additionally, a minimum of MinLongCables long cables must be made."", ""formulation"": ""NumberShortCables \\geq MinShortToLongRatio \\times NumberLongCables \\n NumberLongCables \\geq MinLongCables"", ""code"": {""gurobipy"": ""model.addConstr(NumberShortCables >= MinShortToLongRatio * NumberLongCables)\nmodel.addConstr(NumberLongCables >= MinLongCables)""}}], ""objective"": {""description"": ""Total profit is the sum of the profits from long and short cables. The objective is to maximize total profit."", ""formulation"": ""Max \\ ProfitPerLong \\times NumberLongCables + ProfitPerShort \\times NumberShortCables"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPerLong * NumberLongCables + ProfitPerShort * NumberShortCables, GRB.MAXIMIZE)""}}}","{""TotalGold"": 1000, ""GoldPerLong"": 10, ""GoldPerShort"": 7, ""MinShortToLongRatio"": 5, ""MinLongCables"": 10, ""ProfitPerLong"": 12, ""ProfitPerShort"": 5}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
There is TotalGold available to produce long and short cables. Each long cable
requires GoldPerLong amount of gold, while each short cable requires
GoldPerShort amount of gold. At least MinShortToLongRatio times the number of
long cables must be produced as short cables. Additionally, a minimum of
MinLongCables long cables must be made. Each long cable sold generates a
ProfitPerLong profit, and each short cable sold generates a ProfitPerShort
profit. Determine the number of each type of cable to maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/4/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalGold @Def: Total amount of gold available @Shape: [] 
TotalGold = data['TotalGold']
# @Parameter GoldPerLong @Def: Amount of gold required to produce one long cable @Shape: [] 
GoldPerLong = data['GoldPerLong']
# @Parameter GoldPerShort @Def: Amount of gold required to produce one short cable @Shape: [] 
GoldPerShort = data['GoldPerShort']
# @Parameter MinShortToLongRatio @Def: Minimum ratio of the number of short cables to long cables @Shape: [] 
MinShortToLongRatio = data['MinShortToLongRatio']
# @Parameter MinLongCables @Def: Minimum number of long cables to be made @Shape: [] 
MinLongCables = data['MinLongCables']
# @Parameter ProfitPerLong @Def: Profit earned per long cable sold @Shape: [] 
ProfitPerLong = data['ProfitPerLong']
# @Parameter ProfitPerShort @Def: Profit earned per short cable sold @Shape: [] 
ProfitPerShort = data['ProfitPerShort']

# Variables 
# @Variable NumberLongCables @Def: The number of long cables to produce @Shape: [] 
NumberLongCables = model.addVar(vtype=GRB.INTEGER, name=""NumberLongCables"")
# @Variable NumberShortCables @Def: The number of short cables to produce @Shape: [] 
NumberShortCables = model.addVar(vtype=GRB.INTEGER, name=""NumberShortCables"")

# Constraints 
# @Constraint Constr_1 @Def: Each long cable requires GoldPerLong amount of gold, and each short cable requires GoldPerShort amount of gold. The total amount of gold used cannot exceed TotalGold.
model.addConstr(NumberLongCables * GoldPerLong + NumberShortCables * GoldPerShort <= TotalGold)
# @Constraint Constr_2 @Def: At least MinShortToLongRatio times the number of long cables must be produced as short cables. Additionally, a minimum of MinLongCables long cables must be made.
model.addConstr(NumberShortCables >= MinShortToLongRatio * NumberLongCables)
model.addConstr(NumberLongCables >= MinLongCables)

# Objective 
# @Objective Objective @Def: Total profit is the sum of the profits from long and short cables. The objective is to maximize total profit.
model.setObjective(ProfitPerLong * NumberLongCables + ProfitPerShort * NumberShortCables, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberLongCables'] = NumberLongCables.x
variables['NumberShortCables'] = NumberShortCables.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A store employs senior citizens who earn $500 per week and young adults who earn $750 per week. The store must keep the weekly wage bill below $30000. On any day, the store requires at least 50 workers, of whom at least 10 must be young adults. To ensure the store runs smoothly, the number of young adults should be at least a third the number of senior citizens. Formulate a LP to minimize the wage bill.","{""variables"": {""NumberOfSeniorCitizens"": 37.0, ""NumberOfYoungAdults"": 13.0}, ""objective"": 28250.0}","{""parametrized_description"": ""Minimize (SeniorWage \u00d7 NumberOfSeniorCitizens + YoungAdultWage \u00d7 NumberOfYoungAdults) subject to (SeniorWage \u00d7 NumberOfSeniorCitizens + YoungAdultWage \u00d7 NumberOfYoungAdults \u2264 MaxWeeklyWageBill), (NumberOfSeniorCitizens + NumberOfYoungAdults \u2265 MinWorkersPerDay), (NumberOfYoungAdults \u2265 MinYoungAdultsPerDay), and (NumberOfYoungAdults \u2265 MinYoungToSeniorRatio \u00d7 NumberOfSeniorCitizens)."", ""keywords"": [""N.A.""], ""parameters"": {""SeniorWage"": {""description"": ""Weekly wage rate for senior citizens"", ""shape"": []}, ""YoungAdultWage"": {""description"": ""Weekly wage rate for young adults"", ""shape"": []}, ""MaxWeeklyWageBill"": {""description"": ""Maximum weekly wage bill"", ""shape"": []}, ""MinWorkersPerDay"": {""description"": ""Minimum number of workers required per day"", ""shape"": []}, ""MinYoungAdultsPerDay"": {""description"": ""Minimum number of young adults required per day"", ""shape"": []}, ""MinYoungToSeniorRatio"": {""description"": ""Minimum ratio of young adults to senior citizens"", ""shape"": []}}, ""variables"": {""NumberOfSeniorCitizens"": {""description"": ""The number of senior citizens"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberOfYoungAdults"": {""description"": ""The number of young adults"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total weekly wage bill (SeniorWage \u00d7 NumberOfSeniorCitizens + YoungAdultWage \u00d7 NumberOfYoungAdults) must not exceed the maximum weekly wage bill (MaxWeeklyWageBill)."", ""formulation"": ""SeniorWage \\times NumberOfSeniorCitizens + YoungAdultWage \\times NumberOfYoungAdults \\leq MaxWeeklyWageBill"", ""code"": {""gurobipy"": ""model.addConstr(SeniorWage * NumberOfSeniorCitizens + YoungAdultWage * NumberOfYoungAdults <= MaxWeeklyWageBill)""}}, {""description"": ""The total number of employees (NumberOfSeniorCitizens + NumberOfYoungAdults) must be at least the minimum number of workers required per day (MinWorkersPerDay)."", ""formulation"": ""NumberOfSeniorCitizens + NumberOfYoungAdults \\geq MinWorkersPerDay"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfSeniorCitizens + NumberOfYoungAdults >= MinWorkersPerDay)""}}, {""description"": ""The number of young adults (NumberOfYoungAdults) must be at least the minimum number of young adults required per day (MinYoungAdultsPerDay)."", ""formulation"": ""NumberOfYoungAdults \\geq MinYoungAdultsPerDay"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfYoungAdults >= MinYoungAdultsPerDay)""}}, {""description"": ""The number of young adults (NumberOfYoungAdults) must be at least the product of the minimum young to senior ratio (MinYoungToSeniorRatio) and the number of senior citizens (NumberOfSeniorCitizens)."", ""formulation"": ""NumberOfYoungAdults \\geq MinYoungToSeniorRatio \\times NumberOfSeniorCitizens"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfYoungAdults >= MinYoungToSeniorRatio * NumberOfSeniorCitizens)""}}], ""objective"": {""description"": ""Minimize the total weekly wage expenses, calculated as (SeniorWage \u00d7 NumberOfSeniorCitizens + YoungAdultWage \u00d7 NumberOfYoungAdults)."", ""formulation"": ""Min SeniorWage \\times NumberOfSeniorCitizens + YoungAdultWage \\times NumberOfYoungAdults"", ""code"": {""gurobipy"": ""model.setObjective(SeniorWage * NumberOfSeniorCitizens + YoungAdultWage * NumberOfYoungAdults, GRB.MINIMIZE)""}}}","{""SeniorWage"": 500, ""YoungAdultWage"": 750, ""MaxWeeklyWageBill"": 30000, ""MinWorkersPerDay"": 50, ""MinYoungAdultsPerDay"": 10, ""MinYoungToSeniorRatio"": 0.3333333333333333}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Minimize (SeniorWage × NumberOfSeniorCitizens + YoungAdultWage ×
NumberOfYoungAdults) subject to (SeniorWage × NumberOfSeniorCitizens +
YoungAdultWage × NumberOfYoungAdults ≤ MaxWeeklyWageBill),
(NumberOfSeniorCitizens + NumberOfYoungAdults ≥ MinWorkersPerDay),
(NumberOfYoungAdults ≥ MinYoungAdultsPerDay), and (NumberOfYoungAdults ≥
MinYoungToSeniorRatio × NumberOfSeniorCitizens).
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/5/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SeniorWage @Def: Weekly wage rate for senior citizens @Shape: [] 
SeniorWage = data['SeniorWage']
# @Parameter YoungAdultWage @Def: Weekly wage rate for young adults @Shape: [] 
YoungAdultWage = data['YoungAdultWage']
# @Parameter MaxWeeklyWageBill @Def: Maximum weekly wage bill @Shape: [] 
MaxWeeklyWageBill = data['MaxWeeklyWageBill']
# @Parameter MinWorkersPerDay @Def: Minimum number of workers required per day @Shape: [] 
MinWorkersPerDay = data['MinWorkersPerDay']
# @Parameter MinYoungAdultsPerDay @Def: Minimum number of young adults required per day @Shape: [] 
MinYoungAdultsPerDay = data['MinYoungAdultsPerDay']
# @Parameter MinYoungToSeniorRatio @Def: Minimum ratio of young adults to senior citizens @Shape: [] 
MinYoungToSeniorRatio = data['MinYoungToSeniorRatio']

# Variables 
# @Variable NumberOfSeniorCitizens @Def: The number of senior citizens @Shape: ['Integer'] 
NumberOfSeniorCitizens = model.addVar(vtype=GRB.INTEGER, name=""NumberOfSeniorCitizens"")
# @Variable NumberOfYoungAdults @Def: The number of young adults @Shape: ['Integer'] 
NumberOfYoungAdults = model.addVar(vtype=GRB.INTEGER, name=""NumberOfYoungAdults"")

# Constraints 
# @Constraint Constr_1 @Def: The total weekly wage bill (SeniorWage × NumberOfSeniorCitizens + YoungAdultWage × NumberOfYoungAdults) must not exceed the maximum weekly wage bill (MaxWeeklyWageBill).
model.addConstr(SeniorWage * NumberOfSeniorCitizens + YoungAdultWage * NumberOfYoungAdults <= MaxWeeklyWageBill)
# @Constraint Constr_2 @Def: The total number of employees (NumberOfSeniorCitizens + NumberOfYoungAdults) must be at least the minimum number of workers required per day (MinWorkersPerDay).
model.addConstr(NumberOfSeniorCitizens + NumberOfYoungAdults >= MinWorkersPerDay)
# @Constraint Constr_3 @Def: The number of young adults (NumberOfYoungAdults) must be at least the minimum number of young adults required per day (MinYoungAdultsPerDay).
model.addConstr(NumberOfYoungAdults >= MinYoungAdultsPerDay)
# @Constraint Constr_4 @Def: The number of young adults (NumberOfYoungAdults) must be at least the product of the minimum young to senior ratio (MinYoungToSeniorRatio) and the number of senior citizens (NumberOfSeniorCitizens).
model.addConstr(NumberOfYoungAdults >= MinYoungToSeniorRatio * NumberOfSeniorCitizens)

# Objective 
# @Objective Objective @Def: Minimize the total weekly wage expenses, calculated as (SeniorWage × NumberOfSeniorCitizens + YoungAdultWage × NumberOfYoungAdults).
model.setObjective(SeniorWage * NumberOfSeniorCitizens + YoungAdultWage * NumberOfYoungAdults, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfSeniorCitizens'] = NumberOfSeniorCitizens.x
variables['NumberOfYoungAdults'] = NumberOfYoungAdults.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A company is deciding where to promote their product. Some options include z-tube, soorchle engine, and wassa advertisements. The cost for each option and the number of viewers they each attract is given. On z-tube, each ad costs $1000 and attracts 400,000 viewers. On soorchle, each ad costs $200 and attracts 5,000 viewers. On wassa, each ad costs $100 and attracts 3,000 viewers. Soorchle limits the number of advertisements from a single company to fifteen. Moreover, in order to balance the advertising among the three types of media, at most a third of the total number of advertisements should occur on wassa. And at least 5% should occur on z-tube. The weekly advertising budget is $10000. How many advertisements should be run in each of the three types of media to maximize the total audience?","{""variables"": {""NumberAdsZTube"": -0.0, ""NumberAdsSoorchle"": -0.0, ""NumberAdsWassa"": -0.0, ""xZ"": 1e+30, ""xS"": 1e+30, ""xW"": 9.999985000007499e+29}, ""objective"": 4.0799999550000226e+35}","{""parametrized_description"": ""Let x_Z, x_S, and x_W represent the number of advertisements on z-tube, soorchle, and wassa respectively. The objective is to maximize the total audience, which is calculated as ViewersZTube multiplied by x_Z plus ViewersSoorchle multiplied by x_S plus ViewersWassa multiplied by x_W. The constraints are as follows: the total cost, given by CostZTube times x_Z plus CostSoorchle times x_S plus CostWassa times x_W, must not exceed the WeeklyAdvertisingBudget; the number of soorchle advertisements x_S must be less than or equal to MaxAdsSoorchle; the number of wassa advertisements x_W must be at most MaxFractionWassaAds multiplied by the total number of advertisements (x_Z + x_S + x_W); and the number of z-tube advertisements x_Z must be at least MinFractionZTubeAds multiplied by the total number of advertisements (x_Z + x_S + x_W)."", ""keywords"": [""N.A.""], ""parameters"": {""CostZTube"": {""description"": ""Cost per advertisement on z-tube"", ""shape"": []}, ""ViewersZTube"": {""description"": ""Number of viewers attracted by each advertisement on z-tube"", ""shape"": []}, ""CostSoorchle"": {""description"": ""Cost per advertisement on soorchle"", ""shape"": []}, ""ViewersSoorchle"": {""description"": ""Number of viewers attracted by each advertisement on soorchle"", ""shape"": []}, ""CostWassa"": {""description"": ""Cost per advertisement on wassa"", ""shape"": []}, ""ViewersWassa"": {""description"": ""Number of viewers attracted by each advertisement on wassa"", ""shape"": []}, ""MaxAdsSoorchle"": {""description"": ""Maximum number of advertisements allowed on soorchle"", ""shape"": []}, ""MaxFractionWassaAds"": {""description"": ""Maximum fraction of total advertisements allowed on wassa"", ""shape"": []}, ""MinFractionZTubeAds"": {""description"": ""Minimum fraction of total advertisements required on z-tube"", ""shape"": []}, ""WeeklyAdvertisingBudget"": {""description"": ""Weekly advertising budget"", ""shape"": []}}, ""variables"": {""NumberAdsZTube"": {""description"": ""The number of advertisements on Z-Tube"", ""type"": ""continuous"", ""shape"": []}, ""NumberAdsSoorchle"": {""description"": ""The number of advertisements on Soorchle"", ""type"": ""continuous"", ""shape"": []}, ""NumberAdsWassa"": {""description"": ""The number of advertisements on Wassa"", ""type"": ""continuous"", ""shape"": []}, ""xZ"": {""description"": ""The number of advertisements on Z-Tube"", ""type"": ""continuous"", ""shape"": []}, ""xS"": {""description"": ""The number of advertisements on Soorchle"", ""type"": ""continuous"", ""shape"": []}, ""xW"": {""description"": ""The number of advertisements on Wassa"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total cost, given by CostZTube times x_Z plus CostSoorchle times x_S plus CostWassa times x_W, must not exceed the WeeklyAdvertisingBudget."", ""formulation"": ""CostZTube \\times NumberAdsZTube + CostSoorchle \\times NumberAdsSoorchle + CostWassa \\times NumberAdsWassa \\leq WeeklyAdvertisingBudget"", ""code"": {""gurobipy"": ""model.addConstr(CostZTube * NumberAdsZTube + CostSoorchle * NumberAdsSoorchle + CostWassa * NumberAdsWassa <= WeeklyAdvertisingBudget)""}}, {""description"": ""The number of soorchle advertisements x_S must be less than or equal to MaxAdsSoorchle."", ""formulation"": ""NumberAdsSoorchle \\leq MaxAdsSoorchle"", ""code"": {""gurobipy"": ""model.addConstr(NumberAdsSoorchle <= MaxAdsSoorchle)""}}, {""description"": ""The number of wassa advertisements x_W must be at most MaxFractionWassaAds multiplied by the total number of advertisements (x_Z + x_S + x_W)."", ""formulation"": ""xW \\leq MaxFractionWassaAds \\times \\left( xZ + xS + xW \\right )"", ""code"": {""gurobipy"": ""model.addConstr((1 - MaxFractionWassaAds) * xW <= MaxFractionWassaAds * (xZ + xS))""}}, {""description"": ""The number of z-tube advertisements x_Z must be at least MinFractionZTubeAds multiplied by the total number of advertisements (x_Z + x_S + x_W)."", ""formulation"": ""xZ \\geq MinFractionZTubeAds \\times (xZ + xS + xW)"", ""code"": {""gurobipy"": ""model.addConstr(xZ >= MinFractionZTubeAds * (xZ + xS + xW))""}}], ""objective"": {""description"": ""Maximize the total audience, which is calculated as ViewersZTube multiplied by x_Z plus ViewersSoorchle multiplied by x_S plus ViewersWassa multiplied by x_W."", ""formulation"": ""Max \\ ViewersZTube \\times x_Z + ViewersSoorchle \\times x_S + ViewersWassa \\times x_W"", ""code"": {""gurobipy"": ""model.setObjective(ViewersZTube * xZ + ViewersSoorchle * xS + ViewersWassa * xW, GRB.MAXIMIZE)""}}}","{""CostZTube"": 1000, ""ViewersZTube"": 400000, ""CostSoorchle"": 200, ""ViewersSoorchle"": 5000, ""CostWassa"": 100, ""ViewersWassa"": 3000, ""MaxAdsSoorchle"": 15, ""MaxFractionWassaAds"": 0.333333, ""MinFractionZTubeAds"": 0.05, ""WeeklyAdvertisingBudget"": 10000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Let x_Z, x_S, and x_W represent the number of advertisements on z-tube,
soorchle, and wassa respectively. The objective is to maximize the total
audience, which is calculated as ViewersZTube multiplied by x_Z plus
ViewersSoorchle multiplied by x_S plus ViewersWassa multiplied by x_W. The
constraints are as follows: the total cost, given by CostZTube times x_Z plus
CostSoorchle times x_S plus CostWassa times x_W, must not exceed the
WeeklyAdvertisingBudget; the number of soorchle advertisements x_S must be less
than or equal to MaxAdsSoorchle; the number of wassa advertisements x_W must be
at most MaxFractionWassaAds multiplied by the total number of advertisements
(x_Z + x_S + x_W); and the number of z-tube advertisements x_Z must be at least
MinFractionZTubeAds multiplied by the total number of advertisements (x_Z + x_S
+ x_W).
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/6/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CostZTube @Def: Cost per advertisement on z-tube @Shape: [] 
CostZTube = data['CostZTube']
# @Parameter ViewersZTube @Def: Number of viewers attracted by each advertisement on z-tube @Shape: [] 
ViewersZTube = data['ViewersZTube']
# @Parameter CostSoorchle @Def: Cost per advertisement on soorchle @Shape: [] 
CostSoorchle = data['CostSoorchle']
# @Parameter ViewersSoorchle @Def: Number of viewers attracted by each advertisement on soorchle @Shape: [] 
ViewersSoorchle = data['ViewersSoorchle']
# @Parameter CostWassa @Def: Cost per advertisement on wassa @Shape: [] 
CostWassa = data['CostWassa']
# @Parameter ViewersWassa @Def: Number of viewers attracted by each advertisement on wassa @Shape: [] 
ViewersWassa = data['ViewersWassa']
# @Parameter MaxAdsSoorchle @Def: Maximum number of advertisements allowed on soorchle @Shape: [] 
MaxAdsSoorchle = data['MaxAdsSoorchle']
# @Parameter MaxFractionWassaAds @Def: Maximum fraction of total advertisements allowed on wassa @Shape: [] 
MaxFractionWassaAds = data['MaxFractionWassaAds']
# @Parameter MinFractionZTubeAds @Def: Minimum fraction of total advertisements required on z-tube @Shape: [] 
MinFractionZTubeAds = data['MinFractionZTubeAds']
# @Parameter WeeklyAdvertisingBudget @Def: Weekly advertising budget @Shape: [] 
WeeklyAdvertisingBudget = data['WeeklyAdvertisingBudget']

# Variables 
# @Variable NumberAdsZTube @Def: The number of advertisements on Z-Tube @Shape: [] 
NumberAdsZTube = model.addVar(vtype=GRB.INTEGER, name=""NumberAdsZTube"")
# @Variable NumberAdsSoorchle @Def: The number of advertisements on Soorchle @Shape: [] 
NumberAdsSoorchle = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxAdsSoorchle, name=""NumberAdsSoorchle"")
# @Variable NumberAdsWassa @Def: The number of advertisements on Wassa @Shape: [] 
NumberAdsWassa = model.addVar(vtype=GRB.INTEGER, name=""NumberAdsWassa"", lb=0)
# @Variable xZ @Def: The number of advertisements on Z-Tube @Shape: [] 
xZ = model.addVar(vtype=GRB.CONTINUOUS, name=""xZ"")
# @Variable xS @Def: The number of advertisements on Soorchle @Shape: [] 
xS = model.addVar(vtype=GRB.INTEGER, name=""xS"")
# @Variable xW @Def: The number of advertisements on Wassa @Shape: [] 
xW = model.addVar(vtype=GRB.INTEGER, name=""xW"")

# Constraints 
# @Constraint Constr_1 @Def: The total cost, given by CostZTube times x_Z plus CostSoorchle times x_S plus CostWassa times x_W, must not exceed the WeeklyAdvertisingBudget.
model.addConstr(CostZTube * NumberAdsZTube + CostSoorchle * NumberAdsSoorchle + CostWassa * NumberAdsWassa <= WeeklyAdvertisingBudget)
# @Constraint Constr_2 @Def: The number of soorchle advertisements x_S must be less than or equal to MaxAdsSoorchle.
model.addConstr(NumberAdsSoorchle <= MaxAdsSoorchle)
# @Constraint Constr_3 @Def: The number of wassa advertisements x_W must be at most MaxFractionWassaAds multiplied by the total number of advertisements (x_Z + x_S + x_W).
model.addConstr((1 - MaxFractionWassaAds) * xW <= MaxFractionWassaAds * (xZ + xS))
# @Constraint Constr_4 @Def: The number of z-tube advertisements x_Z must be at least MinFractionZTubeAds multiplied by the total number of advertisements (x_Z + x_S + x_W).
model.addConstr(xZ >= MinFractionZTubeAds * (xZ + xS + xW))

# Objective 
# @Objective Objective @Def: Maximize the total audience, which is calculated as ViewersZTube multiplied by x_Z plus ViewersSoorchle multiplied by x_S plus ViewersWassa multiplied by x_W.
model.setObjective(ViewersZTube * xZ + ViewersSoorchle * xS + ViewersWassa * xW, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberAdsZTube'] = NumberAdsZTube.x
variables['NumberAdsSoorchle'] = NumberAdsSoorchle.x
variables['NumberAdsWassa'] = NumberAdsWassa.x
variables['xZ'] = xZ.x
variables['xS'] = xS.x
variables['xW'] = xW.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A chair produced by Elm Furniture yields a profit of $43, while every dresser yields a $52 profit. Each week, 17 gallons of stain and 11 lengths of oak wood are available. Each chair requires 1.4 gallons of stain and 2 lengths of oak wood, while each dresser requires 1.1 gallons of stain and 3 lengths of oak wood. Determine the maximum profit.","{""variables"": {""NumberOfChairs"": 4.0, ""NumberOfDressers"": 1.0}, ""objective"": 224.0}","{""parametrized_description"": ""A company produces chairs and dressers. Each chair yields a profit of ProfitPerChair, while each dresser yields a profit of ProfitPerDresser. Each week, AvailableStain gallons of stain and AvailableOak lengths of oak wood are available. Each chair requires StainPerChair gallons of stain and OakPerChair lengths of oak wood, while each dresser requires StainPerDresser gallons of stain and OakPerDresser lengths of oak wood. Determine the maximum profit."", ""keywords"": [""N.A.""], ""parameters"": {""ProfitPerChair"": {""description"": ""Profit per chair"", ""shape"": []}, ""ProfitPerDresser"": {""description"": ""Profit per dresser"", ""shape"": []}, ""AvailableStain"": {""description"": ""Available gallons of stain per week"", ""shape"": []}, ""AvailableOak"": {""description"": ""Available lengths of oak wood per week"", ""shape"": []}, ""StainPerChair"": {""description"": ""Gallons of stain required to produce one chair"", ""shape"": []}, ""StainPerDresser"": {""description"": ""Gallons of stain required to produce one dresser"", ""shape"": []}, ""OakPerChair"": {""description"": ""Lengths of oak wood required to produce one chair"", ""shape"": []}, ""OakPerDresser"": {""description"": ""Lengths of oak wood required to produce one dresser"", ""shape"": []}}, ""variables"": {""NumberOfChairs"": {""description"": ""The number of chairs produced per week"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfDressers"": {""description"": ""The number of dressers produced per week"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total gallons of stain used for producing chairs and dressers cannot exceed AvailableStain per week."", ""formulation"": ""StainPerChair \\cdot NumberOfChairs + StainPerDresser \\cdot NumberOfDressers \\leq AvailableStain"", ""code"": {""gurobipy"": ""model.addConstr(StainPerChair * NumberOfChairs + StainPerDresser * NumberOfDressers <= AvailableStain)""}}, {""description"": ""The total lengths of oak wood used for producing chairs and dressers cannot exceed AvailableOak per week."", ""formulation"": ""NumberOfChairs \\cdot OakPerChair + NumberOfDressers \\cdot OakPerDresser \\leq AvailableOak"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfChairs * OakPerChair + NumberOfDressers * OakPerDresser <= AvailableOak)""}}, {""description"": ""The number of chairs produced must be a non-negative integer."", ""formulation"": ""NumberOfChairs \\geq 0"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfChairs >= 0)""}}, {""description"": ""The number of dressers produced must be a non-negative integer."", ""formulation"": ""NumberOfDressers \\geq 0"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfDressers >= 0)""}}], ""objective"": {""description"": ""Maximize the total profit, which is ProfitPerChair multiplied by the number of chairs produced plus ProfitPerDresser multiplied by the number of dressers produced."", ""formulation"": ""Max ProfitPerChair \\cdot NumberOfChairs + ProfitPerDresser \\cdot NumberOfDressers"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPerChair * NumberOfChairs + ProfitPerDresser * NumberOfDressers, GRB.MAXIMIZE)""}}}","{""ProfitPerChair"": 43, ""ProfitPerDresser"": 52, ""AvailableStain"": 17, ""AvailableOak"": 11, ""StainPerChair"": 1.4, ""StainPerDresser"": 1.1, ""OakPerChair"": 2, ""OakPerDresser"": 3}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company produces chairs and dressers. Each chair yields a profit of
ProfitPerChair, while each dresser yields a profit of ProfitPerDresser. Each
week, AvailableStain gallons of stain and AvailableOak lengths of oak wood are
available. Each chair requires StainPerChair gallons of stain and OakPerChair
lengths of oak wood, while each dresser requires StainPerDresser gallons of
stain and OakPerDresser lengths of oak wood. Determine the maximum profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/7/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProfitPerChair @Def: Profit per chair @Shape: [] 
ProfitPerChair = data['ProfitPerChair']
# @Parameter ProfitPerDresser @Def: Profit per dresser @Shape: [] 
ProfitPerDresser = data['ProfitPerDresser']
# @Parameter AvailableStain @Def: Available gallons of stain per week @Shape: [] 
AvailableStain = data['AvailableStain']
# @Parameter AvailableOak @Def: Available lengths of oak wood per week @Shape: [] 
AvailableOak = data['AvailableOak']
# @Parameter StainPerChair @Def: Gallons of stain required to produce one chair @Shape: [] 
StainPerChair = data['StainPerChair']
# @Parameter StainPerDresser @Def: Gallons of stain required to produce one dresser @Shape: [] 
StainPerDresser = data['StainPerDresser']
# @Parameter OakPerChair @Def: Lengths of oak wood required to produce one chair @Shape: [] 
OakPerChair = data['OakPerChair']
# @Parameter OakPerDresser @Def: Lengths of oak wood required to produce one dresser @Shape: [] 
OakPerDresser = data['OakPerDresser']

# Variables 
# @Variable NumberOfChairs @Def: The number of chairs produced per week @Shape: [] 
NumberOfChairs = model.addVar(vtype=GRB.INTEGER, name=""NumberOfChairs"")
# @Variable NumberOfDressers @Def: The number of dressers produced per week @Shape: [] 
NumberOfDressers = model.addVar(vtype=GRB.INTEGER, lb=0, name=""NumberOfDressers"")

# Constraints 
# @Constraint Constr_1 @Def: The total gallons of stain used for producing chairs and dressers cannot exceed AvailableStain per week.
model.addConstr(StainPerChair * NumberOfChairs + StainPerDresser * NumberOfDressers <= AvailableStain)
# @Constraint Constr_2 @Def: The total lengths of oak wood used for producing chairs and dressers cannot exceed AvailableOak per week.
model.addConstr(NumberOfChairs * OakPerChair + NumberOfDressers * OakPerDresser <= AvailableOak)
# @Constraint Constr_3 @Def: The number of chairs produced must be a non-negative integer.
model.addConstr(NumberOfChairs >= 0)
# @Constraint Constr_4 @Def: The number of dressers produced must be a non-negative integer.
model.addConstr(NumberOfDressers >= 0)

# Objective 
# @Objective Objective @Def: Maximize the total profit, which is ProfitPerChair multiplied by the number of chairs produced plus ProfitPerDresser multiplied by the number of dressers produced.
model.setObjective(ProfitPerChair * NumberOfChairs + ProfitPerDresser * NumberOfDressers, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfChairs'] = NumberOfChairs.x
variables['NumberOfDressers'] = NumberOfDressers.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A farmer wants to mix his animal feeds, Feed A and Feed B, in such a way that the mixture will contain a minimum of 30 units of protein and 50 units of fat. Feed A costs $100 per kilogram and contains 10 units of protein and 8 units of fat. Feed B costs $80 per kilogram and contains 7 units of protein and 15 units of fat. Determine the minimum cost of the mixture.","{""variables"": {""QuantityFeedA"": 1.0638297872340428, ""QuantityFeedB"": 2.765957446808511}, ""objective"": 327.6595744680851}","{""parametrized_description"": ""A farmer wants to mix FeedA and FeedB such that the mixture contains at least MinProtein units of protein and at least MinFat units of fat. FeedA costs CostFeedA per kilogram and provides ProteinFeedA units of protein and FatFeedA units of fat per kilogram. FeedB costs CostFeedB per kilogram and provides ProteinFeedB units of protein and FatFeedB units of fat per kilogram. The objective is to determine the amounts of FeedA and FeedB to minimize the total cost of the mixture."", ""keywords"": [""N.A.""], ""parameters"": {""CostFeedA"": {""description"": ""Cost per kilogram of Feed A"", ""shape"": []}, ""CostFeedB"": {""description"": ""Cost per kilogram of Feed B"", ""shape"": []}, ""ProteinFeedA"": {""description"": ""Protein units per kilogram of Feed A"", ""shape"": []}, ""ProteinFeedB"": {""description"": ""Protein units per kilogram of Feed B"", ""shape"": []}, ""FatFeedA"": {""description"": ""Fat units per kilogram of Feed A"", ""shape"": []}, ""FatFeedB"": {""description"": ""Fat units per kilogram of Feed B"", ""shape"": []}, ""MinProtein"": {""description"": ""Minimum required units of protein in the mixture"", ""shape"": []}, ""MinFat"": {""description"": ""Minimum required units of fat in the mixture"", ""shape"": []}}, ""variables"": {""QuantityFeedA"": {""description"": ""The quantity of Feed A used in the mixture (in kilograms)"", ""type"": ""continuous"", ""shape"": []}, ""QuantityFeedB"": {""description"": ""The quantity of Feed B used in the mixture (in kilograms)"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""Each kilogram of FeedA provides ProteinFeedA units of protein and each kilogram of FeedB provides ProteinFeedB units of protein. The mixture must contain at least MinProtein units of protein."", ""formulation"": ""ProteinFeedA \\times QuantityFeedA + ProteinFeedB \\times QuantityFeedB \\geq MinProtein"", ""code"": {""gurobipy"": ""model.addConstr(ProteinFeedA * QuantityFeedA + ProteinFeedB * QuantityFeedB >= MinProtein)""}}, {""description"": ""Each kilogram of FeedA provides FatFeedA units of fat and each kilogram of FeedB provides FatFeedB units of fat. The mixture must contain at least MinFat units of fat."", ""formulation"": ""FatFeedA \\cdot QuantityFeedA + FatFeedB \\cdot QuantityFeedB \\geq MinFat"", ""code"": {""gurobipy"": ""model.addConstr(FatFeedA * QuantityFeedA + FatFeedB * QuantityFeedB >= MinFat)""}}], ""objective"": {""description"": ""The total cost of the mixture is CostFeedA multiplied by the amount of FeedA plus CostFeedB multiplied by the amount of FeedB. The objective is to minimize the total cost."", ""formulation"": ""Min CostFeedA \\times QuantityFeedA + CostFeedB \\times QuantityFeedB"", ""code"": {""gurobipy"": ""model.setObjective(CostFeedA * QuantityFeedA + CostFeedB * QuantityFeedB, GRB.MINIMIZE)""}}}","{""CostFeedA"": 100, ""CostFeedB"": 80, ""ProteinFeedA"": 10, ""ProteinFeedB"": 7, ""FatFeedA"": 8, ""FatFeedB"": 15, ""MinProtein"": 30, ""MinFat"": 50}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A farmer wants to mix FeedA and FeedB such that the mixture contains at least
MinProtein units of protein and at least MinFat units of fat. FeedA costs
CostFeedA per kilogram and provides ProteinFeedA units of protein and FatFeedA
units of fat per kilogram. FeedB costs CostFeedB per kilogram and provides
ProteinFeedB units of protein and FatFeedB units of fat per kilogram. The
objective is to determine the amounts of FeedA and FeedB to minimize the total
cost of the mixture.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/8/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CostFeedA @Def: Cost per kilogram of Feed A @Shape: [] 
CostFeedA = data['CostFeedA']
# @Parameter CostFeedB @Def: Cost per kilogram of Feed B @Shape: [] 
CostFeedB = data['CostFeedB']
# @Parameter ProteinFeedA @Def: Protein units per kilogram of Feed A @Shape: [] 
ProteinFeedA = data['ProteinFeedA']
# @Parameter ProteinFeedB @Def: Protein units per kilogram of Feed B @Shape: [] 
ProteinFeedB = data['ProteinFeedB']
# @Parameter FatFeedA @Def: Fat units per kilogram of Feed A @Shape: [] 
FatFeedA = data['FatFeedA']
# @Parameter FatFeedB @Def: Fat units per kilogram of Feed B @Shape: [] 
FatFeedB = data['FatFeedB']
# @Parameter MinProtein @Def: Minimum required units of protein in the mixture @Shape: [] 
MinProtein = data['MinProtein']
# @Parameter MinFat @Def: Minimum required units of fat in the mixture @Shape: [] 
MinFat = data['MinFat']

# Variables 
# @Variable QuantityFeedA @Def: The quantity of Feed A used in the mixture (in kilograms) @Shape: [] 
QuantityFeedA = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityFeedA"")
# @Variable QuantityFeedB @Def: The quantity of Feed B used in the mixture (in kilograms) @Shape: [] 
QuantityFeedB = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityFeedB"")

# Constraints 
# @Constraint Constr_1 @Def: Each kilogram of FeedA provides ProteinFeedA units of protein and each kilogram of FeedB provides ProteinFeedB units of protein. The mixture must contain at least MinProtein units of protein.
model.addConstr(ProteinFeedA * QuantityFeedA + ProteinFeedB * QuantityFeedB >= MinProtein)
# @Constraint Constr_2 @Def: Each kilogram of FeedA provides FatFeedA units of fat and each kilogram of FeedB provides FatFeedB units of fat. The mixture must contain at least MinFat units of fat.
model.addConstr(FatFeedA * QuantityFeedA + FatFeedB * QuantityFeedB >= MinFat)

# Objective 
# @Objective Objective @Def: The total cost of the mixture is CostFeedA multiplied by the amount of FeedA plus CostFeedB multiplied by the amount of FeedB. The objective is to minimize the total cost.
model.setObjective(CostFeedA * QuantityFeedA + CostFeedB * QuantityFeedB, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityFeedA'] = QuantityFeedA.x
variables['QuantityFeedB'] = QuantityFeedB.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An artisan makes two types of terracotta jars: a thin jar and a stubby jar. Each thin jar requires 50 minutes of shaping time and 90 minutes of baking time. Each stubby jar requires 30 minutes of shaping time and 150 minutes of baking time. Per week, there are 3000 minutes available for shaping and 4000 minutes available for baking. The profit per thin jar is $5 and the profit per stubby jar is $9. How many jars of each type should the artisan make to maximize profit?","{""variables"": {""NumJars"": {""0"": 0.0, ""1"": 26.666666666666668}}, ""objective"": 240.0}","{""parametrized_description"": ""An artisan produces NumJarTypes different types of terracotta jars. Each jar type requires ShapingTimePerType shaping time and BakingTimePerType baking time. Each week, there is a total shaping time available of ShapingTimeAvailable and a total baking time available of BakingTimeAvailable. The profit earned per unit of each jar type is ProfitPerType. The artisan seeks to determine the number of jars of each type to produce in order to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""NumJarTypes"": {""description"": ""Number of different types of terracotta jars produced"", ""shape"": []}, ""ShapingTimePerType"": {""description"": ""Amount of shaping time required to produce one unit of each jar type"", ""shape"": [""NumJarTypes""]}, ""BakingTimePerType"": {""description"": ""Amount of baking time required to produce one unit of each jar type"", ""shape"": [""NumJarTypes""]}, ""ProfitPerType"": {""description"": ""Profit earned per unit of each jar type"", ""shape"": [""NumJarTypes""]}, ""ShapingTimeAvailable"": {""description"": ""Total amount of shaping time available per week"", ""shape"": []}, ""BakingTimeAvailable"": {""description"": ""Total amount of baking time available per week"", ""shape"": []}}, ""variables"": {""NumJars"": {""description"": ""The number of jars produced for each type"", ""type"": ""continuous"", ""shape"": [""NumJarTypes""]}}, ""constraints"": [{""description"": ""The total shaping time required to produce the jars, calculated as the sum of ShapingTimePerType multiplied by the number of jars of each type produced, cannot exceed ShapingTimeAvailable."", ""formulation"": ""\\sum_{i=1}^{NumJarTypes} ShapingTimePerType_i \\times NumJars_i \\leq ShapingTimeAvailable"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ShapingTimePerType[i] * NumJars[i] for i in range(NumJarTypes)) <= ShapingTimeAvailable)""}}, {""description"": ""The total baking time required to produce the jars, calculated as the sum of BakingTimePerType multiplied by the number of jars of each type produced, cannot exceed BakingTimeAvailable."", ""formulation"": ""\\sum_{j=1}^{NumJarTypes} BakingTimePerType_j \\times NumJars_j \\leq BakingTimeAvailable"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(BakingTimePerType[j] * NumJars[j] for j in range(NumJarTypes)) <= BakingTimeAvailable)""}}], ""objective"": {""description"": ""Total profit is the sum of the profit per jar type multiplied by the number of jars of each type produced. The objective is to maximize the total profit."", ""formulation"": ""Max \\sum_{i=1}^{NumJarTypes} ProfitPerType_{i} \\times NumJars_{i}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProfitPerType[i] * NumJars[i] for i in range(NumJarTypes)), GRB.MAXIMIZE)""}}}","{""NumJarTypes"": 2, ""ShapingTimePerType"": [50, 30], ""BakingTimePerType"": [90, 150], ""ProfitPerType"": [5, 9], ""ShapingTimeAvailable"": 3000, ""BakingTimeAvailable"": 4000}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
An artisan produces NumJarTypes different types of terracotta jars. Each jar
type requires ShapingTimePerType shaping time and BakingTimePerType baking time.
Each week, there is a total shaping time available of ShapingTimeAvailable and a
total baking time available of BakingTimeAvailable. The profit earned per unit
of each jar type is ProfitPerType. The artisan seeks to determine the number of
jars of each type to produce in order to maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/9/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumJarTypes @Def: Number of different types of terracotta jars produced @Shape: [] 
NumJarTypes = data['NumJarTypes']
# @Parameter ShapingTimePerType @Def: Amount of shaping time required to produce one unit of each jar type @Shape: ['NumJarTypes'] 
ShapingTimePerType = data['ShapingTimePerType']
# @Parameter BakingTimePerType @Def: Amount of baking time required to produce one unit of each jar type @Shape: ['NumJarTypes'] 
BakingTimePerType = data['BakingTimePerType']
# @Parameter ProfitPerType @Def: Profit earned per unit of each jar type @Shape: ['NumJarTypes'] 
ProfitPerType = data['ProfitPerType']
# @Parameter ShapingTimeAvailable @Def: Total amount of shaping time available per week @Shape: [] 
ShapingTimeAvailable = data['ShapingTimeAvailable']
# @Parameter BakingTimeAvailable @Def: Total amount of baking time available per week @Shape: [] 
BakingTimeAvailable = data['BakingTimeAvailable']

# Variables 
# @Variable NumJars @Def: The number of jars produced for each type @Shape: ['NumJarTypes'] 
NumJars = model.addVars(NumJarTypes, vtype=GRB.CONTINUOUS, name='NumJars')

# Constraints 
# @Constraint Constr_1 @Def: The total shaping time required to produce the jars, calculated as the sum of ShapingTimePerType multiplied by the number of jars of each type produced, cannot exceed ShapingTimeAvailable.
model.addConstr(quicksum(ShapingTimePerType[i] * NumJars[i] for i in range(NumJarTypes)) <= ShapingTimeAvailable)
# @Constraint Constr_2 @Def: The total baking time required to produce the jars, calculated as the sum of BakingTimePerType multiplied by the number of jars of each type produced, cannot exceed BakingTimeAvailable.
model.addConstr(quicksum(BakingTimePerType[j] * NumJars[j] for j in range(NumJarTypes)) <= BakingTimeAvailable)

# Objective 
# @Objective Objective @Def: Total profit is the sum of the profit per jar type multiplied by the number of jars of each type produced. The objective is to maximize the total profit.
model.setObjective(quicksum(ProfitPerType[i] * NumJars[i] for i in range(NumJarTypes)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumJars'] = {i: NumJars[i].x for i in range(NumJarTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A grocery store wants to liquidate its stock of 10 apples, 20 bananas, and 80 grapes. Given past experience, the store knows that they can propose a banana-haters package with 6 apples and 30 grapes and that this package will bring a profit of six euros. Similarly, they can prepare a combo package with 5 apples, 6 bananas, and 20 grapes, yielding a profit of seven euros. They know they can sell any quantity of these two packages within the availability of its stock. What quantity of each package, banana-haters packages and combo packages, should the store prepare to maximize net profit?","{""variables"": {""PackageCount"": {""0"": -0.0, ""1"": 2.0}}, ""objective"": 14.0}","{""parametrized_description"": ""A grocery store aims to liquidate its stock of NumItems different items. It has an Available quantity for each item. The store can prepare NumPackages different package types, where each package requires a certain amount of each item as specified by Required. Each package yields a PackageProfit. Determine the number of each package to prepare in order to maximize the total profit without exceeding the available stock of any item."", ""keywords"": [""N.A.""], ""parameters"": {""NumItems"": {""description"": ""Number of different items to be liquidated"", ""shape"": []}, ""NumPackages"": {""description"": ""Number of different package types"", ""shape"": []}, ""Available"": {""description"": ""Available quantity of each item"", ""shape"": [""NumItems""]}, ""Required"": {""description"": ""Amount of each item required to prepare one unit of each package"", ""shape"": [""NumItems"", ""NumPackages""]}, ""PackageProfit"": {""description"": ""Profit for each package"", ""shape"": [""NumPackages""]}}, ""variables"": {""PackageCount"": {""description"": ""The number of each type of package to produce"", ""type"": ""continuous"", ""shape"": [""NumPackages""]}}, ""constraints"": [{""description"": ""Each package requires the specified amounts of each item as defined by Required."", ""formulation"": ""\\sum_{p=1}^{NumPackages} Required_{i,p} \\cdot PackageCount_p \\leq Available_i \\quad \\forall i \\in \\{1, \\ldots, NumItems\\}"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(Required[i][p] * PackageCount[p] for p in range(NumPackages)) <= Available[i] for i in range(NumItems)), name=\""ResourceConstraints\"")""}}, {""description"": ""The total usage of each item across all prepared packages cannot exceed its available quantity."", ""formulation"": ""\\sum_{j=1}^{NumPackages} Required_{i,j} \\cdot PackageCount_j \\leq Available_i \\quad \\forall i = 1, \\dots, NumItems"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(Required[i, j] * PackageCount[j] for j in range(NumPackages)) <= Available[i] for i in range(NumItems)), name=\""TotalUsage\"")""}}], ""objective"": {""description"": ""Total profit is the sum of the PackageProfit of all prepared packages. The objective is to maximize the total profit without exceeding the available stock of any item."", ""formulation"": ""Max \\sum_{j=1}^{NumPackages} PackageProfit_j \\times PackageCount_j"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(PackageProfit[j] * PackageCount[j] for j in range(NumPackages)), GRB.MAXIMIZE)""}}}","{""NumItems"": 3, ""NumPackages"": 2, ""Available"": [10, 20, 80], ""Required"": [[6, 5], [0, 6], [30, 20]], ""PackageProfit"": [6, 7]}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A grocery store aims to liquidate its stock of NumItems different items. It has
an Available quantity for each item. The store can prepare NumPackages different
package types, where each package requires a certain amount of each item as
specified by Required. Each package yields a PackageProfit. Determine the number
of each package to prepare in order to maximize the total profit without
exceeding the available stock of any item.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/10/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumItems @Def: Number of different items to be liquidated @Shape: [] 
NumItems = data['NumItems']
# @Parameter NumPackages @Def: Number of different package types @Shape: [] 
NumPackages = data['NumPackages']
# @Parameter Available @Def: Available quantity of each item @Shape: ['NumItems'] 
Available = data['Available']
# @Parameter Required @Def: Amount of each item required to prepare one unit of each package @Shape: ['NumItems', 'NumPackages'] 
Required = data['Required']
# @Parameter PackageProfit @Def: Profit for each package @Shape: ['NumPackages'] 
PackageProfit = data['PackageProfit']

# Variables 
# @Variable PackageCount @Def: The number of each type of package to produce @Shape: ['NumPackages'] 
PackageCount = model.addVars(NumPackages, vtype=GRB.INTEGER, name=""PackageCount"")

# Constraints 
# @Constraint Constr_1 @Def: Each package requires the specified amounts of each item as defined by Required.
model.addConstrs((quicksum(Required[i][p] * PackageCount[p] for p in range(NumPackages)) <= Available[i] for i in range(NumItems)), name=""ResourceConstraints"")

# Objective 
# @Objective Objective @Def: Total profit is the sum of the PackageProfit of all prepared packages. The objective is to maximize the total profit without exceeding the available stock of any item.
model.setObjective(quicksum(PackageProfit[j] * PackageCount[j] for j in range(NumPackages)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['PackageCount'] = {p: PackageCount[p].X for p in range(NumPackages)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
A bakery uses a stand-mixer and a slow bake oven to make bread and cookies. Each machine can run for at most 3000 hours per year. To bake a loaf of bread takes 1 hour in the stand mixer and 3 hours in the oven. A batch of cookies requires 0.5 hours in the mixer and 1 hour in the oven. The profit per loaf of bread is $5 and the profit per batch of cookies is $3. How should the bakery operate to maximize total profit?,"{""variables"": {""BreadQuantity"": 0.0, ""CookiesQuantity"": 3000.0}, ""objective"": 9000.0}","{""parametrized_description"": ""A bakery uses a stand mixer with MixerMaximumHours available operating hours per year and an oven with OvenMaximumHours available operating hours per year. Producing one loaf of bread requires BreadMixerTime hours in the stand mixer and BreadOvenTime hours in the oven. Producing one batch of cookies requires CookiesMixerTime hours in the stand mixer and CookiesOvenTime hours in the oven. Each loaf of bread generates a profit of BreadProfit and each batch of cookies generates a profit of CookiesProfit. The bakery aims to maximize its total profit."", ""keywords"": [""N.A.""], ""parameters"": {""MixerMaximumHours"": {""description"": ""Maximum available operating hours per year for the stand mixer"", ""shape"": []}, ""OvenMaximumHours"": {""description"": ""Maximum available operating hours per year for the oven"", ""shape"": []}, ""BreadMixerTime"": {""description"": ""Number of hours the stand mixer is required to bake one loaf of bread"", ""shape"": []}, ""BreadOvenTime"": {""description"": ""Number of hours the oven is required to bake one loaf of bread"", ""shape"": []}, ""CookiesMixerTime"": {""description"": ""Number of hours the stand mixer is required to bake one batch of cookies"", ""shape"": []}, ""CookiesOvenTime"": {""description"": ""Number of hours the oven is required to bake one batch of cookies"", ""shape"": []}, ""BreadProfit"": {""description"": ""Profit earned per loaf of bread"", ""shape"": []}, ""CookiesProfit"": {""description"": ""Profit earned per batch of cookies"", ""shape"": []}}, ""variables"": {""BreadQuantity"": {""description"": ""The number of loaves of bread produced"", ""type"": ""continuous"", ""shape"": []}, ""CookiesQuantity"": {""description"": ""The number of batches of cookies produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total stand mixer time used for producing bread and cookies must not exceed MixerMaximumHours hours per year."", ""formulation"": ""BreadMixerTime \\times BreadQuantity + CookiesMixerTime \\times CookiesQuantity \\leq MixerMaximumHours"", ""code"": {""gurobipy"": ""model.addConstr(BreadMixerTime * BreadQuantity + CookiesMixerTime * CookiesQuantity <= MixerMaximumHours)""}}, {""description"": ""The total oven time used for producing bread and cookies must not exceed OvenMaximumHours hours per year."", ""formulation"": ""BreadOvenTime \\times BreadQuantity + CookiesOvenTime \\times CookiesQuantity \\leq OvenMaximumHours"", ""code"": {""gurobipy"": ""model.addConstr(BreadOvenTime * BreadQuantity + CookiesOvenTime * CookiesQuantity <= OvenMaximumHours)""}}], ""objective"": {""description"": ""Maximize the total profit, where total profit is (BreadProfit \u00d7 number of bread loaves) + (CookiesProfit \u00d7 number of cookie batches)."", ""formulation"": ""Max \\left( BreadProfit \\times BreadQuantity + CookiesProfit \\times CookiesQuantity \\right)"", ""code"": {""gurobipy"": ""model.setObjective(BreadProfit * BreadQuantity + CookiesProfit * CookiesQuantity, GRB.MAXIMIZE)""}}}","{""MixerMaximumHours"": 3000, ""OvenMaximumHours"": 3000, ""BreadMixerTime"": 1, ""BreadOvenTime"": 3, ""CookiesMixerTime"": 0.5, ""CookiesOvenTime"": 1, ""BreadProfit"": 5, ""CookiesProfit"": 3}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A bakery uses a stand mixer with MixerMaximumHours available operating hours per
year and an oven with OvenMaximumHours available operating hours per year.
Producing one loaf of bread requires BreadMixerTime hours in the stand mixer and
BreadOvenTime hours in the oven. Producing one batch of cookies requires
CookiesMixerTime hours in the stand mixer and CookiesOvenTime hours in the oven.
Each loaf of bread generates a profit of BreadProfit and each batch of cookies
generates a profit of CookiesProfit. The bakery aims to maximize its total
profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/11/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MixerMaximumHours @Def: Maximum available operating hours per year for the stand mixer @Shape: [] 
MixerMaximumHours = data['MixerMaximumHours']
# @Parameter OvenMaximumHours @Def: Maximum available operating hours per year for the oven @Shape: [] 
OvenMaximumHours = data['OvenMaximumHours']
# @Parameter BreadMixerTime @Def: Number of hours the stand mixer is required to bake one loaf of bread @Shape: [] 
BreadMixerTime = data['BreadMixerTime']
# @Parameter BreadOvenTime @Def: Number of hours the oven is required to bake one loaf of bread @Shape: [] 
BreadOvenTime = data['BreadOvenTime']
# @Parameter CookiesMixerTime @Def: Number of hours the stand mixer is required to bake one batch of cookies @Shape: [] 
CookiesMixerTime = data['CookiesMixerTime']
# @Parameter CookiesOvenTime @Def: Number of hours the oven is required to bake one batch of cookies @Shape: [] 
CookiesOvenTime = data['CookiesOvenTime']
# @Parameter BreadProfit @Def: Profit earned per loaf of bread @Shape: [] 
BreadProfit = data['BreadProfit']
# @Parameter CookiesProfit @Def: Profit earned per batch of cookies @Shape: [] 
CookiesProfit = data['CookiesProfit']

# Variables 
# @Variable BreadQuantity @Def: The number of loaves of bread produced @Shape: [] 
BreadQuantity = model.addVar(vtype=GRB.CONTINUOUS, name=""BreadQuantity"")
# @Variable CookiesQuantity @Def: The number of batches of cookies produced @Shape: [] 
CookiesQuantity = model.addVar(vtype=GRB.CONTINUOUS, name=""CookiesQuantity"")

# Constraints 
# @Constraint Constr_1 @Def: The total stand mixer time used for producing bread and cookies must not exceed MixerMaximumHours hours per year.
model.addConstr(BreadMixerTime * BreadQuantity + CookiesMixerTime * CookiesQuantity <= MixerMaximumHours)
# @Constraint Constr_2 @Def: The total oven time used for producing bread and cookies must not exceed OvenMaximumHours hours per year.
model.addConstr(BreadOvenTime * BreadQuantity + CookiesOvenTime * CookiesQuantity <= OvenMaximumHours)

# Objective 
# @Objective Objective @Def: Maximize the total profit, where total profit is (BreadProfit × number of bread loaves) + (CookiesProfit × number of cookie batches).
model.setObjective(BreadProfit * BreadQuantity + CookiesProfit * CookiesQuantity, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['BreadQuantity'] = BreadQuantity.x
variables['CookiesQuantity'] = CookiesQuantity.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
A glass factory makes two types of glass panes: a regular glass pane and a tempered glass pane. Both require time on a heating and cooling machine. Both machines are available for a maximum of 300 minutes per day. It takes 3 minutes in the heating machine and 5 minutes in the cooling machine to make one regular glass pane. It takes 5 minutes in the heating machine and 8 minutes in the cooling machine to make one tempered glass pane. The profit per pane of regular glass is $8 and the profit per pane of tempered glass is $10. How many panes of each glass type should the factory make to maximize profit? What is the maximum profit?,"{""variables"": {""QuantityRegular"": 60.0, ""QuantityTempered"": 0.0}, ""objective"": 480.0}","{""parametrized_description"": ""A glass factory produces Regular and Tempered glass panes. Producing one Regular pane requires HeatingRegular time on the heating machine and CoolingRegular time on the cooling machine. Producing one Tempered pane requires HeatingTempered time on the heating machine and CoolingTempered time on the cooling machine. The heating machine is available for a maximum of MaxHeatingTime per day, and the cooling machine is available for a maximum of MaxCoolingTime per day. Each Regular pane generates a profit of ProfitRegular, and each Tempered pane generates a profit of ProfitTempered. The factory aims to determine the number of Regular and Tempered panes to produce in order to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""MaxHeatingTime"": {""description"": ""Maximum available time for the heating machine per day"", ""shape"": []}, ""MaxCoolingTime"": {""description"": ""Maximum available time for the cooling machine per day"", ""shape"": []}, ""HeatingRegular"": {""description"": ""Heating time required to produce one regular glass pane"", ""shape"": []}, ""CoolingRegular"": {""description"": ""Cooling time required to produce one regular glass pane"", ""shape"": []}, ""HeatingTempered"": {""description"": ""Heating time required to produce one tempered glass pane"", ""shape"": []}, ""CoolingTempered"": {""description"": ""Cooling time required to produce one tempered glass pane"", ""shape"": []}, ""ProfitRegular"": {""description"": ""Profit per regular glass pane"", ""shape"": []}, ""ProfitTempered"": {""description"": ""Profit per tempered glass pane"", ""shape"": []}}, ""variables"": {""QuantityRegular"": {""description"": ""The number of regular glass panes to produce"", ""type"": ""continuous"", ""shape"": []}, ""QuantityTempered"": {""description"": ""The number of tempered glass panes to produce"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total heating time required for producing Regular and Tempered panes does not exceed MaxHeatingTime."", ""formulation"": ""HeatingRegular \\cdot QuantityRegular + HeatingTempered \\cdot QuantityTempered \\leq MaxHeatingTime"", ""code"": {""gurobipy"": ""model.addConstr(HeatingRegular * QuantityRegular + HeatingTempered * QuantityTempered <= MaxHeatingTime, name=\""HeatingTime\"")""}}, {""description"": ""The total cooling time required for producing Regular and Tempered panes does not exceed MaxCoolingTime."", ""formulation"": ""CoolingRegular \\times QuantityRegular + CoolingTempered \\times QuantityTempered \\leq MaxCoolingTime"", ""code"": {""gurobipy"": ""model.addConstr(CoolingRegular * QuantityRegular + CoolingTempered * QuantityTempered <= MaxCoolingTime)""}}], ""objective"": {""description"": ""Total profit is ProfitRegular multiplied by the number of Regular panes plus ProfitTempered multiplied by the number of Tempered panes. The objective is to maximize the total profit."", ""formulation"": ""Max \\ ProfitRegular \\times QuantityRegular + ProfitTempered \\times QuantityTempered"", ""code"": {""gurobipy"": ""model.setObjective(ProfitRegular * QuantityRegular + ProfitTempered * QuantityTempered, GRB.MAXIMIZE)""}}}","{""MaxHeatingTime"": 300, ""MaxCoolingTime"": 300, ""HeatingRegular"": 3, ""CoolingRegular"": 5, ""HeatingTempered"": 5, ""CoolingTempered"": 8, ""ProfitRegular"": 8, ""ProfitTempered"": 10}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A glass factory produces Regular and Tempered glass panes. Producing one Regular
pane requires HeatingRegular time on the heating machine and CoolingRegular time
on the cooling machine. Producing one Tempered pane requires HeatingTempered
time on the heating machine and CoolingTempered time on the cooling machine. The
heating machine is available for a maximum of MaxHeatingTime per day, and the
cooling machine is available for a maximum of MaxCoolingTime per day. Each
Regular pane generates a profit of ProfitRegular, and each Tempered pane
generates a profit of ProfitTempered. The factory aims to determine the number
of Regular and Tempered panes to produce in order to maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/12/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MaxHeatingTime @Def: Maximum available time for the heating machine per day @Shape: [] 
MaxHeatingTime = data['MaxHeatingTime']
# @Parameter MaxCoolingTime @Def: Maximum available time for the cooling machine per day @Shape: [] 
MaxCoolingTime = data['MaxCoolingTime']
# @Parameter HeatingRegular @Def: Heating time required to produce one regular glass pane @Shape: [] 
HeatingRegular = data['HeatingRegular']
# @Parameter CoolingRegular @Def: Cooling time required to produce one regular glass pane @Shape: [] 
CoolingRegular = data['CoolingRegular']
# @Parameter HeatingTempered @Def: Heating time required to produce one tempered glass pane @Shape: [] 
HeatingTempered = data['HeatingTempered']
# @Parameter CoolingTempered @Def: Cooling time required to produce one tempered glass pane @Shape: [] 
CoolingTempered = data['CoolingTempered']
# @Parameter ProfitRegular @Def: Profit per regular glass pane @Shape: [] 
ProfitRegular = data['ProfitRegular']
# @Parameter ProfitTempered @Def: Profit per tempered glass pane @Shape: [] 
ProfitTempered = data['ProfitTempered']

# Variables 
# @Variable QuantityRegular @Def: The number of regular glass panes to produce @Shape: [] 
QuantityRegular = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityRegular"")
# @Variable QuantityTempered @Def: The number of tempered glass panes to produce @Shape: [] 
QuantityTempered = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityTempered"")

# Constraints 
# @Constraint Constr_1 @Def: The total heating time required for producing Regular and Tempered panes does not exceed MaxHeatingTime.
model.addConstr(HeatingRegular * QuantityRegular + HeatingTempered * QuantityTempered <= MaxHeatingTime, name=""HeatingTime"")
# @Constraint Constr_2 @Def: The total cooling time required for producing Regular and Tempered panes does not exceed MaxCoolingTime.
model.addConstr(CoolingRegular * QuantityRegular + CoolingTempered * QuantityTempered <= MaxCoolingTime)

# Objective 
# @Objective Objective @Def: Total profit is ProfitRegular multiplied by the number of Regular panes plus ProfitTempered multiplied by the number of Tempered panes. The objective is to maximize the total profit.
model.setObjective(ProfitRegular * QuantityRegular + ProfitTempered * QuantityTempered, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityRegular'] = QuantityRegular.x
variables['QuantityTempered'] = QuantityTempered.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A souvenir shop makes wooden elephants and tigers with plastic ornaments. Each elephant requires 50 grams of wood and 20 grams of plastic. Each tiger requires 40 grams of wood and 30 grams of plastic. In a week, 5000 grams of wood and 4000 grams of plastic are available. The profit per elephant sold is $5 and the profit per tiger sold is $4. How many of each should be made in order to maximize profit?","{""variables"": {""Production"": {""0"": 100.0, ""1"": 0.0}}, ""objective"": 500.0}","{""parametrized_description"": ""A souvenir shop produces NumProducts different products using NumResources different resources. Each product has a profit defined by Profit and requires specific amounts of resources as specified by ResourceRequirement. The ResourceAvailability defines the total amount of each resource available. The objective is to determine the number of each product to produce to maximize total Profit."", ""keywords"": [""N.A.""], ""parameters"": {""NumProducts"": {""description"": ""Number of different products produced"", ""shape"": []}, ""NumResources"": {""description"": ""Number of different resources used"", ""shape"": []}, ""Profit"": {""description"": ""Profit per unit of each product"", ""shape"": [""NumProducts""]}, ""ResourceRequirement"": {""description"": ""Amount of each resource required to produce one unit of each product"", ""shape"": [""NumResources"", ""NumProducts""]}, ""ResourceAvailability"": {""description"": ""Amount of each resource available per week"", ""shape"": [""NumResources""]}}, ""variables"": {""Production"": {""description"": ""The quantity produced for each product"", ""type"": ""continuous"", ""shape"": [""NumProducts""]}}, ""constraints"": [{""description"": ""The total amount of wood required to produce all products does not exceed the available wood."", ""formulation"": ""\\sum_{j=1}^{NumProducts} ResourceRequirement_{\\text{Wood},j} \\cdot Production_j \\leq ResourceAvailability_{\\text{Wood}}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ResourceRequirement[0][j] * Production[j] for j in range(NumProducts)) <= ResourceAvailability[0])""}}, {""description"": ""The total amount of plastic required to produce all products does not exceed the available plastic."", ""formulation"": ""\\sum_{i=1}^{\\text{NumProducts}} \\text{ResourceRequirement}_{\\text{Plastic},i} \\times \\text{Production}_{i} \\leq \\text{ResourceAvailability}_{\\text{Plastic}}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ResourceRequirement[0][i] * Production[i] for i in range(NumProducts)) <= ResourceAvailability[0])""}}], ""objective"": {""description"": ""Total Profit is the sum of the profit per unit of each product multiplied by the number of each product produced. The objective is to maximize the total Profit."", ""formulation"": ""Max \\sum_{i=1}^{NumProducts} Profit_i \\times Production_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(Profit[i] * Production[i] for i in range(NumProducts)), GRB.MAXIMIZE)""}}}","{""NumProducts"": 2, ""NumResources"": 2, ""Profit"": [5, 4], ""ResourceRequirement"": [[50, 40], [20, 30]], ""ResourceAvailability"": [5000, 4000]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A souvenir shop produces NumProducts different products using NumResources
different resources. Each product has a profit defined by Profit and requires
specific amounts of resources as specified by ResourceRequirement. The
ResourceAvailability defines the total amount of each resource available. The
objective is to determine the number of each product to produce to maximize
total Profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/13/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumProducts @Def: Number of different products produced @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter NumResources @Def: Number of different resources used @Shape: [] 
NumResources = data['NumResources']
# @Parameter Profit @Def: Profit per unit of each product @Shape: ['NumProducts'] 
Profit = data['Profit']
# @Parameter ResourceRequirement @Def: Amount of each resource required to produce one unit of each product @Shape: ['NumResources', 'NumProducts'] 
ResourceRequirement = data['ResourceRequirement']
# @Parameter ResourceAvailability @Def: Amount of each resource available per week @Shape: ['NumResources'] 
ResourceAvailability = data['ResourceAvailability']
    
# Variables 
# @Variable Production @Def: The quantity produced for each product @Shape: ['NumProducts'] 
Production = model.addVars(NumProducts, vtype=GRB.CONTINUOUS, name=""Production"")
    
# Constraints 
# @Constraint Constr_1 @Def: The total amount of wood required to produce all products does not exceed the available wood.
model.addConstr(quicksum(ResourceRequirement[0][j] * Production[j] for j in range(NumProducts)) <= ResourceAvailability[0], name=""Constr_1"")
# @Constraint Constr_2 @Def: The total amount of plastic required to produce all products does not exceed the available plastic.
model.addConstr(quicksum(ResourceRequirement[1][j] * Production[j] for j in range(NumProducts)) <= ResourceAvailability[1], name=""Constr_2"")
    
# Objective 
# @Objective Objective @Def: Total Profit is the sum of the profit per unit of each product multiplied by the number of each product produced. The objective is to maximize the total Profit.
model.setObjective(quicksum(Profit[i] * Production[i] for i in range(NumProducts)), GRB.MAXIMIZE)
    
# Solve 
model.optimize()
    
# Extract solution 
solution = {}
variables = {}
objective = []
variables['Production'] = {j: Production[j].x for j in range(NumProducts)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An art store makes large and small art pieces. The store has available 100 units of paint, 50 units of glitter, and 70 units of glue. To make a large art piece requires 4 units of paint, 3 units of glitter, and 5 units of glue. To make a small art piece requires 2 units of paint, 1 unit of glitter, and 2 units of glue. The store must make at least 5 units of each large and small art pieces. If the profit per large art piece is $30 and the profit per small art piece is $15, how many of each should be made to maximize profit?","{""variables"": {""NumberLarge"": 5.2, ""NumberSmall"": 22.0}, ""objective"": 486.0}","{""parametrized_description"": ""An art store produces large and small art pieces. Each large art piece requires PaintPerLarge units of paint, GlitterPerLarge units of glitter, and GluePerLarge units of glue. Each small art piece requires PaintPerSmall units of paint, GlitterPerSmall units of glitter, and GluePerSmall units of glue. The store has AvailablePaint units of paint, AvailableGlitter units of glitter, and AvailableGlue units of glue available. The store must produce at least MinLarge large art pieces and at least MinSmall small art pieces. The objective is to maximize profit, where each large art piece generates ProfitLarge and each small art piece generates ProfitSmall."", ""keywords"": [""N.A.""], ""parameters"": {""AvailablePaint"": {""description"": ""Total units of paint available"", ""shape"": []}, ""AvailableGlitter"": {""description"": ""Total units of glitter available"", ""shape"": []}, ""AvailableGlue"": {""description"": ""Total units of glue available"", ""shape"": []}, ""PaintPerLarge"": {""description"": ""Units of paint required to make one large art piece"", ""shape"": []}, ""GlitterPerLarge"": {""description"": ""Units of glitter required to make one large art piece"", ""shape"": []}, ""GluePerLarge"": {""description"": ""Units of glue required to make one large art piece"", ""shape"": []}, ""PaintPerSmall"": {""description"": ""Units of paint required to make one small art piece"", ""shape"": []}, ""GlitterPerSmall"": {""description"": ""Units of glitter required to make one small art piece"", ""shape"": []}, ""GluePerSmall"": {""description"": ""Units of glue required to make one small art piece"", ""shape"": []}, ""ProfitLarge"": {""description"": ""Profit per large art piece"", ""shape"": []}, ""ProfitSmall"": {""description"": ""Profit per small art piece"", ""shape"": []}, ""MinLarge"": {""description"": ""Minimum number of large art pieces to produce"", ""shape"": []}, ""MinSmall"": {""description"": ""Minimum number of small art pieces to produce"", ""shape"": []}}, ""variables"": {""NumberLarge"": {""description"": ""The number of large art pieces to produce"", ""type"": ""continuous"", ""shape"": []}, ""NumberSmall"": {""description"": ""The number of small art pieces to produce"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""Each large art piece requires PaintPerLarge units of paint, and each small art piece requires PaintPerSmall units of paint.\nThe total paint used cannot exceed AvailablePaint units."", ""formulation"": ""PaintPerLarge \\cdot NumberLarge + PaintPerSmall \\cdot NumberSmall \\leq AvailablePaint"", ""code"": {""gurobipy"": ""model.addConstr(PaintPerLarge * NumberLarge + PaintPerSmall * NumberSmall <= AvailablePaint)""}}, {""description"": ""Each large art piece requires GlitterPerLarge units of glitter, and each small art piece requires GlitterPerSmall units of glitter.\nThe total glitter used cannot exceed AvailableGlitter units."", ""formulation"": ""GlitterPerLarge \\times NumberLarge + GlitterPerSmall \\times NumberSmall \\leq AvailableGlitter"", ""code"": {""gurobipy"": ""model.addConstr(GlitterPerLarge * NumberLarge + GlitterPerSmall * NumberSmall <= AvailableGlitter)""}}, {""description"": ""Each large art piece requires GluePerLarge units of glue, and each small art piece requires GluePerSmall units of glue.\nThe total glue used cannot exceed AvailableGlue units."", ""formulation"": ""GluePerLarge \\cdot NumberLarge + GluePerSmall \\cdot NumberSmall \\leq AvailableGlue"", ""code"": {""gurobipy"": ""model.addConstr(GluePerLarge * NumberLarge + GluePerSmall * NumberSmall <= AvailableGlue)""}}, {""description"": ""At least MinLarge large art pieces must be produced."", ""formulation"": ""NumberLarge \\geq MinLarge"", ""code"": {""gurobipy"": ""model.addConstr(NumberLarge >= MinLarge)""}}, {""description"": ""At least MinSmall small art pieces must be produced."", ""formulation"": ""NumberSmall \\geq MinSmall"", ""code"": {""gurobipy"": ""model.addConstr(NumberSmall >= MinSmall)""}}], ""objective"": {""description"": ""Total profit is the sum of the profits generated by large and small art pieces.\nThe objective is to maximize the total profit."", ""formulation"": ""\\text{Max} \\; (ProfitLarge \\times NumberLarge + ProfitSmall \\times NumberSmall)"", ""code"": {""gurobipy"": ""model.setObjective(ProfitLarge * NumberLarge + ProfitSmall * NumberSmall, GRB.MAXIMIZE)""}}}","{""AvailablePaint"": 100, ""AvailableGlitter"": 50, ""AvailableGlue"": 70, ""PaintPerLarge"": 4, ""GlitterPerLarge"": 3, ""GluePerLarge"": 5, ""PaintPerSmall"": 2, ""GlitterPerSmall"": 1, ""GluePerSmall"": 2, ""ProfitLarge"": 30, ""ProfitSmall"": 15, ""MinLarge"": 5, ""MinSmall"": 5}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
An art store produces large and small art pieces. Each large art piece requires
PaintPerLarge units of paint, GlitterPerLarge units of glitter, and GluePerLarge
units of glue. Each small art piece requires PaintPerSmall units of paint,
GlitterPerSmall units of glitter, and GluePerSmall units of glue. The store has
AvailablePaint units of paint, AvailableGlitter units of glitter, and
AvailableGlue units of glue available. The store must produce at least MinLarge
large art pieces and at least MinSmall small art pieces. The objective is to
maximize profit, where each large art piece generates ProfitLarge and each small
art piece generates ProfitSmall.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/14/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter AvailablePaint @Def: Total units of paint available @Shape: [] 
AvailablePaint = data['AvailablePaint']
# @Parameter AvailableGlitter @Def: Total units of glitter available @Shape: [] 
AvailableGlitter = data['AvailableGlitter']
# @Parameter AvailableGlue @Def: Total units of glue available @Shape: [] 
AvailableGlue = data['AvailableGlue']
# @Parameter PaintPerLarge @Def: Units of paint required to make one large art piece @Shape: [] 
PaintPerLarge = data['PaintPerLarge']
# @Parameter GlitterPerLarge @Def: Units of glitter required to make one large art piece @Shape: [] 
GlitterPerLarge = data['GlitterPerLarge']
# @Parameter GluePerLarge @Def: Units of glue required to make one large art piece @Shape: [] 
GluePerLarge = data['GluePerLarge']
# @Parameter PaintPerSmall @Def: Units of paint required to make one small art piece @Shape: [] 
PaintPerSmall = data['PaintPerSmall']
# @Parameter GlitterPerSmall @Def: Units of glitter required to make one small art piece @Shape: [] 
GlitterPerSmall = data['GlitterPerSmall']
# @Parameter GluePerSmall @Def: Units of glue required to make one small art piece @Shape: [] 
GluePerSmall = data['GluePerSmall']
# @Parameter ProfitLarge @Def: Profit per large art piece @Shape: [] 
ProfitLarge = data['ProfitLarge']
# @Parameter ProfitSmall @Def: Profit per small art piece @Shape: [] 
ProfitSmall = data['ProfitSmall']
# @Parameter MinLarge @Def: Minimum number of large art pieces to produce @Shape: [] 
MinLarge = data['MinLarge']
# @Parameter MinSmall @Def: Minimum number of small art pieces to produce @Shape: [] 
MinSmall = data['MinSmall']

# Variables 
# @Variable NumberLarge @Def: The number of large art pieces to produce @Shape: [] 
NumberLarge = model.addVar(lb=MinLarge, vtype=GRB.CONTINUOUS, name=""NumberLarge"")
# @Variable NumberSmall @Def: The number of small art pieces to produce @Shape: [] 
NumberSmall = model.addVar(vtype=GRB.INTEGER, lb=MinSmall, name=""NumberSmall"")

# Constraints 
# @Constraint Constr_1 @Def: Each large art piece requires PaintPerLarge units of paint, and each small art piece requires PaintPerSmall units of paint.
# The total paint used cannot exceed AvailablePaint units.
model.addConstr(PaintPerLarge * NumberLarge + PaintPerSmall * NumberSmall <= AvailablePaint)
# @Constraint Constr_2 @Def: Each large art piece requires GlitterPerLarge units of glitter, and each small art piece requires GlitterPerSmall units of glitter.
# The total glitter used cannot exceed AvailableGlitter units.
model.addConstr(GlitterPerLarge * NumberLarge + GlitterPerSmall * NumberSmall <= AvailableGlitter)
# @Constraint Constr_3 @Def: Each large art piece requires GluePerLarge units of glue, and each small art piece requires GluePerSmall units of glue.
# The total glue used cannot exceed AvailableGlue units.
model.addConstr(GluePerLarge * NumberLarge + GluePerSmall * NumberSmall <= AvailableGlue)
# @Constraint Constr_4 @Def: At least MinLarge large art pieces must be produced.
model.addConstr(NumberLarge >= MinLarge)
# @Constraint Constr_5 @Def: At least MinSmall small art pieces must be produced.
model.addConstr(NumberSmall >= MinSmall)

# Objective 
# @Objective Objective @Def: Total profit is the sum of the profits generated by large and small art pieces.
# The objective is to maximize the total profit.
model.setObjective(ProfitLarge * NumberLarge + ProfitSmall * NumberSmall, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberLarge'] = NumberLarge.x
variables['NumberSmall'] = NumberSmall.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"My family has decided to invest in real state for the first time. Currently, they have $600,000 to invest, some in apartments and the rest in townhouses. The money invested in apartments must not be greater than $200,000. They have decided that the money invested in apartments must be at least a half as much as that in townhouses.  If the apartments earn 10%, and the townhouses earn 15%, how much money should they invest in each to maximize profit?","{""variables"": {""InvestmentApartments"": 200000.0, ""InvestmentTownhouses"": 400000.0}, ""objective"": 80000.0}","{""parametrized_description"": ""A family has a TotalInvestment to allocate between apartments and townhouses. The investment in apartments must not exceed MaxInvestmentApartments and must be at least MinInvestmentRatio times the investment in townhouses. Apartments yield a return rate of ReturnRateApartments and townhouses yield a return rate of ReturnRateTownhouses. The goal is to determine the investment amounts in each to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""TotalInvestment"": {""description"": ""Total amount available for investment"", ""shape"": []}, ""MaxInvestmentApartments"": {""description"": ""Maximum amount that can be invested in apartments"", ""shape"": []}, ""MinInvestmentRatio"": {""description"": ""Minimum ratio of investment in apartments to investment in townhouses"", ""shape"": []}, ""ReturnRateApartments"": {""description"": ""Return on investment rate for apartments"", ""shape"": []}, ""ReturnRateTownhouses"": {""description"": ""Return on investment rate for townhouses"", ""shape"": []}}, ""variables"": {""InvestmentApartments"": {""description"": ""The amount invested in apartments"", ""type"": ""continuous"", ""shape"": []}, ""InvestmentTownhouses"": {""description"": ""The amount invested in townhouses"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total investment allocated to apartments and townhouses must equal TotalInvestment."", ""formulation"": ""InvestmentApartments + InvestmentTownhouses = TotalInvestment"", ""code"": {""gurobipy"": ""model.addConstr(InvestmentApartments + InvestmentTownhouses == TotalInvestment)""}}, {""description"": ""The investment in apartments must not exceed MaxInvestmentApartments."", ""formulation"": ""InvestmentApartments \\leq MaxInvestmentApartments"", ""code"": {""gurobipy"": ""model.addConstr(InvestmentApartments <= MaxInvestmentApartments)""}}, {""description"": ""The investment in apartments must be at least MinInvestmentRatio times the investment in townhouses."", ""formulation"": ""InvestmentApartments \\geq MinInvestmentRatio \\times InvestmentTownhouses"", ""code"": {""gurobipy"": ""model.addConstr(InvestmentApartments >= MinInvestmentRatio * InvestmentTownhouses)""}}], ""objective"": {""description"": ""Maximize total profit, which is the sum of ReturnRateApartments multiplied by the investment in apartments and ReturnRateTownhouses multiplied by the investment in townhouses."", ""formulation"": ""Max \\left(ReturnRateApartments \\times InvestmentApartments + ReturnRateTownhouses \\times InvestmentTownhouses\\right)"", ""code"": {""gurobipy"": ""model.setObjective(ReturnRateApartments * InvestmentApartments + ReturnRateTownhouses * InvestmentTownhouses, GRB.MAXIMIZE)""}}}","{""TotalInvestment"": 600000, ""MaxInvestmentApartments"": 200000, ""MinInvestmentRatio"": 0.5, ""ReturnRateApartments"": 0.1, ""ReturnRateTownhouses"": 0.15}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A family has a TotalInvestment to allocate between apartments and townhouses.
The investment in apartments must not exceed MaxInvestmentApartments and must be
at least MinInvestmentRatio times the investment in townhouses. Apartments yield
a return rate of ReturnRateApartments and townhouses yield a return rate of
ReturnRateTownhouses. The goal is to determine the investment amounts in each to
maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/15/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalInvestment @Def: Total amount available for investment @Shape: [] 
TotalInvestment = data['TotalInvestment']
# @Parameter MaxInvestmentApartments @Def: Maximum amount that can be invested in apartments @Shape: [] 
MaxInvestmentApartments = data['MaxInvestmentApartments']
# @Parameter MinInvestmentRatio @Def: Minimum ratio of investment in apartments to investment in townhouses @Shape: [] 
MinInvestmentRatio = data['MinInvestmentRatio']
# @Parameter ReturnRateApartments @Def: Return on investment rate for apartments @Shape: [] 
ReturnRateApartments = data['ReturnRateApartments']
# @Parameter ReturnRateTownhouses @Def: Return on investment rate for townhouses @Shape: [] 
ReturnRateTownhouses = data['ReturnRateTownhouses']

# Variables 
# @Variable InvestmentApartments @Def: The amount invested in apartments @Shape: [] 
InvestmentApartments = model.addVar(vtype=GRB.CONTINUOUS, lb=0, ub=MaxInvestmentApartments, name=""InvestmentApartments"")
# @Variable InvestmentTownhouses @Def: The amount invested in townhouses @Shape: [] 
InvestmentTownhouses = model.addVar(vtype=GRB.CONTINUOUS, name=""InvestmentTownhouses"")

# Constraints 
# @Constraint Constr_1 @Def: The total investment allocated to apartments and townhouses must equal TotalInvestment.
model.addConstr(InvestmentApartments + InvestmentTownhouses == TotalInvestment)
# @Constraint Constr_2 @Def: The investment in apartments must not exceed MaxInvestmentApartments.
model.addConstr(InvestmentApartments <= MaxInvestmentApartments)
# @Constraint Constr_3 @Def: The investment in apartments must be at least MinInvestmentRatio times the investment in townhouses.
model.addConstr(InvestmentApartments >= MinInvestmentRatio * InvestmentTownhouses)

# Objective 
# @Objective Objective @Def: Maximize total profit, which is the sum of ReturnRateApartments multiplied by the investment in apartments and ReturnRateTownhouses multiplied by the investment in townhouses.
model.setObjective(ReturnRateApartments * InvestmentApartments + ReturnRateTownhouses * InvestmentTownhouses, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['InvestmentApartments'] = InvestmentApartments.x
variables['InvestmentTownhouses'] = InvestmentTownhouses.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"My grandma is required to take two medicines Z1 and D3 everyday. She needs to take at least 5 grams of Z1 and 10 grams of D3 everyday. These medicines are available in two pills named Zodiac and Sunny. One pill of Zodiac contains 1.3 grams of Z1 while one pill of Sunny contains 1.2 grams of Z1. On the other hand, one pill of Zodiac contains 1.5 grams of D3 and one pill of Sunny contains 5 grams of D3. The cost per pill of Zodiac is $1 and the cost per pill of Sunny is $3. Formulate a LP such that the medicine requirement can be fulfilled at the lowest cost.","{""variables"": {""QuantityZodiac"": 4.0, ""QuantitySunny"": 1.0}, ""objective"": 7.0}","{""parametrized_description"": ""A patient must consume at least RequiredZ1 grams of medicine Z1 and at least RequiredD3 grams of medicine D3 daily by taking Zodiac and Sunny pills. Each Zodiac pill provides Z1PerZodiac grams of Z1 and D3PerZodiac grams of D3 and costs CostZodiac dollars. Each Sunny pill provides Z1PerSunny grams of Z1 and D3PerSunny grams of D3 and costs CostSunny dollars. The objective is to minimize the total cost while satisfying the medicine requirements."", ""keywords"": [""N.A.""], ""parameters"": {""RequiredZ1"": {""description"": ""Minimum required daily amount of medicine Z1 in grams"", ""shape"": []}, ""RequiredD3"": {""description"": ""Minimum required daily amount of medicine D3 in grams"", ""shape"": []}, ""Z1PerZodiac"": {""description"": ""Amount of medicine Z1 in grams per pill of Zodiac"", ""shape"": []}, ""Z1PerSunny"": {""description"": ""Amount of medicine Z1 in grams per pill of Sunny"", ""shape"": []}, ""D3PerZodiac"": {""description"": ""Amount of medicine D3 in grams per pill of Zodiac"", ""shape"": []}, ""D3PerSunny"": {""description"": ""Amount of medicine D3 in grams per pill of Sunny"", ""shape"": []}, ""CostZodiac"": {""description"": ""Cost per pill of Zodiac in dollars"", ""shape"": []}, ""CostSunny"": {""description"": ""Cost per pill of Sunny in dollars"", ""shape"": []}}, ""variables"": {""QuantityZodiac"": {""description"": ""The number of Zodiac pills selected"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""QuantitySunny"": {""description"": ""The number of Sunny pills selected"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total amount of medicine Z1 provided by Zodiac and Sunny pills must be at least RequiredZ1 grams."", ""formulation"": ""Z1PerZodiac \\cdot QuantityZodiac + Z1PerSunny \\cdot QuantitySunny \\geq RequiredZ1"", ""code"": {""gurobipy"": ""model.addConstr(Z1PerZodiac * QuantityZodiac + Z1PerSunny * QuantitySunny >= RequiredZ1)""}}, {""description"": ""The total amount of medicine D3 provided by Zodiac and Sunny pills must be at least RequiredD3 grams."", ""formulation"": ""D3PerZodiac \\times QuantityZodiac + D3PerSunny \\times QuantitySunny \\geq RequiredD3"", ""code"": {""gurobipy"": ""model.addConstr(D3PerZodiac * QuantityZodiac + D3PerSunny * QuantitySunny >= RequiredD3)""}}], ""objective"": {""description"": ""Minimize the total cost, which is the sum of CostZodiac multiplied by the number of Zodiac pills and CostSunny multiplied by the number of Sunny pills, while satisfying the daily minimum requirements for medicines Z1 and D3."", ""formulation"": ""Min CostZodiac \\times QuantityZodiac + CostSunny \\times QuantitySunny"", ""code"": {""gurobipy"": ""model.setObjective(CostZodiac * QuantityZodiac + CostSunny * QuantitySunny, GRB.MINIMIZE)""}}}","{""RequiredZ1"": 5, ""RequiredD3"": 10, ""Z1PerZodiac"": 1.3, ""Z1PerSunny"": 1.2, ""D3PerZodiac"": 1.5, ""D3PerSunny"": 5, ""CostZodiac"": 1, ""CostSunny"": 3}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A patient must consume at least RequiredZ1 grams of medicine Z1 and at least
RequiredD3 grams of medicine D3 daily by taking Zodiac and Sunny pills. Each
Zodiac pill provides Z1PerZodiac grams of Z1 and D3PerZodiac grams of D3 and
costs CostZodiac dollars. Each Sunny pill provides Z1PerSunny grams of Z1 and
D3PerSunny grams of D3 and costs CostSunny dollars. The objective is to minimize
the total cost while satisfying the medicine requirements.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/16/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter RequiredZ1 @Def: Minimum required daily amount of medicine Z1 in grams @Shape: [] 
RequiredZ1 = data['RequiredZ1']
# @Parameter RequiredD3 @Def: Minimum required daily amount of medicine D3 in grams @Shape: [] 
RequiredD3 = data['RequiredD3']
# @Parameter Z1PerZodiac @Def: Amount of medicine Z1 in grams per pill of Zodiac @Shape: [] 
Z1PerZodiac = data['Z1PerZodiac']
# @Parameter Z1PerSunny @Def: Amount of medicine Z1 in grams per pill of Sunny @Shape: [] 
Z1PerSunny = data['Z1PerSunny']
# @Parameter D3PerZodiac @Def: Amount of medicine D3 in grams per pill of Zodiac @Shape: [] 
D3PerZodiac = data['D3PerZodiac']
# @Parameter D3PerSunny @Def: Amount of medicine D3 in grams per pill of Sunny @Shape: [] 
D3PerSunny = data['D3PerSunny']
# @Parameter CostZodiac @Def: Cost per pill of Zodiac in dollars @Shape: [] 
CostZodiac = data['CostZodiac']
# @Parameter CostSunny @Def: Cost per pill of Sunny in dollars @Shape: [] 
CostSunny = data['CostSunny']

# Variables 
# @Variable QuantityZodiac @Def: The number of Zodiac pills selected @Shape: ['Integer'] 
QuantityZodiac = model.addVar(vtype=GRB.INTEGER, name=""QuantityZodiac"")
# @Variable QuantitySunny @Def: The number of Sunny pills selected @Shape: ['Integer'] 
QuantitySunny = model.addVar(vtype=GRB.INTEGER, name=""QuantitySunny"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of medicine Z1 provided by Zodiac and Sunny pills must be at least RequiredZ1 grams.
model.addConstr(Z1PerZodiac * QuantityZodiac + Z1PerSunny * QuantitySunny >= RequiredZ1)
# @Constraint Constr_2 @Def: The total amount of medicine D3 provided by Zodiac and Sunny pills must be at least RequiredD3 grams.
model.addConstr(D3PerZodiac * QuantityZodiac + D3PerSunny * QuantitySunny >= RequiredD3)

# Objective 
# @Objective Objective @Def: Minimize the total cost, which is the sum of CostZodiac multiplied by the number of Zodiac pills and CostSunny multiplied by the number of Sunny pills, while satisfying the daily minimum requirements for medicines Z1 and D3.
model.setObjective(CostZodiac * QuantityZodiac + CostSunny * QuantitySunny, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityZodiac'] = QuantityZodiac.x
variables['QuantitySunny'] = QuantitySunny.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A hobbyist makes model trains and planes using wood and paint. A model train requires 3 units of wood and 3 units of paint. A model plane requires 4 units of wood and 2 units of paint. The hobbyist has available 120 units of wood and 90 units of paint. If the profit per model train is $8 and the profit per model plane is $10, how many of each should be made to maximize his profit?","{""variables"": {""NumberOfTrains"": 20.0, ""NumberOfPlanes"": 15.0}, ""objective"": 310.0}","{""parametrized_description"": ""A hobbyist makes model trains and model planes using wood and paint. Each model train requires WoodPerTrain units of wood and PaintPerTrain units of paint. Each model plane requires WoodPerPlane units of wood and PaintPerPlane units of paint. The hobbyist has AvailableWood units of wood and AvailablePaint units of paint. The profit per model train is ProfitTrain and the profit per model plane is ProfitPlane. The hobbyist aims to determine the number of each to produce to maximize profit."", ""keywords"": [""N.A.""], ""parameters"": {""WoodPerTrain"": {""description"": ""Amount of wood required to produce one model train"", ""shape"": []}, ""PaintPerTrain"": {""description"": ""Amount of paint required to produce one model train"", ""shape"": []}, ""WoodPerPlane"": {""description"": ""Amount of wood required to produce one model plane"", ""shape"": []}, ""PaintPerPlane"": {""description"": ""Amount of paint required to produce one model plane"", ""shape"": []}, ""AvailableWood"": {""description"": ""Total available units of wood"", ""shape"": []}, ""AvailablePaint"": {""description"": ""Total available units of paint"", ""shape"": []}, ""ProfitTrain"": {""description"": ""Profit earned per model train"", ""shape"": []}, ""ProfitPlane"": {""description"": ""Profit earned per model plane"", ""shape"": []}}, ""variables"": {""NumberOfTrains"": {""description"": ""The number of model trains to produce"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfPlanes"": {""description"": ""The number of model planes to produce"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total wood required for producing model trains and model planes cannot exceed AvailableWood units of wood."", ""formulation"": ""NumberOfTrains \\times WoodPerTrain + NumberOfPlanes \\times WoodPerPlane \\leq AvailableWood"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfTrains * WoodPerTrain + NumberOfPlanes * WoodPerPlane <= AvailableWood)""}}, {""description"": ""The total paint required for producing model trains and model planes cannot exceed AvailablePaint units of paint."", ""formulation"": ""PaintPerTrain \\cdot NumberOfTrains + PaintPerPlane \\cdot NumberOfPlanes \\leq AvailablePaint"", ""code"": {""gurobipy"": ""model.addConstr(PaintPerTrain * NumberOfTrains + PaintPerPlane * NumberOfPlanes <= AvailablePaint)""}}], ""objective"": {""description"": ""The total profit is calculated as ProfitTrain times the number of model trains plus ProfitPlane times the number of model planes. The objective is to maximize the total profit."", ""formulation"": ""Max ( ProfitTrain \\times NumberOfTrains + ProfitPlane \\times NumberOfPlanes )"", ""code"": {""gurobipy"": ""model.setObjective(ProfitTrain * NumberOfTrains + ProfitPlane * NumberOfPlanes, GRB.MAXIMIZE)""}}}","{""WoodPerTrain"": 3, ""PaintPerTrain"": 3, ""WoodPerPlane"": 4, ""PaintPerPlane"": 2, ""AvailableWood"": 120, ""AvailablePaint"": 90, ""ProfitTrain"": 8, ""ProfitPlane"": 10}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A hobbyist makes model trains and model planes using wood and paint. Each model
train requires WoodPerTrain units of wood and PaintPerTrain units of paint. Each
model plane requires WoodPerPlane units of wood and PaintPerPlane units of
paint. The hobbyist has AvailableWood units of wood and AvailablePaint units of
paint. The profit per model train is ProfitTrain and the profit per model plane
is ProfitPlane. The hobbyist aims to determine the number of each to produce to
maximize profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/17/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter WoodPerTrain @Def: Amount of wood required to produce one model train @Shape: [] 
WoodPerTrain = data['WoodPerTrain']
# @Parameter PaintPerTrain @Def: Amount of paint required to produce one model train @Shape: [] 
PaintPerTrain = data['PaintPerTrain']
# @Parameter WoodPerPlane @Def: Amount of wood required to produce one model plane @Shape: [] 
WoodPerPlane = data['WoodPerPlane']
# @Parameter PaintPerPlane @Def: Amount of paint required to produce one model plane @Shape: [] 
PaintPerPlane = data['PaintPerPlane']
# @Parameter AvailableWood @Def: Total available units of wood @Shape: [] 
AvailableWood = data['AvailableWood']
# @Parameter AvailablePaint @Def: Total available units of paint @Shape: [] 
AvailablePaint = data['AvailablePaint']
# @Parameter ProfitTrain @Def: Profit earned per model train @Shape: [] 
ProfitTrain = data['ProfitTrain']
# @Parameter ProfitPlane @Def: Profit earned per model plane @Shape: [] 
ProfitPlane = data['ProfitPlane']

# Variables 
# @Variable NumberOfTrains @Def: The number of model trains to produce @Shape: [] 
NumberOfTrains = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfTrains"")
# @Variable NumberOfPlanes @Def: The number of model planes to produce @Shape: [] 
NumberOfPlanes = model.addVar(vtype=GRB.CONTINUOUS, name='NumberOfPlanes')

# Constraints 
# @Constraint Constr_1 @Def: The total wood required for producing model trains and model planes cannot exceed AvailableWood units of wood.
model.addConstr(NumberOfTrains * WoodPerTrain + NumberOfPlanes * WoodPerPlane <= AvailableWood)
# @Constraint Constr_2 @Def: The total paint required for producing model trains and model planes cannot exceed AvailablePaint units of paint.
model.addConstr(PaintPerTrain * NumberOfTrains + PaintPerPlane * NumberOfPlanes <= AvailablePaint)

# Objective 
# @Objective Objective @Def: The total profit is calculated as ProfitTrain times the number of model trains plus ProfitPlane times the number of model planes. The objective is to maximize the total profit.
model.setObjective(ProfitTrain * NumberOfTrains + ProfitPlane * NumberOfPlanes, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfTrains'] = NumberOfTrains.x
variables['NumberOfPlanes'] = NumberOfPlanes.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An electronics store wants to optimize how many phones and laptops are enough to keep in inventory. A phone will earn the store $120 in profits, and a laptop will earn $40. A phone requires 1 sq ft of floor space, whereas a laptop requires 4 sq ft. In total, 400 sq ft of floor space is available. The store stocks only phones and laptops. Corporate has required that at least 80% of all appliances in stock be laptops. Finally, a phone costs $400 for the store, and a laptop, $100. The store wants to spend at most $6000. Formulate an LP that can be used to maximize the store's profit.","{""variables"": {""NumberOfPhones"": 0.0, ""NumberOfLaptops"": 60.0}, ""objective"": 2400.0}","{""parametrized_description"": ""An electronics store seeks to determine the optimal quantities of two types of products to maintain in inventory to maximize profit. Each unit of the first product yields ProfitPhone in profit, while each unit of the second product yields ProfitLaptop in profit. The first product requires SpacePhone square feet of floor space, and the second product requires SpaceLaptop square feet of floor space. The store has a total of TotalSpace square feet of available floor space. The inventory is limited to these two products only, with a corporate requirement that at least MinLaptopPercentage of all stocked products must be the second product. Additionally, each unit of the first product costs CostPhone and each unit of the second product costs CostLaptop, with the total expenditure not exceeding MaxBudget. Formulate a linear programming model to maximize the store's profit."", ""keywords"": [""N.A.""], ""parameters"": {""ProfitPhone"": {""description"": ""Profit earned per phone"", ""shape"": []}, ""ProfitLaptop"": {""description"": ""Profit earned per laptop"", ""shape"": []}, ""SpacePhone"": {""description"": ""Floor space required per phone (sq ft)"", ""shape"": []}, ""SpaceLaptop"": {""description"": ""Floor space required per laptop (sq ft)"", ""shape"": []}, ""TotalSpace"": {""description"": ""Total available floor space (sq ft)"", ""shape"": []}, ""MinLaptopPercentage"": {""description"": ""Minimum percentage of laptops required in inventory"", ""shape"": []}, ""CostPhone"": {""description"": ""Cost per phone"", ""shape"": []}, ""CostLaptop"": {""description"": ""Cost per laptop"", ""shape"": []}, ""MaxBudget"": {""description"": ""Maximum total budget"", ""shape"": []}}, ""variables"": {""NumberOfPhones"": {""description"": ""The number of phones"", ""type"": ""continuous"", ""shape"": [""NonNegative""]}, ""NumberOfLaptops"": {""description"": ""The number of laptops"", ""type"": ""continuous"", ""shape"": [""NonNegative""]}}, ""constraints"": [{""description"": ""The total floor space used by phones and laptops must not exceed TotalSpace square feet."", ""formulation"": ""NumberOfPhones \\cdot SpacePhone + NumberOfLaptops \\cdot SpaceLaptop \\leq TotalSpace"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfPhones * SpacePhone + NumberOfLaptops * SpaceLaptop <= TotalSpace)""}}, {""description"": ""The total cost of phones and laptops must not exceed MaxBudget."", ""formulation"": ""CostPhone \\times NumberOfPhones + CostLaptop \\times NumberOfLaptops \\leq MaxBudget"", ""code"": {""gurobipy"": ""model.addConstr(CostPhone * NumberOfPhones + CostLaptop * NumberOfLaptops <= MaxBudget)""}}, {""description"": ""The number of laptops must be at least MinLaptopPercentage of the total inventory of phones and laptops."", ""formulation"": ""NumberOfLaptops \\geq MinLaptopPercentage \\times (NumberOfPhones + NumberOfLaptops)"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfLaptops >= MinLaptopPercentage * (NumberOfPhones + NumberOfLaptops))""}}], ""objective"": {""description"": ""Maximize the total profit, which is calculated as (ProfitPhone multiplied by the number of phones) plus (ProfitLaptop multiplied by the number of laptops)."", ""formulation"": ""Max (ProfitPhone \\times NumberOfPhones + ProfitLaptop \\times NumberOfLaptops)"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPhone * NumberOfPhones + ProfitLaptop * NumberOfLaptops, GRB.MAXIMIZE)""}}}","{""ProfitPhone"": 120, ""ProfitLaptop"": 40, ""SpacePhone"": 1, ""SpaceLaptop"": 4, ""TotalSpace"": 400, ""MinLaptopPercentage"": 0.8, ""CostPhone"": 400, ""CostLaptop"": 100, ""MaxBudget"": 6000}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
An electronics store seeks to determine the optimal quantities of two types of
products to maintain in inventory to maximize profit. Each unit of the first
product yields ProfitPhone in profit, while each unit of the second product
yields ProfitLaptop in profit. The first product requires SpacePhone square feet
of floor space, and the second product requires SpaceLaptop square feet of floor
space. The store has a total of TotalSpace square feet of available floor space.
The inventory is limited to these two products only, with a corporate
requirement that at least MinLaptopPercentage of all stocked products must be
the second product. Additionally, each unit of the first product costs CostPhone
and each unit of the second product costs CostLaptop, with the total expenditure
not exceeding MaxBudget. Formulate a linear programming model to maximize the
store's profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/18/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProfitPhone @Def: Profit earned per phone @Shape: [] 
ProfitPhone = data['ProfitPhone']
# @Parameter ProfitLaptop @Def: Profit earned per laptop @Shape: [] 
ProfitLaptop = data['ProfitLaptop']
# @Parameter SpacePhone @Def: Floor space required per phone (sq ft) @Shape: [] 
SpacePhone = data['SpacePhone']
# @Parameter SpaceLaptop @Def: Floor space required per laptop (sq ft) @Shape: [] 
SpaceLaptop = data['SpaceLaptop']
# @Parameter TotalSpace @Def: Total available floor space (sq ft) @Shape: [] 
TotalSpace = data['TotalSpace']
# @Parameter MinLaptopPercentage @Def: Minimum percentage of laptops required in inventory @Shape: [] 
MinLaptopPercentage = data['MinLaptopPercentage']
# @Parameter CostPhone @Def: Cost per phone @Shape: [] 
CostPhone = data['CostPhone']
# @Parameter CostLaptop @Def: Cost per laptop @Shape: [] 
CostLaptop = data['CostLaptop']
# @Parameter MaxBudget @Def: Maximum total budget @Shape: [] 
MaxBudget = data['MaxBudget']

# Variables 
# @Variable NumberOfPhones @Def: The number of phones @Shape: ['NonNegative'] 
NumberOfPhones = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfPhones"")
# @Variable NumberOfLaptops @Def: The number of laptops @Shape: ['NonNegative'] 
NumberOfLaptops = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfLaptops"")

# Constraints 
# @Constraint Constr_1 @Def: The total floor space used by phones and laptops must not exceed TotalSpace square feet.
model.addConstr(NumberOfPhones * SpacePhone + NumberOfLaptops * SpaceLaptop <= TotalSpace)
# @Constraint Constr_2 @Def: The total cost of phones and laptops must not exceed MaxBudget.
model.addConstr(CostPhone * NumberOfPhones + CostLaptop * NumberOfLaptops <= MaxBudget)
# @Constraint Constr_3 @Def: The number of laptops must be at least MinLaptopPercentage of the total inventory of phones and laptops.
model.addConstr(NumberOfLaptops >= MinLaptopPercentage * (NumberOfPhones + NumberOfLaptops))

# Objective 
# @Objective Objective @Def: Maximize the total profit, which is calculated as (ProfitPhone multiplied by the number of phones) plus (ProfitLaptop multiplied by the number of laptops).
model.setObjective(ProfitPhone * NumberOfPhones + ProfitLaptop * NumberOfLaptops, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfPhones'] = NumberOfPhones.x
variables['NumberOfLaptops'] = NumberOfLaptops.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A candy store mixes regular candy and sour candy to prepare two products, regular mix and sour surprise mix. Each kilogram of the regular mix contains 0.8 kg of regular candy and 0.2 kg of sour candy. The profit per kilogram of the regular mix is $3. Each kilogram of the sour surprise mix contains 0.1 kg of regular candy and 0.9 kg of sour candy. The profit per kilogram of the sour surprise mix is $5. The candy store has 80 kg of regular candy and 60 kg of sour candy available. How many kilograms of each type of candy mix should be created to maximize profits?","{""variables"": {""ProductionMix"": {""0"": 94.28571428571428, ""1"": 45.71428571428571}}, ""objective"": 511.4285714285714}","{""parametrized_description"": ""A candy store prepares NumMixes different candy mixes using NumCandyTypes different types of candy. Each kilogram of each mix requires specific amounts of each candy type as defined by CompositionRequired. The profit per kilogram of each mix is given by ProfitPerMix. The store has AvailableCandy kilograms of each candy type available. Determine the quantities of each mix to produce to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""NumMixes"": {""description"": ""Number of different candy mixes prepared"", ""shape"": []}, ""NumCandyTypes"": {""description"": ""Number of different candy types used"", ""shape"": []}, ""CompositionRequired"": {""description"": ""Amount of each candy type required per kilogram of each mix"", ""shape"": [""NumCandyTypes"", ""NumMixes""]}, ""ProfitPerMix"": {""description"": ""Profit per kilogram of each mix"", ""shape"": [""NumMixes""]}, ""AvailableCandy"": {""description"": ""Amount of each candy type available"", ""shape"": [""NumCandyTypes""]}}, ""variables"": {""ProductionMix"": {""description"": ""The quantity of each mix produced (in kilograms)"", ""type"": ""continuous"", ""shape"": [""NumMixes""]}}, ""constraints"": [{""description"": ""Each kilogram of each mix requires specific amounts of each candy type as defined by CompositionRequired."", ""formulation"": ""\\sum_{i=1}^{NumMixes} CompositionRequired_{j,i} \\times ProductionMix_i \\leq AvailableCandy_j \\quad \\forall j = 1, \\dots, NumCandyTypes"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(CompositionRequired[j][i] * ProductionMix[i] for i in range(NumMixes)) <= AvailableCandy[j] for j in range(NumCandyTypes)), name=\""CandySupply\"")""}}, {""description"": ""The total usage of each candy type across all mixes cannot exceed the available amount AvailableCandy."", ""formulation"": ""\\sum_{m=1}^{\\text{NumMixes}} \\text{CompositionRequired}_{c,m} \\times \\text{ProductionMix}_{m} \\leq \\text{AvailableCandy}_{c} \\quad \\forall c = 1, \\dots, \\text{NumCandyTypes}"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(CompositionRequired[c, m] * ProductionMix[m] for m in range(NumMixes)) <= AvailableCandy[c] for c in range(NumCandyTypes)), name=\""CandyUsage\"")""}}], ""objective"": {""description"": ""Total profit is the sum of the profit per kilogram of each mix multiplied by the quantities produced. The objective is to maximize the total profit."", ""formulation"": ""Max \\sum_{i=1}^{NumMixes} ProfitPerMix_i \\cdot ProductionMix_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProductionMix[i] * ProfitPerMix[i] for i in range(NumMixes)), GRB.MAXIMIZE)""}}}","{""NumMixes"": 2, ""NumCandyTypes"": 2, ""CompositionRequired"": [[0.8, 0.1], [0.2, 0.9]], ""ProfitPerMix"": [3, 5], ""AvailableCandy"": [80, 60]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A candy store prepares NumMixes different candy mixes using NumCandyTypes
different types of candy. Each kilogram of each mix requires specific amounts of
each candy type as defined by CompositionRequired. The profit per kilogram of
each mix is given by ProfitPerMix. The store has AvailableCandy kilograms of
each candy type available. Determine the quantities of each mix to produce to
maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/19/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumMixes @Def: Number of different candy mixes prepared @Shape: [] 
NumMixes = data['NumMixes']
# @Parameter NumCandyTypes @Def: Number of different candy types used @Shape: [] 
NumCandyTypes = data['NumCandyTypes']
# @Parameter CompositionRequired @Def: Amount of each candy type required per kilogram of each mix @Shape: ['NumCandyTypes', 'NumMixes'] 
CompositionRequired = data['CompositionRequired']
# @Parameter ProfitPerMix @Def: Profit per kilogram of each mix @Shape: ['NumMixes'] 
ProfitPerMix = data['ProfitPerMix']
# @Parameter AvailableCandy @Def: Amount of each candy type available @Shape: ['NumCandyTypes'] 
AvailableCandy = data['AvailableCandy']

# Variables 
# @Variable ProductionMix @Def: The quantity of each mix produced (in kilograms) @Shape: ['NumMixes'] 
ProductionMix = model.addVars(NumMixes, vtype=GRB.CONTINUOUS, name=""ProductionMix"")

# Constraints 
# @Constraint Constr_1 @Def: Each kilogram of each mix requires specific amounts of each candy type as defined by CompositionRequired.
model.addConstrs((quicksum(CompositionRequired[j][i] * ProductionMix[i] for i in range(NumMixes)) <= AvailableCandy[j] for j in range(NumCandyTypes)), name=""CandySupply"")
# @Constraint Constr_2 @Def: The total usage of each candy type across all mixes cannot exceed the available amount AvailableCandy.
model.addConstrs((quicksum(CompositionRequired[c][m] * ProductionMix[m] for m in range(NumMixes)) <= AvailableCandy[c] for c in range(NumCandyTypes)), name=""CandyUsage"")

# Objective 
# @Objective Objective @Def: Total profit is the sum of the profit per kilogram of each mix multiplied by the quantities produced. The objective is to maximize the total profit.
model.setObjective(quicksum(ProductionMix[i] * ProfitPerMix[i] for i in range(NumMixes)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ProductionMix'] = {i: ProductionMix[i].X for i in range(NumMixes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
A suspicious factory has 100 sq. feet of space. It makes bootleg phones and laptops. Phones require 2 hours of labor and cost $12 for each sq. foot of space allocated for phone production (cost of electricity and equipment). Laptops require 3 hours of labor and cost $15 for each sq. foot of space allocated for laptop production. Phones produce a net revenue of $50 per sq. foot while laptops produce a net revenue of $70 per sq. foot. The factory wants to spend at most $5000 and 2000 hours of labor. What is the optimal factory layout to maximize revenue?,"{""variables"": {""AllocatedSpace"": {""0"": 0.0, ""1"": 100.0}}, ""objective"": 7000.0}","{""parametrized_description"": ""A factory has TotalSpace square feet of available space. It produces NumberOfProducts different products. Each product requires LaborRequiredPerSqFt labor hours per square foot and costs CostPerSqFt dollars per square foot to produce. Each product generates RevenuePerSqFt dollars of net revenue per square foot. The factory aims to spend at most Budget dollars and has at most LaborHoursAvailable labor hours. The objective is to determine the allocation of space to each product to maximize revenue."", ""keywords"": [""N.A.""], ""parameters"": {""TotalSpace"": {""description"": ""Total available space in square feet"", ""shape"": []}, ""Budget"": {""description"": ""Maximum allowed budget in dollars"", ""shape"": []}, ""LaborHoursAvailable"": {""description"": ""Maximum available labor hours"", ""shape"": []}, ""NumberOfProducts"": {""description"": ""Number of products produced"", ""shape"": []}, ""LaborRequiredPerSqFt"": {""description"": ""Labor hours required per square foot for each product"", ""shape"": [""NumberOfProducts""]}, ""CostPerSqFt"": {""description"": ""Cost per square foot for each product"", ""shape"": [""NumberOfProducts""]}, ""RevenuePerSqFt"": {""description"": ""Net revenue per square foot for each product"", ""shape"": [""NumberOfProducts""]}}, ""variables"": {""AllocatedSpace"": {""description"": ""The allocated space for each product"", ""type"": ""continuous"", ""shape"": [""NumberOfProducts""]}}, ""constraints"": [{""description"": ""The total allocated space for all products cannot exceed TotalSpace square feet."", ""formulation"": ""\\sum_{i=1}^{NumberOfProducts} AllocatedSpace_{i} \\leq TotalSpace"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(AllocatedSpace[i] for i in range(NumberOfProducts)) <= TotalSpace)""}}, {""description"": ""The total production cost, calculated as the sum of CostPerSqFt multiplied by the allocated space for each product, cannot exceed Budget dollars."", ""formulation"": ""\\sum_{i=1}^{NumberOfProducts} CostPerSqFt_{i} \\times AllocatedSpace_{i} \\leq Budget"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(CostPerSqFt[i] * AllocatedSpace[i] for i in range(NumberOfProducts)) <= Budget)""}}, {""description"": ""The total labor hours required, calculated as the sum of LaborRequiredPerSqFt multiplied by the allocated space for each product, cannot exceed LaborHoursAvailable labor hours."", ""formulation"": ""\\sum_{i=1}^{\\text{NumberOfProducts}} \\text{LaborRequiredPerSqFt}_i \\cdot \\text{AllocatedSpace}_i \\leq \\text{LaborHoursAvailable}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(LaborRequiredPerSqFt[i] * AllocatedSpace[i] for i in range(NumberOfProducts)) <= LaborHoursAvailable)""}}], ""objective"": {""description"": ""Total revenue is the sum of the net revenue per square foot for each product multiplied by the allocated space for each product. The objective is to maximize total revenue."", ""formulation"": ""Max \\sum_{i=1}^{NumberOfProducts} RevenuePerSqFt_i \\cdot AllocatedSpace_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(RevenuePerSqFt[i] * AllocatedSpace[i] for i in range(NumberOfProducts)), GRB.MAXIMIZE)""}}}","{""TotalSpace"": 100, ""Budget"": 5000, ""LaborHoursAvailable"": 2000, ""NumberOfProducts"": 2, ""LaborRequiredPerSqFt"": [2, 3], ""CostPerSqFt"": [12, 15], ""RevenuePerSqFt"": [50, 70]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A factory has TotalSpace square feet of available space. It produces
NumberOfProducts different products. Each product requires LaborRequiredPerSqFt
labor hours per square foot and costs CostPerSqFt dollars per square foot to
produce. Each product generates RevenuePerSqFt dollars of net revenue per square
foot. The factory aims to spend at most Budget dollars and has at most
LaborHoursAvailable labor hours. The objective is to determine the allocation of
space to each product to maximize revenue.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/20/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter TotalSpace @Def: Total available space in square feet @Shape: [] 
TotalSpace = data['TotalSpace']
# @Parameter Budget @Def: Maximum allowed budget in dollars @Shape: [] 
Budget = data['Budget']
# @Parameter LaborHoursAvailable @Def: Maximum available labor hours @Shape: [] 
LaborHoursAvailable = data['LaborHoursAvailable']
# @Parameter NumberOfProducts @Def: Number of products produced @Shape: [] 
NumberOfProducts = data['NumberOfProducts']
# @Parameter LaborRequiredPerSqFt @Def: Labor hours required per square foot for each product @Shape: ['NumberOfProducts'] 
LaborRequiredPerSqFt = data['LaborRequiredPerSqFt']
# @Parameter CostPerSqFt @Def: Cost per square foot for each product @Shape: ['NumberOfProducts'] 
CostPerSqFt = data['CostPerSqFt']
# @Parameter RevenuePerSqFt @Def: Net revenue per square foot for each product @Shape: ['NumberOfProducts'] 
RevenuePerSqFt = data['RevenuePerSqFt']

# Variables 
# @Variable AllocatedSpace @Def: The allocated space for each product @Shape: ['NumberOfProducts'] 
AllocatedSpace = model.addVars(NumberOfProducts, vtype=GRB.CONTINUOUS, name=""AllocatedSpace"")

# Constraints 
# @Constraint Constr_1 @Def: The total allocated space for all products cannot exceed TotalSpace square feet.
model.addConstr(quicksum(AllocatedSpace[i] for i in range(NumberOfProducts)) <= TotalSpace)
# @Constraint Constr_2 @Def: The total production cost, calculated as the sum of CostPerSqFt multiplied by the allocated space for each product, cannot exceed Budget dollars.
model.addConstr(quicksum(CostPerSqFt[i] * AllocatedSpace[i] for i in range(NumberOfProducts)) <= Budget)
# @Constraint Constr_3 @Def: The total labor hours required, calculated as the sum of LaborRequiredPerSqFt multiplied by the allocated space for each product, cannot exceed LaborHoursAvailable labor hours.
model.addConstr(quicksum(LaborRequiredPerSqFt[i] * AllocatedSpace[i] for i in range(NumberOfProducts)) <= LaborHoursAvailable)

# Objective 
# @Objective Objective @Def: Total revenue is the sum of the net revenue per square foot for each product multiplied by the allocated space for each product. The objective is to maximize total revenue.
model.setObjective(quicksum(RevenuePerSqFt[i] * AllocatedSpace[i] for i in range(NumberOfProducts)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['AllocatedSpace'] = {i: AllocatedSpace[i].x for i in range(NumberOfProducts)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
A electronics store sells premium desktops with more power as well as regular desktops for everyday use. Each premium desktop costs the store $2000 to make and yields a profit of $500. Each regular desktop costs the store $1000 to make and yields a profit of $300. The store sells at most 200 desktops each month and wants to spend at most $300000 on making the desktops. How many of each should be made and sold to maximize profit?,"{""variables"": {""NumPremiumDesktops"": 100.0, ""NumRegularDesktops"": 100.0}, ""objective"": 80000.0}","{""parametrized_description"": ""The store produces premium desktops and regular desktops. The total number of desktops produced does not exceed MaxDesktopSales. The total manufacturing cost, calculated as the number of premium desktops multiplied by ManufacturingCostPremiumDesktop plus the number of regular desktops multiplied by ManufacturingCostRegularDesktop, does not exceed MaxManufacturingBudget. The objective is to maximize profit, which is the number of premium desktops multiplied by ProfitPremiumDesktop plus the number of regular desktops multiplied by ProfitRegularDesktop."", ""keywords"": [""N.A.""], ""parameters"": {""ManufacturingCostPremiumDesktop"": {""description"": ""Manufacturing cost of a premium desktop"", ""shape"": []}, ""ManufacturingCostRegularDesktop"": {""description"": ""Manufacturing cost of a regular desktop"", ""shape"": []}, ""ProfitPremiumDesktop"": {""description"": ""Profit from a premium desktop"", ""shape"": []}, ""ProfitRegularDesktop"": {""description"": ""Profit from a regular desktop"", ""shape"": []}, ""MaxDesktopSales"": {""description"": ""Maximum number of desktops sold per month"", ""shape"": []}, ""MaxManufacturingBudget"": {""description"": ""Maximum spending on making the desktops"", ""shape"": []}}, ""variables"": {""NumPremiumDesktops"": {""description"": ""The number of premium desktops produced"", ""type"": ""continuous"", ""shape"": [""Continuous"", ""NonNegative""]}, ""NumRegularDesktops"": {""description"": ""The number of regular desktops produced"", ""type"": ""continuous"", ""shape"": [""Continuous"", ""NonNegative""]}}, ""constraints"": [{""description"": ""The total number of desktops produced does not exceed MaxDesktopSales."", ""formulation"": ""NumPremiumDesktops + NumRegularDesktops \\leq MaxDesktopSales"", ""code"": {""gurobipy"": ""model.addConstr(NumPremiumDesktops + NumRegularDesktops <= MaxDesktopSales)""}}, {""description"": ""The total manufacturing cost, calculated as the number of premium desktops multiplied by ManufacturingCostPremiumDesktop plus the number of regular desktops multiplied by ManufacturingCostRegularDesktop, does not exceed MaxManufacturingBudget."", ""formulation"": ""NumPremiumDesktops \\cdot ManufacturingCostPremiumDesktop + NumRegularDesktops \\cdot ManufacturingCostRegularDesktop \\leq MaxManufacturingBudget"", ""code"": {""gurobipy"": ""model.addConstr(ManufacturingCostPremiumDesktop * NumPremiumDesktops + ManufacturingCostRegularDesktop * NumRegularDesktops <= MaxManufacturingBudget)""}}], ""objective"": {""description"": ""The profit is the number of premium desktops multiplied by ProfitPremiumDesktop plus the number of regular desktops multiplied by ProfitRegularDesktop. The objective is to maximize profit."", ""formulation"": ""Max ProfitPremiumDesktop \\times NumPremiumDesktops + ProfitRegularDesktop \\times NumRegularDesktops"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPremiumDesktop * NumPremiumDesktops + ProfitRegularDesktop * NumRegularDesktops, GRB.MAXIMIZE)""}}}","{""ManufacturingCostPremiumDesktop"": 2000, ""ManufacturingCostRegularDesktop"": 1000, ""ProfitPremiumDesktop"": 500, ""ProfitRegularDesktop"": 300, ""MaxDesktopSales"": 200, ""MaxManufacturingBudget"": 300000}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
The store produces premium desktops and regular desktops. The total number of
desktops produced does not exceed MaxDesktopSales. The total manufacturing cost,
calculated as the number of premium desktops multiplied by
ManufacturingCostPremiumDesktop plus the number of regular desktops multiplied
by ManufacturingCostRegularDesktop, does not exceed MaxManufacturingBudget. The
objective is to maximize profit, which is the number of premium desktops
multiplied by ProfitPremiumDesktop plus the number of regular desktops
multiplied by ProfitRegularDesktop.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/21/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ManufacturingCostPremiumDesktop @Def: Manufacturing cost of a premium desktop @Shape: [] 
ManufacturingCostPremiumDesktop = data['ManufacturingCostPremiumDesktop']
# @Parameter ManufacturingCostRegularDesktop @Def: Manufacturing cost of a regular desktop @Shape: [] 
ManufacturingCostRegularDesktop = data['ManufacturingCostRegularDesktop']
# @Parameter ProfitPremiumDesktop @Def: Profit from a premium desktop @Shape: [] 
ProfitPremiumDesktop = data['ProfitPremiumDesktop']
# @Parameter ProfitRegularDesktop @Def: Profit from a regular desktop @Shape: [] 
ProfitRegularDesktop = data['ProfitRegularDesktop']
# @Parameter MaxDesktopSales @Def: Maximum number of desktops sold per month @Shape: [] 
MaxDesktopSales = data['MaxDesktopSales']
# @Parameter MaxManufacturingBudget @Def: Maximum spending on making the desktops @Shape: [] 
MaxManufacturingBudget = data['MaxManufacturingBudget']

# Variables 
# @Variable NumPremiumDesktops @Def: The number of premium desktops produced @Shape: ['Continuous', 'NonNegative'] 
NumPremiumDesktops = model.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""NumPremiumDesktops"")
# @Variable NumRegularDesktops @Def: The number of regular desktops produced @Shape: ['Continuous', 'NonNegative'] 
NumRegularDesktops = model.addVar(vtype=GRB.CONTINUOUS, name=""NumRegularDesktops"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of desktops produced does not exceed MaxDesktopSales.
model.addConstr(NumPremiumDesktops + NumRegularDesktops <= MaxDesktopSales)
# @Constraint Constr_2 @Def: The total manufacturing cost, calculated as the number of premium desktops multiplied by ManufacturingCostPremiumDesktop plus the number of regular desktops multiplied by ManufacturingCostRegularDesktop, does not exceed MaxManufacturingBudget.
model.addConstr(ManufacturingCostPremiumDesktop * NumPremiumDesktops + ManufacturingCostRegularDesktop * NumRegularDesktops <= MaxManufacturingBudget)

# Objective 
# @Objective Objective @Def: The profit is the number of premium desktops multiplied by ProfitPremiumDesktop plus the number of regular desktops multiplied by ProfitRegularDesktop. The objective is to maximize profit.
model.setObjective(ProfitPremiumDesktop * NumPremiumDesktops + ProfitRegularDesktop * NumRegularDesktops, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumPremiumDesktops'] = NumPremiumDesktops.x
variables['NumRegularDesktops'] = NumRegularDesktops.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A car manufacturer makes two versions of the same car, a regular model and a premium model. They make x1 regular models per day and x2 premium models per day. The profit per regular model is $5000 and the profit per premium model is $8500 (x1 and x2 are unknown values both greater than or equal to 0). The daily demand for these cars is limited to and most 8 regular models and 6 premium models. In addition, the manufacturer can make a maximum of 12 cars of either type per day. How many cars of each model should the manufacturer make in order to maximize profit?","{""variables"": {""RegularModelsProduced"": 6.0, ""PremiumModelsProduced"": 6.0}, ""objective"": 81000.0}","{""parametrized_description"": ""The manufacturer aims to maximize total profit, calculated as ProfitRegular multiplied by the number of regular models produced (x\u2081) plus ProfitPremium multiplied by the number of premium models produced (x\u2082). This objective is subject to the following constraints: the number of regular models produced (x\u2081) must not exceed DemandRegular, the number of premium models produced (x\u2082) must not exceed DemandPremium, the combined production of regular and premium models (x\u2081 + x\u2082) must not exceed MaxCarsTotal, and both x\u2081 and x\u2082 must be greater than or equal to zero."", ""keywords"": [""N.A.""], ""parameters"": {""ProfitRegular"": {""description"": ""Profit per regular model"", ""shape"": []}, ""ProfitPremium"": {""description"": ""Profit per premium model"", ""shape"": []}, ""DemandRegular"": {""description"": ""Daily demand for regular models"", ""shape"": []}, ""DemandPremium"": {""description"": ""Daily demand for premium models"", ""shape"": []}, ""MaxCarsTotal"": {""description"": ""Maximum number of cars that can be made per day"", ""shape"": []}}, ""variables"": {""RegularModelsProduced"": {""description"": ""The number of regular models produced"", ""type"": ""continuous"", ""shape"": []}, ""PremiumModelsProduced"": {""description"": ""The number of premium models produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of regular models produced (x\u2081) must not exceed DemandRegular."", ""formulation"": ""RegularModelsProduced \\leq DemandRegular"", ""code"": {""gurobipy"": ""model.addConstr(RegularModelsProduced <= DemandRegular)""}}, {""description"": ""The number of premium models produced (x\u2082) must not exceed DemandPremium."", ""formulation"": ""PremiumModelsProduced \\leq DemandPremium"", ""code"": {""gurobipy"": ""model.addConstr(PremiumModelsProduced <= DemandPremium)""}}, {""description"": ""The combined production of regular and premium models (x\u2081 + x\u2082) must not exceed MaxCarsTotal."", ""formulation"": ""RegularModelsProduced + PremiumModelsProduced \\leq MaxCarsTotal"", ""code"": {""gurobipy"": ""model.addConstr(RegularModelsProduced + PremiumModelsProduced <= MaxCarsTotal)""}}, {""description"": ""Both x\u2081 and x\u2082 must be greater than or equal to zero."", ""formulation"": ""RegularModelsProduced \\geq 0 \\n PremiumModelsProduced \\geq 0"", ""code"": {""gurobipy"": ""model.addConstr(RegularModelsProduced >= 0)\nmodel.addConstr(PremiumModelsProduced >= 0)""}}], ""objective"": {""description"": ""Maximize total profit, calculated as ProfitRegular multiplied by the number of regular models produced (x\u2081) plus ProfitPremium multiplied by the number of premium models produced (x\u2082)."", ""formulation"": ""Max ProfitRegular \\times RegularModelsProduced + ProfitPremium \\times PremiumModelsProduced"", ""code"": {""gurobipy"": ""model.setObjective(ProfitRegular * RegularModelsProduced + ProfitPremium * PremiumModelsProduced, GRB.MAXIMIZE)""}}}","{""ProfitRegular"": 5000, ""ProfitPremium"": 8500, ""DemandRegular"": 8, ""DemandPremium"": 6, ""MaxCarsTotal"": 12}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
The manufacturer aims to maximize total profit, calculated as ProfitRegular
multiplied by the number of regular models produced (x₁) plus ProfitPremium
multiplied by the number of premium models produced (x₂). This objective is
subject to the following constraints: the number of regular models produced (x₁)
must not exceed DemandRegular, the number of premium models produced (x₂) must
not exceed DemandPremium, the combined production of regular and premium models
(x₁ + x₂) must not exceed MaxCarsTotal, and both x₁ and x₂ must be greater than
or equal to zero.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/22/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProfitRegular @Def: Profit per regular model @Shape: [] 
ProfitRegular = data['ProfitRegular']
# @Parameter ProfitPremium @Def: Profit per premium model @Shape: [] 
ProfitPremium = data['ProfitPremium']
# @Parameter DemandRegular @Def: Daily demand for regular models @Shape: [] 
DemandRegular = data['DemandRegular']
# @Parameter DemandPremium @Def: Daily demand for premium models @Shape: [] 
DemandPremium = data['DemandPremium']
# @Parameter MaxCarsTotal @Def: Maximum number of cars that can be made per day @Shape: [] 
MaxCarsTotal = data['MaxCarsTotal']

# Variables 
# @Variable RegularModelsProduced @Def: The number of regular models produced @Shape: [] 
RegularModelsProduced = model.addVar(vtype=GRB.CONTINUOUS, name=""RegularModelsProduced"")
# @Variable PremiumModelsProduced @Def: The number of premium models produced @Shape: [] 
PremiumModelsProduced = model.addVar(vtype=GRB.CONTINUOUS, name=""PremiumModelsProduced"")

# Constraints 
# @Constraint Constr_1 @Def: The number of regular models produced (x₁) must not exceed DemandRegular.
model.addConstr(RegularModelsProduced <= DemandRegular)
# @Constraint Constr_2 @Def: The number of premium models produced (x₂) must not exceed DemandPremium.
model.addConstr(PremiumModelsProduced <= DemandPremium)
# @Constraint Constr_3 @Def: The combined production of regular and premium models (x₁ + x₂) must not exceed MaxCarsTotal.
model.addConstr(RegularModelsProduced + PremiumModelsProduced <= MaxCarsTotal)
# @Constraint Constr_4 @Def: Both x₁ and x₂ must be greater than or equal to zero.
model.addConstr(RegularModelsProduced >= 0)
model.addConstr(PremiumModelsProduced >= 0)

# Objective 
# @Objective Objective @Def: Maximize total profit, calculated as ProfitRegular multiplied by the number of regular models produced (x₁) plus ProfitPremium multiplied by the number of premium models produced (x₂).
model.setObjective(ProfitRegular * RegularModelsProduced + ProfitPremium * PremiumModelsProduced, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['RegularModelsProduced'] = RegularModelsProduced.x
variables['PremiumModelsProduced'] = PremiumModelsProduced.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"You are designing an office space with two types of desks: long desks and short desks. You can spend at most $2000. Long desks cost $300, take up 10 square feet of space, and seat 6 employees. Short desks cost $100, take up 4 square feet of space, and seat 2 employees. The office can have at most 200 square feet of desks. How many of each desk should you buy in order to maximize the seating availability?","{""variables"": {""NumDesks"": {""0"": -0.0, ""1"": 20.0}}, ""objective"": 40.0}","{""parametrized_description"": ""You are designing an office space with NumDeskTypes different desk types. Each desk type has a Price, Space, and Seats. The total cost of the desks must not exceed MaxBudget, and the total space occupied by the desks must not exceed MaxSpace. The goal is to determine the number of each desk type to maximize the total seating availability."", ""keywords"": [""N.A.""], ""parameters"": {""NumDeskTypes"": {""description"": ""Number of desk types"", ""shape"": []}, ""Price"": {""description"": ""Cost of each desk type"", ""shape"": [""NumDeskTypes""]}, ""Space"": {""description"": ""Space occupied by each desk type"", ""shape"": [""NumDeskTypes""]}, ""Seats"": {""description"": ""Seating capacity of each desk type"", ""shape"": [""NumDeskTypes""]}, ""MaxBudget"": {""description"": ""Maximum budget available"", ""shape"": []}, ""MaxSpace"": {""description"": ""Maximum office space for desks"", ""shape"": []}}, ""variables"": {""NumDesks"": {""description"": ""The number of desks of each type"", ""type"": ""continuous"", ""shape"": [""NumDeskTypes""]}}, ""constraints"": [{""description"": ""The total cost of the desks must not exceed MaxBudget."", ""formulation"": ""\\sum_{i=1}^{NumDeskTypes} Price_i \\times NumDesks_i \\leq MaxBudget"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(Price[i] * NumDesks[i] for i in range(NumDeskTypes)) <= MaxBudget)""}}, {""description"": ""The total space occupied by the desks must not exceed MaxSpace."", ""formulation"": ""\\sum_{i=1}^{\\text{NumDeskTypes}} \\text{Space}_i \\cdot \\text{NumDesks}_i \\leq \\text{MaxSpace}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(Space[i] * NumDesks[i] for i in range(NumDeskTypes)) <= MaxSpace)""}}], ""objective"": {""description"": ""The total seating availability is the sum of the seating capacity of each desk type multiplied by the number of that desk type. The objective is to maximize the total seating availability."", ""formulation"": ""Max \\sum_{i=1}^{NumDeskTypes} \\text{Seats}_i \\times \\text{NumDesks}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(Seats[i] * NumDesks[i] for i in range(NumDeskTypes)), GRB.MAXIMIZE)""}}}","{""NumDeskTypes"": 2, ""Price"": [300, 100], ""Space"": [10, 4], ""Seats"": [6, 2], ""MaxBudget"": 2000, ""MaxSpace"": 200}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
You are designing an office space with NumDeskTypes different desk types. Each
desk type has a Price, Space, and Seats. The total cost of the desks must not
exceed MaxBudget, and the total space occupied by the desks must not exceed
MaxSpace. The goal is to determine the number of each desk type to maximize the
total seating availability.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/23/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumDeskTypes @Def: Number of desk types @Shape: [] 
NumDeskTypes = data['NumDeskTypes']
# @Parameter Price @Def: Cost of each desk type @Shape: ['NumDeskTypes'] 
Price = data['Price']
# @Parameter Space @Def: Space occupied by each desk type @Shape: ['NumDeskTypes'] 
Space = data['Space']
# @Parameter Seats @Def: Seating capacity of each desk type @Shape: ['NumDeskTypes'] 
Seats = data['Seats']
# @Parameter MaxBudget @Def: Maximum budget available @Shape: [] 
MaxBudget = data['MaxBudget']
# @Parameter MaxSpace @Def: Maximum office space for desks @Shape: [] 
MaxSpace = data['MaxSpace']

# Variables 
# @Variable NumDesks @Def: The number of desks of each type @Shape: ['NumDeskTypes'] 
NumDesks = model.addVars(NumDeskTypes, vtype=GRB.INTEGER, name=""NumDesks"")

# Constraints 
# @Constraint Constr_1 @Def: The total cost of the desks must not exceed MaxBudget.
model.addConstr(quicksum(Price[i] * NumDesks[i] for i in range(NumDeskTypes)) <= MaxBudget)
# @Constraint Constr_2 @Def: The total space occupied by the desks must not exceed MaxSpace.
model.addConstr(quicksum(Space[i] * NumDesks[i] for i in range(NumDeskTypes)) <= MaxSpace)

# Objective 
# @Objective Objective @Def: The total seating availability is the sum of the seating capacity of each desk type multiplied by the number of that desk type. The objective is to maximize the total seating availability.
model.setObjective(quicksum(Seats[i] * NumDesks[i] for i in range(NumDeskTypes)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumDesks'] = {i: var.x for i, var in NumDesks.items()}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
Ayse produces a plant growth compound by mixing two types of fertilizer: C and Y. This growth compound must contain at least 5 units of nitrous oxide and 8 units of vitamin mix. Fertilizer C and Y cost $2 and $3 per kg respectively. Fertilizer C contains 1.5 units of nitrous oxide per kg and 3 units of vitamin mix per kg. Fertilizer Y contains 5 units of nitrous oxide per kg and 1 unit of vitamin mix per kg. Determine the minimum cost of Ayse's compound.,"{""variables"": {""FertilizerQuantity"": [2.5925925925925926, 0.22222222222222224]}, ""objective"": 5.851851851851852}","{""parametrized_description"": ""Ayse produces a plant growth compound by mixing NumFertilizers different types of fertilizer. The compound must contain at least RequiredNitrousOxide units of nitrous oxide and at least RequiredVitaminMix units of vitamin mix. Each fertilizer has a cost per kilogram given by CostFertilizer, contains NitrousOxidePerFertilizer units of nitrous oxide per kilogram, and VitaminMixPerFertilizer units of vitamin mix per kilogram. Determine the minimum cost of Ayse's compound."", ""keywords"": [""N.A.""], ""parameters"": {""NumFertilizers"": {""description"": ""Number of different fertilizers used in the compound"", ""shape"": []}, ""CostFertilizer"": {""description"": ""Cost per kilogram of each fertilizer"", ""shape"": [""NumFertilizers""]}, ""NitrousOxidePerFertilizer"": {""description"": ""Units of nitrous oxide per kilogram of each fertilizer"", ""shape"": [""NumFertilizers""]}, ""VitaminMixPerFertilizer"": {""description"": ""Units of vitamin mix per kilogram of each fertilizer"", ""shape"": [""NumFertilizers""]}, ""RequiredNitrousOxide"": {""description"": ""Minimum required units of nitrous oxide in the compound"", ""shape"": []}, ""RequiredVitaminMix"": {""description"": ""Minimum required units of vitamin mix in the compound"", ""shape"": []}}, ""variables"": {""FertilizerQuantity"": {""description"": ""The quantity of each fertilizer used in the compound"", ""type"": ""continuous"", ""shape"": [""NumFertilizers""]}}, ""constraints"": [{""description"": ""The compound must contain at least RequiredNitrousOxide units of nitrous oxide."", ""formulation"": ""\\sum_{i=1}^{NumFertilizers} NitrousOxidePerFertilizer_{i} \\cdot FertilizerQuantity_{i} \\geq RequiredNitrousOxide"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(NitrousOxidePerFertilizer[i] * FertilizerQuantity[i] for i in range(NumFertilizers)) >= RequiredNitrousOxide)""}}, {""description"": ""The compound must contain at least RequiredVitaminMix units of vitamin mix."", ""formulation"": ""\\sum_{i=1}^{NumFertilizers} VitaminMixPerFertilizer_i \\cdot FertilizerQuantity_i \\geq RequiredVitaminMix"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(VitaminMixPerFertilizer[i] * FertilizerQuantity[i] for i in range(NumFertilizers)) >= RequiredVitaminMix)""}}, {""description"": ""The amount of each fertilizer used must be non-negative."", ""formulation"": ""FertilizerQuantity \\geq 0"", ""code"": {""gurobipy"": ""model.addConstrs((FertilizerQuantity[k] >= 0 for k in range(NumFertilizers)), name=\""NonNegativeFertilizerQuantity\"")""}}], ""objective"": {""description"": ""The total cost of the compound is the sum of the cost per kilogram of each fertilizer multiplied by the amount used. The objective is to minimize the total cost of the compound."", ""formulation"": ""Min \\sum_{i=1}^{NumFertilizers} CostFertilizer_i \\cdot FertilizerQuantity_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(CostFertilizer[i] * FertilizerQuantity[i] for i in range(NumFertilizers)), GRB.MINIMIZE)""}}}","{""NumFertilizers"": 2, ""CostFertilizer"": [2, 3], ""NitrousOxidePerFertilizer"": [1.5, 5], ""VitaminMixPerFertilizer"": [3, 1], ""RequiredNitrousOxide"": 5, ""RequiredVitaminMix"": 8}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Ayse produces a plant growth compound by mixing NumFertilizers different types
of fertilizer. The compound must contain at least RequiredNitrousOxide units of
nitrous oxide and at least RequiredVitaminMix units of vitamin mix. Each
fertilizer has a cost per kilogram given by CostFertilizer, contains
NitrousOxidePerFertilizer units of nitrous oxide per kilogram, and
VitaminMixPerFertilizer units of vitamin mix per kilogram. Determine the minimum
cost of Ayse's compound.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/24/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumFertilizers @Def: Number of different fertilizers used in the compound @Shape: [] 
NumFertilizers = data['NumFertilizers']
# @Parameter CostFertilizer @Def: Cost per kilogram of each fertilizer @Shape: ['NumFertilizers'] 
CostFertilizer = data['CostFertilizer']
# @Parameter NitrousOxidePerFertilizer @Def: Units of nitrous oxide per kilogram of each fertilizer @Shape: ['NumFertilizers'] 
NitrousOxidePerFertilizer = data['NitrousOxidePerFertilizer']
# @Parameter VitaminMixPerFertilizer @Def: Units of vitamin mix per kilogram of each fertilizer @Shape: ['NumFertilizers'] 
VitaminMixPerFertilizer = data['VitaminMixPerFertilizer']
# @Parameter RequiredNitrousOxide @Def: Minimum required units of nitrous oxide in the compound @Shape: [] 
RequiredNitrousOxide = data['RequiredNitrousOxide']
# @Parameter RequiredVitaminMix @Def: Minimum required units of vitamin mix in the compound @Shape: [] 
RequiredVitaminMix = data['RequiredVitaminMix']

# Variables 
# @Variable FertilizerQuantity @Def: The quantity of each fertilizer used in the compound @Shape: ['NumFertilizers'] 
FertilizerQuantity = model.addVars(NumFertilizers, vtype=GRB.CONTINUOUS, name=""FertilizerQuantity"")

# Constraints 
# @Constraint Constr_1 @Def: The compound must contain at least RequiredNitrousOxide units of nitrous oxide.
model.addConstr(quicksum(NitrousOxidePerFertilizer[i] * FertilizerQuantity[i] for i in range(NumFertilizers)) >= RequiredNitrousOxide)
# @Constraint Constr_2 @Def: The compound must contain at least RequiredVitaminMix units of vitamin mix.
model.addConstr(quicksum(VitaminMixPerFertilizer[i] * FertilizerQuantity[i] for i in range(NumFertilizers)) >= RequiredVitaminMix)
# @Constraint Constr_3 @Def: The amount of each fertilizer used must be non-negative.
model.addConstrs((FertilizerQuantity[k] >= 0 for k in range(NumFertilizers)), name=""NonNegativeFertilizerQuantity"")

# Objective 
# @Objective Objective @Def: The total cost of the compound is the sum of the cost per kilogram of each fertilizer multiplied by the amount used. The objective is to minimize the total cost of the compound.
model.setObjective(quicksum(CostFertilizer[i] * FertilizerQuantity[i] for i in range(NumFertilizers)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['FertilizerQuantity'] = [FertilizerQuantity[i].X for i in range(NumFertilizers)]
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Sleep inducing medicine and anti-inflammatory medicine is found in two pills, pill A and pill B. One pill A contains 3 units of sleep inducing medicine and 5 units of anti-inflammatory medicine. One pill B contains 6 units of sleep-inducing medicine and 1 unit of anti-inflammatory medicine. The cost per pill for pill A is $4 and the cost per pill for pill B is $5. A patient must consume these two pills to get at least 40 units of sleep-inducing medicine and 50 units of anti-inflammatory medicine. Formulate a LP to minimize the cost for the patient.","{""variables"": {""PillsSelected"": {""0"": 9.62962962962963, ""1"": 1.8518518518518519}}, ""objective"": 47.77777777777778}","{""parametrized_description"": ""A patient selects non-negative quantities of each of the NumPillTypes pill types. Each pill type provides specific amounts of each of the NumMedicineTypes medicine types as defined by AmountPerPill. The total amount of each medicine must meet or exceed the RequiredAmount. The objective is to minimize the total cost, calculated using PillCost."", ""keywords"": [""N.A.""], ""parameters"": {""NumPillTypes"": {""description"": ""Number of different pill types"", ""shape"": []}, ""NumMedicineTypes"": {""description"": ""Number of different medicine types"", ""shape"": []}, ""AmountPerPill"": {""description"": ""Amount of a medicine type per pill type"", ""shape"": [""NumMedicineTypes"", ""NumPillTypes""]}, ""PillCost"": {""description"": ""Cost per pill type"", ""shape"": [""NumPillTypes""]}, ""RequiredAmount"": {""description"": ""Required amount of a medicine type"", ""shape"": [""NumMedicineTypes""]}}, ""variables"": {""PillsSelected"": {""description"": ""The number of pills selected for each pill type"", ""type"": ""continuous"", ""shape"": [""NumPillTypes""]}}, ""constraints"": [{""description"": ""The total amount of each medicine type provided by the selected pills must meet or exceed the RequiredAmount."", ""formulation"": ""\\sum_{j=1}^{\\text{NumPillTypes}} \\text{AmountPerPill}_{i,j} \\times \\text{PillsSelected}_j \\geq \\text{RequiredAmount}_i \\quad \\forall i \\in \\{1, \\dots, \\text{NumMedicineTypes}\\}"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(AmountPerPill[i][j] * PillsSelected[j] for j in range(NumPillTypes)) >= RequiredAmount[i] for i in range(NumMedicineTypes)), \""MedicineRequirements\"")""}}, {""description"": ""The quantity of each pill type selected must be non-negative."", ""formulation"": ""PillsSelected \\geq 0"", ""code"": {""gurobipy"": ""model.addConstrs((PillsSelected[k] >= 0 for k in range(NumPillTypes)), name='NonNegativity')""}}], ""objective"": {""description"": ""Minimize the total cost, calculated using PillCost."", ""formulation"": ""Min \\sum_{i=1}^{NumPillTypes} PillCost_i \\times PillsSelected_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(PillCost[i] * PillsSelected[i] for i in range(NumPillTypes)), GRB.MINIMIZE)""}}}","{""NumPillTypes"": 2, ""NumMedicineTypes"": 2, ""AmountPerPill"": [[3, 6], [5, 1]], ""PillCost"": [4, 5], ""RequiredAmount"": [40, 50]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A patient selects non-negative quantities of each of the NumPillTypes pill
types. Each pill type provides specific amounts of each of the NumMedicineTypes
medicine types as defined by AmountPerPill. The total amount of each medicine
must meet or exceed the RequiredAmount. The objective is to minimize the total
cost, calculated using PillCost.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/25/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumPillTypes @Def: Number of different pill types @Shape: [] 
NumPillTypes = data['NumPillTypes']
# @Parameter NumMedicineTypes @Def: Number of different medicine types @Shape: [] 
NumMedicineTypes = data['NumMedicineTypes']
# @Parameter AmountPerPill @Def: Amount of a medicine type per pill type @Shape: ['NumMedicineTypes', 'NumPillTypes'] 
AmountPerPill = data['AmountPerPill']
# @Parameter PillCost @Def: Cost per pill type @Shape: ['NumPillTypes'] 
PillCost = data['PillCost']
# @Parameter RequiredAmount @Def: Required amount of a medicine type @Shape: ['NumMedicineTypes'] 
RequiredAmount = data['RequiredAmount']

# Variables 
# @Variable PillsSelected @Def: The number of pills selected for each pill type @Shape: ['NumPillTypes'] 
PillsSelected = model.addVars(NumPillTypes, vtype=GRB.CONTINUOUS, name=""PillsSelected"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of each medicine type provided by the selected pills must meet or exceed the RequiredAmount.
model.addConstrs((quicksum(AmountPerPill[i][j] * PillsSelected[j] for j in range(NumPillTypes)) >= RequiredAmount[i] for i in range(NumMedicineTypes)), ""MedicineRequirements"")
# @Constraint Constr_2 @Def: The quantity of each pill type selected must be non-negative.
model.addConstrs((PillsSelected[k] >= 0 for k in range(NumPillTypes)), name='NonNegativity')

# Objective 
# @Objective Objective @Def: Minimize the total cost, calculated using PillCost.
model.setObjective(quicksum(PillCost[i] * PillsSelected[i] for i in range(NumPillTypes)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['PillsSelected'] = {k: v.x for k, v in PillsSelected.items()}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A car manufacturer makes two types of car oils: Oil Max and Oil Max Pro. A container of Oil Max contains 46 grams of substance A, 43 grams of substance B and 56 grams of substance C. A container of Oil Max Pro contains 13 grams of substance A, 4 grams of substance B and 45 grams of substance C. The car manufacturer has 1345 grams of substance A, 346 grams of substance B, 1643 grams of substance C. In addition, the profit per container of Oil Max is $10 and the profit per container of Oil Max Pro is $15. How many containers of each of oil should the car manufacturer make to maximize profit?","{""variables"": {""xOilType"": [0.0, 36.51111111111111]}, ""objective"": 547.6666666666667}","{""parametrized_description"": ""A car manufacturer produces NumOilTypes different types of car oils using NumSubstances different substances. Each container of oil type requires specific amounts of each substance as defined in SubstanceAmountPerContainer. The manufacturer has AvailableSubstances amounts of each substance available. The profit obtained from each container of oil type is specified in ProfitPerContainer. The objective is to determine the number of containers to produce for each oil type in order to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""NumOilTypes"": {""description"": ""Number of different types of car oils produced"", ""shape"": []}, ""NumSubstances"": {""description"": ""Number of different substances used in the car oils"", ""shape"": []}, ""ProfitPerContainer"": {""description"": ""Profit per container for each type of car oil"", ""shape"": [""NumOilTypes""]}, ""SubstanceAmountPerContainer"": {""description"": ""Amount of each substance required per container of each type of car oil"", ""shape"": [""NumSubstances"", ""NumOilTypes""]}, ""AvailableSubstances"": {""description"": ""Available amount of each substance"", ""shape"": [""NumSubstances""]}}, ""variables"": {""xOilType"": {""description"": ""The number of containers produced for each type of car oil"", ""type"": ""continuous"", ""shape"": [""NumOilTypes""]}}, ""constraints"": [{""description"": ""The total amount of each substance used across all oil types cannot exceed the available amount of that substance."", ""formulation"": ""\\sum_{t=1}^{\\text{NumOilTypes}} \\text{SubstanceAmountPerContainer}_{s,t} \\cdot xOilType_t \\leq \\text{AvailableSubstances}_s \\quad \\forall s = 1, \\dots, \\text{NumSubstances}"", ""code"": {""gurobipy"": ""model.addConstrs(\n    (quicksum(SubstanceAmountPerContainer[s][t] * xOilType[t] for t in range(NumOilTypes)) <= AvailableSubstances[s]\n     for s in range(NumSubstances)),\n    name=\""SubstanceLimit\""\n)""}}, {""description"": ""The number of containers produced for each oil type must be a non-negative value."", ""formulation"": ""xOilType \\geq 0"", ""code"": {""gurobipy"": ""model.addConstrs((xOilType[i] >= 0 for i in range(NumOilTypes)), \""NonNegative\"")""}}], ""objective"": {""description"": ""Maximize the total profit obtained from producing the car oil containers by determining the optimal number of containers for each oil type."", ""formulation"": ""Max \\sum_{o=1}^{NumOilTypes} ProfitPerContainer_{o} \\cdot xOilType_{o}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProfitPerContainer[o] * xOilType[o] for o in range(NumOilTypes)), GRB.MAXIMIZE)""}}}","{""NumOilTypes"": 2, ""NumSubstances"": 3, ""ProfitPerContainer"": [10, 15], ""SubstanceAmountPerContainer"": [[46, 13], [43, 4], [56, 45]], ""AvailableSubstances"": [1345, 346, 1643]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A car manufacturer produces NumOilTypes different types of car oils using
NumSubstances different substances. Each container of oil type requires specific
amounts of each substance as defined in SubstanceAmountPerContainer. The
manufacturer has AvailableSubstances amounts of each substance available. The
profit obtained from each container of oil type is specified in
ProfitPerContainer. The objective is to determine the number of containers to
produce for each oil type in order to maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/26/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumOilTypes @Def: Number of different types of car oils produced @Shape: [] 
NumOilTypes = data['NumOilTypes']
# @Parameter NumSubstances @Def: Number of different substances used in the car oils @Shape: [] 
NumSubstances = data['NumSubstances']
# @Parameter ProfitPerContainer @Def: Profit per container for each type of car oil @Shape: ['NumOilTypes'] 
ProfitPerContainer = data['ProfitPerContainer']
# @Parameter SubstanceAmountPerContainer @Def: Amount of each substance required per container of each type of car oil @Shape: ['NumSubstances', 'NumOilTypes'] 
SubstanceAmountPerContainer = data['SubstanceAmountPerContainer']
# @Parameter AvailableSubstances @Def: Available amount of each substance @Shape: ['NumSubstances'] 
AvailableSubstances = data['AvailableSubstances']

# Variables 
# @Variable xOilType @Def: The number of containers produced for each type of car oil @Shape: ['NumOilTypes'] 
xOilType = model.addVars(NumOilTypes, vtype=GRB.CONTINUOUS, name=""xOilType"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of each substance used across all oil types cannot exceed the available amount of that substance.
model.addConstrs(
    (quicksum(SubstanceAmountPerContainer[s][t] * xOilType[t] for t in range(NumOilTypes)) <= AvailableSubstances[s]
     for s in range(NumSubstances)),
    name=""SubstanceLimit""
)
# @Constraint Constr_2 @Def: The number of containers produced for each oil type must be a non-negative value.
model.addConstrs((xOilType[i] >= 0 for i in range(NumOilTypes)), ""NonNegative"")

# Objective 
# @Objective Objective @Def: Maximize the total profit obtained from producing the car oil containers by determining the optimal number of containers for each oil type.
model.setObjective(quicksum(ProfitPerContainer[o] * xOilType[o] for o in range(NumOilTypes)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['xOilType'] = [xOilType[t].X for t in range(NumOilTypes)]
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
A food truck owner can spend at most $20000 on mangos and guavas. A mango costs the food truck owner $5 and a guava costs him $3. Spices are added and each mango is sold for a profit of $3 while each guava is sold for a profit of $4. The owner estimates that at least 100 mangos but at the most 150 are sold each month. He also estimates that the number of guavas sold is at most a third of the mangos sold. How many mangos and guavas should be sold in order to maximize the profit?,"{""variables"": {""QuantityMango"": -0.0, ""QuantityGuava"": -0.0, ""MangosSold"": 150.0, ""GuavasSold"": 50.0}, ""objective"": 650.0}","{""parametrized_description"": ""The food truck owner allocates funds up to MaxSpendingBudget for purchasing mangos and guavas, with each mango costing CostMango and each guava costing CostGuava. Each mango sold generates a profit of ProfitMango and each guava sold generates a profit of ProfitGuava. The monthly sales of mangos are constrained to be at least MinMangosSold and at most MaxMangosSold. Furthermore, the number of guavas sold is limited to a maximum ratio defined by MaxGuavaToMangoRatio relative to the number of mangos sold. The goal is to determine the optimal quantities of mangos and guavas to sell in order to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""MaxSpendingBudget"": {""description"": ""The maximum amount the owner can spend on mangos and guavas"", ""shape"": []}, ""CostMango"": {""description"": ""The cost to purchase one mango"", ""shape"": []}, ""CostGuava"": {""description"": ""The cost to purchase one guava"", ""shape"": []}, ""ProfitMango"": {""description"": ""The profit earned from selling one mango"", ""shape"": []}, ""ProfitGuava"": {""description"": ""The profit earned from selling one guava"", ""shape"": []}, ""MinMangosSold"": {""description"": ""The minimum number of mangos sold each month"", ""shape"": []}, ""MaxMangosSold"": {""description"": ""The maximum number of mangos sold each month"", ""shape"": []}, ""MaxGuavaToMangoRatio"": {""description"": ""The maximum proportion of guavas sold relative to mangos sold"", ""shape"": []}}, ""variables"": {""QuantityMango"": {""description"": ""The number of mangos purchased"", ""type"": ""continuous"", ""shape"": []}, ""QuantityGuava"": {""description"": ""The number of guavas purchased"", ""type"": ""continuous"", ""shape"": []}, ""MangosSold"": {""description"": ""The number of mangos sold each month"", ""type"": ""continuous"", ""shape"": []}, ""GuavasSold"": {""description"": ""The number of guavas sold each month"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total spending on mangos and guavas cannot exceed MaxSpendingBudget."", ""formulation"": ""CostMango \\cdot QuantityMango + CostGuava \\cdot QuantityGuava \\leq MaxSpendingBudget"", ""code"": {""gurobipy"": ""model.addConstr(CostMango * QuantityMango + CostGuava * QuantityGuava <= MaxSpendingBudget)""}}, {""description"": ""The number of mangos sold must be at least MinMangosSold and at most MaxMangosSold each month."", ""formulation"": ""MangosSold \\geq MinMangosSold \\n MangosSold \\leq MaxMangosSold"", ""code"": {""gurobipy"": ""model.addConstr(MangosSold >= MinMangosSold)\nmodel.addConstr(MangosSold <= MaxMangosSold)""}}, {""description"": ""The number of guavas sold cannot exceed MaxGuavaToMangoRatio times the number of mangos sold."", ""formulation"": ""GuavasSold \\leq MaxGuavaToMangoRatio \\times MangosSold"", ""code"": {""gurobipy"": ""model.addConstr(GuavasSold <= MaxGuavaToMangoRatio * MangosSold)""}}], ""objective"": {""description"": ""Total profit is the sum of (ProfitMango multiplied by the number of mangos sold) and (ProfitGuava multiplied by the number of guavas sold). The objective is to maximize the total profit."", ""formulation"": ""Max \\ ProfitMango \\cdot MangosSold + ProfitGuava \\cdot GuavasSold"", ""code"": {""gurobipy"": ""model.setObjective(ProfitMango * MangosSold + ProfitGuava * GuavasSold, GRB.MAXIMIZE)""}}}","{""MaxSpendingBudget"": 20000, ""CostMango"": 5, ""CostGuava"": 3, ""ProfitMango"": 3, ""ProfitGuava"": 4, ""MinMangosSold"": 100, ""MaxMangosSold"": 150, ""MaxGuavaToMangoRatio"": 0.3333333333}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
The food truck owner allocates funds up to MaxSpendingBudget for purchasing
mangos and guavas, with each mango costing CostMango and each guava costing
CostGuava. Each mango sold generates a profit of ProfitMango and each guava sold
generates a profit of ProfitGuava. The monthly sales of mangos are constrained
to be at least MinMangosSold and at most MaxMangosSold. Furthermore, the number
of guavas sold is limited to a maximum ratio defined by MaxGuavaToMangoRatio
relative to the number of mangos sold. The goal is to determine the optimal
quantities of mangos and guavas to sell in order to maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/27/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MaxSpendingBudget @Def: The maximum amount the owner can spend on mangos and guavas @Shape: [] 
MaxSpendingBudget = data['MaxSpendingBudget']
# @Parameter CostMango @Def: The cost to purchase one mango @Shape: [] 
CostMango = data['CostMango']
# @Parameter CostGuava @Def: The cost to purchase one guava @Shape: [] 
CostGuava = data['CostGuava']
# @Parameter ProfitMango @Def: The profit earned from selling one mango @Shape: [] 
ProfitMango = data['ProfitMango']
# @Parameter ProfitGuava @Def: The profit earned from selling one guava @Shape: [] 
ProfitGuava = data['ProfitGuava']
# @Parameter MinMangosSold @Def: The minimum number of mangos sold each month @Shape: [] 
MinMangosSold = data['MinMangosSold']
# @Parameter MaxMangosSold @Def: The maximum number of mangos sold each month @Shape: [] 
MaxMangosSold = data['MaxMangosSold']
# @Parameter MaxGuavaToMangoRatio @Def: The maximum proportion of guavas sold relative to mangos sold @Shape: [] 
MaxGuavaToMangoRatio = data['MaxGuavaToMangoRatio']

# Variables 
# @Variable QuantityMango @Def: The number of mangos purchased @Shape: [] 
QuantityMango = model.addVar(vtype=GRB.INTEGER, name=""QuantityMango"")
# @Variable QuantityGuava @Def: The number of guavas purchased @Shape: [] 
QuantityGuava = model.addVar(vtype=GRB.INTEGER, name=""QuantityGuava"")
# @Variable MangosSold @Def: The number of mangos sold each month @Shape: [] 
MangosSold = model.addVar(vtype=GRB.INTEGER, lb=MinMangosSold, ub=MaxMangosSold, name=""MangosSold"")
# @Variable GuavasSold @Def: The number of guavas sold each month @Shape: [] 
GuavasSold = model.addVar(vtype=GRB.INTEGER, name=""GuavasSold"")

# Constraints 
# @Constraint Constr_1 @Def: The total spending on mangos and guavas cannot exceed MaxSpendingBudget.
model.addConstr(CostMango * QuantityMango + CostGuava * QuantityGuava <= MaxSpendingBudget)
# @Constraint Constr_2 @Def: The number of mangos sold must be at least MinMangosSold and at most MaxMangosSold each month.
model.addConstr(MangosSold >= MinMangosSold)
model.addConstr(MangosSold <= MaxMangosSold)
# @Constraint Constr_3 @Def: The number of guavas sold cannot exceed MaxGuavaToMangoRatio times the number of mangos sold.
model.addConstr(GuavasSold <= MaxGuavaToMangoRatio * MangosSold)

# Objective 
# @Objective Objective @Def: Total profit is the sum of (ProfitMango multiplied by the number of mangos sold) and (ProfitGuava multiplied by the number of guavas sold). The objective is to maximize the total profit.
model.setObjective(ProfitMango * MangosSold + ProfitGuava * GuavasSold, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityMango'] = QuantityMango.x
variables['QuantityGuava'] = QuantityGuava.x
variables['MangosSold'] = MangosSold.x
variables['GuavasSold'] = GuavasSold.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A nutritionist is making a special vitamin mix using two drinks: A and B. The vitamin mix must contain at least 150 units of Vitamin A, at least 300 units of vitamin D, and at most 400 units of vitamin E. A cup of drink A contains 8 units of Vitamin A, 6 units of Vitamin D, 10 units of Vitamin E, and 4 units of Vitamin K. A cup of drink B contains 15 units of Vitamin A, 2 units of Vitamin D, 20 units of Vitamin E, and 12 units of Vitamin K. How many cups of each drink should be used to make the vitamin mix in order to minimize the amount of Vitamin K?",{},{},"{""NumVitamins"": 4, ""NumDrinks"": 2, ""MinRequirements"": [150, 300, 0, 0], ""MaxRequirements"": [0, 0, 400, 0], ""VitaminContent"": [[8, 15], [6, 2], [10, 20], [4, 12]]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A nutritionist is creating a mix using NumDrinks different drinks. The mix must
contain at least the minimum required units specified by MinRequirements for
certain vitamins and at most the maximum allowed units specified by
MaxRequirements for other vitamins. Each cup of each drink provides amounts of
each vitamin as defined in VitaminContent. The goal is to determine the number
of cups of each drink to minimize the total units of a specific vitamin.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/28/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumVitamins @Def: Number of different vitamins @Shape: [] 
NumVitamins = data['NumVitamins']
# @Parameter NumDrinks @Def: Number of different drinks @Shape: [] 
NumDrinks = data['NumDrinks']
# @Parameter MinRequirements @Def: Minimum required units for each vitamin @Shape: ['NumVitamins'] 
MinRequirements = data['MinRequirements']
# @Parameter MaxRequirements @Def: Maximum allowed units for each vitamin @Shape: ['NumVitamins'] 
MaxRequirements = data['MaxRequirements']
# @Parameter VitaminContent @Def: Amount of each vitamin per cup of each drink @Shape: ['NumVitamins', 'NumDrinks'] 
VitaminContent = data['VitaminContent']

# Variables 
# @Variable DrinkCups @Def: The number of cups selected for each drink @Shape: ['NumDrinks'] 
DrinkCups = model.addVars(range(NumDrinks), vtype=GRB.CONTINUOUS, name=""DrinkCups"")

# Constraints 
# @Constraint Constr_1 @Def: The mix must contain at least the minimum required units specified by MinRequirements for certain vitamins.
model.addConstrs((quicksum(VitaminContent[i][j] * DrinkCups[j] for j in range(NumDrinks)) >= MinRequirements[i] for i in range(NumVitamins)), name=""MinVitamin"")
# @Constraint Constr_2 @Def: The mix must contain at most the maximum allowed units specified by MaxRequirements for other vitamins.
model.addConstrs(
    (quicksum(VitaminContent[v][d] * DrinkCups[d] for d in range(NumDrinks)) <= MaxRequirements[v] for v in range(NumVitamins)),
    name=""MaxVitaminRequirements""
)

# Objective 
# @Objective Objective @Def: Minimize the total units of Vitamin K in the mix.
model.setObjective(quicksum(VitaminContent[K, j] * DrinkCups[j] for j in range(NumDrinks)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['DrinkCups'] = DrinkCups.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An ice cream store makes chocolate and vanilla ice cream by the gallon. In a week, they must make at least 5 gallons of each type but at most 10 gallons of chocolate ice cream and at most 8 gallons of vanilla ice cream. It takes 1 hour to produce a gallon of chocolate ice cream and 2 hours to produce a gallon of vanilla ice cream. In a week, 30 hours are available to make ice cream. In addition at least 6 workers are needed with 1 working on the chocolate ice cream and 2 on the vanilla ice cream at any time. If the profit per gallon of chocolate ice cream is $200 and the profit per gallon of vanilla ice cream is $300, how many gallons of each should be made to maximize profit?","{""variables"": {""GallonsChocolateProduced"": 10.0, ""GallonsVanillaProduced"": 8.0}, ""objective"": 4400.0}","{""parametrized_description"": ""Maximize the total profit, which is ProfitChocolate multiplied by the number of gallons of chocolate ice cream produced plus ProfitVanilla multiplied by the number of gallons of vanilla ice cream produced, subject to the following constraints: the number of gallons of chocolate ice cream produced is at least MinGallonsChocolate and at most MaxGallonsChocolate; the number of gallons of vanilla ice cream produced is at least MinGallonsVanilla and at most MaxGallonsVanilla; the total production time, calculated as ProductionTimeChocolate multiplied by the number of gallons of chocolate ice cream produced plus ProductionTimeVanilla multiplied by the number of gallons of vanilla ice cream produced, does not exceed TotalProductionHours; WorkersNeededChocolate multiplied by the number of chocolate production operations plus WorkersNeededVanilla multiplied by the number of vanilla production operations does not exceed the total number of workers available, and the total number of workers is at least MinTotalWorkers."", ""keywords"": [""N.A.""], ""parameters"": {""MinGallonsChocolate"": {""description"": ""Minimum gallons of chocolate ice cream to produce per week"", ""shape"": []}, ""MinGallonsVanilla"": {""description"": ""Minimum gallons of vanilla ice cream to produce per week"", ""shape"": []}, ""MaxGallonsChocolate"": {""description"": ""Maximum gallons of chocolate ice cream to produce per week"", ""shape"": []}, ""MaxGallonsVanilla"": {""description"": ""Maximum gallons of vanilla ice cream to produce per week"", ""shape"": []}, ""ProductionTimeChocolate"": {""description"": ""Production time in hours to produce one gallon of chocolate ice cream"", ""shape"": []}, ""ProductionTimeVanilla"": {""description"": ""Production time in hours to produce one gallon of vanilla ice cream"", ""shape"": []}, ""TotalProductionHours"": {""description"": ""Total production hours available per week"", ""shape"": []}, ""WorkersNeededChocolate"": {""description"": ""Number of workers required to operate production of chocolate ice cream"", ""shape"": []}, ""WorkersNeededVanilla"": {""description"": ""Number of workers required to operate production of vanilla ice cream"", ""shape"": []}, ""MinTotalWorkers"": {""description"": ""Minimum total number of workers required"", ""shape"": []}, ""ProfitChocolate"": {""description"": ""Profit per gallon of chocolate ice cream"", ""shape"": []}, ""ProfitVanilla"": {""description"": ""Profit per gallon of vanilla ice cream"", ""shape"": []}}, ""variables"": {""GallonsChocolateProduced"": {""description"": ""The number of gallons of chocolate ice cream produced per week"", ""type"": ""continuous"", ""shape"": [""Continuous""]}, ""GallonsVanillaProduced"": {""description"": ""The number of gallons of vanilla ice cream produced per week"", ""type"": ""continuous"", ""shape"": [""Continuous""]}}, ""constraints"": [{""description"": ""The number of gallons of chocolate ice cream produced is at least MinGallonsChocolate and at most MaxGallonsChocolate."", ""formulation"": ""GallonsChocolateProduced \\geq MinGallonsChocolate \\n GallonsChocolateProduced \\leq MaxGallonsChocolate"", ""code"": {""gurobipy"": ""model.addConstr(GallonsChocolateProduced >= MinGallonsChocolate)\nmodel.addConstr(GallonsChocolateProduced <= MaxGallonsChocolate)""}}, {""description"": ""The number of gallons of vanilla ice cream produced is at least MinGallonsVanilla and at most MaxGallonsVanilla."", ""formulation"": ""MinGallonsVanilla \\leq GallonsVanillaProduced \\leq MaxGallonsVanilla"", ""code"": {""gurobipy"": """"}}, {""description"": ""The total production time, calculated as ProductionTimeChocolate multiplied by the number of gallons of chocolate ice cream produced plus ProductionTimeVanilla multiplied by the number of gallons of vanilla ice cream produced, does not exceed TotalProductionHours."", ""formulation"": ""ProductionTimeChocolate \\times GallonsChocolateProduced + ProductionTimeVanilla \\times GallonsVanillaProduced \\leq TotalProductionHours"", ""code"": {""gurobipy"": ""model.addConstr(ProductionTimeChocolate * GallonsChocolateProduced + ProductionTimeVanilla * GallonsVanillaProduced <= TotalProductionHours)""}}, {""description"": ""WorkersNeededChocolate multiplied by the number of gallons of chocolate ice cream produced plus WorkersNeededVanilla multiplied by the number of gallons of vanilla ice cream produced is at least MinTotalWorkers."", ""formulation"": ""WorkersNeededChocolate \\times GallonsChocolateProduced + WorkersNeededVanilla \\times GallonsVanillaProduced \\geq MinTotalWorkers"", ""code"": {""gurobipy"": ""model.addConstr(WorkersNeededChocolate * GallonsChocolateProduced + WorkersNeededVanilla * GallonsVanillaProduced >= MinTotalWorkers)""}}], ""objective"": {""description"": ""Maximize the total profit, which is ProfitChocolate multiplied by the number of gallons of chocolate ice cream produced plus ProfitVanilla multiplied by the number of gallons of vanilla ice cream produced."", ""formulation"": ""Max \\ ProfitChocolate \\times GallonsChocolateProduced + ProfitVanilla \\times GallonsVanillaProduced"", ""code"": {""gurobipy"": ""model.setObjective(ProfitChocolate * GallonsChocolateProduced + ProfitVanilla * GallonsVanillaProduced, GRB.MAXIMIZE)""}}}","{""MinGallonsChocolate"": 5, ""MinGallonsVanilla"": 5, ""MaxGallonsChocolate"": 10, ""MaxGallonsVanilla"": 8, ""ProductionTimeChocolate"": 1, ""ProductionTimeVanilla"": 2, ""TotalProductionHours"": 30, ""WorkersNeededChocolate"": 1, ""WorkersNeededVanilla"": 2, ""MinTotalWorkers"": 6, ""ProfitChocolate"": 200, ""ProfitVanilla"": 300}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Maximize the total profit, which is ProfitChocolate multiplied by the number of
gallons of chocolate ice cream produced plus ProfitVanilla multiplied by the
number of gallons of vanilla ice cream produced, subject to the following
constraints: the number of gallons of chocolate ice cream produced is at least
MinGallonsChocolate and at most MaxGallonsChocolate; the number of gallons of
vanilla ice cream produced is at least MinGallonsVanilla and at most
MaxGallonsVanilla; the total production time, calculated as
ProductionTimeChocolate multiplied by the number of gallons of chocolate ice
cream produced plus ProductionTimeVanilla multiplied by the number of gallons of
vanilla ice cream produced, does not exceed TotalProductionHours;
WorkersNeededChocolate multiplied by the number of chocolate production
operations plus WorkersNeededVanilla multiplied by the number of vanilla
production operations does not exceed the total number of workers available, and
the total number of workers is at least MinTotalWorkers.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/29/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MinGallonsChocolate @Def: Minimum gallons of chocolate ice cream to produce per week @Shape: [] 
MinGallonsChocolate = data['MinGallonsChocolate']
# @Parameter MinGallonsVanilla @Def: Minimum gallons of vanilla ice cream to produce per week @Shape: [] 
MinGallonsVanilla = data['MinGallonsVanilla']
# @Parameter MaxGallonsChocolate @Def: Maximum gallons of chocolate ice cream to produce per week @Shape: [] 
MaxGallonsChocolate = data['MaxGallonsChocolate']
# @Parameter MaxGallonsVanilla @Def: Maximum gallons of vanilla ice cream to produce per week @Shape: [] 
MaxGallonsVanilla = data['MaxGallonsVanilla']
# @Parameter ProductionTimeChocolate @Def: Production time in hours to produce one gallon of chocolate ice cream @Shape: [] 
ProductionTimeChocolate = data['ProductionTimeChocolate']
# @Parameter ProductionTimeVanilla @Def: Production time in hours to produce one gallon of vanilla ice cream @Shape: [] 
ProductionTimeVanilla = data['ProductionTimeVanilla']
# @Parameter TotalProductionHours @Def: Total production hours available per week @Shape: [] 
TotalProductionHours = data['TotalProductionHours']
# @Parameter WorkersNeededChocolate @Def: Number of workers required to operate production of chocolate ice cream @Shape: [] 
WorkersNeededChocolate = data['WorkersNeededChocolate']
# @Parameter WorkersNeededVanilla @Def: Number of workers required to operate production of vanilla ice cream @Shape: [] 
WorkersNeededVanilla = data['WorkersNeededVanilla']
# @Parameter MinTotalWorkers @Def: Minimum total number of workers required @Shape: [] 
MinTotalWorkers = data['MinTotalWorkers']
# @Parameter ProfitChocolate @Def: Profit per gallon of chocolate ice cream @Shape: [] 
ProfitChocolate = data['ProfitChocolate']
# @Parameter ProfitVanilla @Def: Profit per gallon of vanilla ice cream @Shape: [] 
ProfitVanilla = data['ProfitVanilla']

# Variables 
# @Variable GallonsChocolateProduced @Def: The number of gallons of chocolate ice cream produced per week @Shape: ['Continuous'] 
GallonsChocolateProduced = model.addVar(lb=MinGallonsChocolate, ub=MaxGallonsChocolate, vtype=GRB.CONTINUOUS, name=""GallonsChocolateProduced"")
# @Variable GallonsVanillaProduced @Def: The number of gallons of vanilla ice cream produced per week @Shape: ['Continuous'] 
GallonsVanillaProduced = model.addVar(vtype=GRB.CONTINUOUS, lb=MinGallonsVanilla, ub=MaxGallonsVanilla, name=""GallonsVanillaProduced"")

# Constraints 
# @Constraint Constr_1 @Def: The number of gallons of chocolate ice cream produced is at least MinGallonsChocolate and at most MaxGallonsChocolate.
model.addConstr(GallonsChocolateProduced >= MinGallonsChocolate)
model.addConstr(GallonsChocolateProduced <= MaxGallonsChocolate)
# @Constraint Constr_2 @Def: The number of gallons of vanilla ice cream produced is at least MinGallonsVanilla and at most MaxGallonsVanilla.

# @Constraint Constr_3 @Def: The total production time, calculated as ProductionTimeChocolate multiplied by the number of gallons of chocolate ice cream produced plus ProductionTimeVanilla multiplied by the number of gallons of vanilla ice cream produced, does not exceed TotalProductionHours.
model.addConstr(ProductionTimeChocolate * GallonsChocolateProduced + ProductionTimeVanilla * GallonsVanillaProduced <= TotalProductionHours)
# @Constraint Constr_4 @Def: WorkersNeededChocolate multiplied by the number of gallons of chocolate ice cream produced plus WorkersNeededVanilla multiplied by the number of gallons of vanilla ice cream produced is at least MinTotalWorkers.
model.addConstr(WorkersNeededChocolate * GallonsChocolateProduced + WorkersNeededVanilla * GallonsVanillaProduced >= MinTotalWorkers)

# Objective 
# @Objective Objective @Def: Maximize the total profit, which is ProfitChocolate multiplied by the number of gallons of chocolate ice cream produced plus ProfitVanilla multiplied by the number of gallons of vanilla ice cream produced.
model.setObjective(ProfitChocolate * GallonsChocolateProduced + ProfitVanilla * GallonsVanillaProduced, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['GallonsChocolateProduced'] = GallonsChocolateProduced.x
variables['GallonsVanillaProduced'] = GallonsVanillaProduced.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Mark has 50 acres of land available to grow potatoes and cucumbers that he sells at a farmers' market. He must grow at least 12 acres of potatoes and 15 acres of cucumbers to meet his contract. Mark prefers to grow more cucumbers than potatoes, but he only has enough resources to grow at most twice the amount of cucumbers as potatoes. If the profit per acre of potatoes is $500 and the profit per acre of cucumbers is $650, how many acres of each should he grow to maximize his profit? What is that profit?","{""variables"": {""AcresPotatoes"": 16.666666666666668, ""AcresCucumbers"": 33.33333333333333}, ""objective"": 30000.0}","{""parametrized_description"": ""Mark has TotalLandAvailable acres of land to grow potatoes and cucumbers. He must grow at least MinAcresPotatoes acres of potatoes and at least MinAcresCucumbers acres of cucumbers to meet his contract. Mark prefers to grow more cucumbers than potatoes, but he can grow at most MaxCucumbersPerPotatoesRatio times as many cucumbers as potatoes. The profit per acre of potatoes is ProfitPerAcrePotatoes and the profit per acre of cucumbers is ProfitPerAcreCucumbers. He aims to determine the number of acres to allocate to each crop to maximize his total profit."", ""keywords"": [""N.A.""], ""parameters"": {""TotalLandAvailable"": {""description"": ""Total land available to grow crops"", ""shape"": []}, ""MinAcresPotatoes"": {""description"": ""Minimum acres of potatoes required"", ""shape"": []}, ""MinAcresCucumbers"": {""description"": ""Minimum acres of cucumbers required"", ""shape"": []}, ""MaxCucumbersPerPotatoesRatio"": {""description"": ""Maximum ratio of cucumbers to potatoes that can be grown"", ""shape"": []}, ""ProfitPerAcrePotatoes"": {""description"": ""Profit per acre of potatoes"", ""shape"": []}, ""ProfitPerAcreCucumbers"": {""description"": ""Profit per acre of cucumbers"", ""shape"": []}}, ""variables"": {""AcresPotatoes"": {""description"": ""The number of acres allocated to potatoes"", ""type"": ""continuous"", ""shape"": []}, ""AcresCucumbers"": {""description"": ""The number of acres allocated to cucumbers"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of acres allocated to potatoes must be at least MinAcresPotatoes."", ""formulation"": ""AcresPotatoes \\geq MinAcresPotatoes"", ""code"": {""gurobipy"": ""model.addConstr(AcresPotatoes >= MinAcresPotatoes)""}}, {""description"": ""The number of acres allocated to cucumbers must be at least MinAcresCucumbers."", ""formulation"": ""AcresCucumbers \\geq MinAcresCucumbers"", ""code"": {""gurobipy"": ""model.addConstr(AcresCucumbers >= MinAcresCucumbers)""}}, {""description"": ""The total acres allocated to potatoes and cucumbers must not exceed TotalLandAvailable."", ""formulation"": ""AcresPotatoes + AcresCucumbers \\leq TotalLandAvailable"", ""code"": {""gurobipy"": ""model.addConstr(AcresPotatoes + AcresCucumbers <= TotalLandAvailable)""}}, {""description"": ""The number of acres allocated to cucumbers must be at most MaxCucumbersPerPotatoesRatio times the number of acres allocated to potatoes."", ""formulation"": ""AcresCucumbers \\leq MaxCucumbersPerPotatoesRatio \\times AcresPotatoes"", ""code"": {""gurobipy"": ""model.addConstr(AcresCucumbers <= MaxCucumbersPerPotatoesRatio * AcresPotatoes)""}}, {""description"": ""The number of acres allocated to cucumbers must be at least equal to the number of acres allocated to potatoes."", ""formulation"": ""AcresCucumbers \\geq AcresPotatoes"", ""code"": {""gurobipy"": ""model.addConstr(AcresCucumbers >= AcresPotatoes)""}}], ""objective"": {""description"": ""Maximize total profit, where total profit is calculated as (ProfitPerAcrePotatoes \u00d7 acres of potatoes) plus (ProfitPerAcreCucumbers \u00d7 acres of cucumbers)."", ""formulation"": ""Max \\left( ProfitPerAcrePotatoes \\times AcresPotatoes + ProfitPerAcreCucumbers \\times AcresCucumbers \\right )"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPerAcrePotatoes * AcresPotatoes + ProfitPerAcreCucumbers * AcresCucumbers, GRB.MAXIMIZE)""}}}","{""TotalLandAvailable"": 50, ""MinAcresPotatoes"": 12, ""MinAcresCucumbers"": 15, ""MaxCucumbersPerPotatoesRatio"": 2, ""ProfitPerAcrePotatoes"": 500, ""ProfitPerAcreCucumbers"": 650}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Mark has TotalLandAvailable acres of land to grow potatoes and cucumbers. He
must grow at least MinAcresPotatoes acres of potatoes and at least
MinAcresCucumbers acres of cucumbers to meet his contract. Mark prefers to grow
more cucumbers than potatoes, but he can grow at most
MaxCucumbersPerPotatoesRatio times as many cucumbers as potatoes. The profit per
acre of potatoes is ProfitPerAcrePotatoes and the profit per acre of cucumbers
is ProfitPerAcreCucumbers. He aims to determine the number of acres to allocate
to each crop to maximize his total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/30/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalLandAvailable @Def: Total land available to grow crops @Shape: [] 
TotalLandAvailable = data['TotalLandAvailable']
# @Parameter MinAcresPotatoes @Def: Minimum acres of potatoes required @Shape: [] 
MinAcresPotatoes = data['MinAcresPotatoes']
# @Parameter MinAcresCucumbers @Def: Minimum acres of cucumbers required @Shape: [] 
MinAcresCucumbers = data['MinAcresCucumbers']
# @Parameter MaxCucumbersPerPotatoesRatio @Def: Maximum ratio of cucumbers to potatoes that can be grown @Shape: [] 
MaxCucumbersPerPotatoesRatio = data['MaxCucumbersPerPotatoesRatio']
# @Parameter ProfitPerAcrePotatoes @Def: Profit per acre of potatoes @Shape: [] 
ProfitPerAcrePotatoes = data['ProfitPerAcrePotatoes']
# @Parameter ProfitPerAcreCucumbers @Def: Profit per acre of cucumbers @Shape: [] 
ProfitPerAcreCucumbers = data['ProfitPerAcreCucumbers']

# Variables 
# @Variable AcresPotatoes @Def: The number of acres allocated to potatoes @Shape: [] 
AcresPotatoes = model.addVar(vtype=GRB.CONTINUOUS, lb=MinAcresPotatoes, name=""AcresPotatoes"")
# @Variable AcresCucumbers @Def: The number of acres allocated to cucumbers @Shape: [] 
AcresCucumbers = model.addVar(vtype=GRB.CONTINUOUS, name=""AcresCucumbers"")

# Constraints 
# @Constraint Constr_1 @Def: The number of acres allocated to potatoes must be at least MinAcresPotatoes.
model.addConstr(AcresPotatoes >= MinAcresPotatoes)
# @Constraint Constr_2 @Def: The number of acres allocated to cucumbers must be at least MinAcresCucumbers.
model.addConstr(AcresCucumbers >= MinAcresCucumbers)
# @Constraint Constr_3 @Def: The total acres allocated to potatoes and cucumbers must not exceed TotalLandAvailable.
model.addConstr(AcresPotatoes + AcresCucumbers <= TotalLandAvailable)
# @Constraint Constr_4 @Def: The number of acres allocated to cucumbers must be at most MaxCucumbersPerPotatoesRatio times the number of acres allocated to potatoes.
model.addConstr(AcresCucumbers <= MaxCucumbersPerPotatoesRatio * AcresPotatoes)
# @Constraint Constr_5 @Def: The number of acres allocated to cucumbers must be at least equal to the number of acres allocated to potatoes.
model.addConstr(AcresCucumbers >= AcresPotatoes)

# Objective 
# @Objective Objective @Def: Maximize total profit, where total profit is calculated as (ProfitPerAcrePotatoes × acres of potatoes) plus (ProfitPerAcreCucumbers × acres of cucumbers).
model.setObjective(ProfitPerAcrePotatoes * AcresPotatoes + ProfitPerAcreCucumbers * AcresCucumbers, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['AcresPotatoes'] = AcresPotatoes.x
variables['AcresCucumbers'] = AcresCucumbers.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A flooring company produces engineered hardwood and vinyl planks. Their sales forecasts show an expected demand of at least 20,000 square foot of hardwood and 10,000 square feet of vinyl planks each week. To satisfy a shipping contract, a total of at least 60,000 square feet of flooring much be shipped each week. Due to a labor shortage issue, no more than 50,000 square feet of hardwood and 30,000  square feet of vinyl  can be produced weekly. If a square foot of hardwood flooring yields a profit of $2.5 and a square foot of vinyl planks produces a $3 profit, how many of each type of flooring should be made weekly to maximize the company's profit?","{""variables"": {""ProductionHardwood"": 50000.0, ""ProductionVinyl"": 30000.0}, ""objective"": 215000.0}","{""parametrized_description"": ""A flooring company produces two types of products: hardwood and vinyl planks. The weekly production of hardwood must be at least MinimumDemandHardwood and no more than MaxProductionHardwood. Similarly, the weekly production of vinyl planks must be at least MinimumDemandVinyl and no more than MaxProductionVinyl. Additionally, the combined weekly production of both hardwood and vinyl planks must be at least MinimumTotalShipping. The objective is to maximize the total profit, which is calculated as ProfitHardwood multiplied by the quantity of hardwood produced plus ProfitVinyl multiplied by the quantity of vinyl planks produced."", ""keywords"": [""N.A.""], ""parameters"": {""MinimumDemandHardwood"": {""description"": ""Minimum expected weekly demand for hardwood"", ""shape"": []}, ""MinimumDemandVinyl"": {""description"": ""Minimum expected weekly demand for vinyl planks"", ""shape"": []}, ""MinimumTotalShipping"": {""description"": ""Minimum total square feet of flooring to be shipped weekly"", ""shape"": []}, ""MaxProductionHardwood"": {""description"": ""Maximum weekly production capacity for hardwood"", ""shape"": []}, ""MaxProductionVinyl"": {""description"": ""Maximum weekly production capacity for vinyl planks"", ""shape"": []}, ""ProfitHardwood"": {""description"": ""Profit per square foot of hardwood"", ""shape"": []}, ""ProfitVinyl"": {""description"": ""Profit per square foot of vinyl planks"", ""shape"": []}}, ""variables"": {""ProductionHardwood"": {""description"": ""Weekly production of hardwood"", ""type"": ""continuous"", ""shape"": []}, ""ProductionVinyl"": {""description"": ""Weekly production of vinyl planks"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""Weekly production of hardwood must be at least MinimumDemandHardwood."", ""formulation"": ""ProductionHardwood \\geq MinimumDemandHardwood"", ""code"": {""gurobipy"": ""model.addConstr(ProductionHardwood >= MinimumDemandHardwood)""}}, {""description"": ""Weekly production of hardwood must be no more than MaxProductionHardwood."", ""formulation"": ""ProductionHardwood \\leq MaxProductionHardwood"", ""code"": {""gurobipy"": ""model.addConstr(ProductionHardwood <= MaxProductionHardwood)""}}, {""description"": ""Weekly production of vinyl planks must be at least MinimumDemandVinyl."", ""formulation"": ""ProductionVinyl \\geq MinimumDemandVinyl"", ""code"": {""gurobipy"": ""model.addConstr(ProductionVinyl >= MinimumDemandVinyl)""}}, {""description"": ""Weekly production of vinyl planks must be no more than MaxProductionVinyl."", ""formulation"": ""ProductionVinyl \\leq MaxProductionVinyl"", ""code"": {""gurobipy"": ""model.addConstr(ProductionVinyl <= MaxProductionVinyl)""}}, {""description"": ""The combined weekly production of both hardwood and vinyl planks must be at least MinimumTotalShipping."", ""formulation"": ""ProductionHardwood + ProductionVinyl \\geq MinimumTotalShipping"", ""code"": {""gurobipy"": ""model.addConstr(ProductionHardwood + ProductionVinyl >= MinimumTotalShipping)""}}], ""objective"": {""description"": ""Total profit is calculated as ProfitHardwood multiplied by the quantity of hardwood produced plus ProfitVinyl multiplied by the quantity of vinyl planks produced. The objective is to maximize the total profit."", ""formulation"": ""Max ProfitHardwood \\times ProductionHardwood + ProfitVinyl \\times ProductionVinyl"", ""code"": {""gurobipy"": ""model.setObjective(ProfitHardwood * ProductionHardwood + ProfitVinyl * ProductionVinyl, GRB.MAXIMIZE)""}}}","{""MinimumDemandHardwood"": 20000, ""MinimumDemandVinyl"": 10000, ""MinimumTotalShipping"": 60000, ""MaxProductionHardwood"": 50000, ""MaxProductionVinyl"": 30000, ""ProfitHardwood"": 2.5, ""ProfitVinyl"": 3}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A flooring company produces two types of products: hardwood and vinyl planks.
The weekly production of hardwood must be at least MinimumDemandHardwood and no
more than MaxProductionHardwood. Similarly, the weekly production of vinyl
planks must be at least MinimumDemandVinyl and no more than MaxProductionVinyl.
Additionally, the combined weekly production of both hardwood and vinyl planks
must be at least MinimumTotalShipping. The objective is to maximize the total
profit, which is calculated as ProfitHardwood multiplied by the quantity of
hardwood produced plus ProfitVinyl multiplied by the quantity of vinyl planks
produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/31/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MinimumDemandHardwood @Def: Minimum expected weekly demand for hardwood @Shape: [] 
MinimumDemandHardwood = data['MinimumDemandHardwood']
# @Parameter MinimumDemandVinyl @Def: Minimum expected weekly demand for vinyl planks @Shape: [] 
MinimumDemandVinyl = data['MinimumDemandVinyl']
# @Parameter MinimumTotalShipping @Def: Minimum total square feet of flooring to be shipped weekly @Shape: [] 
MinimumTotalShipping = data['MinimumTotalShipping']
# @Parameter MaxProductionHardwood @Def: Maximum weekly production capacity for hardwood @Shape: [] 
MaxProductionHardwood = data['MaxProductionHardwood']
# @Parameter MaxProductionVinyl @Def: Maximum weekly production capacity for vinyl planks @Shape: [] 
MaxProductionVinyl = data['MaxProductionVinyl']
# @Parameter ProfitHardwood @Def: Profit per square foot of hardwood @Shape: [] 
ProfitHardwood = data['ProfitHardwood']
# @Parameter ProfitVinyl @Def: Profit per square foot of vinyl planks @Shape: [] 
ProfitVinyl = data['ProfitVinyl']

# Variables 
# @Variable ProductionHardwood @Def: Weekly production of hardwood @Shape: [] 
ProductionHardwood = model.addVar(lb=MinimumDemandHardwood, ub=MaxProductionHardwood, vtype=GRB.CONTINUOUS, name=""ProductionHardwood"")
# @Variable ProductionVinyl @Def: Weekly production of vinyl planks @Shape: [] 
ProductionVinyl = model.addVar(vtype=GRB.CONTINUOUS, name=""ProductionVinyl"")

# Constraints 
# @Constraint Constr_1 @Def: Weekly production of hardwood must be at least MinimumDemandHardwood.
model.addConstr(ProductionHardwood >= MinimumDemandHardwood)
# @Constraint Constr_2 @Def: Weekly production of hardwood must be no more than MaxProductionHardwood.
model.addConstr(ProductionHardwood <= MaxProductionHardwood)
# @Constraint Constr_3 @Def: Weekly production of vinyl planks must be at least MinimumDemandVinyl.
model.addConstr(ProductionVinyl >= MinimumDemandVinyl)
# @Constraint Constr_4 @Def: Weekly production of vinyl planks must be no more than MaxProductionVinyl.
model.addConstr(ProductionVinyl <= MaxProductionVinyl)
# @Constraint Constr_5 @Def: The combined weekly production of both hardwood and vinyl planks must be at least MinimumTotalShipping.
model.addConstr(ProductionHardwood + ProductionVinyl >= MinimumTotalShipping)

# Objective 
# @Objective Objective @Def: Total profit is calculated as ProfitHardwood multiplied by the quantity of hardwood produced plus ProfitVinyl multiplied by the quantity of vinyl planks produced. The objective is to maximize the total profit.
model.setObjective(ProfitHardwood * ProductionHardwood + ProfitVinyl * ProductionVinyl, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ProductionHardwood'] = ProductionHardwood.x
variables['ProductionVinyl'] = ProductionVinyl.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A berry farmer has two farms, an old and new farm, where he grows raspberries, blueberries, and strawberries. He has a contract to provide a local store with 10 kg of raspberries, 9 kg of blueberries, and 15 kg of strawberries. At his old farm, it cost $300 to operate per day and he can harvest and deliver 2 kg of raspberries, 2 kg of blueberries, and 4 kg of strawberries in a day. At his new farm, it costs $200 to operate per day and he can harvest and deliver 4 kg of raspberries, 1 kg of blueberries, and 2 kg of strawberries in a day. Formulate a LP to meet his contract while minimizing his cost.","{""variables"": {""DaysOperated"": [4.333333333333333, 0.3333333333333335]}, ""objective"": 1366.6666666666667}","{""parametrized_description"": ""A berry farmer operates NumFarms farms to harvest and deliver NumBerries types of berries in order to fulfill a contract requiring RequiredQuantity of each berry type. Each farm incurs an OperatingCost per day and can harvest and deliver HarvestDelivery amounts of each berry type per day. The farmer aims to minimize the total operating cost while ensuring that the harvested and delivered quantities meet or exceed the RequiredQuantity for each type of berry."", ""keywords"": [""N.A.""], ""parameters"": {""NumFarms"": {""description"": ""Number of farms"", ""shape"": []}, ""NumBerries"": {""description"": ""Number of berry types"", ""shape"": []}, ""OperatingCost"": {""description"": ""Operating cost per day for each farm"", ""shape"": [""NumFarms""]}, ""HarvestDelivery"": {""description"": ""Harvest and delivery rate per day for each farm and berry type"", ""shape"": [""NumFarms"", ""NumBerries""]}, ""RequiredQuantity"": {""description"": ""Required quantity of each berry type to meet contract"", ""shape"": [""NumBerries""]}}, ""variables"": {""DaysOperated"": {""description"": ""The number of days each farm operates"", ""type"": ""continuous"", ""shape"": [""NumFarms""]}}, ""constraints"": [{""description"": ""For each berry type, the total harvested and delivered quantity across all farms must meet or exceed the RequiredQuantity."", ""formulation"": ""\\sum_{f=1}^{\\text{NumFarms}} \\text{HarvestDelivery}_{f, b} \\cdot \\text{DaysOperated}_{f} \\geq \\text{RequiredQuantity}_{b} \\quad \\forall b \\in \\{1, \\dots, \\text{NumBerries}\\}"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(HarvestDelivery[f][b] * DaysOperated[f] for f in range(NumFarms)) >= RequiredQuantity[b] for b in range(NumBerries)))""}}], ""objective"": {""description"": ""Minimize the total operating cost while ensuring that the harvested and delivered quantities meet or exceed the RequiredQuantity for each type of berry."", ""formulation"": ""Min \\sum_{i=1}^{NumFarms} OperatingCost_{i} \\cdot DaysOperated_{i}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(OperatingCost[i] * DaysOperated[i] for i in range(NumFarms)), GRB.MINIMIZE)""}}}","{""NumFarms"": 2, ""NumBerries"": 3, ""OperatingCost"": [300, 200], ""HarvestDelivery"": [[2, 2, 4], [4, 1, 2]], ""RequiredQuantity"": [10, 9, 15]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A berry farmer operates NumFarms farms to harvest and deliver NumBerries types
of berries in order to fulfill a contract requiring RequiredQuantity of each
berry type. Each farm incurs an OperatingCost per day and can harvest and
deliver HarvestDelivery amounts of each berry type per day. The farmer aims to
minimize the total operating cost while ensuring that the harvested and
delivered quantities meet or exceed the RequiredQuantity for each type of berry.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/32/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumFarms @Def: Number of farms @Shape: [] 
NumFarms = data['NumFarms']
# @Parameter NumBerries @Def: Number of berry types @Shape: [] 
NumBerries = data['NumBerries']
# @Parameter OperatingCost @Def: Operating cost per day for each farm @Shape: ['NumFarms'] 
OperatingCost = data['OperatingCost']
# @Parameter HarvestDelivery @Def: Harvest and delivery rate per day for each farm and berry type @Shape: ['NumFarms', 'NumBerries'] 
HarvestDelivery = data['HarvestDelivery']
# @Parameter RequiredQuantity @Def: Required quantity of each berry type to meet contract @Shape: ['NumBerries'] 
RequiredQuantity = data['RequiredQuantity']

# Variables 
# @Variable DaysOperated @Def: The number of days each farm operates @Shape: ['NumFarms'] 
DaysOperated = model.addVars(NumFarms, vtype=GRB.CONTINUOUS, name=""DaysOperated"")

# Constraints 
# @Constraint Constr_1 @Def: For each berry type, the total harvested and delivered quantity across all farms must meet or exceed the RequiredQuantity.
model.addConstrs((quicksum(HarvestDelivery[f][b] * DaysOperated[f] for f in range(NumFarms)) >= RequiredQuantity[b] for b in range(NumBerries)))

# Objective 
# @Objective Objective @Def: Minimize the total operating cost while ensuring that the harvested and delivered quantities meet or exceed the RequiredQuantity for each type of berry.
model.setObjective(quicksum(OperatingCost[i] * DaysOperated[i] for i in range(NumFarms)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['DaysOperated'] = [DaysOperated[f].x for f in range(NumFarms)]
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
Jordan is a chef. He wants to design a diet consisting of Kebabs and Rice.  Assume that each serving of Rice costs $3 and contains 300 calories and 4.5 grams of protein. Assume that each serving of Kebab costs $2 and contains 200 calories and 4 grams of protein. He's interested in spending as little money as possible but he wants to ensure that his meals have at least 2200 calories and at least 30 grams of protein per day. Formulate a linear programming problem that will help minimize the cost of the diet.,"{""variables"": {""ServingsRice"": 0.0, ""ServingsKebab"": 11.0}, ""objective"": 22.0}","{""parametrized_description"": ""Jordan aims to minimize the total cost of his diet by selecting servings of Rice and Kebab. Each serving of Rice and Kebab costs CostRice and CostKebab respectively. The diet must provide at least MinCalories in calories and at least MinProtein in protein per day. Each serving of Rice and Kebab contributes CaloriesRice and CaloriesKebab calories, and ProteinRice and ProteinKebab grams of protein respectively."", ""keywords"": [""N.A.""], ""parameters"": {""CostRice"": {""description"": ""Cost per serving of Rice"", ""shape"": []}, ""CostKebab"": {""description"": ""Cost per serving of Kebab"", ""shape"": []}, ""CaloriesRice"": {""description"": ""Calories per serving of Rice"", ""shape"": []}, ""CaloriesKebab"": {""description"": ""Calories per serving of Kebab"", ""shape"": []}, ""ProteinRice"": {""description"": ""Protein per serving of Rice"", ""shape"": []}, ""ProteinKebab"": {""description"": ""Protein per serving of Kebab"", ""shape"": []}, ""MinCalories"": {""description"": ""Minimum daily calories required"", ""shape"": []}, ""MinProtein"": {""description"": ""Minimum daily protein required"", ""shape"": []}}, ""variables"": {""ServingsRice"": {""description"": ""The number of servings of Rice"", ""type"": ""continuous"", ""shape"": []}, ""ServingsKebab"": {""description"": ""The number of servings of Kebab"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The diet must provide at least MinCalories in calories."", ""formulation"": ""ServingsRice \\times CaloriesRice + ServingsKebab \\times CaloriesKebab \\geq MinCalories"", ""code"": {""gurobipy"": ""model.addConstr(ServingsRice * CaloriesRice + ServingsKebab * CaloriesKebab >= MinCalories)""}}, {""description"": ""The diet must provide at least MinProtein in protein."", ""formulation"": ""ProteinRice \\times ServingsRice + ProteinKebab \\times ServingsKebab \\geq MinProtein"", ""code"": {""gurobipy"": ""model.addConstr(ProteinRice * ServingsRice + ProteinKebab * ServingsKebab >= MinProtein)""}}], ""objective"": {""description"": ""Minimize the total cost of the diet, calculated as CostRice multiplied by the number of servings of Rice plus CostKebab multiplied by the number of servings of Kebab."", ""formulation"": ""Min CostRice \\times ServingsRice + CostKebab \\times ServingsKebab"", ""code"": {""gurobipy"": ""model.setObjective(CostRice * ServingsRice + CostKebab * ServingsKebab, GRB.MINIMIZE)""}}}","{""CostRice"": 3, ""CostKebab"": 2, ""CaloriesRice"": 300, ""CaloriesKebab"": 200, ""ProteinRice"": 4.5, ""ProteinKebab"": 4, ""MinCalories"": 2200, ""MinProtein"": 30}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Jordan aims to minimize the total cost of his diet by selecting servings of Rice
and Kebab. Each serving of Rice and Kebab costs CostRice and CostKebab
respectively. The diet must provide at least MinCalories in calories and at
least MinProtein in protein per day. Each serving of Rice and Kebab contributes
CaloriesRice and CaloriesKebab calories, and ProteinRice and ProteinKebab grams
of protein respectively.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/33/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CostRice @Def: Cost per serving of Rice @Shape: [] 
CostRice = data['CostRice']
# @Parameter CostKebab @Def: Cost per serving of Kebab @Shape: [] 
CostKebab = data['CostKebab']
# @Parameter CaloriesRice @Def: Calories per serving of Rice @Shape: [] 
CaloriesRice = data['CaloriesRice']
# @Parameter CaloriesKebab @Def: Calories per serving of Kebab @Shape: [] 
CaloriesKebab = data['CaloriesKebab']
# @Parameter ProteinRice @Def: Protein per serving of Rice @Shape: [] 
ProteinRice = data['ProteinRice']
# @Parameter ProteinKebab @Def: Protein per serving of Kebab @Shape: [] 
ProteinKebab = data['ProteinKebab']
# @Parameter MinCalories @Def: Minimum daily calories required @Shape: [] 
MinCalories = data['MinCalories']
# @Parameter MinProtein @Def: Minimum daily protein required @Shape: [] 
MinProtein = data['MinProtein']

# Variables 
# @Variable ServingsRice @Def: The number of servings of Rice @Shape: [] 
ServingsRice = model.addVar(vtype=GRB.CONTINUOUS, name=""ServingsRice"")
# @Variable ServingsKebab @Def: The number of servings of Kebab @Shape: [] 
ServingsKebab = model.addVar(vtype=GRB.CONTINUOUS, name=""ServingsKebab"")

# Constraints 
# @Constraint Constr_1 @Def: The diet must provide at least MinCalories in calories.
model.addConstr(ServingsRice * CaloriesRice + ServingsKebab * CaloriesKebab >= MinCalories)
# @Constraint Constr_2 @Def: The diet must provide at least MinProtein in protein.
model.addConstr(ProteinRice * ServingsRice + ProteinKebab * ServingsKebab >= MinProtein)

# Objective 
# @Objective Objective @Def: Minimize the total cost of the diet, calculated as CostRice multiplied by the number of servings of Rice plus CostKebab multiplied by the number of servings of Kebab.
model.setObjective(CostRice * ServingsRice + CostKebab * ServingsKebab, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ServingsRice'] = ServingsRice.x
variables['ServingsKebab'] = ServingsKebab.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A company sells custom scooters and bikes for customers. The profit per scooter is $200 and the profit per bike is $300. Each product requires time with the design team and engineering team. Each scooter needs 2 hours with the design team and 3 hours with the engineering team. Each bike needs 4 hours with the design team and 5 hours with the engineering team. Per month, there are 5000 hours available on the design team and 6000 hours available on the engineering team. How many of each should the company make per month to maximize profit?","{""variables"": {""NumberOfScooters"": 2000.0, ""NumberOfBikes"": 0.0}, ""objective"": 400000.0}","{""parametrized_description"": ""A company sells two types of products: scooters and bikes. The profit per scooter is ProfitPerScooter and the profit per bike is ProfitPerBike. Each scooter requires DesignHoursPerScooter hours with the design team and EngineeringHoursPerScooter hours with the engineering team. Each bike requires DesignHoursPerBike hours with the design team and EngineeringHoursPerBike hours with the engineering team. The company has TotalDesignHoursAvailable design hours and TotalEngineeringHoursAvailable engineering hours available each month. Determine the number of scooters and bikes the company should produce each month to maximize profit."", ""keywords"": [""N.A.""], ""parameters"": {""ProfitPerScooter"": {""description"": ""Profit per scooter"", ""shape"": []}, ""ProfitPerBike"": {""description"": ""Profit per bike"", ""shape"": []}, ""DesignHoursPerScooter"": {""description"": ""Design hours required per scooter"", ""shape"": []}, ""DesignHoursPerBike"": {""description"": ""Design hours required per bike"", ""shape"": []}, ""EngineeringHoursPerScooter"": {""description"": ""Engineering hours required per scooter"", ""shape"": []}, ""EngineeringHoursPerBike"": {""description"": ""Engineering hours required per bike"", ""shape"": []}, ""TotalDesignHoursAvailable"": {""description"": ""Total design hours available per month"", ""shape"": []}, ""TotalEngineeringHoursAvailable"": {""description"": ""Total engineering hours available per month"", ""shape"": []}}, ""variables"": {""NumberOfScooters"": {""description"": ""The number of scooters to be produced"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfBikes"": {""description"": ""The number of bikes to be produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""DesignHoursPerScooter * NumberOfScooters + DesignHoursPerBike * NumberOfBikes \u2264 TotalDesignHoursAvailable"", ""formulation"": ""DesignHoursPerScooter \\times NumberOfScooters + DesignHoursPerBike \\times NumberOfBikes \\leq TotalDesignHoursAvailable"", ""code"": {""gurobipy"": ""model.addConstr(DesignHoursPerScooter * NumberOfScooters + DesignHoursPerBike * NumberOfBikes <= TotalDesignHoursAvailable)""}}, {""description"": ""EngineeringHoursPerScooter * NumberOfScooters + EngineeringHoursPerBike * NumberOfBikes \u2264 TotalEngineeringHoursAvailable"", ""formulation"": ""EngineeringHoursPerScooter \\times NumberOfScooters + EngineeringHoursPerBike \\times NumberOfBikes \\leq TotalEngineeringHoursAvailable"", ""code"": {""gurobipy"": ""model.addConstr(EngineeringHoursPerScooter * NumberOfScooters + EngineeringHoursPerBike * NumberOfBikes <= TotalEngineeringHoursAvailable)""}}], ""objective"": {""description"": ""Maximize total profit, which is ProfitPerScooter * NumberOfScooters + ProfitPerBike * NumberOfBikes"", ""formulation"": ""Max \\ ProfitPerScooter \\times NumberOfScooters + ProfitPerBike \\times NumberOfBikes"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPerScooter * NumberOfScooters + ProfitPerBike * NumberOfBikes, GRB.MAXIMIZE)""}}}","{""ProfitPerScooter"": 200, ""ProfitPerBike"": 300, ""DesignHoursPerScooter"": 2, ""DesignHoursPerBike"": 4, ""EngineeringHoursPerScooter"": 3, ""EngineeringHoursPerBike"": 5, ""TotalDesignHoursAvailable"": 5000, ""TotalEngineeringHoursAvailable"": 6000}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A company sells two types of products: scooters and bikes. The profit per
scooter is ProfitPerScooter and the profit per bike is ProfitPerBike. Each
scooter requires DesignHoursPerScooter hours with the design team and
EngineeringHoursPerScooter hours with the engineering team. Each bike requires
DesignHoursPerBike hours with the design team and EngineeringHoursPerBike hours
with the engineering team. The company has TotalDesignHoursAvailable design
hours and TotalEngineeringHoursAvailable engineering hours available each month.
Determine the number of scooters and bikes the company should produce each month
to maximize profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/34/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProfitPerScooter @Def: Profit per scooter @Shape: [] 
ProfitPerScooter = data['ProfitPerScooter']
# @Parameter ProfitPerBike @Def: Profit per bike @Shape: [] 
ProfitPerBike = data['ProfitPerBike']
# @Parameter DesignHoursPerScooter @Def: Design hours required per scooter @Shape: [] 
DesignHoursPerScooter = data['DesignHoursPerScooter']
# @Parameter DesignHoursPerBike @Def: Design hours required per bike @Shape: [] 
DesignHoursPerBike = data['DesignHoursPerBike']
# @Parameter EngineeringHoursPerScooter @Def: Engineering hours required per scooter @Shape: [] 
EngineeringHoursPerScooter = data['EngineeringHoursPerScooter']
# @Parameter EngineeringHoursPerBike @Def: Engineering hours required per bike @Shape: [] 
EngineeringHoursPerBike = data['EngineeringHoursPerBike']
# @Parameter TotalDesignHoursAvailable @Def: Total design hours available per month @Shape: [] 
TotalDesignHoursAvailable = data['TotalDesignHoursAvailable']
# @Parameter TotalEngineeringHoursAvailable @Def: Total engineering hours available per month @Shape: [] 
TotalEngineeringHoursAvailable = data['TotalEngineeringHoursAvailable']

# Variables 
# @Variable NumberOfScooters @Def: The number of scooters to be produced @Shape: [] 
NumberOfScooters = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfScooters"")
# @Variable NumberOfBikes @Def: The number of bikes to be produced @Shape: [] 
NumberOfBikes = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfBikes"")

# Constraints 
# @Constraint Constr_1 @Def: DesignHoursPerScooter * NumberOfScooters + DesignHoursPerBike * NumberOfBikes ≤ TotalDesignHoursAvailable
model.addConstr(DesignHoursPerScooter * NumberOfScooters + DesignHoursPerBike * NumberOfBikes <= TotalDesignHoursAvailable)
# @Constraint Constr_2 @Def: EngineeringHoursPerScooter * NumberOfScooters + EngineeringHoursPerBike * NumberOfBikes ≤ TotalEngineeringHoursAvailable
model.addConstr(EngineeringHoursPerScooter * NumberOfScooters + EngineeringHoursPerBike * NumberOfBikes <= TotalEngineeringHoursAvailable)

# Objective 
# @Objective Objective @Def: Maximize total profit, which is ProfitPerScooter * NumberOfScooters + ProfitPerBike * NumberOfBikes
model.setObjective(ProfitPerScooter * NumberOfScooters + ProfitPerBike * NumberOfBikes, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfScooters'] = NumberOfScooters.x
variables['NumberOfBikes'] = NumberOfBikes.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"John has a 300 acre berry farm on which to plant blueberries and raspberries. John has $10000 to spend on watering and 575 days worth of labor available. For each acre of blueberries, 6 days worth of labor and $22 in watering costs is required. For each acre of raspberries, 3 days worth of labor and $25 in watering costs is required. The profit per acre of blueberries is $56 and the profit per acre of raspberries is $75. Formulate an LP problem in order to maximize profit.","{""variables"": {""Acreage"": [0.0, 191.66666666666666]}, ""objective"": 14375.0}","{""parametrized_description"": ""A farmer has TotalFarmArea acres to plant NumCrops different crops. The total watering budget is TotalWateringBudget dollars and the total available labor is TotalAvailableLabor days. Each crop requires LaborPerAcre[i] days of labor and WateringCostPerAcre[i] dollars per acre for watering. The profit per acre for each crop is ProfitPerAcre[i] dollars. The objective is to maximize the total profit."", ""keywords"": [""N.A.""], ""parameters"": {""TotalFarmArea"": {""description"": ""Total area of the farm in acres"", ""shape"": []}, ""TotalWateringBudget"": {""description"": ""Total budget available for watering in dollars"", ""shape"": []}, ""TotalAvailableLabor"": {""description"": ""Total available labor in days"", ""shape"": []}, ""NumCrops"": {""description"": ""Number of different crops to be planted"", ""shape"": []}, ""LaborPerAcre"": {""description"": ""Amount of labor required per acre for each crop in days"", ""shape"": [""NumCrops""]}, ""WateringCostPerAcre"": {""description"": ""Watering cost per acre for each crop in dollars"", ""shape"": [""NumCrops""]}, ""ProfitPerAcre"": {""description"": ""Profit per acre for each crop in dollars"", ""shape"": [""NumCrops""]}}, ""variables"": {""Acreage"": {""description"": ""The acreage allocated to each crop"", ""type"": ""continuous"", ""shape"": [""NumCrops""]}}, ""constraints"": [{""description"": ""The total acreage allocated to all crops must not exceed TotalFarmArea."", ""formulation"": ""\\sum_{i=1}^{NumCrops} Acreage_{i} \\leq TotalFarmArea"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(Acreage[i] for i in range(NumCrops)) <= TotalFarmArea)""}}, {""description"": ""The total watering cost, calculated as the sum of WateringCostPerAcre[i] multiplied by the acreage of each crop, must not exceed TotalWateringBudget."", ""formulation"": ""\\sum_{i=1}^{NumCrops} WateringCostPerAcre_i \\cdot Acreage_i \\leq TotalWateringBudget"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(WateringCostPerAcre[i] * Acreage[i] for i in range(NumCrops)) <= TotalWateringBudget)""}}, {""description"": ""The total labor required, calculated as the sum of LaborPerAcre[i] multiplied by the acreage of each crop, must not exceed TotalAvailableLabor."", ""formulation"": ""\\sum_{i=1}^{NumCrops} LaborPerAcre_i \\cdot Acreage_i \\leq TotalAvailableLabor"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(LaborPerAcre[i] * Acreage[i] for i in range(NumCrops)) <= TotalAvailableLabor)""}}], ""objective"": {""description"": ""Maximize the total profit, which is the sum of ProfitPerAcre[i] multiplied by the acreage of each crop."", ""formulation"": ""Max \\sum_{i=1}^{NumCrops} ProfitPerAcre_i \\times Acreage_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProfitPerAcre[i] * Acreage[i] for i in range(NumCrops)), GRB.MAXIMIZE)""}}}","{""TotalFarmArea"": 300, ""TotalWateringBudget"": 10000, ""TotalAvailableLabor"": 575, ""NumCrops"": 2, ""LaborPerAcre"": [6, 3], ""WateringCostPerAcre"": [22, 25], ""ProfitPerAcre"": [56, 75]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A farmer has TotalFarmArea acres to plant NumCrops different crops. The total
watering budget is TotalWateringBudget dollars and the total available labor is
TotalAvailableLabor days. Each crop requires LaborPerAcre[i] days of labor and
WateringCostPerAcre[i] dollars per acre for watering. The profit per acre for
each crop is ProfitPerAcre[i] dollars. The objective is to maximize the total
profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/35/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter TotalFarmArea @Def: Total area of the farm in acres @Shape: [] 
TotalFarmArea = data['TotalFarmArea']
# @Parameter TotalWateringBudget @Def: Total budget available for watering in dollars @Shape: [] 
TotalWateringBudget = data['TotalWateringBudget']
# @Parameter TotalAvailableLabor @Def: Total available labor in days @Shape: [] 
TotalAvailableLabor = data['TotalAvailableLabor']
# @Parameter NumCrops @Def: Number of different crops to be planted @Shape: [] 
NumCrops = data['NumCrops']
# @Parameter LaborPerAcre @Def: Amount of labor required per acre for each crop in days @Shape: ['NumCrops'] 
LaborPerAcre = data['LaborPerAcre']
# @Parameter WateringCostPerAcre @Def: Watering cost per acre for each crop in dollars @Shape: ['NumCrops'] 
WateringCostPerAcre = data['WateringCostPerAcre']
# @Parameter ProfitPerAcre @Def: Profit per acre for each crop in dollars @Shape: ['NumCrops'] 
ProfitPerAcre = data['ProfitPerAcre']
    
# Variables 
# @Variable Acreage @Def: The acreage allocated to each crop @Shape: ['NumCrops'] 
Acreage = model.addVars(NumCrops, vtype=GRB.CONTINUOUS, name=""Acreage"")
    
# Constraints 
# @Constraint Constr_1 @Def: The total acreage allocated to all crops must not exceed TotalFarmArea.
model.addConstr(quicksum(Acreage[i] for i in range(NumCrops)) <= TotalFarmArea)
# @Constraint Constr_2 @Def: The total watering cost, calculated as the sum of WateringCostPerAcre[i] multiplied by the acreage of each crop, must not exceed TotalWateringBudget.
model.addConstr(quicksum(WateringCostPerAcre[i] * Acreage[i] for i in range(NumCrops)) <= TotalWateringBudget)
# @Constraint Constr_3 @Def: The total labor required, calculated as the sum of LaborPerAcre[i] multiplied by the acreage of each crop, must not exceed TotalAvailableLabor.
model.addConstr(quicksum(LaborPerAcre[i] * Acreage[i] for i in range(NumCrops)) <= TotalAvailableLabor)
    
# Objective 
# @Objective Objective @Def: Maximize the total profit, which is the sum of ProfitPerAcre[i] multiplied by the acreage of each crop.
model.setObjective(quicksum(ProfitPerAcre[i] * Acreage[i] for i in range(NumCrops)), GRB.MAXIMIZE)
    
# Solve 
model.optimize()
    
# Extract solution 
solution = {}
variables = {}
objective = []
variables['Acreage'] = [Acreage[i].x for i in range(NumCrops)]
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A man  only eats vegetable and fruits. A serving of vegetables contains 2 units of vitamins and 3 units of minerals. A serving of fruit contains 4 units of vitamins and 1 unit of minerals. He wants to eat at least 20 units of vitamins and 30 units of minerals. If vegetables cost $3 per serving and fruits cost $5 per serving, how many servings of each should he eat to minimize his cost?","{""variables"": {""VegetableServings"": 10.0, ""FruitServings"": 0.0}, ""objective"": 30.0}","{""parametrized_description"": ""An individual consumes vegetables and fruits. A serving of vegetables contains VegetableVitamins units of vitamins and VegetableMinerals units of minerals. A serving of fruits contains FruitVitamins units of vitamins and FruitMinerals units of minerals. The individual requires at least MinimumVitamins units of vitamins and MinimumMinerals units of minerals. Vegetables cost VegetableCost per serving and fruits cost FruitCost per serving. Determine the number of servings of each to minimize total cost."", ""keywords"": [""N.A.""], ""parameters"": {""VegetableVitamins"": {""description"": ""Amount of vitamins in one serving of vegetables"", ""shape"": []}, ""VegetableMinerals"": {""description"": ""Amount of minerals in one serving of vegetables"", ""shape"": []}, ""FruitVitamins"": {""description"": ""Amount of vitamins in one serving of fruits"", ""shape"": []}, ""FruitMinerals"": {""description"": ""Amount of minerals in one serving of fruits"", ""shape"": []}, ""MinimumVitamins"": {""description"": ""Minimum required units of vitamins"", ""shape"": []}, ""MinimumMinerals"": {""description"": ""Minimum required units of minerals"", ""shape"": []}, ""VegetableCost"": {""description"": ""Cost per serving of vegetables"", ""shape"": []}, ""FruitCost"": {""description"": ""Cost per serving of fruits"", ""shape"": []}}, ""variables"": {""VegetableServings"": {""description"": ""The number of servings of vegetables"", ""type"": ""continuous"", ""shape"": []}, ""FruitServings"": {""description"": ""The number of servings of fruits"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""A serving of vegetables contains VegetableVitamins units of vitamins and a serving of fruits contains FruitVitamins units of vitamins. The individual requires at least MinimumVitamins units of vitamins."", ""formulation"": ""VegetableVitamins \\times VegetableServings + FruitVitamins \\times FruitServings \\geq MinimumVitamins"", ""code"": {""gurobipy"": ""model.addConstr(VegetableVitamins * VegetableServings + FruitVitamins * FruitServings >= MinimumVitamins)""}}, {""description"": ""A serving of vegetables contains VegetableMinerals units of minerals and a serving of fruits contains FruitMinerals units of minerals. The individual requires at least MinimumMinerals units of minerals."", ""formulation"": ""VegetableMinerals \\cdot VegetableServings + FruitMinerals \\cdot FruitServings \\geq MinimumMinerals"", ""code"": {""gurobipy"": ""model.addConstr(VegetableMinerals * VegetableServings + FruitMinerals * FruitServings >= MinimumMinerals)""}}], ""objective"": {""description"": ""Total cost is the sum of VegetableCost per serving of vegetables and FruitCost per serving of fruits. The objective is to minimize the total cost while meeting the minimum nutrient requirements."", ""formulation"": ""Min VegetableCost \\times VegetableServings + FruitCost \\times FruitServings"", ""code"": {""gurobipy"": ""model.setObjective(VegetableCost * VegetableServings + FruitCost * FruitServings, GRB.MINIMIZE)""}}}","{""VegetableVitamins"": 2, ""VegetableMinerals"": 3, ""FruitVitamins"": 4, ""FruitMinerals"": 1, ""MinimumVitamins"": 20, ""MinimumMinerals"": 30, ""VegetableCost"": 3, ""FruitCost"": 5}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
An individual consumes vegetables and fruits. A serving of vegetables contains
VegetableVitamins units of vitamins and VegetableMinerals units of minerals. A
serving of fruits contains FruitVitamins units of vitamins and FruitMinerals
units of minerals. The individual requires at least MinimumVitamins units of
vitamins and MinimumMinerals units of minerals. Vegetables cost VegetableCost
per serving and fruits cost FruitCost per serving. Determine the number of
servings of each to minimize total cost.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/36/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter VegetableVitamins @Def: Amount of vitamins in one serving of vegetables @Shape: [] 
VegetableVitamins = data['VegetableVitamins']
# @Parameter VegetableMinerals @Def: Amount of minerals in one serving of vegetables @Shape: [] 
VegetableMinerals = data['VegetableMinerals']
# @Parameter FruitVitamins @Def: Amount of vitamins in one serving of fruits @Shape: [] 
FruitVitamins = data['FruitVitamins']
# @Parameter FruitMinerals @Def: Amount of minerals in one serving of fruits @Shape: [] 
FruitMinerals = data['FruitMinerals']
# @Parameter MinimumVitamins @Def: Minimum required units of vitamins @Shape: [] 
MinimumVitamins = data['MinimumVitamins']
# @Parameter MinimumMinerals @Def: Minimum required units of minerals @Shape: [] 
MinimumMinerals = data['MinimumMinerals']
# @Parameter VegetableCost @Def: Cost per serving of vegetables @Shape: [] 
VegetableCost = data['VegetableCost']
# @Parameter FruitCost @Def: Cost per serving of fruits @Shape: [] 
FruitCost = data['FruitCost']

# Variables 
# @Variable VegetableServings @Def: The number of servings of vegetables @Shape: [] 
VegetableServings = model.addVar(vtype=GRB.CONTINUOUS, name=""VegetableServings"")
# @Variable FruitServings @Def: The number of servings of fruits @Shape: [] 
FruitServings = model.addVar(vtype=GRB.CONTINUOUS, name=""FruitServings"")

# Constraints 
# @Constraint Constr_1 @Def: A serving of vegetables contains VegetableVitamins units of vitamins and a serving of fruits contains FruitVitamins units of vitamins. The individual requires at least MinimumVitamins units of vitamins.
model.addConstr(VegetableVitamins * VegetableServings + FruitVitamins * FruitServings >= MinimumVitamins)
# @Constraint Constr_2 @Def: A serving of vegetables contains VegetableMinerals units of minerals and a serving of fruits contains FruitMinerals units of minerals. The individual requires at least MinimumMinerals units of minerals.
model.addConstr(VegetableMinerals * VegetableServings + FruitMinerals * FruitServings >= MinimumMinerals)

# Objective 
# @Objective Objective @Def: Total cost is the sum of VegetableCost per serving of vegetables and FruitCost per serving of fruits. The objective is to minimize the total cost while meeting the minimum nutrient requirements.
model.setObjective(VegetableCost * VegetableServings + FruitCost * FruitServings, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['VegetableServings'] = VegetableServings.x
variables['FruitServings'] = FruitServings.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A bakery bakes bagels and croissants. A batch of bagels can be made using 2 hours of oven time and 0.25 hours of pastry chef time. A batch of croissants is more complicated, so while they take 1 hour of oven time, they take 2 hours of pastry chef time. In a day, the bakery has at most 70 hours available for the oven and 32 pastry chef hours available. Using all the available capacity, what is the maximum profit the bakery can generate assuming the profit per batch is $20 and $40 respectively for a batch of bagels and a batch of croissants.","{""variables"": {""Batch"": {""0"": 28.8, ""1"": 12.4}}, ""objective"": 1072.0}","{""parametrized_description"": ""A bakery manufactures NumProducts distinct products, each yielding a specific Profit per batch. Each product requires a certain amount of time from each of the NumResources resource types for production. The bakery has a limited amount of time available for each resource, defined by ResourceAvailability. The goal is to maximize the total Profit by fully utilizing the available Resource capacities."", ""keywords"": [""N.A.""], ""parameters"": {""NumProducts"": {""description"": ""Number of products baked"", ""shape"": []}, ""NumResources"": {""description"": ""Number of resource types"", ""shape"": []}, ""Profit"": {""description"": ""Profit per batch of each product"", ""shape"": [""NumProducts""]}, ""ResourceTime"": {""description"": ""Time required per batch of each product for each resource"", ""shape"": [""NumResources"", ""NumProducts""]}, ""ResourceAvailability"": {""description"": ""Total available time per resource"", ""shape"": [""NumResources""]}}, ""variables"": {""Batch"": {""description"": ""The number of batches for each product"", ""type"": ""continuous"", ""shape"": [""NumProducts""]}}, ""constraints"": [{""description"": ""For each resource type, the total time required by all product batches does not exceed the ResourceAvailability."", ""formulation"": ""\\sum_{p=1}^{\\text{NumProducts}} \\text{ResourceTime}_{r,p} \\cdot \\text{Batch}_p \\leq \\text{ResourceAvailability}_r \\quad \\forall r \\in \\{1, \\dots, \\text{NumResources}\\}"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(ResourceTime[r][p] * Batch[p] for p in range(NumProducts)) <= ResourceAvailability[r] for r in range(NumResources)), name=\""ResourceLimit\"")""}}], ""objective"": {""description"": ""Total Profit is the sum of the profit per batch of each product multiplied by the number of batches produced. The objective is to maximize the total Profit."", ""formulation"": ""Max \\sum_{i=1}^{NumProducts} Profit_i \\times Batch_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(Profit[i] * Batch[i] for i in range(NumProducts)), GRB.MAXIMIZE)""}}}","{""NumProducts"": 2, ""NumResources"": 2, ""Profit"": [20, 40], ""ResourceTime"": [[2, 1], [0.25, 2]], ""ResourceAvailability"": [70, 32]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A bakery manufactures NumProducts distinct products, each yielding a specific
Profit per batch. Each product requires a certain amount of time from each of
the NumResources resource types for production. The bakery has a limited amount
of time available for each resource, defined by ResourceAvailability. The goal
is to maximize the total Profit by fully utilizing the available Resource
capacities.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/37/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumProducts @Def: Number of products baked @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter NumResources @Def: Number of resource types @Shape: [] 
NumResources = data['NumResources']
# @Parameter Profit @Def: Profit per batch of each product @Shape: ['NumProducts'] 
Profit = data['Profit']
# @Parameter ResourceTime @Def: Time required per batch of each product for each resource @Shape: ['NumResources', 'NumProducts'] 
ResourceTime = data['ResourceTime']
# @Parameter ResourceAvailability @Def: Total available time per resource @Shape: ['NumResources'] 
ResourceAvailability = data['ResourceAvailability']

# Variables 
# @Variable Batch @Def: The number of batches for each product @Shape: ['NumProducts'] 
Batch = model.addVars(NumProducts, vtype=GRB.CONTINUOUS, name=""Batch"")

# Constraints 
# @Constraint Constr_1 @Def: For each resource type, the total time required by all product batches does not exceed the ResourceAvailability.
model.addConstrs((quicksum(ResourceTime[r][p] * Batch[p] for p in range(NumProducts)) <= ResourceAvailability[r] for r in range(NumResources)), name=""ResourceLimit"")

# Objective 
# @Objective Objective @Def: Total Profit is the sum of the profit per batch of each product multiplied by the number of batches produced. The objective is to maximize the total Profit.
model.setObjective(quicksum(Profit[i] * Batch[i] for i in range(NumProducts)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Batch'] = {p: Batch[p].x for p in Batch}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A teddy bear company produces three different colored bears: black, white, and brown. These bears are made in two different factories. Running factory 1 for 1 hour costs $300 and produces 5 black teddy bears, 6 white teddy bears, and 3 brown ones. Running factory 2 for 1 hour costs $600 and produces 10 black teddy bears and 10 white teddy bears. (but no brown ones). To meet children's demand, at least 20 black teddy bears, 5 white teddy bears, and 15 brown teddy bears must be made daily. Given this information, develop a linear programming problem assuming the teddy bear company wants to minimize the cost of production.","{""variables"": {""RunningTime"": {""0"": 5.0, ""1"": 0.0}}, ""objective"": 1500.0}","{""parametrized_description"": ""A teddy bear company produces NumColors different colored bears using NumFactories different factories. Running factory k for one hour costs FactoryRunningCost[k]. Factory k produces ProductionRate[k][c] teddy bears of color c per hour. To meet demand, the company must produce at least Demand[c] teddy bears of each color daily. The objective is to minimize the total production cost."", ""keywords"": [""N.A.""], ""parameters"": {""NumFactories"": {""description"": ""The number of different factories available for production"", ""shape"": []}, ""NumColors"": {""description"": ""The number of different colored teddy bears produced"", ""shape"": []}, ""FactoryRunningCost"": {""description"": ""The cost to run each factory for one hour"", ""shape"": [""NumFactories""]}, ""ProductionRate"": {""description"": ""The number of teddy bears of each color produced per hour by each factory"", ""shape"": [""NumFactories"", ""NumColors""]}, ""Demand"": {""description"": ""The minimum number of teddy bears of each color required per day"", ""shape"": [""NumColors""]}}, ""variables"": {""RunningTime"": {""description"": ""The running time of each factory"", ""type"": ""continuous"", ""shape"": [""NumFactories""]}}, ""constraints"": [{""description"": ""For each color c, the total production across all factories must be at least Demand[c]. This means that the sum of ProductionRate[k][c] multiplied by the running time of factory k for all factories k must be greater than or equal to Demand[c]."", ""formulation"": ""\\sum_{k=1}^{NumFactories} ProductionRate_{k,c} \\times RunningTime_{k} \\geq Demand_{c} \\quad \\forall c \\in \\{1, \\dots, NumColors\\}"", ""code"": {""gurobipy"": ""model.addConstrs(\n    (quicksum(ProductionRate[k][c] * RunningTime[k] for k in range(NumFactories)) >= Demand[c] \n     for c in range(NumColors)),\n    name=\""DemandConstraint\""\n)""}}, {""description"": ""Factory running times must be non-negative."", ""formulation"": ""RunningTime_i \\geq 0 \\quad \\forall i = 1, \\dots, NumFactories"", ""code"": {""gurobipy"": ""model.addConstrs(RunningTime[i] >= 0 for i in range(NumFactories))""}}], ""objective"": {""description"": ""Minimize the total production cost, which is the sum of the running costs of all factories multiplied by their respective running times."", ""formulation"": ""Min \\sum_{i=1}^{NumFactories} FactoryRunningCost_{i} \\cdot RunningTime_{i}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(FactoryRunningCost[i] * RunningTime[i] for i in range(NumFactories)), GRB.MINIMIZE)""}}}","{""NumFactories"": 2, ""NumColors"": 3, ""FactoryRunningCost"": [300, 600], ""ProductionRate"": [[5, 6, 3], [10, 10, 0]], ""Demand"": [20, 5, 15]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A teddy bear company produces NumColors different colored bears using
NumFactories different factories. Running factory k for one hour costs
FactoryRunningCost[k]. Factory k produces ProductionRate[k][c] teddy bears of
color c per hour. To meet demand, the company must produce at least Demand[c]
teddy bears of each color daily. The objective is to minimize the total
production cost.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/38/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumFactories @Def: The number of different factories available for production @Shape: [] 
NumFactories = data['NumFactories']
# @Parameter NumColors @Def: The number of different colored teddy bears produced @Shape: [] 
NumColors = data['NumColors']
# @Parameter FactoryRunningCost @Def: The cost to run each factory for one hour @Shape: ['NumFactories'] 
FactoryRunningCost = data['FactoryRunningCost']
# @Parameter ProductionRate @Def: The number of teddy bears of each color produced per hour by each factory @Shape: ['NumFactories', 'NumColors'] 
ProductionRate = data['ProductionRate']
# @Parameter Demand @Def: The minimum number of teddy bears of each color required per day @Shape: ['NumColors'] 
Demand = data['Demand']

# Variables 
# @Variable RunningTime @Def: The running time of each factory @Shape: ['NumFactories'] 
RunningTime = model.addVars(NumFactories, vtype=GRB.CONTINUOUS, name=""RunningTime"")

# Constraints 
# @Constraint Constr_1 @Def: For each color c, the total production across all factories must be at least Demand[c]. This means that the sum of ProductionRate[k][c] multiplied by the running time of factory k for all factories k must be greater than or equal to Demand[c].
model.addConstrs(
    (quicksum(ProductionRate[k][c] * RunningTime[k] for k in range(NumFactories)) >= Demand[c] 
     for c in range(NumColors)),
    name=""DemandConstraint""
)
# @Constraint Constr_2 @Def: Factory running times must be non-negative.
model.addConstrs(RunningTime[i] >= 0 for i in range(NumFactories))

# Objective 
# @Objective Objective @Def: Minimize the total production cost, which is the sum of the running costs of all factories multiplied by their respective running times.
model.setObjective(quicksum(FactoryRunningCost[i] * RunningTime[i] for i in range(NumFactories)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['RunningTime'] = {k: RunningTime[k].X for k in range(NumFactories)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A farmer has 500 acres of land to grow turnips and pumpkins. Turnips require 50 minutes of watering and $80 worth of pesticide per acre. Pumpkins require 90 minutes of watering and $50 worth of pesticide per acre. The farmer has 40000 minutes available for watering and $34000 available to spend on pesticide. If the revenue per acre of turnips is $300 and the revenue per acre of pumpkins is $450, how many acres of each should he grow to maximize his revenue.","{""variables"": {""LandTurnips"": 125.0, ""LandPumpkins"": 375.0}, ""objective"": 206250.0}","{""parametrized_description"": ""A farmer has TotalLand acres to cultivate turnips and pumpkins. Turnips require WateringTimeTurnips minutes of watering and PesticideCostTurnips dollars worth of pesticide per acre. Pumpkins require WateringTimePumpkins minutes of watering and PesticideCostPumpkins dollars worth of pesticide per acre. The farmer has TotalWateringTime minutes available for watering and TotalPesticideBudget dollars available to spend on pesticide. The revenue per acre of turnips is RevenueTurnips and the revenue per acre of pumpkins is RevenuePumpkins. Determine the number of acres of each crop to maximize the farmer's total revenue."", ""keywords"": [""N.A.""], ""parameters"": {""TotalLand"": {""description"": ""Total land available for cultivation"", ""shape"": []}, ""WateringTimeTurnips"": {""description"": ""Watering time required per acre of turnips"", ""shape"": []}, ""PesticideCostTurnips"": {""description"": ""Pesticide cost per acre of turnips"", ""shape"": []}, ""WateringTimePumpkins"": {""description"": ""Watering time required per acre of pumpkins"", ""shape"": []}, ""PesticideCostPumpkins"": {""description"": ""Pesticide cost per acre of pumpkins"", ""shape"": []}, ""TotalWateringTime"": {""description"": ""Total available watering time"", ""shape"": []}, ""TotalPesticideBudget"": {""description"": ""Total pesticide budget"", ""shape"": []}, ""RevenueTurnips"": {""description"": ""Revenue per acre of turnips"", ""shape"": []}, ""RevenuePumpkins"": {""description"": ""Revenue per acre of pumpkins"", ""shape"": []}}, ""variables"": {""LandTurnips"": {""description"": ""The land allocated to turnips"", ""type"": ""continuous"", ""shape"": []}, ""LandPumpkins"": {""description"": ""The land allocated to pumpkins"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total land allocated to turnips and pumpkins cannot exceed TotalLand."", ""formulation"": ""LandTurnips + LandPumpkins \\leq TotalLand"", ""code"": {""gurobipy"": ""model.addConstr(LandTurnips + LandPumpkins <= TotalLand)""}}, {""description"": ""The total watering time required for turnips and pumpkins cannot exceed TotalWateringTime."", ""formulation"": ""WateringTimeTurnips \\times LandTurnips + WateringTimePumpkins \\times LandPumpkins \\leq TotalWateringTime"", ""code"": {""gurobipy"": ""model.addConstr(WateringTimeTurnips * LandTurnips + WateringTimePumpkins * LandPumpkins <= TotalWateringTime)""}}, {""description"": ""The total pesticide cost for turnips and pumpkins cannot exceed TotalPesticideBudget."", ""formulation"": ""PesticideCostTurnips \\\\times LandTurnips + PesticideCostPumpkins \\\\times LandPumpkins \\\\leq TotalPesticideBudget"", ""code"": {""gurobipy"": ""model.addConstr(PesticideCostTurnips * LandTurnips + PesticideCostPumpkins * LandPumpkins <= TotalPesticideBudget)""}}], ""objective"": {""description"": ""Total revenue is the sum of the revenue per acre of turnips and pumpkins. The objective is to maximize the total revenue."", ""formulation"": ""Max \\ RevenueTurnips \\times LandTurnips + RevenuePumpkins \\times LandPumpkins"", ""code"": {""gurobipy"": ""model.setObjective(RevenueTurnips * LandTurnips + RevenuePumpkins * LandPumpkins, GRB.MAXIMIZE)""}}}","{""TotalLand"": 500, ""WateringTimeTurnips"": 50, ""PesticideCostTurnips"": 80, ""WateringTimePumpkins"": 90, ""PesticideCostPumpkins"": 50, ""TotalWateringTime"": 40000, ""TotalPesticideBudget"": 34000, ""RevenueTurnips"": 300, ""RevenuePumpkins"": 450}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A farmer has TotalLand acres to cultivate turnips and pumpkins. Turnips require
WateringTimeTurnips minutes of watering and PesticideCostTurnips dollars worth
of pesticide per acre. Pumpkins require WateringTimePumpkins minutes of watering
and PesticideCostPumpkins dollars worth of pesticide per acre. The farmer has
TotalWateringTime minutes available for watering and TotalPesticideBudget
dollars available to spend on pesticide. The revenue per acre of turnips is
RevenueTurnips and the revenue per acre of pumpkins is RevenuePumpkins.
Determine the number of acres of each crop to maximize the farmer's total
revenue.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/39/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalLand @Def: Total land available for cultivation @Shape: [] 
TotalLand = data['TotalLand']
# @Parameter WateringTimeTurnips @Def: Watering time required per acre of turnips @Shape: [] 
WateringTimeTurnips = data['WateringTimeTurnips']
# @Parameter PesticideCostTurnips @Def: Pesticide cost per acre of turnips @Shape: [] 
PesticideCostTurnips = data['PesticideCostTurnips']
# @Parameter WateringTimePumpkins @Def: Watering time required per acre of pumpkins @Shape: [] 
WateringTimePumpkins = data['WateringTimePumpkins']
# @Parameter PesticideCostPumpkins @Def: Pesticide cost per acre of pumpkins @Shape: [] 
PesticideCostPumpkins = data['PesticideCostPumpkins']
# @Parameter TotalWateringTime @Def: Total available watering time @Shape: [] 
TotalWateringTime = data['TotalWateringTime']
# @Parameter TotalPesticideBudget @Def: Total pesticide budget @Shape: [] 
TotalPesticideBudget = data['TotalPesticideBudget']
# @Parameter RevenueTurnips @Def: Revenue per acre of turnips @Shape: [] 
RevenueTurnips = data['RevenueTurnips']
# @Parameter RevenuePumpkins @Def: Revenue per acre of pumpkins @Shape: [] 
RevenuePumpkins = data['RevenuePumpkins']

# Variables 
# @Variable LandTurnips @Def: The land allocated to turnips @Shape: [] 
LandTurnips = model.addVar(vtype=GRB.CONTINUOUS, name=""LandTurnips"")
# @Variable LandPumpkins @Def: The land allocated to pumpkins @Shape: [] 
LandPumpkins = model.addVar(vtype=GRB.CONTINUOUS, name=""LandPumpkins"")

# Constraints 
# @Constraint Constr_1 @Def: The total land allocated to turnips and pumpkins cannot exceed TotalLand.
model.addConstr(LandTurnips + LandPumpkins <= TotalLand)
# @Constraint Constr_2 @Def: The total watering time required for turnips and pumpkins cannot exceed TotalWateringTime.
model.addConstr(WateringTimeTurnips * LandTurnips + WateringTimePumpkins * LandPumpkins <= TotalWateringTime)
# @Constraint Constr_3 @Def: The total pesticide cost for turnips and pumpkins cannot exceed TotalPesticideBudget.
model.addConstr(PesticideCostTurnips * LandTurnips + PesticideCostPumpkins * LandPumpkins <= TotalPesticideBudget)

# Objective 
# @Objective Objective @Def: Total revenue is the sum of the revenue per acre of turnips and pumpkins. The objective is to maximize the total revenue.
model.setObjective(RevenueTurnips * LandTurnips + RevenuePumpkins * LandPumpkins, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['LandTurnips'] = LandTurnips.x
variables['LandPumpkins'] = LandPumpkins.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A school employs staff and substitute teachers. Per shift, staff teachers work 6 hours and get paid $300. Per shift, substitute teachers work 3 hours and get paid $100. For the summer term, the school requires 1000 hours of teaching availability. If the school has a budget of $40000, how many of each teacher should be hired to minimize the total number of teachers?","{""variables"": {""NumStaffShifts"": 0.0, ""NumSubstituteShifts"": 400.0, ""NumStaffTeachers"": -0.0, ""NumSubstituteTeachers"": -0.0}, ""objective"": 0.0}","{""parametrized_description"": ""Minimize the total number of staff teachers and substitute teachers, where each staff teacher works StaffShiftHours hours per shift and is paid StaffShiftPay per shift, and each substitute teacher works SubstituteShiftHours hours per shift and is paid SubstituteShiftPay per shift, subject to the constraints that the total teaching hours meet TotalTeachingHours and the total payments do not exceed TotalBudget."", ""keywords"": [""N.A.""], ""parameters"": {""StaffShiftHours"": {""description"": ""Number of hours worked per shift by a staff teacher"", ""shape"": []}, ""StaffShiftPay"": {""description"": ""Payment per shift to a staff teacher"", ""shape"": []}, ""SubstituteShiftHours"": {""description"": ""Number of hours worked per shift by a substitute teacher"", ""shape"": []}, ""SubstituteShiftPay"": {""description"": ""Payment per shift to a substitute teacher"", ""shape"": []}, ""TotalTeachingHours"": {""description"": ""Total required teaching hours for the summer term"", ""shape"": []}, ""TotalBudget"": {""description"": ""Total budget allocated for teacher payments"", ""shape"": []}}, ""variables"": {""NumStaffShifts"": {""description"": ""The number of shifts worked by staff teachers"", ""type"": ""continuous"", ""shape"": []}, ""NumSubstituteShifts"": {""description"": ""The number of shifts worked by substitute teachers"", ""type"": ""continuous"", ""shape"": []}, ""NumStaffTeachers"": {""description"": ""The number of staff teachers"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumSubstituteTeachers"": {""description"": ""The number of substitute teachers"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total teaching hours provided by staff teachers and substitute teachers must meet TotalTeachingHours."", ""formulation"": ""NumStaffShifts \\times StaffShiftHours + NumSubstituteShifts \\times SubstituteShiftHours \\geq TotalTeachingHours"", ""code"": {""gurobipy"": ""model.addConstr(NumStaffShifts * StaffShiftHours + NumSubstituteShifts * SubstituteShiftHours >= TotalTeachingHours)""}}, {""description"": ""The total payments to staff teachers and substitute teachers must not exceed TotalBudget."", ""formulation"": ""NumStaffShifts \\cdot StaffShiftPay + NumSubstituteShifts \\cdot SubstituteShiftPay \\leq TotalBudget"", ""code"": {""gurobipy"": ""model.addConstr(NumStaffShifts * StaffShiftPay + NumSubstituteShifts * SubstituteShiftPay <= TotalBudget)""}}], ""objective"": {""description"": ""The primary objective is to minimize the total number of staff teachers and substitute teachers while meeting the total teaching hours requirement and not exceeding the total budget."", ""formulation"": ""Min \\left( NumStaffTeachers + NumSubstituteTeachers \\right )"", ""code"": {""gurobipy"": ""model.setObjective(NumStaffTeachers + NumSubstituteTeachers, GRB.MINIMIZE)""}}}","{""StaffShiftHours"": 6, ""StaffShiftPay"": 300, ""SubstituteShiftHours"": 3, ""SubstituteShiftPay"": 100, ""TotalTeachingHours"": 1000, ""TotalBudget"": 40000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Minimize the total number of staff teachers and substitute teachers, where each
staff teacher works StaffShiftHours hours per shift and is paid StaffShiftPay
per shift, and each substitute teacher works SubstituteShiftHours hours per
shift and is paid SubstituteShiftPay per shift, subject to the constraints that
the total teaching hours meet TotalTeachingHours and the total payments do not
exceed TotalBudget.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/40/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter StaffShiftHours @Def: Number of hours worked per shift by a staff teacher @Shape: [] 
StaffShiftHours = data['StaffShiftHours']
# @Parameter StaffShiftPay @Def: Payment per shift to a staff teacher @Shape: [] 
StaffShiftPay = data['StaffShiftPay']
# @Parameter SubstituteShiftHours @Def: Number of hours worked per shift by a substitute teacher @Shape: [] 
SubstituteShiftHours = data['SubstituteShiftHours']
# @Parameter SubstituteShiftPay @Def: Payment per shift to a substitute teacher @Shape: [] 
SubstituteShiftPay = data['SubstituteShiftPay']
# @Parameter TotalTeachingHours @Def: Total required teaching hours for the summer term @Shape: [] 
TotalTeachingHours = data['TotalTeachingHours']
# @Parameter TotalBudget @Def: Total budget allocated for teacher payments @Shape: [] 
TotalBudget = data['TotalBudget']

# Variables 
# @Variable NumStaffShifts @Def: The number of shifts worked by staff teachers @Shape: [] 
NumStaffShifts = model.addVar(vtype=GRB.INTEGER, name=""NumStaffShifts"")
# @Variable NumSubstituteShifts @Def: The number of shifts worked by substitute teachers @Shape: [] 
NumSubstituteShifts = model.addVar(vtype=GRB.INTEGER, name=""NumSubstituteShifts"")
# @Variable NumStaffTeachers @Def: The number of staff teachers @Shape: ['Integer'] 
NumStaffTeachers = model.addVar(vtype=GRB.INTEGER, name=""NumStaffTeachers"")
# @Variable NumSubstituteTeachers @Def: The number of substitute teachers @Shape: ['Integer'] 
NumSubstituteTeachers = model.addVar(vtype=GRB.INTEGER, name=""NumSubstituteTeachers"")

# Constraints 
# @Constraint Constr_1 @Def: The total teaching hours provided by staff teachers and substitute teachers must meet TotalTeachingHours.
model.addConstr(NumStaffShifts * StaffShiftHours + NumSubstituteShifts * SubstituteShiftHours >= TotalTeachingHours)
# @Constraint Constr_2 @Def: The total payments to staff teachers and substitute teachers must not exceed TotalBudget.
model.addConstr(NumStaffShifts * StaffShiftPay + NumSubstituteShifts * SubstituteShiftPay <= TotalBudget)

# Objective 
# @Objective Objective @Def: The primary objective is to minimize the total number of staff teachers and substitute teachers while meeting the total teaching hours requirement and not exceeding the total budget.
model.setObjective(NumStaffTeachers + NumSubstituteTeachers, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumStaffShifts'] = NumStaffShifts.x
variables['NumSubstituteShifts'] = NumSubstituteShifts.x
variables['NumStaffTeachers'] = NumStaffTeachers.x
variables['NumSubstituteTeachers'] = NumSubstituteTeachers.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A gem factory has two drills, a high intensity one and a low intensity one. Each day, the high intensity drill can process 50 gems and requires 50 units of water to dissipate heat. Each day, the low intensity drill can process 30 gems and requires 20 units of water to dissipate heat. Each day the factory must process 800 gems and they have available 700 units of water. Since the high intensity drill produces a lot of noise pollution, at most 40% of the drills can be high intensity ones. Further, at least 10 should be low intensity drills. How many of each drill should be used to minimize the total number of drills needed?","{""variables"": {""HighDrills"": 7.0, ""LowDrills"": 15.0}, ""objective"": 22.0}","{""parametrized_description"": ""A factory utilizes high intensity drills and low intensity drills. Each high intensity drill processes GemsPerHigh gems per day and requires WaterPerHigh units of water daily. Each low intensity drill processes GemsPerLow gems per day and requires WaterPerLow units of water daily. The factory must process a total of TotalGems gems each day and has AvailableWater units of water available for dissipation. No more than MaxHighFraction of the total drills can be high intensity to control noise pollution, and at least MinLowDrills low intensity drills must be employed. The objective is to minimize the total number of drills used."", ""keywords"": [""N.A.""], ""parameters"": {""GemsPerHigh"": {""description"": ""Number of gems processed per day by a high intensity drill."", ""shape"": []}, ""WaterPerHigh"": {""description"": ""Units of water required per day to dissipate heat by a high intensity drill."", ""shape"": []}, ""GemsPerLow"": {""description"": ""Number of gems processed per day by a low intensity drill."", ""shape"": []}, ""WaterPerLow"": {""description"": ""Units of water required per day to dissipate heat by a low intensity drill."", ""shape"": []}, ""TotalGems"": {""description"": ""Total number of gems that must be processed per day by the factory."", ""shape"": []}, ""AvailableWater"": {""description"": ""Total units of water available per day for dissipating heat."", ""shape"": []}, ""MaxHighFraction"": {""description"": ""Maximum fraction of drills that can be high intensity to limit noise pollution."", ""shape"": []}, ""MinLowDrills"": {""description"": ""Minimum number of low intensity drills that must be used."", ""shape"": []}}, ""variables"": {""HighDrills"": {""description"": ""The number of high intensity drills used"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""LowDrills"": {""description"": ""The number of low intensity drills used"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total number of gems processed per day by high and low intensity drills must equal TotalGems."", ""formulation"": ""GemsPerHigh \\cdot HighDrills + GemsPerLow \\cdot LowDrills = TotalGems"", ""code"": {""gurobipy"": ""model.addConstr(GemsPerHigh * HighDrills + GemsPerLow * LowDrills == TotalGems)""}}, {""description"": ""The total water usage by all drills must not exceed AvailableWater units per day."", ""formulation"": ""WaterPerHigh \\cdot HighDrills + WaterPerLow \\cdot LowDrills \\leq AvailableWater"", ""code"": {""gurobipy"": ""model.addConstr(WaterPerHigh * HighDrills + WaterPerLow * LowDrills <= AvailableWater)""}}, {""description"": ""No more than MaxHighFraction of the total drills can be high intensity to limit noise pollution."", ""formulation"": ""(1 - MaxHighFraction) \\cdot HighDrills \\leq MaxHighFraction \\cdot LowDrills"", ""code"": {""gurobipy"": ""model.addConstr((1 - MaxHighFraction) * HighDrills <= MaxHighFraction * LowDrills)""}}, {""description"": ""At least MinLowDrills low intensity drills must be employed."", ""formulation"": ""LowDrills \\geq MinLowDrills"", ""code"": {""gurobipy"": ""model.addConstr(LowDrills >= MinLowDrills)""}}], ""objective"": {""description"": ""Minimize the total number of drills used."", ""formulation"": ""\\min \\ HighDrills + LowDrills"", ""code"": {""gurobipy"": ""model.setObjective(HighDrills + LowDrills, GRB.MINIMIZE)""}}}","{""GemsPerHigh"": 50, ""WaterPerHigh"": 50, ""GemsPerLow"": 30, ""WaterPerLow"": 20, ""TotalGems"": 800, ""AvailableWater"": 700, ""MaxHighFraction"": 0.4, ""MinLowDrills"": 10}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A factory utilizes high intensity drills and low intensity drills. Each high
intensity drill processes GemsPerHigh gems per day and requires WaterPerHigh
units of water daily. Each low intensity drill processes GemsPerLow gems per day
and requires WaterPerLow units of water daily. The factory must process a total
of TotalGems gems each day and has AvailableWater units of water available for
dissipation. No more than MaxHighFraction of the total drills can be high
intensity to control noise pollution, and at least MinLowDrills low intensity
drills must be employed. The objective is to minimize the total number of drills
used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/41/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter GemsPerHigh @Def: Number of gems processed per day by a high intensity drill. @Shape: [] 
GemsPerHigh = data['GemsPerHigh']
# @Parameter WaterPerHigh @Def: Units of water required per day to dissipate heat by a high intensity drill. @Shape: [] 
WaterPerHigh = data['WaterPerHigh']
# @Parameter GemsPerLow @Def: Number of gems processed per day by a low intensity drill. @Shape: [] 
GemsPerLow = data['GemsPerLow']
# @Parameter WaterPerLow @Def: Units of water required per day to dissipate heat by a low intensity drill. @Shape: [] 
WaterPerLow = data['WaterPerLow']
# @Parameter TotalGems @Def: Total number of gems that must be processed per day by the factory. @Shape: [] 
TotalGems = data['TotalGems']
# @Parameter AvailableWater @Def: Total units of water available per day for dissipating heat. @Shape: [] 
AvailableWater = data['AvailableWater']
# @Parameter MaxHighFraction @Def: Maximum fraction of drills that can be high intensity to limit noise pollution. @Shape: [] 
MaxHighFraction = data['MaxHighFraction']
# @Parameter MinLowDrills @Def: Minimum number of low intensity drills that must be used. @Shape: [] 
MinLowDrills = data['MinLowDrills']

# Variables 
# @Variable HighDrills @Def: The number of high intensity drills used @Shape: ['Integer'] 
HighDrills = model.addVar(vtype=GRB.INTEGER, name=""HighDrills"")
# @Variable LowDrills @Def: The number of low intensity drills used @Shape: ['Integer'] 
LowDrills = model.addVar(vtype=GRB.INTEGER, name=""LowDrills"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of gems processed per day by high and low intensity drills must equal TotalGems.
model.addConstr(GemsPerHigh * HighDrills + GemsPerLow * LowDrills == TotalGems)
# @Constraint Constr_2 @Def: The total water usage by all drills must not exceed AvailableWater units per day.
model.addConstr(WaterPerHigh * HighDrills + WaterPerLow * LowDrills <= AvailableWater)
# @Constraint Constr_3 @Def: No more than MaxHighFraction of the total drills can be high intensity to limit noise pollution.
model.addConstr((1 - MaxHighFraction) * HighDrills <= MaxHighFraction * LowDrills)
# @Constraint Constr_4 @Def: At least MinLowDrills low intensity drills must be employed.
model.addConstr(LowDrills >= MinLowDrills)

# Objective 
# @Objective Objective @Def: Minimize the total number of drills used.
model.setObjective(HighDrills + LowDrills, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['HighDrills'] = HighDrills.x
variables['LowDrills'] = LowDrills.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A sandwich company can open two types of stores, a dine-in place and a food-truck. A dine-in place can make 100 sandwiches per day and requires 8 employees to operate. A food-truck can make 50 sandwiches per day and requires 3 employees to operate. The company must make at least 500 sandwiches per day but they only have available 35 employees. How many of each type of store should the company open to minimize the total number of stores?","{""variables"": {""NumberStore"": {""0"": 2.0, ""1"": 6.0}}, ""objective"": 8.0}","{""parametrized_description"": ""A sandwich company can open NumStoreTypes types of stores. Each store type produces SandwichesPerStoreType sandwiches per day and requires EmployeesPerStoreType employees to operate. The company must produce at least MinimumSandwiches sandwiches per day and has at most MaximumEmployees employees available. Determine the number of each type of store to minimize the total number of stores."", ""keywords"": [""N.A.""], ""parameters"": {""NumStoreTypes"": {""description"": ""Number of types of stores available"", ""shape"": []}, ""SandwichesPerStoreType"": {""description"": ""Number of sandwiches produced per store type per day"", ""shape"": [""NumStoreTypes""]}, ""EmployeesPerStoreType"": {""description"": ""Number of employees required per store type"", ""shape"": [""NumStoreTypes""]}, ""MinimumSandwiches"": {""description"": ""Minimum number of sandwiches to be produced per day"", ""shape"": []}, ""MaximumEmployees"": {""description"": ""Maximum number of employees available"", ""shape"": []}}, ""variables"": {""NumberStore"": {""description"": ""The number of stores for each store type"", ""type"": ""continuous"", ""shape"": [""NumStoreTypes""]}}, ""constraints"": [{""description"": ""The total number of sandwiches produced per day must be at least MinimumSandwiches. This is calculated by summing SandwichesPerStoreType multiplied by the number of each store type."", ""formulation"": ""\\sum_{i=1}^{NumStoreTypes} SandwichesPerStoreType_i \\cdot NumberStore_i \\geq MinimumSandwiches"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(SandwichesPerStoreType[i] * NumberStore[i] for i in range(NumStoreTypes)) >= MinimumSandwiches)""}}, {""description"": ""The total number of employees required must not exceed MaximumEmployees. This is calculated by summing EmployeesPerStoreType multiplied by the number of each store type."", ""formulation"": ""\\sum_{i=1}^{\\text{NumStoreTypes}} \\text{EmployeesPerStoreType}_i \\times \\text{NumberStore}_i \\leq \\text{MaximumEmployees}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(EmployeesPerStoreType[i] * NumberStore[i] for i in range(NumStoreTypes)) <= MaximumEmployees)""}}], ""objective"": {""description"": ""Minimize the total number of stores, which is the sum of the number of each type of store."", ""formulation"": ""Min \\sum_{t=1}^{NumStoreTypes} NumberStore_t"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(NumberStore[t] for t in range(NumStoreTypes)), GRB.MINIMIZE)""}}}","{""NumStoreTypes"": 2, ""SandwichesPerStoreType"": [100, 50], ""EmployeesPerStoreType"": [8, 3], ""MinimumSandwiches"": 500, ""MaximumEmployees"": 35}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A sandwich company can open NumStoreTypes types of stores. Each store type
produces SandwichesPerStoreType sandwiches per day and requires
EmployeesPerStoreType employees to operate. The company must produce at least
MinimumSandwiches sandwiches per day and has at most MaximumEmployees employees
available. Determine the number of each type of store to minimize the total
number of stores.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/42/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumStoreTypes @Def: Number of types of stores available @Shape: [] 
NumStoreTypes = data['NumStoreTypes']
# @Parameter SandwichesPerStoreType @Def: Number of sandwiches produced per store type per day @Shape: ['NumStoreTypes'] 
SandwichesPerStoreType = data['SandwichesPerStoreType']
# @Parameter EmployeesPerStoreType @Def: Number of employees required per store type @Shape: ['NumStoreTypes'] 
EmployeesPerStoreType = data['EmployeesPerStoreType']
# @Parameter MinimumSandwiches @Def: Minimum number of sandwiches to be produced per day @Shape: [] 
MinimumSandwiches = data['MinimumSandwiches']
# @Parameter MaximumEmployees @Def: Maximum number of employees available @Shape: [] 
MaximumEmployees = data['MaximumEmployees']

# Variables 
# @Variable NumberStore @Def: The number of stores for each store type @Shape: ['NumStoreTypes'] 
NumberStore = model.addVars(NumStoreTypes, vtype=GRB.INTEGER, name=""NumberStore"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of sandwiches produced per day must be at least MinimumSandwiches. This is calculated by summing SandwichesPerStoreType multiplied by the number of each store type.
model.addConstr(quicksum(SandwichesPerStoreType[i] * NumberStore[i] for i in range(NumStoreTypes)) >= MinimumSandwiches)
# @Constraint Constr_2 @Def: The total number of employees required must not exceed MaximumEmployees. This is calculated by summing EmployeesPerStoreType multiplied by the number of each store type.
model.addConstr(quicksum(EmployeesPerStoreType[i] * NumberStore[i] for i in range(NumStoreTypes)) <= MaximumEmployees)

# Objective 
# @Objective Objective @Def: Minimize the total number of stores, which is the sum of the number of each type of store.
model.setObjective(quicksum(NumberStore[t] for t in range(NumStoreTypes)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberStore'] = {i: NumberStore[i].x for i in range(NumStoreTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"There are two processes, process A and process B, to plate a coin with gold. Process A requires 3 units of gold, 2 wires, and can plate 5 coins. Process B requires 5 units of gold, 3 wires, and can plate 7 coins. There are 500 units of gold and 300 wires available. How many processes of each type should be run to maximize the total number of coins that can be plated?","{""variables"": {""ExecuteProcessA"": 150.0, ""ExecuteProcessB"": 0.0}, ""objective"": 750.0}","{""parametrized_description"": ""There are two processes, Process A and Process B. Executing Process A once requires GoldRequiredProcessA units of gold and WireRequiredProcessA wires, and plates CoinsPlatedProcessA coins. Executing Process B once requires GoldRequiredProcessB units of gold and WireRequiredProcessB wires, and plates CoinsPlatedProcessB coins. A total of TotalGoldAvailable units of gold and TotalWiresAvailable wires are available. Determine the number of executions of Process A and Process B to maximize the total number of coins plated."", ""keywords"": [""N.A.""], ""parameters"": {""GoldRequiredProcessA"": {""description"": ""Amount of gold required to run Process A once"", ""shape"": []}, ""WireRequiredProcessA"": {""description"": ""Number of wires required to run Process A once"", ""shape"": []}, ""CoinsPlatedProcessA"": {""description"": ""Number of coins plated per execution of Process A"", ""shape"": []}, ""GoldRequiredProcessB"": {""description"": ""Amount of gold required to run Process B once"", ""shape"": []}, ""WireRequiredProcessB"": {""description"": ""Number of wires required to run Process B once"", ""shape"": []}, ""CoinsPlatedProcessB"": {""description"": ""Number of coins plated per execution of Process B"", ""shape"": []}, ""TotalGoldAvailable"": {""description"": ""Total amount of gold available"", ""shape"": []}, ""TotalWiresAvailable"": {""description"": ""Total number of wires available"", ""shape"": []}}, ""variables"": {""ExecuteProcessA"": {""description"": ""The number of times Process A is executed"", ""type"": ""continuous"", ""shape"": []}, ""ExecuteProcessB"": {""description"": ""The number of times Process B is executed"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total amount of gold required for executing Process A and Process B does not exceed TotalGoldAvailable units of gold."", ""formulation"": ""GoldRequiredProcessA \\cdot ExecuteProcessA + GoldRequiredProcessB \\cdot ExecuteProcessB \\leq TotalGoldAvailable"", ""code"": {""gurobipy"": ""model.addConstr(GoldRequiredProcessA * ExecuteProcessA + GoldRequiredProcessB * ExecuteProcessB <= TotalGoldAvailable)""}}, {""description"": ""The total number of wires required for executing Process A and Process B does not exceed TotalWiresAvailable wires."", ""formulation"": ""WireRequiredProcessA \\cdot ExecuteProcessA + WireRequiredProcessB \\cdot ExecuteProcessB \\leq TotalWiresAvailable"", ""code"": {""gurobipy"": ""model.addConstr(WireRequiredProcessA * ExecuteProcessA + WireRequiredProcessB * ExecuteProcessB <= TotalWiresAvailable)""}}], ""objective"": {""description"": ""The total number of coins plated is the sum of CoinsPlatedProcessA multiplied by the number of executions of Process A and CoinsPlatedProcessB multiplied by the number of executions of Process B. The objective is to maximize the total number of coins plated."", ""formulation"": ""Max \\ (CoinsPlatedProcessA \\cdot ExecuteProcessA + CoinsPlatedProcessB \\cdot ExecuteProcessB)"", ""code"": {""gurobipy"": ""model.setObjective(CoinsPlatedProcessA * ExecuteProcessA + CoinsPlatedProcessB * ExecuteProcessB, GRB.MAXIMIZE)""}}}","{""GoldRequiredProcessA"": 3, ""WireRequiredProcessA"": 2, ""CoinsPlatedProcessA"": 5, ""GoldRequiredProcessB"": 5, ""WireRequiredProcessB"": 3, ""CoinsPlatedProcessB"": 7, ""TotalGoldAvailable"": 500, ""TotalWiresAvailable"": 300}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
There are two processes, Process A and Process B. Executing Process A once
requires GoldRequiredProcessA units of gold and WireRequiredProcessA wires, and
plates CoinsPlatedProcessA coins. Executing Process B once requires
GoldRequiredProcessB units of gold and WireRequiredProcessB wires, and plates
CoinsPlatedProcessB coins. A total of TotalGoldAvailable units of gold and
TotalWiresAvailable wires are available. Determine the number of executions of
Process A and Process B to maximize the total number of coins plated.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/43/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter GoldRequiredProcessA @Def: Amount of gold required to run Process A once @Shape: [] 
GoldRequiredProcessA = data['GoldRequiredProcessA']
# @Parameter WireRequiredProcessA @Def: Number of wires required to run Process A once @Shape: [] 
WireRequiredProcessA = data['WireRequiredProcessA']
# @Parameter CoinsPlatedProcessA @Def: Number of coins plated per execution of Process A @Shape: [] 
CoinsPlatedProcessA = data['CoinsPlatedProcessA']
# @Parameter GoldRequiredProcessB @Def: Amount of gold required to run Process B once @Shape: [] 
GoldRequiredProcessB = data['GoldRequiredProcessB']
# @Parameter WireRequiredProcessB @Def: Number of wires required to run Process B once @Shape: [] 
WireRequiredProcessB = data['WireRequiredProcessB']
# @Parameter CoinsPlatedProcessB @Def: Number of coins plated per execution of Process B @Shape: [] 
CoinsPlatedProcessB = data['CoinsPlatedProcessB']
# @Parameter TotalGoldAvailable @Def: Total amount of gold available @Shape: [] 
TotalGoldAvailable = data['TotalGoldAvailable']
# @Parameter TotalWiresAvailable @Def: Total number of wires available @Shape: [] 
TotalWiresAvailable = data['TotalWiresAvailable']

# Variables 
# @Variable ExecuteProcessA @Def: The number of times Process A is executed @Shape: [] 
ExecuteProcessA = model.addVar(vtype=GRB.INTEGER, name=""ExecuteProcessA"")
# @Variable ExecuteProcessB @Def: The number of times Process B is executed @Shape: [] 
ExecuteProcessB = model.addVar(vtype=GRB.INTEGER, name=""ExecuteProcessB"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of gold required for executing Process A and Process B does not exceed TotalGoldAvailable units of gold.
model.addConstr(GoldRequiredProcessA * ExecuteProcessA + GoldRequiredProcessB * ExecuteProcessB <= TotalGoldAvailable)
# @Constraint Constr_2 @Def: The total number of wires required for executing Process A and Process B does not exceed TotalWiresAvailable wires.
model.addConstr(WireRequiredProcessA * ExecuteProcessA + WireRequiredProcessB * ExecuteProcessB <= TotalWiresAvailable)

# Objective 
# @Objective Objective @Def: The total number of coins plated is the sum of CoinsPlatedProcessA multiplied by the number of executions of Process A and CoinsPlatedProcessB multiplied by the number of executions of Process B. The objective is to maximize the total number of coins plated.
model.setObjective(CoinsPlatedProcessA * ExecuteProcessA + CoinsPlatedProcessB * ExecuteProcessB, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ExecuteProcessA'] = ExecuteProcessA.x
variables['ExecuteProcessB'] = ExecuteProcessB.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A woodshop can purchase two types of saws, a miter saw and a circular saw. A miter saw can cut 50 planks of wood and produces 60 units of sawdust per day. A circular saw can cut 70 planks of wood and produces 100 units of sawdust per day. The woodshop must cut at least 1500 planks of wood per day. However, to avoid too much pollution in the woodshop they can produce at most 2000 units of sawdust per day. How many of each type of saw should be purchased to minimize the total number of saws needed?","{""variables"": {""NumberOfSaws"": {""0"": 15.0, ""1"": 11.0}}, ""objective"": 26.0}","{""parametrized_description"": ""A woodshop can purchase NumSawTypes different types of saws. Each saw type can cut PlanksCutPerSaw planks of wood per day and produce SawdustPerSaw units of sawdust per day. The woodshop must cut at least MinPlanks planks of wood per day and produce at most MaxSawdust units of sawdust per day. The goal is to determine the number of each type of saw to purchase to minimize the total number of saws needed."", ""keywords"": [""N.A.""], ""parameters"": {""NumSawTypes"": {""description"": ""Number of types of saws available"", ""shape"": []}, ""PlanksCutPerSaw"": {""description"": ""Number of planks cut per day by each saw type"", ""shape"": [""NumSawTypes""]}, ""SawdustPerSaw"": {""description"": ""Units of sawdust produced per day by each saw type"", ""shape"": [""NumSawTypes""]}, ""MinPlanks"": {""description"": ""Minimum number of planks to be cut per day"", ""shape"": []}, ""MaxSawdust"": {""description"": ""Maximum units of sawdust to be produced per day"", ""shape"": []}}, ""variables"": {""NumberOfSaws"": {""description"": ""The number of saws of each type used per day"", ""type"": ""continuous"", ""shape"": [""NumSawTypes""]}}, ""constraints"": [{""description"": ""The woodshop must cut at least MinPlanks planks of wood per day."", ""formulation"": ""\\sum_{j=1}^{NumSawTypes} NumberOfSaws_{j} \\times PlanksCutPerSaw_{j} \\geq MinPlanks"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(NumberOfSaws[j] * PlanksCutPerSaw[j] for j in range(NumSawTypes)) >= MinPlanks)""}}, {""description"": ""The woodshop must produce at most MaxSawdust units of sawdust per day."", ""formulation"": ""\\sum_{i=1}^{NumSawTypes} NumberOfSaws_i \\cdot SawdustPerSaw_i \\leq MaxSawdust"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(NumberOfSaws[i] * SawdustPerSaw[i] for i in range(NumSawTypes)) <= MaxSawdust)""}}], ""objective"": {""description"": ""Minimize the total number of saws purchased."", ""formulation"": ""Min \\sum_{i=1}^{\\text{NumSawTypes}} \\text{NumberOfSaws}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(NumberOfSaws[i] for i in range(NumSawTypes)), GRB.MINIMIZE)""}}}","{""NumSawTypes"": 2, ""PlanksCutPerSaw"": [50, 70], ""SawdustPerSaw"": [60, 100], ""MinPlanks"": 1500, ""MaxSawdust"": 2000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A woodshop can purchase NumSawTypes different types of saws. Each saw type can
cut PlanksCutPerSaw planks of wood per day and produce SawdustPerSaw units of
sawdust per day. The woodshop must cut at least MinPlanks planks of wood per day
and produce at most MaxSawdust units of sawdust per day. The goal is to
determine the number of each type of saw to purchase to minimize the total
number of saws needed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/44/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumSawTypes @Def: Number of types of saws available @Shape: [] 
NumSawTypes = data['NumSawTypes']
# @Parameter PlanksCutPerSaw @Def: Number of planks cut per day by each saw type @Shape: ['NumSawTypes'] 
PlanksCutPerSaw = data['PlanksCutPerSaw']
# @Parameter SawdustPerSaw @Def: Units of sawdust produced per day by each saw type @Shape: ['NumSawTypes'] 
SawdustPerSaw = data['SawdustPerSaw']
# @Parameter MinPlanks @Def: Minimum number of planks to be cut per day @Shape: [] 
MinPlanks = data['MinPlanks']
# @Parameter MaxSawdust @Def: Maximum units of sawdust to be produced per day @Shape: [] 
MaxSawdust = data['MaxSawdust']

# Variables 
# @Variable NumberOfSaws @Def: The number of saws of each type used per day @Shape: ['NumSawTypes'] 
NumberOfSaws = model.addVars(range(NumSawTypes), vtype=GRB.INTEGER, name=""NumberOfSaws"")

# Constraints 
# @Constraint Constr_1 @Def: The woodshop must cut at least MinPlanks planks of wood per day.
model.addConstr(quicksum(NumberOfSaws[j] * PlanksCutPerSaw[j] for j in range(NumSawTypes)) >= MinPlanks)
# @Constraint Constr_2 @Def: The woodshop must produce at most MaxSawdust units of sawdust per day.
model.addConstr(quicksum(NumberOfSaws[i] * SawdustPerSaw[i] for i in range(NumSawTypes)) <= MaxSawdust)

# Objective 
# @Objective Objective @Def: Minimize the total number of saws purchased.
model.setObjective(quicksum(NumberOfSaws[i] for i in range(NumSawTypes)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfSaws'] = {j: NumberOfSaws[j].X for j in range(NumSawTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A farmer has 200 acres of land on which he must process hay using either a windrower or hay harvester. For each acre of land, the windrower can process 10 kg of hay while the hay harvester can process 8 kg of hay. Per acre, the windrower produces 5 kg of methane gas and requires 2 kg of fuel. On the other hand, the hay harvester produces 3 kg of methane gas per acre and requires 1 kg of fuel. There are 300 kg of fuel available and the farmer can produce at most 800 kg of methane gas. For how many acres should each machine be used to maximize the amount of hay processed?","{""variables"": {""AcresAllocated"": [100.0, 100.0]}, ""objective"": 1800.0}","{""parametrized_description"": ""A farmer has TotalAcres of land on which hay must be processed using NumMachines different machine types. For each acre of land, machine type i can process HayProcessedPerAcre[i] units of hay, produce MethaneProducedPerAcre[i] units of methane gas, and require FuelRequiredPerAcre[i] units of fuel. The total fuel available is FuelAvailable, and the total methane production must not exceed MethaneLimit. The farmer aims to determine the number of acres to allocate to each machine type to maximize the total amount of hay processed."", ""keywords"": [""N.A.""], ""parameters"": {""TotalAcres"": {""description"": ""Total number of acres available for processing hay"", ""shape"": []}, ""NumMachines"": {""description"": ""Number of different machine types available for processing hay"", ""shape"": []}, ""FuelAvailable"": {""description"": ""Total amount of fuel available"", ""shape"": []}, ""MethaneLimit"": {""description"": ""Maximum allowable amount of methane gas production"", ""shape"": []}, ""HayProcessedPerAcre"": {""description"": ""Amount of hay processed per acre by each machine type"", ""shape"": [""NumMachines""]}, ""MethaneProducedPerAcre"": {""description"": ""Amount of methane gas produced per acre by each machine type"", ""shape"": [""NumMachines""]}, ""FuelRequiredPerAcre"": {""description"": ""Amount of fuel required per acre by each machine type"", ""shape"": [""NumMachines""]}}, ""variables"": {""AcresAllocated"": {""description"": ""The number of acres allocated to each machine type"", ""type"": ""continuous"", ""shape"": [""NumMachines""]}}, ""constraints"": [{""description"": ""The total number of acres allocated to all machine types cannot exceed TotalAcres."", ""formulation"": ""\\sum_{i=1}^{\\text{NumMachines}} \\text{AcresAllocated}_i \\leq \\text{TotalAcres}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(AcresAllocated[i] for i in range(NumMachines)) <= TotalAcres)""}}, {""description"": ""The total fuel required for processing, based on FuelRequiredPerAcre for each machine type, cannot exceed FuelAvailable."", ""formulation"": ""\\sum_{i=1}^{NumMachines} FuelRequiredPerAcre_i \\cdot AcresAllocated_i \\leq FuelAvailable"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(FuelRequiredPerAcre[i] * AcresAllocated[i] for i in range(NumMachines)) <= FuelAvailable)""}}, {""description"": ""The total methane produced, based on MethaneProducedPerAcre for each machine type, cannot exceed MethaneLimit."", ""formulation"": ""\\sum_{i=1}^{NumMachines} \\text{MethaneProducedPerAcre}_i \\cdot \\text{AcresAllocated}_i \\leq \\text{MethaneLimit}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(MethaneProducedPerAcre[i] * AcresAllocated[i] for i in range(NumMachines)) <= MethaneLimit)""}}], ""objective"": {""description"": ""Total hay processed is the sum of the hay processed per acre by each machine type. The objective is to maximize the total hay processed."", ""formulation"": ""Max \\sum_{i=1}^{\\text{NumMachines}} \\text{HayProcessedPerAcre}_i \\cdot \\text{AcresAllocated}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(HayProcessedPerAcre[i] * AcresAllocated[i] for i in range(NumMachines)), GRB.MAXIMIZE)""}}}","{""TotalAcres"": 200, ""NumMachines"": 2, ""FuelAvailable"": 300, ""MethaneLimit"": 800, ""HayProcessedPerAcre"": [10, 8], ""MethaneProducedPerAcre"": [5, 3], ""FuelRequiredPerAcre"": [2, 1]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A farmer has TotalAcres of land on which hay must be processed using NumMachines
different machine types. For each acre of land, machine type i can process
HayProcessedPerAcre[i] units of hay, produce MethaneProducedPerAcre[i] units of
methane gas, and require FuelRequiredPerAcre[i] units of fuel. The total fuel
available is FuelAvailable, and the total methane production must not exceed
MethaneLimit. The farmer aims to determine the number of acres to allocate to
each machine type to maximize the total amount of hay processed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/45/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalAcres @Def: Total number of acres available for processing hay @Shape: [] 
TotalAcres = data['TotalAcres']
# @Parameter NumMachines @Def: Number of different machine types available for processing hay @Shape: [] 
NumMachines = data['NumMachines']
# @Parameter FuelAvailable @Def: Total amount of fuel available @Shape: [] 
FuelAvailable = data['FuelAvailable']
# @Parameter MethaneLimit @Def: Maximum allowable amount of methane gas production @Shape: [] 
MethaneLimit = data['MethaneLimit']
# @Parameter HayProcessedPerAcre @Def: Amount of hay processed per acre by each machine type @Shape: ['NumMachines'] 
HayProcessedPerAcre = data['HayProcessedPerAcre']
# @Parameter MethaneProducedPerAcre @Def: Amount of methane gas produced per acre by each machine type @Shape: ['NumMachines'] 
MethaneProducedPerAcre = data['MethaneProducedPerAcre']
# @Parameter FuelRequiredPerAcre @Def: Amount of fuel required per acre by each machine type @Shape: ['NumMachines'] 
FuelRequiredPerAcre = data['FuelRequiredPerAcre']

# Variables 
# @Variable AcresAllocated @Def: The number of acres allocated to each machine type @Shape: ['NumMachines'] 
AcresAllocated = model.addVars(NumMachines, vtype=GRB.CONTINUOUS, name=""AcresAllocated"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of acres allocated to all machine types cannot exceed TotalAcres.
model.addConstr(quicksum(AcresAllocated[i] for i in range(NumMachines)) <= TotalAcres)
# @Constraint Constr_2 @Def: The total fuel required for processing, based on FuelRequiredPerAcre for each machine type, cannot exceed FuelAvailable.
model.addConstr(quicksum(FuelRequiredPerAcre[i] * AcresAllocated[i] for i in range(NumMachines)) <= FuelAvailable)
# @Constraint Constr_3 @Def: The total methane produced, based on MethaneProducedPerAcre for each machine type, cannot exceed MethaneLimit.
model.addConstr(quicksum(MethaneProducedPerAcre[i] * AcresAllocated[i] for i in range(NumMachines)) <= MethaneLimit)

# Objective 
# @Objective Objective @Def: Total hay processed is the sum of the hay processed per acre by each machine type. The objective is to maximize the total hay processed.
model.setObjective(quicksum(HayProcessedPerAcre[i] * AcresAllocated[i] for i in range(NumMachines)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['AcresAllocated'] = [AcresAllocated[i].x for i in range(NumMachines)]
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A new fast food place makes wraps and platters. Each wrap requires 5 units of meat and 3 units of rice. Each platter requires 7 units of meant and 5 units of rice. While each wrap takes 10 minutes to make, each platter takes 8 minutes to make. The fast food place must use at least 3000 units of meat and 2500 units of rice. Since wraps are easier to eat on the go, at least 3 times as many wraps need to be made as platter. How many of each should the fast food place make to minimize the total production time?","{""variables"": {""NumberOfWraps"": 535.7142857142857, ""NumberOfPlatters"": 178.57142857142856}, ""objective"": 6785.714285714285}","{""parametrized_description"": ""A fast food place produces wraps and platters. Each wrap requires MeatPerWrap units of meat and RicePerWrap units of rice, and takes TimePerWrap time to make. Each platter requires MeatPerPlatter units of meat and RicePerPlatter units of rice, and takes TimePerPlatter time to make. The production must use at least MinMeat units of meat and MinRice units of rice. Additionally, the number of wraps produced must be at least WrapPlatterRatio times the number of platters produced. The objective is to minimize the total production time."", ""keywords"": [""N.A.""], ""parameters"": {""MeatPerWrap"": {""description"": ""Amount of meat required to produce one wrap"", ""shape"": []}, ""RicePerWrap"": {""description"": ""Amount of rice required to produce one wrap"", ""shape"": []}, ""MeatPerPlatter"": {""description"": ""Amount of meat required to produce one platter"", ""shape"": []}, ""RicePerPlatter"": {""description"": ""Amount of rice required to produce one platter"", ""shape"": []}, ""TimePerWrap"": {""description"": ""Production time required to produce one wrap"", ""shape"": []}, ""TimePerPlatter"": {""description"": ""Production time required to produce one platter"", ""shape"": []}, ""MinMeat"": {""description"": ""Minimum required amount of meat"", ""shape"": []}, ""MinRice"": {""description"": ""Minimum required amount of rice"", ""shape"": []}, ""WrapPlatterRatio"": {""description"": ""Minimum ratio of wraps to platters"", ""shape"": []}}, ""variables"": {""NumberOfWraps"": {""description"": ""The number of wraps produced"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfPlatters"": {""description"": ""The number of platters produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total meat used, calculated as MeatPerWrap multiplied by the number of wraps plus MeatPerPlatter multiplied by the number of platters, must be at least MinMeat."", ""formulation"": ""MeatPerWrap \\cdot NumberOfWraps + MeatPerPlatter \\cdot NumberOfPlatters \\geq MinMeat"", ""code"": {""gurobipy"": ""model.addConstr(MeatPerWrap * NumberOfWraps + MeatPerPlatter * NumberOfPlatters >= MinMeat)""}}, {""description"": ""The total rice used, calculated as RicePerWrap multiplied by the number of wraps plus RicePerPlatter multiplied by the number of platters, must be at least MinRice."", ""formulation"": ""RicePerWrap \\cdot NumberOfWraps + RicePerPlatter \\cdot NumberOfPlatters \\geq MinRice"", ""code"": {""gurobipy"": ""model.addConstr(RicePerWrap * NumberOfWraps + RicePerPlatter * NumberOfPlatters >= MinRice)""}}, {""description"": ""The number of wraps produced must be at least WrapPlatterRatio times the number of platters produced."", ""formulation"": ""NumberOfWraps \\geq WrapPlatterRatio \\times NumberOfPlatters"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfWraps >= WrapPlatterRatio * NumberOfPlatters)""}}], ""objective"": {""description"": ""Total production time is TimePerWrap multiplied by the number of wraps plus TimePerPlatter multiplied by the number of platters. The objective is to minimize the total production time while meeting requirements for meat, rice, and product ratio."", ""formulation"": ""Min \\left( TimePerWrap \\times NumberOfWraps + TimePerPlatter \\times NumberOfPlatters \\right)"", ""code"": {""gurobipy"": ""model.setObjective(TimePerWrap * NumberOfWraps + TimePerPlatter * NumberOfPlatters, GRB.MINIMIZE)""}}}","{""MeatPerWrap"": 5, ""RicePerWrap"": 3, ""MeatPerPlatter"": 7, ""RicePerPlatter"": 5, ""TimePerWrap"": 10, ""TimePerPlatter"": 8, ""MinMeat"": 3000, ""MinRice"": 2500, ""WrapPlatterRatio"": 3}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A fast food place produces wraps and platters. Each wrap requires MeatPerWrap
units of meat and RicePerWrap units of rice, and takes TimePerWrap time to make.
Each platter requires MeatPerPlatter units of meat and RicePerPlatter units of
rice, and takes TimePerPlatter time to make. The production must use at least
MinMeat units of meat and MinRice units of rice. Additionally, the number of
wraps produced must be at least WrapPlatterRatio times the number of platters
produced. The objective is to minimize the total production time.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/46/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MeatPerWrap @Def: Amount of meat required to produce one wrap @Shape: [] 
MeatPerWrap = data['MeatPerWrap']
# @Parameter RicePerWrap @Def: Amount of rice required to produce one wrap @Shape: [] 
RicePerWrap = data['RicePerWrap']
# @Parameter MeatPerPlatter @Def: Amount of meat required to produce one platter @Shape: [] 
MeatPerPlatter = data['MeatPerPlatter']
# @Parameter RicePerPlatter @Def: Amount of rice required to produce one platter @Shape: [] 
RicePerPlatter = data['RicePerPlatter']
# @Parameter TimePerWrap @Def: Production time required to produce one wrap @Shape: [] 
TimePerWrap = data['TimePerWrap']
# @Parameter TimePerPlatter @Def: Production time required to produce one platter @Shape: [] 
TimePerPlatter = data['TimePerPlatter']
# @Parameter MinMeat @Def: Minimum required amount of meat @Shape: [] 
MinMeat = data['MinMeat']
# @Parameter MinRice @Def: Minimum required amount of rice @Shape: [] 
MinRice = data['MinRice']
# @Parameter WrapPlatterRatio @Def: Minimum ratio of wraps to platters @Shape: [] 
WrapPlatterRatio = data['WrapPlatterRatio']

# Variables 
# @Variable NumberOfWraps @Def: The number of wraps produced @Shape: [] 
NumberOfWraps = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfWraps"")
# @Variable NumberOfPlatters @Def: The number of platters produced @Shape: [] 
NumberOfPlatters = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfPlatters"")

# Constraints 
# @Constraint Constr_1 @Def: The total meat used, calculated as MeatPerWrap multiplied by the number of wraps plus MeatPerPlatter multiplied by the number of platters, must be at least MinMeat.
model.addConstr(MeatPerWrap * NumberOfWraps + MeatPerPlatter * NumberOfPlatters >= MinMeat)
# @Constraint Constr_2 @Def: The total rice used, calculated as RicePerWrap multiplied by the number of wraps plus RicePerPlatter multiplied by the number of platters, must be at least MinRice.
model.addConstr(RicePerWrap * NumberOfWraps + RicePerPlatter * NumberOfPlatters >= MinRice)
# @Constraint Constr_3 @Def: The number of wraps produced must be at least WrapPlatterRatio times the number of platters produced.
model.addConstr(NumberOfWraps >= WrapPlatterRatio * NumberOfPlatters)

# Objective 
# @Objective Objective @Def: Total production time is TimePerWrap multiplied by the number of wraps plus TimePerPlatter multiplied by the number of platters. The objective is to minimize the total production time while meeting requirements for meat, rice, and product ratio.
model.setObjective(TimePerWrap * NumberOfWraps + TimePerPlatter * NumberOfPlatters, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfWraps'] = NumberOfWraps.x
variables['NumberOfPlatters'] = NumberOfPlatters.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An amusement park is installing ticket machines, both cash-based and card-only machines. A cash-based machine can process 20 people per hour while a card-only machine can process 30 people per hour. The cash-based machine needs 4 rolls of paper per hour while the card-only machine requires 5 rolls of paper per hour. The amusement park needs to be able to process at least 500 people per hour but can use at most 90 rolls of paper per hour. Since most people prefer to pay by cash, the number of card-only machines must not exceed the number of cash-based machines. How many of each machine should be bought to minimize the total number of machines in the park?","{""variables"": {""NumCashMachines"": 10.0, ""NumCardMachines"": 10.0}, ""objective"": 20.0}","{""parametrized_description"": ""An amusement park is installing cash-based machines and card-only machines. A cash-based machine can process CashMachineProcessingRate people per hour, while a card-only machine can process CardMachineProcessingRate people per hour. The cash-based machine needs CashMachinePaperRolls rolls of paper per hour, while the card-only machine requires CardMachinePaperRolls rolls of paper per hour. The amusement park needs to be able to process at least MinPeopleProcessed people per hour but can use at most MaxPaperRolls paper rolls per hour. Additionally, the number of card-only machines must not exceed the number of cash-based machines. The objective is to minimize the total number of machines in the park."", ""keywords"": [""N.A.""], ""parameters"": {""CashMachineProcessingRate"": {""description"": ""Processing rate of a cash-based machine in people per hour"", ""shape"": []}, ""CardMachineProcessingRate"": {""description"": ""Processing rate of a card-only machine in people per hour"", ""shape"": []}, ""CashMachinePaperRolls"": {""description"": ""Number of paper rolls used per hour by a cash-based machine"", ""shape"": []}, ""CardMachinePaperRolls"": {""description"": ""Number of paper rolls used per hour by a card-only machine"", ""shape"": []}, ""MinPeopleProcessed"": {""description"": ""Minimum number of people that must be processed per hour"", ""shape"": []}, ""MaxPaperRolls"": {""description"": ""Maximum number of paper rolls that can be used per hour"", ""shape"": []}}, ""variables"": {""NumCashMachines"": {""description"": ""The number of cash-based machines"", ""type"": ""continuous"", ""shape"": []}, ""NumCardMachines"": {""description"": ""The number of card-only machines"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of people processed per hour by cash-based and card-only machines must be at least MinPeopleProcessed."", ""formulation"": ""CashMachineProcessingRate \\cdot NumCashMachines + CardMachineProcessingRate \\cdot NumCardMachines \\geq MinPeopleProcessed"", ""code"": {""gurobipy"": ""model.addConstr(CashMachineProcessingRate * NumCashMachines + CardMachineProcessingRate * NumCardMachines >= MinPeopleProcessed)""}}, {""description"": ""The total number of paper rolls used per hour by cash-based and card-only machines must not exceed MaxPaperRolls."", ""formulation"": ""NumCashMachines \\times CashMachinePaperRolls + NumCardMachines \\times CardMachinePaperRolls \\leq MaxPaperRolls"", ""code"": {""gurobipy"": ""model.addConstr(NumCashMachines * CashMachinePaperRolls + NumCardMachines * CardMachinePaperRolls <= MaxPaperRolls)""}}, {""description"": ""The number of card-only machines must not exceed the number of cash-based machines."", ""formulation"": ""NumCardMachines \\leq NumCashMachines"", ""code"": {""gurobipy"": ""model.addConstr(NumCardMachines <= NumCashMachines)""}}], ""objective"": {""description"": ""Minimize the total number of machines in the park."", ""formulation"": ""Min \\ NumCashMachines + NumCardMachines"", ""code"": {""gurobipy"": ""model.setObjective(NumCashMachines + NumCardMachines, GRB.MINIMIZE)""}}}","{""CashMachineProcessingRate"": 20, ""CardMachineProcessingRate"": 30, ""CashMachinePaperRolls"": 4, ""CardMachinePaperRolls"": 5, ""MinPeopleProcessed"": 500, ""MaxPaperRolls"": 90}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
An amusement park is installing cash-based machines and card-only machines. A
cash-based machine can process CashMachineProcessingRate people per hour, while
a card-only machine can process CardMachineProcessingRate people per hour. The
cash-based machine needs CashMachinePaperRolls rolls of paper per hour, while
the card-only machine requires CardMachinePaperRolls rolls of paper per hour.
The amusement park needs to be able to process at least MinPeopleProcessed
people per hour but can use at most MaxPaperRolls paper rolls per hour.
Additionally, the number of card-only machines must not exceed the number of
cash-based machines. The objective is to minimize the total number of machines
in the park.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/47/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CashMachineProcessingRate @Def: Processing rate of a cash-based machine in people per hour @Shape: [] 
CashMachineProcessingRate = data['CashMachineProcessingRate']
# @Parameter CardMachineProcessingRate @Def: Processing rate of a card-only machine in people per hour @Shape: [] 
CardMachineProcessingRate = data['CardMachineProcessingRate']
# @Parameter CashMachinePaperRolls @Def: Number of paper rolls used per hour by a cash-based machine @Shape: [] 
CashMachinePaperRolls = data['CashMachinePaperRolls']
# @Parameter CardMachinePaperRolls @Def: Number of paper rolls used per hour by a card-only machine @Shape: [] 
CardMachinePaperRolls = data['CardMachinePaperRolls']
# @Parameter MinPeopleProcessed @Def: Minimum number of people that must be processed per hour @Shape: [] 
MinPeopleProcessed = data['MinPeopleProcessed']
# @Parameter MaxPaperRolls @Def: Maximum number of paper rolls that can be used per hour @Shape: [] 
MaxPaperRolls = data['MaxPaperRolls']

# Variables 
# @Variable NumCashMachines @Def: The number of cash-based machines @Shape: [] 
NumCashMachines = model.addVar(vtype=GRB.INTEGER, name=""NumCashMachines"")
# @Variable NumCardMachines @Def: The number of card-only machines @Shape: [] 
NumCardMachines = model.addVar(vtype=GRB.INTEGER, name=""NumCardMachines"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of people processed per hour by cash-based and card-only machines must be at least MinPeopleProcessed.
model.addConstr(CashMachineProcessingRate * NumCashMachines + CardMachineProcessingRate * NumCardMachines >= MinPeopleProcessed)
# @Constraint Constr_2 @Def: The total number of paper rolls used per hour by cash-based and card-only machines must not exceed MaxPaperRolls.
model.addConstr(NumCashMachines * CashMachinePaperRolls + NumCardMachines * CardMachinePaperRolls <= MaxPaperRolls)
# @Constraint Constr_3 @Def: The number of card-only machines must not exceed the number of cash-based machines.
model.addConstr(NumCardMachines <= NumCashMachines)

# Objective 
# @Objective Objective @Def: Minimize the total number of machines in the park.
model.setObjective(NumCashMachines + NumCardMachines, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumCashMachines'] = NumCashMachines.x
variables['NumCardMachines'] = NumCardMachines.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A honey farmer sells his honey in glass and plastic jars. A glass jar can hold 250 ml of honey while a plastic jar can hold 300 ml of honey. Since glass jars are more expensive, at least twice as many plastic jars must be filled as glass jars. However, at least 20 glass jars should be filled. If the farmer has 20000 ml of honey, how many jars of each should be filled to maximize the total number of bottles filled?","{""variables"": {""GlassJarsFilled"": 20.0, ""PlasticJarsFilled"": 50.0}, ""objective"": 70.0}","{""parametrized_description"": ""A honey farmer sells his honey in glass and plastic jars. A glass jar can hold GlassJarCapacity of honey while a plastic jar can hold PlasticJarCapacity of honey. Since glass jars are more expensive, at least MinPlasticToGlassRatio as many plastic jars must be filled as glass jars. However, at least MinNumberGlassJars glass jars should be filled. If the farmer has TotalHoney of honey, how many jars of each should be filled to maximize the total number of bottles filled?"", ""keywords"": [""N.A.""], ""parameters"": {""GlassJarCapacity"": {""description"": ""The capacity of a glass jar in milliliters"", ""shape"": []}, ""PlasticJarCapacity"": {""description"": ""The capacity of a plastic jar in milliliters"", ""shape"": []}, ""MinPlasticToGlassRatio"": {""description"": ""The minimum ratio of plastic jars to glass jars that must be filled"", ""shape"": []}, ""MinNumberGlassJars"": {""description"": ""The minimum number of glass jars that must be filled"", ""shape"": []}, ""TotalHoney"": {""description"": ""Total amount of honey available in milliliters"", ""shape"": []}}, ""variables"": {""GlassJarsFilled"": {""description"": ""The number of glass jars that are filled"", ""type"": ""continuous"", ""shape"": []}, ""PlasticJarsFilled"": {""description"": ""The number of plastic jars filled"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""At least MinNumberGlassJars glass jars must be filled."", ""formulation"": ""GlassJarsFilled \\geq MinNumberGlassJars"", ""code"": {""gurobipy"": ""model.addConstr(GlassJarsFilled >= MinNumberGlassJars)""}}, {""description"": ""The number of plastic jars filled must be at least MinPlasticToGlassRatio times the number of glass jars filled."", ""formulation"": ""PlasticJarsFilled \\geq MinPlasticToGlassRatio \\times GlassJarsFilled"", ""code"": {""gurobipy"": ""model.addConstr(PlasticJarsFilled >= MinPlasticToGlassRatio * GlassJarsFilled)""}}, {""description"": ""The total amount of honey used by the filled jars cannot exceed TotalHoney."", ""formulation"": ""GlassJarsFilled \\times GlassJarCapacity + PlasticJarsFilled \\times PlasticJarCapacity \\leq TotalHoney"", ""code"": {""gurobipy"": ""model.addConstr(GlassJarCapacity * GlassJarsFilled + PlasticJarCapacity * PlasticJarsFilled <= TotalHoney)""}}], ""objective"": {""description"": ""The total number of jars filled is the sum of glass jars and plastic jars. The objective is to maximize the total number of jars filled."", ""formulation"": ""Max \\ GlassJarsFilled + PlasticJarsFilled"", ""code"": {""gurobipy"": ""model.setObjective(GlassJarsFilled + PlasticJarsFilled, GRB.MAXIMIZE)""}}}","{""GlassJarCapacity"": 250, ""PlasticJarCapacity"": 300, ""MinPlasticToGlassRatio"": 2, ""MinNumberGlassJars"": 20, ""TotalHoney"": 20000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A honey farmer sells his honey in glass and plastic jars. A glass jar can hold
GlassJarCapacity of honey while a plastic jar can hold PlasticJarCapacity of
honey. Since glass jars are more expensive, at least MinPlasticToGlassRatio as
many plastic jars must be filled as glass jars. However, at least
MinNumberGlassJars glass jars should be filled. If the farmer has TotalHoney of
honey, how many jars of each should be filled to maximize the total number of
bottles filled?
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/48/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter GlassJarCapacity @Def: The capacity of a glass jar in milliliters @Shape: [] 
GlassJarCapacity = data['GlassJarCapacity']
# @Parameter PlasticJarCapacity @Def: The capacity of a plastic jar in milliliters @Shape: [] 
PlasticJarCapacity = data['PlasticJarCapacity']
# @Parameter MinPlasticToGlassRatio @Def: The minimum ratio of plastic jars to glass jars that must be filled @Shape: [] 
MinPlasticToGlassRatio = data['MinPlasticToGlassRatio']
# @Parameter MinNumberGlassJars @Def: The minimum number of glass jars that must be filled @Shape: [] 
MinNumberGlassJars = data['MinNumberGlassJars']
# @Parameter TotalHoney @Def: Total amount of honey available in milliliters @Shape: [] 
TotalHoney = data['TotalHoney']

# Variables 
# @Variable GlassJarsFilled @Def: The number of glass jars that are filled @Shape: [] 
GlassJarsFilled = model.addVar(vtype=GRB.INTEGER, name=""GlassJarsFilled"")
# @Variable PlasticJarsFilled @Def: The number of plastic jars filled @Shape: [] 
PlasticJarsFilled = model.addVar(vtype=GRB.INTEGER, name='PlasticJarsFilled')

# Constraints 
# @Constraint Constr_1 @Def: At least MinNumberGlassJars glass jars must be filled.
model.addConstr(GlassJarsFilled >= MinNumberGlassJars)
# @Constraint Constr_2 @Def: The number of plastic jars filled must be at least MinPlasticToGlassRatio times the number of glass jars filled.
model.addConstr(PlasticJarsFilled >= MinPlasticToGlassRatio * GlassJarsFilled)
# @Constraint Constr_3 @Def: The total amount of honey used by the filled jars cannot exceed TotalHoney.
model.addConstr(GlassJarCapacity * GlassJarsFilled + PlasticJarCapacity * PlasticJarsFilled <= TotalHoney)

# Objective 
# @Objective Objective @Def: The total number of jars filled is the sum of glass jars and plastic jars. The objective is to maximize the total number of jars filled.
model.setObjective(GlassJarsFilled + PlasticJarsFilled, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['GlassJarsFilled'] = GlassJarsFilled.x
variables['PlasticJarsFilled'] = PlasticJarsFilled.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A bubble tea shop sells mango and lychee bubble tea. Each mango bubble tea requires 4 units of mango juice and 8 units of tea. Each lychee bubble tea requires 6 units of lychee juice and 6 units of tea. The shop has available 2000 units of mango juice and 3000 units of lychee juice. At least 40% of the bubble teas made must be lychee flavored. However, mango bubble tea sells better and thus the number of mango bubble teas made must be large than the number of lychee bubble teas made. How many of each bubble tea flavor should be made to minimize the total amount of tea needed?","{""variables"": {""NumberOfMangoBubbleTeas"": 0.0, ""NumberOfLycheeBubbleTeas"": 0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A bubble tea shop produces two types of bubble teas: mango and lychee. Each mango bubble tea requires MangoJuicePerMangoTea units of mango juice and TeaPerMangoTea units of tea. Each lychee bubble tea requires LycheeJuicePerLycheeTea units of lychee juice and TeaPerLycheeTea units of tea. The shop has a total of TotalMangoJuice units of mango juice and TotalLycheeJuice units of lychee juice available. At least MinLycheePercentage of the total bubble teas produced must be lychee flavored. Additionally, the number of mango bubble teas produced must be greater than the number of lychee bubble teas. The objective is to determine the number of mango and lychee bubble teas to produce in order to minimize the total amount of tea used."", ""keywords"": [""N.A.""], ""parameters"": {""MangoJuicePerMangoTea"": {""description"": ""Units of mango juice required to make one mango bubble tea"", ""shape"": []}, ""LycheeJuicePerLycheeTea"": {""description"": ""Units of lychee juice required to make one lychee bubble tea"", ""shape"": []}, ""TeaPerMangoTea"": {""description"": ""Units of tea required to make one mango bubble tea"", ""shape"": []}, ""TeaPerLycheeTea"": {""description"": ""Units of tea required to make one lychee bubble tea"", ""shape"": []}, ""TotalMangoJuice"": {""description"": ""Total units of mango juice available"", ""shape"": []}, ""TotalLycheeJuice"": {""description"": ""Total units of lychee juice available"", ""shape"": []}, ""MinLycheePercentage"": {""description"": ""Minimum percentage of total bubble teas that must be lychee flavored"", ""shape"": []}}, ""variables"": {""NumberOfMangoBubbleTeas"": {""description"": ""The number of mango bubble teas produced"", ""type"": ""continuous"", ""shape"": [""Non-negative""]}, ""NumberOfLycheeBubbleTeas"": {""description"": ""The number of lychee bubble teas produced"", ""type"": ""continuous"", ""shape"": [""Non-negative""]}}, ""constraints"": [{""description"": ""The total amount of mango juice used for mango bubble teas cannot exceed TotalMangoJuice units. This is calculated as MangoJuicePerMangoTea multiplied by the number of mango bubble teas produced."", ""formulation"": ""MangoJuicePerMangoTea \\times NumberOfMangoBubbleTeas \\leq TotalMangoJuice"", ""code"": {""gurobipy"": ""model.addConstr(MangoJuicePerMangoTea * NumberOfMangoBubbleTeas <= TotalMangoJuice)""}}, {""description"": ""The total amount of lychee juice used for lychee bubble teas cannot exceed TotalLycheeJuice units. This is calculated as LycheeJuicePerLycheeTea multiplied by the number of lychee bubble teas produced."", ""formulation"": ""LycheeJuicePerLycheeTea \\times NumberOfLycheeBubbleTeas \\leq TotalLycheeJuice"", ""code"": {""gurobipy"": ""model.addConstr(LycheeJuicePerLycheeTea * NumberOfLycheeBubbleTeas <= TotalLycheeJuice)""}}, {""description"": ""At least MinLycheePercentage of the total bubble teas produced must be lychee flavored. This means that the number of lychee bubble teas divided by the total number of bubble teas (mango and lychee) must be greater than or equal to MinLycheePercentage."", ""formulation"": ""(1 - MinLycheePercentage) \\cdot NumberOfLycheeBubbleTeas \\geq MinLycheePercentage \\cdot NumberOfMangoBubbleTeas"", ""code"": {""gurobipy"": ""model.addConstr((1 - MinLycheePercentage) * NumberOfLycheeBubbleTeas >= MinLycheePercentage * NumberOfMangoBubbleTeas)""}}, {""description"": ""The number of mango bubble teas produced must be greater than the number of lychee bubble teas produced."", ""formulation"": ""NumberOfMangoBubbleTeas \\geq NumberOfLycheeBubbleTeas"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfMangoBubbleTeas >= NumberOfLycheeBubbleTeas)""}}], ""objective"": {""description"": ""Minimize the total amount of tea used, which is the sum of TeaPerMangoTea units for each mango bubble tea produced and TeaPerLycheeTea units for each lychee bubble tea produced."", ""formulation"": ""Min \\, TeaPerMangoTea \\times NumberOfMangoBubbleTeas + TeaPerLycheeTea \\times NumberOfLycheeBubbleTeas"", ""code"": {""gurobipy"": ""model.setObjective(TeaPerMangoTea * NumberOfMangoBubbleTeas + TeaPerLycheeTea * NumberOfLycheeBubbleTeas, GRB.MINIMIZE)""}}}","{""MangoJuicePerMangoTea"": 4, ""LycheeJuicePerLycheeTea"": 6, ""TeaPerMangoTea"": 8, ""TeaPerLycheeTea"": 6, ""TotalMangoJuice"": 2000, ""TotalLycheeJuice"": 3000, ""MinLycheePercentage"": 40}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A bubble tea shop produces two types of bubble teas: mango and lychee. Each
mango bubble tea requires MangoJuicePerMangoTea units of mango juice and
TeaPerMangoTea units of tea. Each lychee bubble tea requires
LycheeJuicePerLycheeTea units of lychee juice and TeaPerLycheeTea units of tea.
The shop has a total of TotalMangoJuice units of mango juice and
TotalLycheeJuice units of lychee juice available. At least MinLycheePercentage
of the total bubble teas produced must be lychee flavored. Additionally, the
number of mango bubble teas produced must be greater than the number of lychee
bubble teas. The objective is to determine the number of mango and lychee bubble
teas to produce in order to minimize the total amount of tea used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/49/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MangoJuicePerMangoTea @Def: Units of mango juice required to make one mango bubble tea @Shape: [] 
MangoJuicePerMangoTea = data['MangoJuicePerMangoTea']
# @Parameter LycheeJuicePerLycheeTea @Def: Units of lychee juice required to make one lychee bubble tea @Shape: [] 
LycheeJuicePerLycheeTea = data['LycheeJuicePerLycheeTea']
# @Parameter TeaPerMangoTea @Def: Units of tea required to make one mango bubble tea @Shape: [] 
TeaPerMangoTea = data['TeaPerMangoTea']
# @Parameter TeaPerLycheeTea @Def: Units of tea required to make one lychee bubble tea @Shape: [] 
TeaPerLycheeTea = data['TeaPerLycheeTea']
# @Parameter TotalMangoJuice @Def: Total units of mango juice available @Shape: [] 
TotalMangoJuice = data['TotalMangoJuice']
# @Parameter TotalLycheeJuice @Def: Total units of lychee juice available @Shape: [] 
TotalLycheeJuice = data['TotalLycheeJuice']
# @Parameter MinLycheePercentage @Def: Minimum percentage of total bubble teas that must be lychee flavored @Shape: [] 
MinLycheePercentage = data['MinLycheePercentage']

# Variables 
# @Variable NumberOfMangoBubbleTeas @Def: The number of mango bubble teas produced @Shape: ['Non-negative'] 
NumberOfMangoBubbleTeas = model.addVar(vtype=GRB.CONTINUOUS, lb=0, name=""NumberOfMangoBubbleTeas"")
# @Variable NumberOfLycheeBubbleTeas @Def: The number of lychee bubble teas produced @Shape: ['Non-negative'] 
NumberOfLycheeBubbleTeas = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfLycheeBubbleTeas"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of mango juice used for mango bubble teas cannot exceed TotalMangoJuice units. This is calculated as MangoJuicePerMangoTea multiplied by the number of mango bubble teas produced.
model.addConstr(MangoJuicePerMangoTea * NumberOfMangoBubbleTeas <= TotalMangoJuice)
# @Constraint Constr_2 @Def: The total amount of lychee juice used for lychee bubble teas cannot exceed TotalLycheeJuice units. This is calculated as LycheeJuicePerLycheeTea multiplied by the number of lychee bubble teas produced.
model.addConstr(LycheeJuicePerLycheeTea * NumberOfLycheeBubbleTeas <= TotalLycheeJuice)
# @Constraint Constr_3 @Def: At least MinLycheePercentage of the total bubble teas produced must be lychee flavored. This means that the number of lychee bubble teas divided by the total number of bubble teas (mango and lychee) must be greater than or equal to MinLycheePercentage.
model.addConstr((1 - MinLycheePercentage) * NumberOfLycheeBubbleTeas >= MinLycheePercentage * NumberOfMangoBubbleTeas)
# @Constraint Constr_4 @Def: The number of mango bubble teas produced must be greater than the number of lychee bubble teas produced.
model.addConstr(NumberOfMangoBubbleTeas >= NumberOfLycheeBubbleTeas)

# Objective 
# @Objective Objective @Def: Minimize the total amount of tea used, which is the sum of TeaPerMangoTea units for each mango bubble tea produced and TeaPerLycheeTea units for each lychee bubble tea produced.
model.setObjective(TeaPerMangoTea * NumberOfMangoBubbleTeas + TeaPerLycheeTea * NumberOfLycheeBubbleTeas, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfMangoBubbleTeas'] = NumberOfMangoBubbleTeas.x
variables['NumberOfLycheeBubbleTeas'] = NumberOfLycheeBubbleTeas.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A city employs seasonal and permanent snow removers. A seasonal snow remover works 6 hours per shift and gets paid $120. A permanent snow remover works 10 hours per shift and gets paid $250. Currently the city needs 300 hours of snow remover labor after a heavy snowfall. If the city has a budget of $6500, how many of each type of worker should be hired to minimize the total number of snow removers?","{""variables"": {""NumberSeasonal"": 35.0, ""NumberPermanent"": 9.0}, ""objective"": 44.0}","{""parametrized_description"": ""A city employs seasonal and permanent snow removers. A seasonal snow remover works HoursSeasonal hours per shift and gets paid PaymentSeasonal. A permanent snow remover works HoursPermanent hours per shift and gets paid PaymentPermanent. Currently the city needs RequiredLaborHours hours of snow remover labor after a heavy snowfall. If the city has a budget of TotalBudget, how many of each type of worker should be hired to minimize the total number of snow removers?"", ""keywords"": [""N.A.""], ""parameters"": {""HoursSeasonal"": {""description"": ""Number of hours per shift for a seasonal snow remover"", ""shape"": []}, ""PaymentSeasonal"": {""description"": ""Payment per shift for a seasonal snow remover"", ""shape"": []}, ""HoursPermanent"": {""description"": ""Number of hours per shift for a permanent snow remover"", ""shape"": []}, ""PaymentPermanent"": {""description"": ""Payment per shift for a permanent snow remover"", ""shape"": []}, ""RequiredLaborHours"": {""description"": ""Total required labor hours after a heavy snowfall"", ""shape"": []}, ""TotalBudget"": {""description"": ""Total budget available for hiring snow removers"", ""shape"": []}}, ""variables"": {""NumberSeasonal"": {""description"": ""The number of seasonal snow removers hired"", ""type"": ""continuous"", ""shape"": [""NonNegative Integer""]}, ""NumberPermanent"": {""description"": ""The number of permanent snow removers hired"", ""type"": ""continuous"", ""shape"": [""NonNegative Integer""]}}, ""constraints"": [{""description"": ""The total labor hours provided by seasonal and permanent snow removers must meet or exceed RequiredLaborHours."", ""formulation"": ""HoursSeasonal \\times NumberSeasonal + HoursPermanent \\times NumberPermanent \\geq RequiredLaborHours"", ""code"": {""gurobipy"": ""model.addConstr(HoursSeasonal * NumberSeasonal + HoursPermanent * NumberPermanent >= RequiredLaborHours)""}}, {""description"": ""The total payment for seasonal and permanent snow removers must not exceed TotalBudget."", ""formulation"": ""NumberSeasonal \\times PaymentSeasonal + NumberPermanent \\times PaymentPermanent \\leq TotalBudget"", ""code"": {""gurobipy"": ""model.addConstr(NumberSeasonal * PaymentSeasonal + NumberPermanent * PaymentPermanent <= TotalBudget)""}}], ""objective"": {""description"": ""The objective is to minimize the total number of snow removers, which is the sum of seasonal and permanent snow removers hired."", ""formulation"": ""Min \\left( NumberSeasonal + NumberPermanent \\right )"", ""code"": {""gurobipy"": ""model.setObjective(quicksum([NumberSeasonal, NumberPermanent]), GRB.MINIMIZE)""}}}","{""HoursSeasonal"": 6, ""PaymentSeasonal"": 120, ""HoursPermanent"": 10, ""PaymentPermanent"": 250, ""RequiredLaborHours"": 300, ""TotalBudget"": 6500}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A city employs seasonal and permanent snow removers. A seasonal snow remover
works HoursSeasonal hours per shift and gets paid PaymentSeasonal. A permanent
snow remover works HoursPermanent hours per shift and gets paid
PaymentPermanent. Currently the city needs RequiredLaborHours hours of snow
remover labor after a heavy snowfall. If the city has a budget of TotalBudget,
how many of each type of worker should be hired to minimize the total number of
snow removers?
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/50/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter HoursSeasonal @Def: Number of hours per shift for a seasonal snow remover @Shape: [] 
HoursSeasonal = data['HoursSeasonal']
# @Parameter PaymentSeasonal @Def: Payment per shift for a seasonal snow remover @Shape: [] 
PaymentSeasonal = data['PaymentSeasonal']
# @Parameter HoursPermanent @Def: Number of hours per shift for a permanent snow remover @Shape: [] 
HoursPermanent = data['HoursPermanent']
# @Parameter PaymentPermanent @Def: Payment per shift for a permanent snow remover @Shape: [] 
PaymentPermanent = data['PaymentPermanent']
# @Parameter RequiredLaborHours @Def: Total required labor hours after a heavy snowfall @Shape: [] 
RequiredLaborHours = data['RequiredLaborHours']
# @Parameter TotalBudget @Def: Total budget available for hiring snow removers @Shape: [] 
TotalBudget = data['TotalBudget']

# Variables 
# @Variable NumberSeasonal @Def: The number of seasonal snow removers hired @Shape: ['NonNegative Integer'] 
NumberSeasonal = model.addVar(vtype=GRB.INTEGER, name=""NumberSeasonal"")
# @Variable NumberPermanent @Def: The number of permanent snow removers hired @Shape: ['NonNegative Integer'] 
NumberPermanent = model.addVar(vtype=GRB.INTEGER, name=""NumberPermanent"")

# Constraints 
# @Constraint Constr_1 @Def: The total labor hours provided by seasonal and permanent snow removers must meet or exceed RequiredLaborHours.
model.addConstr(HoursSeasonal * NumberSeasonal + HoursPermanent * NumberPermanent >= RequiredLaborHours)
# @Constraint Constr_2 @Def: The total payment for seasonal and permanent snow removers must not exceed TotalBudget.
model.addConstr(NumberSeasonal * PaymentSeasonal + NumberPermanent * PaymentPermanent <= TotalBudget)

# Objective 
# @Objective Objective @Def: The objective is to minimize the total number of snow removers, which is the sum of seasonal and permanent snow removers hired.
model.setObjective(quicksum([NumberSeasonal, NumberPermanent]), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberSeasonal'] = NumberSeasonal.x
variables['NumberPermanent'] = NumberPermanent.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A high rise building is buying two types of furnaces, a new model and an old model. A new model furnace can heat 10 apartments and consumes 200 kWh per day. An old model can heat 15 apartments and consumes 250 kWh per day. Since the old model is harder to find, at most 35% of the furnaces can be the old model and at least 5 new model furnaces should be used. If the high rise needs to heat at least 200 apartments and has 3500 kWh of electricity available, how many of each furnace should be purchase to minimize the total number of furnaces?",{},{},"{""HeatingCapacityNew"": 10, ""EnergyConsumptionNew"": 200, ""HeatingCapacityOld"": 15, ""EnergyConsumptionOld"": 250, ""MaxFractionOld"": 0.35, ""MinNewFurnaces"": 5, ""MinHeatingRequirement"": 200, ""AvailableEnergy"": 3500}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A high rise building is purchasing new model furnaces and old model furnaces.
Each new model furnace can heat HeatingCapacityNew apartments and consumes
EnergyConsumptionNew kWh per day. Each old model furnace can heat
HeatingCapacityOld apartments and consumes EnergyConsumptionOld kWh per day. At
most MaxFractionOld fraction of the furnaces can be old model furnaces and at
least MinNewFurnaces new model furnaces must be used. The building needs to heat
at least MinHeatingRequirement apartments and has AvailableEnergy kWh of
electricity available. Determine the number of each type of furnace to purchase
to minimize the total number of furnaces.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/51/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter HeatingCapacityNew @Def: Heating capacity of a new model furnace in the number of apartments heated per furnace @Shape: [] 
HeatingCapacityNew = data['HeatingCapacityNew']
# @Parameter EnergyConsumptionNew @Def: Energy consumption of a new model furnace in kWh per day @Shape: [] 
EnergyConsumptionNew = data['EnergyConsumptionNew']
# @Parameter HeatingCapacityOld @Def: Heating capacity of an old model furnace in the number of apartments heated per furnace @Shape: [] 
HeatingCapacityOld = data['HeatingCapacityOld']
# @Parameter EnergyConsumptionOld @Def: Energy consumption of an old model furnace in kWh per day @Shape: [] 
EnergyConsumptionOld = data['EnergyConsumptionOld']
# @Parameter MaxFractionOld @Def: Maximum fraction of furnaces that can be the old model @Shape: [] 
MaxFractionOld = data['MaxFractionOld']
# @Parameter MinNewFurnaces @Def: Minimum number of new model furnaces that must be used @Shape: [] 
MinNewFurnaces = data['MinNewFurnaces']
# @Parameter MinHeatingRequirement @Def: Minimum number of apartments that need to be heated @Shape: [] 
MinHeatingRequirement = data['MinHeatingRequirement']
# @Parameter AvailableEnergy @Def: Total available electricity in kWh @Shape: [] 
AvailableEnergy = data['AvailableEnergy']

# Variables 
# @Variable NumberOldFurnaces @Def: The number of old model furnaces @Shape: ['Integer'] 
NumberOldFurnaces = model.addVar(vtype=GRB.INTEGER, name=""NumberOldFurnaces"")
# @Variable NumberNewFurnaces @Def: The number of new model furnaces @Shape: ['Integer'] 
NumberNewFurnaces = model.addVar(vtype=GRB.INTEGER, name=""NumberNewFurnaces"")

# Constraints 
# @Constraint Constr_1 @Def: The number of old model furnaces does not exceed MaxFractionOld fraction of the total furnaces.
model.addConstr(NumberOldFurnaces <= MaxFractionOld * (NumberOldFurnaces + NumberNewFurnaces))
# @Constraint Constr_2 @Def: At least MinNewFurnaces new model furnaces must be used.
model.addConstr(NumberNewFurnaces >= MinNewFurnaces)
# @Constraint Constr_3 @Def: The total heating capacity must be at least MinHeatingRequirement apartments.
model.addConstr(HeatingCapacityOld * NumberOldFurnaces + HeatingCapacityNew * NumberNewFurnaces >= MinHeatingRequirement)
# @Constraint Constr_4 @Def: The total energy consumption must not exceed AvailableEnergy kWh.
model.addConstr(EnergyConsumptionOld * NumberOldFurnaces + EnergyConsumptionNew * NumberNewFurnaces <= AvailableEnergy)

# Objective 
# @Objective Objective @Def: Minimize the total number of furnaces.
model.setObjective(NumberOldFurnaces + NumberNewFurnaces, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOldFurnaces'] = NumberOldFurnaces.x
variables['NumberNewFurnaces'] = NumberNewFurnaces.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
A cell phone company is building rural and urban factories. A rural factory can make 100 phones per day and requires 8 managers. An urban factory can make 200 phones per day and requires 20 managers. The company has available 260 managers and must make at least 3000 phones per day. How many of each factory type should be built to minimize the total number of factories?,"{""variables"": {""FactoriesBuilt"": {""0"": 20.0, ""1"": 5.0}}, ""objective"": 25.0}","{""parametrized_description"": ""A company is building NumFactoryTypes different factory types. Each factory type i produces ProductionRate[i] phones per day and requires ManagerRequirement[i] managers. The company has AvailableManagers managers available and must produce at least RequiredPhones phones per day. Determine the number of each factory type to build to minimize the total number of factories."", ""keywords"": [""N.A.""], ""parameters"": {""NumFactoryTypes"": {""description"": ""Number of factory types"", ""shape"": []}, ""ProductionRate"": {""description"": ""Production rate of each factory type in phones per day"", ""shape"": [""NumFactoryTypes""]}, ""ManagerRequirement"": {""description"": ""Number of managers required for each factory type"", ""shape"": [""NumFactoryTypes""]}, ""AvailableManagers"": {""description"": ""Total number of managers available"", ""shape"": []}, ""RequiredPhones"": {""description"": ""Minimum number of phones required per day"", ""shape"": []}}, ""variables"": {""FactoriesBuilt"": {""description"": ""The number of factories built for each factory type"", ""type"": ""continuous"", ""shape"": [""NumFactoryTypes""]}}, ""constraints"": [{""description"": ""The total number of managers required by all factory types built does not exceed AvailableManagers."", ""formulation"": ""\\sum_{i=1}^{\\text{NumFactoryTypes}} \\text{FactoriesBuilt}_i \\times \\text{ManagerRequirement}_i \\leq \\text{AvailableManagers}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(FactoriesBuilt[i] * ManagerRequirement[i] for i in range(NumFactoryTypes)) <= AvailableManagers)""}}, {""description"": ""The total phone production from all factory types built is at least RequiredPhones per day."", ""formulation"": ""\\sum_{i=1}^{NumFactoryTypes} FactoriesBuilt_i \\times ProductionRate_i \\geq RequiredPhones"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(FactoriesBuilt[i] * ProductionRate[i] for i in range(NumFactoryTypes)) >= RequiredPhones)""}}], ""objective"": {""description"": ""Minimize the total number of factories built while meeting the production and manager constraints."", ""formulation"": ""Minimize \\sum_{i=1}^{NumFactoryTypes} \\text{FactoriesBuilt}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(FactoriesBuilt[i] for i in range(NumFactoryTypes)), GRB.MINIMIZE)""}}}","{""NumFactoryTypes"": 2, ""ProductionRate"": [100, 200], ""ManagerRequirement"": [8, 20], ""AvailableManagers"": 260, ""RequiredPhones"": 3000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company is building NumFactoryTypes different factory types. Each factory type
i produces ProductionRate[i] phones per day and requires ManagerRequirement[i]
managers. The company has AvailableManagers managers available and must produce
at least RequiredPhones phones per day. Determine the number of each factory
type to build to minimize the total number of factories.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/52/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumFactoryTypes @Def: Number of factory types @Shape: [] 
NumFactoryTypes = data['NumFactoryTypes']
# @Parameter ProductionRate @Def: Production rate of each factory type in phones per day @Shape: ['NumFactoryTypes'] 
ProductionRate = data['ProductionRate']
# @Parameter ManagerRequirement @Def: Number of managers required for each factory type @Shape: ['NumFactoryTypes'] 
ManagerRequirement = data['ManagerRequirement']
# @Parameter AvailableManagers @Def: Total number of managers available @Shape: [] 
AvailableManagers = data['AvailableManagers']
# @Parameter RequiredPhones @Def: Minimum number of phones required per day @Shape: [] 
RequiredPhones = data['RequiredPhones']
    
# Variables 
# @Variable FactoriesBuilt @Def: The number of factories built for each factory type @Shape: ['NumFactoryTypes'] 
FactoriesBuilt = model.addVars(NumFactoryTypes, vtype=GRB.INTEGER, name=""FactoriesBuilt"")
    
# Constraints 
# @Constraint Constr_1 @Def: The total number of managers required by all factory types built does not exceed AvailableManagers.
model.addConstr(quicksum(FactoriesBuilt[i] * ManagerRequirement[i] for i in range(NumFactoryTypes)) <= AvailableManagers)
# @Constraint Constr_2 @Def: The total phone production from all factory types built is at least RequiredPhones per day.
model.addConstr(quicksum(FactoriesBuilt[i] * ProductionRate[i] for i in range(NumFactoryTypes)) >= RequiredPhones)
    
# Objective 
# @Objective Objective @Def: Minimize the total number of factories built while meeting the production and manager constraints.
model.setObjective(quicksum(FactoriesBuilt[i] for i in range(NumFactoryTypes)), GRB.MINIMIZE)
    
# Solve 
model.optimize()
    
# Extract solution 
solution = {}
variables = {}
objective = []
variables['FactoriesBuilt'] = {i: FactoriesBuilt[i].x for i in range(NumFactoryTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"An ice cream store can buy two machines, a counter-top sized one and a fridge sized one, to make ice cream. The counter-top sized one can produce 80 cones worth of ice cream every day while the fridge sizes one can produce 150 cones worth of ice cream every day. The counter-top sized machine outputs 50 units of heat while the fridge sized one outputs 70 units of heat. The ice cream store can output at most 500 units of heat per day and must produce at least 1000 cones worth of ice cream. How many of each machine should they buy to minimize the total number of machines needed?","{""variables"": {""MachinesCounterTop"": 0.0, ""MachinesFridge"": 7.0}, ""objective"": 7.0}","{""parametrized_description"": ""To minimize the total number of machines, the ice cream store must decide how many counter-top sized machines and fridge sized machines to purchase. Each counter-top machine produces ProductionCounterTop ice creams per day and outputs HeatCounterTop units of heat, while each fridge machine produces ProductionFridge ice creams per day and outputs HeatFridge units of heat. The total heat output must not exceed MaxHeat, and the total ice cream production must be at least MinProduction."", ""keywords"": [""N.A.""], ""parameters"": {""ProductionCounterTop"": {""description"": ""Ice cream production per day by a counter-top sized machine"", ""shape"": []}, ""ProductionFridge"": {""description"": ""Ice cream production per day by a fridge sized machine"", ""shape"": []}, ""HeatCounterTop"": {""description"": ""Heat output per day by a counter-top sized machine"", ""shape"": []}, ""HeatFridge"": {""description"": ""Heat output per day by a fridge sized machine"", ""shape"": []}, ""MaxHeat"": {""description"": ""Maximum heat output per day"", ""shape"": []}, ""MinProduction"": {""description"": ""Minimum ice cream production per day"", ""shape"": []}}, ""variables"": {""MachinesCounterTop"": {""description"": ""The number of counter-top sized machines"", ""type"": ""continuous"", ""shape"": []}, ""MachinesFridge"": {""description"": ""The number of fridge-sized machines"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total heat output from all counter-top and fridge-sized machines must not exceed MaxHeat."", ""formulation"": ""HeatCounterTop \\cdot MachinesCounterTop + HeatFridge \\cdot MachinesFridge \\leq MaxHeat"", ""code"": {""gurobipy"": ""model.addConstr(HeatCounterTop * MachinesCounterTop + HeatFridge * MachinesFridge <= MaxHeat)""}}, {""description"": ""The total ice cream production from all counter-top and fridge-sized machines must be at least MinProduction."", ""formulation"": ""ProductionCounterTop \\cdot MachinesCounterTop + ProductionFridge \\cdot MachinesFridge \\geq MinProduction"", ""code"": {""gurobipy"": ""model.addConstr(ProductionCounterTop * MachinesCounterTop + ProductionFridge * MachinesFridge >= MinProduction)""}}], ""objective"": {""description"": ""Minimize the total number of machines, which is the sum of the number of counter-top and fridge-sized machines."", ""formulation"": ""Min \\ MachinesCounterTop + MachinesFridge"", ""code"": {""gurobipy"": ""model.setObjective(MachinesCounterTop + MachinesFridge, GRB.MINIMIZE)""}}}","{""ProductionCounterTop"": 80, ""ProductionFridge"": 150, ""HeatCounterTop"": 50, ""HeatFridge"": 70, ""MaxHeat"": 500, ""MinProduction"": 1000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
To minimize the total number of machines, the ice cream store must decide how
many counter-top sized machines and fridge sized machines to purchase. Each
counter-top machine produces ProductionCounterTop ice creams per day and outputs
HeatCounterTop units of heat, while each fridge machine produces
ProductionFridge ice creams per day and outputs HeatFridge units of heat. The
total heat output must not exceed MaxHeat, and the total ice cream production
must be at least MinProduction.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/53/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProductionCounterTop @Def: Ice cream production per day by a counter-top sized machine @Shape: [] 
ProductionCounterTop = data['ProductionCounterTop']
# @Parameter ProductionFridge @Def: Ice cream production per day by a fridge sized machine @Shape: [] 
ProductionFridge = data['ProductionFridge']
# @Parameter HeatCounterTop @Def: Heat output per day by a counter-top sized machine @Shape: [] 
HeatCounterTop = data['HeatCounterTop']
# @Parameter HeatFridge @Def: Heat output per day by a fridge sized machine @Shape: [] 
HeatFridge = data['HeatFridge']
# @Parameter MaxHeat @Def: Maximum heat output per day @Shape: [] 
MaxHeat = data['MaxHeat']
# @Parameter MinProduction @Def: Minimum ice cream production per day @Shape: [] 
MinProduction = data['MinProduction']

# Variables 
# @Variable MachinesCounterTop @Def: The number of counter-top sized machines @Shape: [] 
MachinesCounterTop = model.addVar(vtype=GRB.INTEGER, name=""MachinesCounterTop"")
# @Variable MachinesFridge @Def: The number of fridge-sized machines @Shape: [] 
MachinesFridge = model.addVar(vtype=GRB.INTEGER, name=""MachinesFridge"")

# Constraints 
# @Constraint Constr_1 @Def: The total heat output from all counter-top and fridge-sized machines must not exceed MaxHeat.
model.addConstr(HeatCounterTop * MachinesCounterTop + HeatFridge * MachinesFridge <= MaxHeat)
# @Constraint Constr_2 @Def: The total ice cream production from all counter-top and fridge-sized machines must be at least MinProduction.
model.addConstr(ProductionCounterTop * MachinesCounterTop + ProductionFridge * MachinesFridge >= MinProduction)

# Objective 
# @Objective Objective @Def: Minimize the total number of machines, which is the sum of the number of counter-top and fridge-sized machines.
model.setObjective(MachinesCounterTop + MachinesFridge, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['MachinesCounterTop'] = MachinesCounterTop.x
variables['MachinesFridge'] = MachinesFridge.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"There are two specialized containers, a small and large one, that are used to make a pharmaceutical paste. The small container requires 10 units of water and 15 units of the powdered pill to make 20 units of the paste. The large container requires 20 units of water and 20 units of the powdered pill to make 30 units of the paste. The pharmacy has available 500 units of water and 700 units of the powdered pill. How many of each container should be used to maximize the amount of paste that can be made?","{""variables"": {""NumUsedContainers"": [40.0, 5.0]}, ""objective"": 950.0}","{""parametrized_description"": ""There are NumContainers types of specialized containers used to produce paste. Each container type requires WaterRequiredPerContainer units of water and PowderedPillRequiredPerContainer units of powdered pill to produce PasteProducedPerContainer units of paste. The pharmacy has WaterAvailability units of water and PowderedPillAvailability units of powdered pill available. Determine the number of each container type to maximize the total amount of paste produced."", ""keywords"": [""N.A.""], ""parameters"": {""NumContainers"": {""description"": ""Number of container types"", ""shape"": []}, ""WaterAvailability"": {""description"": ""Available units of water"", ""shape"": []}, ""PowderedPillAvailability"": {""description"": ""Available units of powdered pill"", ""shape"": []}, ""WaterRequiredPerContainer"": {""description"": ""Water required per container type"", ""shape"": [""NumContainers""]}, ""PowderedPillRequiredPerContainer"": {""description"": ""Powdered pill required per container type"", ""shape"": [""NumContainers""]}, ""PasteProducedPerContainer"": {""description"": ""Paste produced per container type"", ""shape"": [""NumContainers""]}}, ""variables"": {""NumUsedContainers"": {""description"": ""The number of containers used for each container type"", ""type"": ""continuous"", ""shape"": [""NumContainers""]}}, ""constraints"": [{""description"": ""The total water required by all container types does not exceed the available units of water."", ""formulation"": ""\\sum_{j=1}^{NumContainers} WaterRequiredPerContainer_j \\cdot NumUsedContainers_j \\leq WaterAvailability"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(WaterRequiredPerContainer[j] * NumUsedContainers[j] for j in range(NumContainers)) <= WaterAvailability)""}}, {""description"": ""The total powdered pill required by all container types does not exceed the available units of powdered pill."", ""formulation"": ""\\sum_{c=1}^{\\text{NumContainers}} \\text{NumUsedContainers}_{c} \\times \\text{PowderedPillRequiredPerContainer}_{c} \\leq \\text{PowderedPillAvailability}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(NumUsedContainers[c] * PowderedPillRequiredPerContainer[c] for c in range(NumContainers)) <= PowderedPillAvailability)""}}], ""objective"": {""description"": ""The total paste produced is the sum of the paste produced by each container type. The objective is to maximize the total amount of paste produced."", ""formulation"": ""Max \\sum_{i=1}^{\\text{NumContainers}} \\text{PasteProducedPerContainer}_{i} \\times \\text{NumUsedContainers}_{i}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(PasteProducedPerContainer[i] * NumUsedContainers[i] for i in range(NumContainers)), GRB.MAXIMIZE)""}}}","{""NumContainers"": 2, ""WaterAvailability"": 500, ""PowderedPillAvailability"": 700, ""WaterRequiredPerContainer"": [10, 20], ""PowderedPillRequiredPerContainer"": [15, 20], ""PasteProducedPerContainer"": [20, 30]}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
There are NumContainers types of specialized containers used to produce paste.
Each container type requires WaterRequiredPerContainer units of water and
PowderedPillRequiredPerContainer units of powdered pill to produce
PasteProducedPerContainer units of paste. The pharmacy has WaterAvailability
units of water and PowderedPillAvailability units of powdered pill available.
Determine the number of each container type to maximize the total amount of
paste produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/54/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumContainers @Def: Number of container types @Shape: [] 
NumContainers = data['NumContainers']
# @Parameter WaterAvailability @Def: Available units of water @Shape: [] 
WaterAvailability = data['WaterAvailability']
# @Parameter PowderedPillAvailability @Def: Available units of powdered pill @Shape: [] 
PowderedPillAvailability = data['PowderedPillAvailability']
# @Parameter WaterRequiredPerContainer @Def: Water required per container type @Shape: ['NumContainers'] 
WaterRequiredPerContainer = data['WaterRequiredPerContainer']
# @Parameter PowderedPillRequiredPerContainer @Def: Powdered pill required per container type @Shape: ['NumContainers'] 
PowderedPillRequiredPerContainer = data['PowderedPillRequiredPerContainer']
# @Parameter PasteProducedPerContainer @Def: Paste produced per container type @Shape: ['NumContainers'] 
PasteProducedPerContainer = data['PasteProducedPerContainer']

# Variables 
# @Variable NumUsedContainers @Def: The number of containers used for each container type @Shape: ['NumContainers'] 
NumUsedContainers = model.addVars(NumContainers, vtype=GRB.INTEGER, name=""NumUsedContainers"")

# Constraints 
# @Constraint Constr_1 @Def: The total water required by all container types does not exceed the available units of water.
model.addConstr(quicksum(WaterRequiredPerContainer[j] * NumUsedContainers[j] for j in range(NumContainers)) <= WaterAvailability)
# @Constraint Constr_2 @Def: The total powdered pill required by all container types does not exceed the available units of powdered pill.
model.addConstr(quicksum(NumUsedContainers[c] * PowderedPillRequiredPerContainer[c] for c in range(NumContainers)) <= PowderedPillAvailability)

# Objective 
# @Objective Objective @Def: The total paste produced is the sum of the paste produced by each container type. The objective is to maximize the total amount of paste produced.
model.setObjective(quicksum(PasteProducedPerContainer[i] * NumUsedContainers[i] for i in range(NumContainers)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumUsedContainers'] = [NumUsedContainers[j].X for j in range(NumContainers)]
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"An oil and gas company operates on 300 acres of land where they use oil wells of small and large size. Per acre of land, a small oil well can produce 2 barrels of oil. Per acre of land, a large oil well can produce 5 barrels of oil. However, a small oil well produces 10 units of pollution and requires 5 drill bits per acre and a large oil well produces 20 units of pollution and requires 10 drill bits per acre. The company has available 2500 drill bits and due to strict environmental laws can produce at most 4500 units of pollution. For how many acres should each oil well be used to maximize the total production of oil?","{""variables"": {""LandAllocated"": {""0"": 0.0, ""1"": 225.0}}, ""objective"": 1125.0}","{""parametrized_description"": ""A company operates on TotalLand acres of land using NumWellTypes types of wells. Each well type produces ProductionPerAcre[i] units of oil per acre, generates PollutionPerAcre[i] units of pollution per acre, and requires DrillBitsPerAcre[i] drill bits per acre. The company has a total of TotalDrillBits drill bits available and must limit pollution to at most MaxPollution units. The objective is to determine the number of acres allocated to each well type to maximize total oil production."", ""keywords"": [""N.A.""], ""parameters"": {""TotalLand"": {""description"": ""Total land available for operations"", ""shape"": []}, ""NumWellTypes"": {""description"": ""Number of different well types"", ""shape"": []}, ""ProductionPerAcre"": {""description"": ""Oil production per acre for each well type"", ""shape"": [""NumWellTypes""]}, ""PollutionPerAcre"": {""description"": ""Pollution generated per acre for each well type"", ""shape"": [""NumWellTypes""]}, ""DrillBitsPerAcre"": {""description"": ""Drill bits required per acre for each well type"", ""shape"": [""NumWellTypes""]}, ""TotalDrillBits"": {""description"": ""Total available drill bits"", ""shape"": []}, ""MaxPollution"": {""description"": ""Maximum allowed pollution units"", ""shape"": []}}, ""variables"": {""LandAllocated"": {""description"": ""The land allocated to each well type"", ""type"": ""continuous"", ""shape"": [""NumWellTypes""]}}, ""constraints"": [{""description"": ""The total land allocated to all well types must not exceed TotalLand acres."", ""formulation"": ""\\sum_{i=1}^{\\text{NumWellTypes}} LandAllocated_i \\leq TotalLand"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(LandAllocated[i] for i in range(NumWellTypes)) <= TotalLand)""}}, {""description"": ""The total drill bits required for all well types must not exceed TotalDrillBits drill bits."", ""formulation"": ""\\sum_{i=1}^{NumWellTypes} LandAllocated_i \\times DrillBitsPerAcre_i \\leq TotalDrillBits"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(LandAllocated[i] * DrillBitsPerAcre[i] for i in range(NumWellTypes)) <= TotalDrillBits)""}}, {""description"": ""The total pollution generated by all well types must not exceed MaxPollution units."", ""formulation"": ""\\sum_{i=1}^{NumWellTypes} PollutionPerAcre_i LandAllocated_i \\leq MaxPollution"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(PollutionPerAcre[i] * LandAllocated[i] for i in range(NumWellTypes)) <= MaxPollution)""}}], ""objective"": {""description"": ""The objective is to maximize total oil production, which is the sum of the oil production from each well type allocated across acres."", ""formulation"": ""Max \\sum_{i=1}^{NumWellTypes} ProductionPerAcre_i \\cdot LandAllocated_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProductionPerAcre[i] * LandAllocated[i] for i in range(NumWellTypes)), GRB.MAXIMIZE)""}}}","{""TotalLand"": 300, ""NumWellTypes"": 2, ""ProductionPerAcre"": [2, 5], ""PollutionPerAcre"": [10, 20], ""DrillBitsPerAcre"": [5, 10], ""TotalDrillBits"": 2500, ""MaxPollution"": 4500}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A company operates on TotalLand acres of land using NumWellTypes types of wells.
Each well type produces ProductionPerAcre[i] units of oil per acre, generates
PollutionPerAcre[i] units of pollution per acre, and requires
DrillBitsPerAcre[i] drill bits per acre. The company has a total of
TotalDrillBits drill bits available and must limit pollution to at most
MaxPollution units. The objective is to determine the number of acres allocated
to each well type to maximize total oil production.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/55/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target	        
        
# Parameters 
# @Parameter TotalLand @Def: Total land available for operations @Shape: [] 
TotalLand = data['TotalLand']
# @Parameter NumWellTypes @Def: Number of different well types @Shape: [] 
NumWellTypes = data['NumWellTypes']
# @Parameter ProductionPerAcre @Def: Oil production per acre for each well type @Shape: ['NumWellTypes'] 
ProductionPerAcre = data['ProductionPerAcre']
# @Parameter PollutionPerAcre @Def: Pollution generated per acre for each well type @Shape: ['NumWellTypes'] 
PollutionPerAcre = data['PollutionPerAcre']
# @Parameter DrillBitsPerAcre @Def: Drill bits required per acre for each well type @Shape: ['NumWellTypes'] 
DrillBitsPerAcre = data['DrillBitsPerAcre']
# @Parameter TotalDrillBits @Def: Total available drill bits @Shape: [] 
TotalDrillBits = data['TotalDrillBits']
# @Parameter MaxPollution @Def: Maximum allowed pollution units @Shape: [] 
MaxPollution = data['MaxPollution']
    
# Variables 
# @Variable LandAllocated @Def: The land allocated to each well type @Shape: ['NumWellTypes'] 
LandAllocated = model.addVars(NumWellTypes, vtype=GRB.CONTINUOUS, name=""LandAllocated"")
    
# Constraints 
# @Constraint Constr_1 @Def: The total land allocated to all well types must not exceed TotalLand acres.
model.addConstr(quicksum(LandAllocated[i] for i in range(NumWellTypes)) <= TotalLand)
# @Constraint Constr_2 @Def: The total drill bits required for all well types must not exceed TotalDrillBits drill bits.
model.addConstr(quicksum(LandAllocated[i] * DrillBitsPerAcre[i] for i in range(NumWellTypes)) <= TotalDrillBits)
# @Constraint Constr_3 @Def: The total pollution generated by all well types must not exceed MaxPollution units.
model.addConstr(quicksum(PollutionPerAcre[i] * LandAllocated[i] for i in range(NumWellTypes)) <= MaxPollution)
    
# Objective 
# @Objective Objective @Def: The objective is to maximize total oil production, which is the sum of the oil production from each well type allocated across acres.
model.setObjective(quicksum(ProductionPerAcre[i] * LandAllocated[i] for i in range(NumWellTypes)), GRB.MAXIMIZE)
    
# Solve 
model.optimize()
    
# Extract solution 
solution = {}
variables = {}
objective = []
variables['LandAllocated'] = {i: LandAllocated[i].x for i in range(NumWellTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A bakery makes almond and pistachio croissants. An almond croissant requires 5 units of butter and 8 units of flour. A pistachio croissant requires 3 units of butter and 6 units of flour. The bakery has available 600 units of butter and 800 units of flour. Since the almond croissant is more popular, at least 3 times as many almond croissants should be made as pistachio croissants. If making an almond croissant takes 12 minutes and making a pistachio croissant takes 10 minutes, how many of each should be made to minimize the total production time?","{""variables"": {""QuantityAlmondCroissant"": -0.0, ""QuantityPistachioCroissant"": -0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A bakery produces almond and pistachio croissants. An almond croissant requires ButterPerAlmondCroissant units of butter and FlourPerAlmondCroissant units of flour. A pistachio croissant requires ButterPerPistachioCroissant units of butter and FlourPerPistachioCroissant units of flour. The bakery has available AvailableButter units of butter and AvailableFlour units of flour. At least MinAlmondToPistachioRatio times as many almond croissants should be made as pistachio croissants. Making an almond croissant takes ProductionTimeAlmondCroissant minutes and making a pistachio croissant takes ProductionTimePistachioCroissant minutes. How many of each should be made to minimize the total production time?"", ""keywords"": [""N.A.""], ""parameters"": {""AvailableButter"": {""description"": ""Amount of butter available"", ""shape"": []}, ""AvailableFlour"": {""description"": ""Amount of flour available"", ""shape"": []}, ""ButterPerAlmondCroissant"": {""description"": ""Amount of butter required to produce one almond croissant"", ""shape"": []}, ""FlourPerAlmondCroissant"": {""description"": ""Amount of flour required to produce one almond croissant"", ""shape"": []}, ""ButterPerPistachioCroissant"": {""description"": ""Amount of butter required to produce one pistachio croissant"", ""shape"": []}, ""FlourPerPistachioCroissant"": {""description"": ""Amount of flour required to produce one pistachio croissant"", ""shape"": []}, ""MinAlmondToPistachioRatio"": {""description"": ""Minimum ratio of almond croissants to pistachio croissants"", ""shape"": []}, ""ProductionTimeAlmondCroissant"": {""description"": ""Production time per almond croissant"", ""shape"": []}, ""ProductionTimePistachioCroissant"": {""description"": ""Production time per pistachio croissant"", ""shape"": []}}, ""variables"": {""QuantityAlmondCroissant"": {""description"": ""The number of almond croissants produced"", ""type"": ""continuous"", ""shape"": []}, ""QuantityPistachioCroissant"": {""description"": ""The number of pistachio croissants produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total amount of butter used by almond and pistachio croissants cannot exceed AvailableButter."", ""formulation"": ""ButterPerAlmondCroissant \\times QuantityAlmondCroissant + ButterPerPistachioCroissant \\times QuantityPistachioCroissant \\leq AvailableButter"", ""code"": {""gurobipy"": ""model.addConstr(ButterPerAlmondCroissant * QuantityAlmondCroissant + ButterPerPistachioCroissant * QuantityPistachioCroissant <= AvailableButter)""}}, {""description"": ""The total amount of flour used by almond and pistachio croissants cannot exceed AvailableFlour."", ""formulation"": ""FlourPerAlmondCroissant \\times QuantityAlmondCroissant + FlourPerPistachioCroissant \\times QuantityPistachioCroissant \\leq AvailableFlour"", ""code"": {""gurobipy"": ""model.addConstr(FlourPerAlmondCroissant * QuantityAlmondCroissant + \n                FlourPerPistachioCroissant * QuantityPistachioCroissant <= AvailableFlour, \n                name='FlourConstraint')""}}, {""description"": ""The number of almond croissants produced must be at least MinAlmondToPistachioRatio times the number of pistachio croissants."", ""formulation"": ""QuantityAlmondCroissant \\geq MinAlmondToPistachioRatio \\times QuantityPistachioCroissant"", ""code"": {""gurobipy"": ""model.addConstr(QuantityAlmondCroissant >= MinAlmondToPistachioRatio * QuantityPistachioCroissant)""}}], ""objective"": {""description"": ""Minimize the total production time, which is the sum of (ProductionTimeAlmondCroissant multiplied by the number of almond croissants) and (ProductionTimePistachioCroissant multiplied by the number of pistachio croissants)."", ""formulation"": ""Min \\ ProductionTimeAlmondCroissant \\cdot QuantityAlmondCroissant + ProductionTimePistachioCroissant \\cdot QuantityPistachioCroissant"", ""code"": {""gurobipy"": ""model.setObjective(ProductionTimeAlmondCroissant * QuantityAlmondCroissant + ProductionTimePistachioCroissant * QuantityPistachioCroissant, GRB.MINIMIZE)""}}}","{""AvailableButter"": 600, ""AvailableFlour"": 800, ""ButterPerAlmondCroissant"": 5, ""FlourPerAlmondCroissant"": 8, ""ButterPerPistachioCroissant"": 3, ""FlourPerPistachioCroissant"": 6, ""MinAlmondToPistachioRatio"": 3, ""ProductionTimeAlmondCroissant"": 12, ""ProductionTimePistachioCroissant"": 10}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A bakery produces almond and pistachio croissants. An almond croissant requires
ButterPerAlmondCroissant units of butter and FlourPerAlmondCroissant units of
flour. A pistachio croissant requires ButterPerPistachioCroissant units of
butter and FlourPerPistachioCroissant units of flour. The bakery has available
AvailableButter units of butter and AvailableFlour units of flour. At least
MinAlmondToPistachioRatio times as many almond croissants should be made as
pistachio croissants. Making an almond croissant takes
ProductionTimeAlmondCroissant minutes and making a pistachio croissant takes
ProductionTimePistachioCroissant minutes. How many of each should be made to
minimize the total production time?
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/56/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter AvailableButter @Def: Amount of butter available @Shape: [] 
AvailableButter = data['AvailableButter']
# @Parameter AvailableFlour @Def: Amount of flour available @Shape: [] 
AvailableFlour = data['AvailableFlour']
# @Parameter ButterPerAlmondCroissant @Def: Amount of butter required to produce one almond croissant @Shape: [] 
ButterPerAlmondCroissant = data['ButterPerAlmondCroissant']
# @Parameter FlourPerAlmondCroissant @Def: Amount of flour required to produce one almond croissant @Shape: [] 
FlourPerAlmondCroissant = data['FlourPerAlmondCroissant']
# @Parameter ButterPerPistachioCroissant @Def: Amount of butter required to produce one pistachio croissant @Shape: [] 
ButterPerPistachioCroissant = data['ButterPerPistachioCroissant']
# @Parameter FlourPerPistachioCroissant @Def: Amount of flour required to produce one pistachio croissant @Shape: [] 
FlourPerPistachioCroissant = data['FlourPerPistachioCroissant']
# @Parameter MinAlmondToPistachioRatio @Def: Minimum ratio of almond croissants to pistachio croissants @Shape: [] 
MinAlmondToPistachioRatio = data['MinAlmondToPistachioRatio']
# @Parameter ProductionTimeAlmondCroissant @Def: Production time per almond croissant @Shape: [] 
ProductionTimeAlmondCroissant = data['ProductionTimeAlmondCroissant']
# @Parameter ProductionTimePistachioCroissant @Def: Production time per pistachio croissant @Shape: [] 
ProductionTimePistachioCroissant = data['ProductionTimePistachioCroissant']

# Variables 
# @Variable QuantityAlmondCroissant @Def: The number of almond croissants produced @Shape: [] 
QuantityAlmondCroissant = model.addVar(vtype=GRB.INTEGER, name='QuantityAlmondCroissant')
# @Variable QuantityPistachioCroissant @Def: The number of pistachio croissants produced @Shape: [] 
QuantityPistachioCroissant = model.addVar(vtype=GRB.INTEGER, name=""QuantityPistachioCroissant"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of butter used by almond and pistachio croissants cannot exceed AvailableButter.
model.addConstr(ButterPerAlmondCroissant * QuantityAlmondCroissant + ButterPerPistachioCroissant * QuantityPistachioCroissant <= AvailableButter)
# @Constraint Constr_2 @Def: The total amount of flour used by almond and pistachio croissants cannot exceed AvailableFlour.
model.addConstr(FlourPerAlmondCroissant * QuantityAlmondCroissant + 
                FlourPerPistachioCroissant * QuantityPistachioCroissant <= AvailableFlour, 
                name='FlourConstraint')
# @Constraint Constr_3 @Def: The number of almond croissants produced must be at least MinAlmondToPistachioRatio times the number of pistachio croissants.
model.addConstr(QuantityAlmondCroissant >= MinAlmondToPistachioRatio * QuantityPistachioCroissant)

# Objective 
# @Objective Objective @Def: Minimize the total production time, which is the sum of (ProductionTimeAlmondCroissant multiplied by the number of almond croissants) and (ProductionTimePistachioCroissant multiplied by the number of pistachio croissants).
model.setObjective(ProductionTimeAlmondCroissant * QuantityAlmondCroissant + ProductionTimePistachioCroissant * QuantityPistachioCroissant, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityAlmondCroissant'] = QuantityAlmondCroissant.x
variables['QuantityPistachioCroissant'] = QuantityPistachioCroissant.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A burger chain is buying both gas and electric grills to make burger patties. A gas grill can cook 20 patties per minute while an electric grill can cook 30 patties per minute. The gas grill requires 20 units of cooking oil per minute while the electric grill requires 25 units of cooking oil per minute. Since the gas grill patties taste better, the number of electric grills must be less than the number of gas grills. Further, the burger chain wants to be able to make at least 150 patties per minute and use at most 140 units of cooking oil per minute. How many of each grill should be bought to minimize the total number of grills in the store?",{},{},"{""GasPattiesPerMinute"": 20, ""ElectricPattiesPerMinute"": 30, ""GasOilPerMinute"": 20, ""ElectricOilPerMinute"": 25, ""MinPattiesPerMinute"": 150, ""MaxOilPerMinute"": 140}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Determine the number of GasGrills and ElectricGrills to minimize the total
number of grills, such that GasPattiesPerMinute multiplied by GasGrills plus
ElectricPattiesPerMinute multiplied by ElectricGrills is at least
MinPattiesPerMinute, GasOilPerMinute multiplied by GasGrills plus
ElectricOilPerMinute multiplied by ElectricGrills does not exceed
MaxOilPerMinute, and the number of ElectricGrills is less than the number of
GasGrills.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/57/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter GasPattiesPerMinute @Def: The number of patties a single gas grill can cook per minute @Shape: [] 
GasPattiesPerMinute = data['GasPattiesPerMinute']
# @Parameter ElectricPattiesPerMinute @Def: The number of patties a single electric grill can cook per minute @Shape: [] 
ElectricPattiesPerMinute = data['ElectricPattiesPerMinute']
# @Parameter GasOilPerMinute @Def: The units of cooking oil a single gas grill uses per minute @Shape: [] 
GasOilPerMinute = data['GasOilPerMinute']
# @Parameter ElectricOilPerMinute @Def: The units of cooking oil a single electric grill uses per minute @Shape: [] 
ElectricOilPerMinute = data['ElectricOilPerMinute']
# @Parameter MinPattiesPerMinute @Def: The minimum number of patties the chain wants to make per minute @Shape: [] 
MinPattiesPerMinute = data['MinPattiesPerMinute']
# @Parameter MaxOilPerMinute @Def: The maximum units of cooking oil the chain wants to use per minute @Shape: [] 
MaxOilPerMinute = data['MaxOilPerMinute']

# Variables 
# @Variable GasGrills @Def: The number of gas grills used @Shape: ['Integer'] 
GasGrills = model.addVar(vtype=GRB.INTEGER, name=""GasGrills"")
# @Variable ElectricGrills @Def: The number of electric grills used @Shape: ['Integer'] 
ElectricGrills = model.addVar(vtype=GRB.INTEGER, name=""ElectricGrills"")

# Constraints 
# @Constraint Constr_1 @Def: GasPattiesPerMinute multiplied by GasGrills plus ElectricPattiesPerMinute multiplied by ElectricGrills is at least MinPattiesPerMinute
model.addConstr(GasPattiesPerMinute * GasGrills + ElectricPattiesPerMinute * ElectricGrills >= MinPattiesPerMinute)
# @Constraint Constr_2 @Def: GasOilPerMinute multiplied by GasGrills plus ElectricOilPerMinute multiplied by ElectricGrills does not exceed MaxOilPerMinute
model.addConstr(GasOilPerMinute * GasGrills + ElectricOilPerMinute * ElectricGrills <= MaxOilPerMinute)
# @Constraint Constr_3 @Def: The number of ElectricGrills is less than the number of GasGrills
model.addConstr(ElectricGrills <= GasGrills - 1)

# Objective 
# @Objective Objective @Def: The objective is to minimize the total number of grills, which is the sum of GasGrills and ElectricGrills.
model.setObjective(GasGrills + ElectricGrills, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['GasGrills'] = GasGrills.x
variables['ElectricGrills'] = ElectricGrills.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A cough syrup company sells cough syrup in kids and adult size bottles. A kids size bottle can hold 100 ml of cough syrup while an adult size bottle can hold 300 ml of cough syrup. Since there is no difference in concentration of medical ingredients between the two bottles, at least 3 times as many adult size bottle must be made as kids size bottles. However, at least 50 kids size bottles must be made. If the company has 25000 ml of cough syrup available, how many bottles of each should be made to maximize the total number of bottles?",{},"{""parametrized_description"": ""A company produces kids size bottles and adult size bottles. Each kids size bottle has a capacity of KidsBottleCapacity milliliters, and each adult size bottle has a capacity of AdultBottleCapacity milliliters. The number of adult size bottles produced must be at least AdultToKidsRatio times the number of kids size bottles. At least MinKidsBottles kids size bottles must be produced. The total available cough syrup is AvailableSyrup milliliters. The goal is to maximize the total number of bottles produced."", ""keywords"": [""N.A.""], ""parameters"": {""KidsBottleCapacity"": {""description"": ""Capacity of a kids size bottle in milliliters"", ""shape"": []}, ""AdultBottleCapacity"": {""description"": ""Capacity of an adult size bottle in milliliters"", ""shape"": []}, ""AdultToKidsRatio"": {""description"": ""Minimum ratio of adult bottles to kids bottles"", ""shape"": []}, ""MinKidsBottles"": {""description"": ""Minimum number of kids size bottles to be produced"", ""shape"": []}, ""AvailableSyrup"": {""description"": ""Total available milliliters of cough syrup"", ""shape"": []}}, ""variables"": {""NumberOfAdultBottles"": {""description"": ""The number of adult size bottles to be produced"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfKidsBottles"": {""description"": ""The number of kids size bottles to be produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of adult size bottles produced must be at least AdultToKidsRatio times the number of kids size bottles."", ""formulation"": ""NumberOfAdultBottles \\geq AdultToKidsRatio \\times NumberOfKidsBottles"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfAdultBottles >= AdultToKidsRatio * NumberOfKidsBottles)""}}, {""description"": ""At least MinKidsBottles kids size bottles must be produced."", ""formulation"": ""NumberOfKidsBottles \\geq MinKidsBottles"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfKidsBottles >= MinKidsBottles)""}}, {""description"": ""The total volume of cough syrup used by both kids and adult size bottles cannot exceed AvailableSyrup milliliters."", ""formulation"": ""AdultBottleCapacity \\cdot NumberOfAdultBottles + KidsBottleCapacity \\cdot NumberOfKidsBottles \\leq AvailableSyrup"", ""code"": {""gurobipy"": ""model.addConstr(AdultBottleCapacity * NumberOfAdultBottles + KidsBottleCapacity * NumberOfKidsBottles <= AvailableSyrup)""}}], ""objective"": {""description"": ""Maximize the total number of bottles produced."", ""formulation"": ""Max \\ NumberOfAdultBottles + NumberOfKidsBottles"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfAdultBottles + NumberOfKidsBottles, GRB.MAXIMIZE)""}}}","{""KidsBottleCapacity"": 100, ""AdultBottleCapacity"": 300, ""AdultToKidsRatio"": 3, ""MinKidsBottles"": 50, ""AvailableSyrup"": 25000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company produces kids size bottles and adult size bottles. Each kids size
bottle has a capacity of KidsBottleCapacity milliliters, and each adult size
bottle has a capacity of AdultBottleCapacity milliliters. The number of adult
size bottles produced must be at least AdultToKidsRatio times the number of kids
size bottles. At least MinKidsBottles kids size bottles must be produced. The
total available cough syrup is AvailableSyrup milliliters. The goal is to
maximize the total number of bottles produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/58/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter KidsBottleCapacity @Def: Capacity of a kids size bottle in milliliters @Shape: [] 
KidsBottleCapacity = data['KidsBottleCapacity']
# @Parameter AdultBottleCapacity @Def: Capacity of an adult size bottle in milliliters @Shape: [] 
AdultBottleCapacity = data['AdultBottleCapacity']
# @Parameter AdultToKidsRatio @Def: Minimum ratio of adult bottles to kids bottles @Shape: [] 
AdultToKidsRatio = data['AdultToKidsRatio']
# @Parameter MinKidsBottles @Def: Minimum number of kids size bottles to be produced @Shape: [] 
MinKidsBottles = data['MinKidsBottles']
# @Parameter AvailableSyrup @Def: Total available milliliters of cough syrup @Shape: [] 
AvailableSyrup = data['AvailableSyrup']

# Variables 
# @Variable NumberOfAdultBottles @Def: The number of adult size bottles to be produced @Shape: [] 
NumberOfAdultBottles = model.addVar(vtype=GRB.INTEGER, name=""NumberOfAdultBottles"")
# @Variable NumberOfKidsBottles @Def: The number of kids size bottles to be produced @Shape: [] 
NumberOfKidsBottles = model.addVar(vtype=GRB.INTEGER, name=""NumberOfKidsBottles"")

# Constraints 
# @Constraint Constr_1 @Def: The number of adult size bottles produced must be at least AdultToKidsRatio times the number of kids size bottles.
model.addConstr(NumberOfAdultBottles >= AdultToKidsRatio * NumberOfKidsBottles)
# @Constraint Constr_2 @Def: At least MinKidsBottles kids size bottles must be produced.
model.addConstr(NumberOfKidsBottles >= MinKidsBottles)
# @Constraint Constr_3 @Def: The total volume of cough syrup used by both kids and adult size bottles cannot exceed AvailableSyrup milliliters.
model.addConstr(AdultBottleCapacity * NumberOfAdultBottles + KidsBottleCapacity * NumberOfKidsBottles <= AvailableSyrup)

# Objective 
# @Objective Objective @Def: Maximize the total number of bottles produced.
model.setObjective(NumberOfAdultBottles + NumberOfKidsBottles, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfAdultBottles'] = NumberOfAdultBottles.x
variables['NumberOfKidsBottles'] = NumberOfKidsBottles.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A bakery makes fiber supplemented brownies and lemon squares. Each brownie requires 5 units of chocolate mix and 4 units of fiber. Each lemon square requires 7 units of lemon mix and 6 units of fiber. Lemon squares sell much faster and thus the number of lemon squares made must be larger than the number of brownies made. However, to please all customers, at least 40% of the items made must be brownies. If the bakery has 2500 units of chocolate mix and 3300 units of lemon mix, how many of each should be made to minimize the total amount of fiber needed?","{""variables"": {""NumberOfBrownies"": 2.0000000000000004, ""NumberOfLemonSquares"": 3.0000000000000004}, ""objective"": 26.000000000000007}","{""parametrized_description"": ""A bakery produces Brownies and LemonSquares. Each Brownie requires ChocolateMixPerBrownie units of ChocolateMix and FiberPerBrownie units of Fiber. Each LemonSquare requires LemonMixPerLemonSquare units of LemonMix and FiberPerLemonSquare units of Fiber. The number of LemonSquares produced must exceed the number of Brownies produced. Additionally, at least MinBrowniePercentage of the total items produced must be Brownies. The bakery has TotalChocolateMix units of ChocolateMix and TotalLemonMix units of LemonMix available. The objective is to minimize the total Fiber used."", ""keywords"": [""N.A.""], ""parameters"": {""ChocolateMixPerBrownie"": {""description"": ""Amount of chocolate mix required to produce one brownie"", ""shape"": []}, ""FiberPerBrownie"": {""description"": ""Amount of fiber required to produce one brownie"", ""shape"": []}, ""LemonMixPerLemonSquare"": {""description"": ""Amount of lemon mix required to produce one lemon square"", ""shape"": []}, ""FiberPerLemonSquare"": {""description"": ""Amount of fiber required to produce one lemon square"", ""shape"": []}, ""TotalChocolateMix"": {""description"": ""Total units of chocolate mix available"", ""shape"": []}, ""TotalLemonMix"": {""description"": ""Total units of lemon mix available"", ""shape"": []}, ""MinBrowniePercentage"": {""description"": ""Minimum percentage of items that must be brownies"", ""shape"": []}, ""MinLemonExceedsBrownie"": {""description"": ""Minimum required difference between the number of lemon squares and brownies"", ""shape"": []}}, ""variables"": {""NumberOfBrownies"": {""description"": ""The number of brownies to be produced"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfLemonSquares"": {""description"": ""The number of lemon squares to be produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total ChocolateMix used does not exceed TotalChocolateMix units."", ""formulation"": ""ChocolateMixPerBrownie \\times NumberOfBrownies \\leq TotalChocolateMix"", ""code"": {""gurobipy"": ""model.addConstr(ChocolateMixPerBrownie * NumberOfBrownies <= TotalChocolateMix)""}}, {""description"": ""The total LemonMix used does not exceed TotalLemonMix units."", ""formulation"": ""LemonMixPerLemonSquare \\times NumberOfLemonSquares \\leq TotalLemonMix"", ""code"": {""gurobipy"": ""model.addConstr(LemonMixPerLemonSquare * NumberOfLemonSquares <= TotalLemonMix)""}}, {""description"": ""The number of LemonSquares produced exceeds the number of Brownies produced by at least MinLemonExceedsBrownie."", ""formulation"": ""NumberOfLemonSquares - NumberOfBrownies \\geq MinLemonExceedsBrownie"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfLemonSquares - NumberOfBrownies >= MinLemonExceedsBrownie)""}}, {""description"": ""At least MinBrowniePercentage of the total items produced are Brownies."", ""formulation"": ""NumberOfBrownies \\geq MinBrowniePercentage \\times \\left(NumberOfBrownies + NumberOfLemonSquares\\right)"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfBrownies >= MinBrowniePercentage * (NumberOfBrownies + NumberOfLemonSquares))""}}], ""objective"": {""description"": ""Minimize the total Fiber used, calculated as FiberPerBrownie multiplied by the number of Brownies plus FiberPerLemonSquare multiplied by the number of LemonSquares."", ""formulation"": ""Min \\ FiberPerBrownie \\times NumberOfBrownies + FiberPerLemonSquare \\times NumberOfLemonSquares"", ""code"": {""gurobipy"": ""model.setObjective(FiberPerBrownie * NumberOfBrownies + FiberPerLemonSquare * NumberOfLemonSquares, GRB.MINIMIZE)""}}}","{""ChocolateMixPerBrownie"": 5, ""FiberPerBrownie"": 4, ""LemonMixPerLemonSquare"": 7, ""FiberPerLemonSquare"": 6, ""TotalChocolateMix"": 2500, ""TotalLemonMix"": 3300, ""MinBrowniePercentage"": 0.4, ""MinLemonExceedsBrownie"": 1}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A bakery produces Brownies and LemonSquares. Each Brownie requires
ChocolateMixPerBrownie units of ChocolateMix and FiberPerBrownie units of Fiber.
Each LemonSquare requires LemonMixPerLemonSquare units of LemonMix and
FiberPerLemonSquare units of Fiber. The number of LemonSquares produced must
exceed the number of Brownies produced. Additionally, at least
MinBrowniePercentage of the total items produced must be Brownies. The bakery
has TotalChocolateMix units of ChocolateMix and TotalLemonMix units of LemonMix
available. The objective is to minimize the total Fiber used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/59/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ChocolateMixPerBrownie @Def: Amount of chocolate mix required to produce one brownie @Shape: [] 
ChocolateMixPerBrownie = data['ChocolateMixPerBrownie']
# @Parameter FiberPerBrownie @Def: Amount of fiber required to produce one brownie @Shape: [] 
FiberPerBrownie = data['FiberPerBrownie']
# @Parameter LemonMixPerLemonSquare @Def: Amount of lemon mix required to produce one lemon square @Shape: [] 
LemonMixPerLemonSquare = data['LemonMixPerLemonSquare']
# @Parameter FiberPerLemonSquare @Def: Amount of fiber required to produce one lemon square @Shape: [] 
FiberPerLemonSquare = data['FiberPerLemonSquare']
# @Parameter TotalChocolateMix @Def: Total units of chocolate mix available @Shape: [] 
TotalChocolateMix = data['TotalChocolateMix']
# @Parameter TotalLemonMix @Def: Total units of lemon mix available @Shape: [] 
TotalLemonMix = data['TotalLemonMix']
# @Parameter MinBrowniePercentage @Def: Minimum percentage of items that must be brownies @Shape: [] 
MinBrowniePercentage = data['MinBrowniePercentage']
# @Parameter MinLemonExceedsBrownie @Def: Minimum required difference between the number of lemon squares and brownies @Shape: [] 
MinLemonExceedsBrownie = data['MinLemonExceedsBrownie']

# Variables 
# @Variable NumberOfBrownies @Def: The number of brownies to be produced @Shape: [] 
NumberOfBrownies = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfBrownies"")
# @Variable NumberOfLemonSquares @Def: The number of lemon squares to be produced @Shape: [] 
NumberOfLemonSquares = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfLemonSquares"")

# Constraints 
# @Constraint Constr_1 @Def: The total ChocolateMix used does not exceed TotalChocolateMix units.
model.addConstr(ChocolateMixPerBrownie * NumberOfBrownies <= TotalChocolateMix)
# @Constraint Constr_2 @Def: The total LemonMix used does not exceed TotalLemonMix units.
model.addConstr(LemonMixPerLemonSquare * NumberOfLemonSquares <= TotalLemonMix)
# @Constraint Constr_3 @Def: The number of LemonSquares produced exceeds the number of Brownies produced by at least MinLemonExceedsBrownie.
model.addConstr(NumberOfLemonSquares - NumberOfBrownies >= MinLemonExceedsBrownie)
# @Constraint Constr_4 @Def: At least MinBrowniePercentage of the total items produced are Brownies.
model.addConstr(NumberOfBrownies >= MinBrowniePercentage * (NumberOfBrownies + NumberOfLemonSquares))

# Objective 
# @Objective Objective @Def: Minimize the total Fiber used, calculated as FiberPerBrownie multiplied by the number of Brownies plus FiberPerLemonSquare multiplied by the number of LemonSquares.
model.setObjective(FiberPerBrownie * NumberOfBrownies + FiberPerLemonSquare * NumberOfLemonSquares, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfBrownies'] = NumberOfBrownies.x
variables['NumberOfLemonSquares'] = NumberOfLemonSquares.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A clinic employs nurses and pharmacists to deliver shots to patients. A nurse works 5 hours per shift while a pharmacist works 7 hours per shift. Nurses are paid $250 per shift while pharmacists are paid $300 per shift. Currently, the clinic needs 200 hours of healthcare labor to meet needs. If the firm has a budget of $9000, how many of each healthcare worker should be scheduled to minimize the total number of workers?","{""variables"": {""NumberOfNurseShifts"": 12.0, ""NumberOfPharmacistShifts"": 20.0, ""NumberOfNurses"": -0.0, ""NumberOfPharmacists"": -0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A clinic employs nurses and pharmacists to deliver shots to patients. A nurse works NurseShiftHours per shift while a pharmacist works PharmacistShiftHours per shift. Nurses are paid NurseCostPerShift per shift while pharmacists are paid PharmacistCostPerShift per shift. Currently, the clinic needs TotalLaborHours hours of healthcare labor to meet needs. If the firm has a budget of TotalBudget, how many of each healthcare worker should be scheduled to minimize the total number of workers?"", ""keywords"": [""N.A.""], ""parameters"": {""NurseShiftHours"": {""description"": ""Number of hours a nurse works per shift"", ""shape"": []}, ""PharmacistShiftHours"": {""description"": ""Number of hours a pharmacist works per shift"", ""shape"": []}, ""NurseCostPerShift"": {""description"": ""Cost to employ one nurse per shift"", ""shape"": []}, ""PharmacistCostPerShift"": {""description"": ""Cost to employ one pharmacist per shift"", ""shape"": []}, ""TotalLaborHours"": {""description"": ""Total required healthcare labor hours"", ""shape"": []}, ""TotalBudget"": {""description"": ""Total budget for labor costs"", ""shape"": []}}, ""variables"": {""NumberOfNurseShifts"": {""description"": ""The number of nurse shifts"", ""type"": ""continuous"", ""shape"": [""NonNegative Integer""]}, ""NumberOfPharmacistShifts"": {""description"": ""The number of pharmacist shifts"", ""type"": ""continuous"", ""shape"": [""NonNegative Integer""]}, ""NumberOfNurses"": {""description"": ""The number of nurses employed"", ""type"": ""continuous"", ""shape"": [""NonNegative Integer""]}, ""NumberOfPharmacists"": {""description"": ""The number of pharmacists employed"", ""type"": ""continuous"", ""shape"": [""NonNegative Integer""]}}, ""constraints"": [{""description"": ""The total healthcare labor hours provided by nurses and pharmacists must be at least TotalLaborHours."", ""formulation"": ""NurseShiftHours \\times NumberOfNurseShifts + PharmacistShiftHours \\times NumberOfPharmacistShifts \\geq TotalLaborHours"", ""code"": {""gurobipy"": ""model.addConstr(NurseShiftHours * NumberOfNurseShifts + PharmacistShiftHours * NumberOfPharmacistShifts >= TotalLaborHours)""}}, {""description"": ""The total labor cost for nurses and pharmacists must not exceed TotalBudget."", ""formulation"": ""NurseCostPerShift \\cdot NumberOfNurseShifts + PharmacistCostPerShift \\cdot NumberOfPharmacistShifts \\leq TotalBudget"", ""code"": {""gurobipy"": ""model.addConstr(NurseCostPerShift * NumberOfNurseShifts + PharmacistCostPerShift * NumberOfPharmacistShifts <= TotalBudget)""}}], ""objective"": {""description"": ""Minimize the total number of workers, which is the sum of nurses and pharmacists, while meeting the required healthcare labor hours and adhering to the budget."", ""formulation"": ""Min \\ NumberOfNurses + NumberOfPharmacists"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfNurses + NumberOfPharmacists, GRB.MINIMIZE)""}}}","{""NurseShiftHours"": 5, ""PharmacistShiftHours"": 7, ""NurseCostPerShift"": 250, ""PharmacistCostPerShift"": 300, ""TotalLaborHours"": 200, ""TotalBudget"": 9000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A clinic employs nurses and pharmacists to deliver shots to patients. A nurse
works NurseShiftHours per shift while a pharmacist works PharmacistShiftHours
per shift. Nurses are paid NurseCostPerShift per shift while pharmacists are
paid PharmacistCostPerShift per shift. Currently, the clinic needs
TotalLaborHours hours of healthcare labor to meet needs. If the firm has a
budget of TotalBudget, how many of each healthcare worker should be scheduled to
minimize the total number of workers?
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/60/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NurseShiftHours @Def: Number of hours a nurse works per shift @Shape: [] 
NurseShiftHours = data['NurseShiftHours']
# @Parameter PharmacistShiftHours @Def: Number of hours a pharmacist works per shift @Shape: [] 
PharmacistShiftHours = data['PharmacistShiftHours']
# @Parameter NurseCostPerShift @Def: Cost to employ one nurse per shift @Shape: [] 
NurseCostPerShift = data['NurseCostPerShift']
# @Parameter PharmacistCostPerShift @Def: Cost to employ one pharmacist per shift @Shape: [] 
PharmacistCostPerShift = data['PharmacistCostPerShift']
# @Parameter TotalLaborHours @Def: Total required healthcare labor hours @Shape: [] 
TotalLaborHours = data['TotalLaborHours']
# @Parameter TotalBudget @Def: Total budget for labor costs @Shape: [] 
TotalBudget = data['TotalBudget']

# Variables 
# @Variable NumberOfNurseShifts @Def: The number of nurse shifts @Shape: ['NonNegative Integer'] 
NumberOfNurseShifts = model.addVar(vtype=GRB.INTEGER, name=""NumberOfNurseShifts"")
# @Variable NumberOfPharmacistShifts @Def: The number of pharmacist shifts @Shape: ['NonNegative Integer'] 
NumberOfPharmacistShifts = model.addVar(vtype=GRB.INTEGER, name=""NumberOfPharmacistShifts"")
# @Variable NumberOfNurses @Def: The number of nurses employed @Shape: ['NonNegative Integer'] 
NumberOfNurses = model.addVar(vtype=GRB.INTEGER, lb=0, name=""NumberOfNurses"")
# @Variable NumberOfPharmacists @Def: The number of pharmacists employed @Shape: ['NonNegative Integer'] 
NumberOfPharmacists = model.addVar(vtype=GRB.INTEGER, lb=0, name=""NumberOfPharmacists"")

# Constraints 
# @Constraint Constr_1 @Def: The total healthcare labor hours provided by nurses and pharmacists must be at least TotalLaborHours.
model.addConstr(NurseShiftHours * NumberOfNurseShifts + PharmacistShiftHours * NumberOfPharmacistShifts >= TotalLaborHours)
# @Constraint Constr_2 @Def: The total labor cost for nurses and pharmacists must not exceed TotalBudget.
model.addConstr(NurseCostPerShift * NumberOfNurseShifts + PharmacistCostPerShift * NumberOfPharmacistShifts <= TotalBudget)

# Objective 
# @Objective Objective @Def: Minimize the total number of workers, which is the sum of nurses and pharmacists, while meeting the required healthcare labor hours and adhering to the budget.
model.setObjective(NumberOfNurses + NumberOfPharmacists, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfNurseShifts'] = NumberOfNurseShifts.x
variables['NumberOfPharmacistShifts'] = NumberOfPharmacistShifts.x
variables['NumberOfNurses'] = NumberOfNurses.x
variables['NumberOfPharmacists'] = NumberOfPharmacists.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A laundromat can buy two types of washing machines, a top-loading model and a front-loading model. The top-loading model can wash 50 items per day while the front-loading model can wash 75 items per day. The top-loading model consumes 85 kWh per day while the front-loading model consumes 100 kWh per day. The laundromat must be able to wash at least 5000 items per day and has available 7000 kWh per day. Since the top-loading machine are harder to use, at most 40% of the machines can be top-loading. Further, at least 10 machines should be front-loading. How many of each machine should the laundromat buy to minimize the total number of washing machines?","{""variables"": {""NumTopLoading"": -0.0, ""NumFrontLoading"": 67.0}, ""objective"": 67.0}","{""parametrized_description"": ""A laundromat can buy two types of washing machines, a top-loading model and a front-loading model. The top-loading model can wash WashRateTopLoading items per day while the front-loading model can wash WashRateFrontLoading items per day. The top-loading model consumes EnergyConsumptionTopLoading kWh per day while the front-loading model consumes EnergyConsumptionFrontLoading kWh per day. The laundromat must be able to wash at least MinItemsPerDay items per day and has available MaxEnergyPerDay kWh per day. Since the top-loading machines are harder to use, at most MaxFractionTopLoading of the machines can be top-loading. Further, at least MinNumFrontLoading machines should be front-loading. How many of each machine should the laundromat buy to minimize the total number of washing machines?"", ""keywords"": [""N.A.""], ""parameters"": {""WashRateTopLoading"": {""description"": ""Number of items washed per day by a top-loading machine"", ""shape"": []}, ""WashRateFrontLoading"": {""description"": ""Number of items washed per day by a front-loading machine"", ""shape"": []}, ""EnergyConsumptionTopLoading"": {""description"": ""Energy consumed per day by a top-loading machine (kWh)"", ""shape"": []}, ""EnergyConsumptionFrontLoading"": {""description"": ""Energy consumed per day by a front-loading machine (kWh)"", ""shape"": []}, ""MinItemsPerDay"": {""description"": ""Minimum number of items to wash per day"", ""shape"": []}, ""MaxEnergyPerDay"": {""description"": ""Maximum available energy per day (kWh)"", ""shape"": []}, ""MaxFractionTopLoading"": {""description"": ""Maximum fraction of machines that can be top-loading"", ""shape"": []}, ""MinNumFrontLoading"": {""description"": ""Minimum number of front-loading machines"", ""shape"": []}}, ""variables"": {""NumTopLoading"": {""description"": ""The number of top-loading machines"", ""type"": ""continuous"", ""shape"": []}, ""NumFrontLoading"": {""description"": ""The number of front-loading machines"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""A top-loading machine washes WashRateTopLoading items per day and a front-loading machine washes WashRateFrontLoading items per day. The total number of items washed per day must be at least MinItemsPerDay."", ""formulation"": ""WashRateTopLoading \\cdot NumTopLoading + WashRateFrontLoading \\cdot NumFrontLoading \\geq MinItemsPerDay"", ""code"": {""gurobipy"": ""model.addConstr(WashRateTopLoading * NumTopLoading + WashRateFrontLoading * NumFrontLoading >= MinItemsPerDay)""}}, {""description"": ""A top-loading machine consumes EnergyConsumptionTopLoading kWh per day and a front-loading machine consumes EnergyConsumptionFrontLoading kWh per day. The total energy consumption per day cannot exceed MaxEnergyPerDay kWh."", ""formulation"": ""NumTopLoading \\times EnergyConsumptionTopLoading + NumFrontLoading \\times EnergyConsumptionFrontLoading \\leq MaxEnergyPerDay"", ""code"": {""gurobipy"": ""model.addConstr(EnergyConsumptionTopLoading * NumTopLoading + EnergyConsumptionFrontLoading * NumFrontLoading <= MaxEnergyPerDay)""}}, {""description"": ""At most MaxFractionTopLoading fraction of the total machines can be top-loading."", ""formulation"": ""NumTopLoading \\leq MaxFractionTopLoading \\times (NumTopLoading + NumFrontLoading)"", ""code"": {""gurobipy"": ""model.addConstr(NumTopLoading <= MaxFractionTopLoading * (NumTopLoading + NumFrontLoading))""}}, {""description"": ""At least MinNumFrontLoading machines must be front-loading."", ""formulation"": ""NumFrontLoading \\geq MinNumFrontLoading"", ""code"": {""gurobipy"": ""model.addConstr(NumFrontLoading >= MinNumFrontLoading)""}}], ""objective"": {""description"": ""Minimize the total number of washing machines purchased."", ""formulation"": ""Min \\ NumTopLoading + NumFrontLoading"", ""code"": {""gurobipy"": ""model.setObjective(NumTopLoading + NumFrontLoading, GRB.MINIMIZE)""}}}","{""WashRateTopLoading"": 50, ""WashRateFrontLoading"": 75, ""EnergyConsumptionTopLoading"": 85, ""EnergyConsumptionFrontLoading"": 100, ""MinItemsPerDay"": 5000, ""MaxEnergyPerDay"": 7000, ""MaxFractionTopLoading"": 0.4, ""MinNumFrontLoading"": 10}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A laundromat can buy two types of washing machines, a top-loading model and a
front-loading model. The top-loading model can wash WashRateTopLoading items per
day while the front-loading model can wash WashRateFrontLoading items per day.
The top-loading model consumes EnergyConsumptionTopLoading kWh per day while the
front-loading model consumes EnergyConsumptionFrontLoading kWh per day. The
laundromat must be able to wash at least MinItemsPerDay items per day and has
available MaxEnergyPerDay kWh per day. Since the top-loading machines are harder
to use, at most MaxFractionTopLoading of the machines can be top-loading.
Further, at least MinNumFrontLoading machines should be front-loading. How many
of each machine should the laundromat buy to minimize the total number of
washing machines?
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/61/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter WashRateTopLoading @Def: Number of items washed per day by a top-loading machine @Shape: [] 
WashRateTopLoading = data['WashRateTopLoading']
# @Parameter WashRateFrontLoading @Def: Number of items washed per day by a front-loading machine @Shape: [] 
WashRateFrontLoading = data['WashRateFrontLoading']
# @Parameter EnergyConsumptionTopLoading @Def: Energy consumed per day by a top-loading machine (kWh) @Shape: [] 
EnergyConsumptionTopLoading = data['EnergyConsumptionTopLoading']
# @Parameter EnergyConsumptionFrontLoading @Def: Energy consumed per day by a front-loading machine (kWh) @Shape: [] 
EnergyConsumptionFrontLoading = data['EnergyConsumptionFrontLoading']
# @Parameter MinItemsPerDay @Def: Minimum number of items to wash per day @Shape: [] 
MinItemsPerDay = data['MinItemsPerDay']
# @Parameter MaxEnergyPerDay @Def: Maximum available energy per day (kWh) @Shape: [] 
MaxEnergyPerDay = data['MaxEnergyPerDay']
# @Parameter MaxFractionTopLoading @Def: Maximum fraction of machines that can be top-loading @Shape: [] 
MaxFractionTopLoading = data['MaxFractionTopLoading']
# @Parameter MinNumFrontLoading @Def: Minimum number of front-loading machines @Shape: [] 
MinNumFrontLoading = data['MinNumFrontLoading']

# Variables 
# @Variable NumTopLoading @Def: The number of top-loading machines @Shape: [] 
NumTopLoading = model.addVar(vtype=GRB.INTEGER, name=""NumTopLoading"")
# @Variable NumFrontLoading @Def: The number of front-loading machines @Shape: [] 
NumFrontLoading = model.addVar(vtype=GRB.INTEGER, lb=MinNumFrontLoading, name=""NumFrontLoading"")

# Constraints 
# @Constraint Constr_1 @Def: A top-loading machine washes WashRateTopLoading items per day and a front-loading machine washes WashRateFrontLoading items per day. The total number of items washed per day must be at least MinItemsPerDay.
model.addConstr(WashRateTopLoading * NumTopLoading + WashRateFrontLoading * NumFrontLoading >= MinItemsPerDay)
# @Constraint Constr_2 @Def: A top-loading machine consumes EnergyConsumptionTopLoading kWh per day and a front-loading machine consumes EnergyConsumptionFrontLoading kWh per day. The total energy consumption per day cannot exceed MaxEnergyPerDay kWh.
model.addConstr(EnergyConsumptionTopLoading * NumTopLoading + EnergyConsumptionFrontLoading * NumFrontLoading <= MaxEnergyPerDay)
# @Constraint Constr_3 @Def: At most MaxFractionTopLoading fraction of the total machines can be top-loading.
model.addConstr(NumTopLoading <= MaxFractionTopLoading * (NumTopLoading + NumFrontLoading))
# @Constraint Constr_4 @Def: At least MinNumFrontLoading machines must be front-loading.
model.addConstr(NumFrontLoading >= MinNumFrontLoading)

# Objective 
# @Objective Objective @Def: Minimize the total number of washing machines purchased.
model.setObjective(NumTopLoading + NumFrontLoading, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumTopLoading'] = NumTopLoading.x
variables['NumFrontLoading'] = NumFrontLoading.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
A bank can build small and large branches to serve their customers. A small branch can serve 50 customers per day and requires 10 bank tellers. A large branch can serve 100 customers per day and requires 15 bank tellers. The bank has available 200 bank tellers and needs to be able to serve at least 1200 customers per day. How many of each branch size should they build to minimize the total number of branches needed?,"{""variables"": {""SmallBranches"": -0.0, ""LargeBranches"": 12.0}, ""objective"": 12.0}","{""parametrized_description"": ""A bank can build small and large branches to serve their customers. A small branch can serve CustomersSmall customers per day and requires TellersSmall bank tellers. A large branch can serve CustomersLarge customers per day and requires TellersLarge bank tellers. The bank has available TotalTellers bank tellers and needs to be able to serve at least MinCustomers customers per day. They aim to minimize the total number of branches built."", ""keywords"": [""N.A.""], ""parameters"": {""CustomersSmall"": {""description"": ""Number of customers a small branch can serve per day"", ""shape"": []}, ""TellersSmall"": {""description"": ""Number of tellers required by a small branch"", ""shape"": []}, ""CustomersLarge"": {""description"": ""Number of customers a large branch can serve per day"", ""shape"": []}, ""TellersLarge"": {""description"": ""Number of tellers required by a large branch"", ""shape"": []}, ""TotalTellers"": {""description"": ""Total number of available bank tellers"", ""shape"": []}, ""MinCustomers"": {""description"": ""Minimum number of customers that need to be served per day"", ""shape"": []}}, ""variables"": {""SmallBranches"": {""description"": ""The number of small branches"", ""type"": ""continuous"", ""shape"": []}, ""LargeBranches"": {""description"": ""The number of large branches"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of tellers required by small and large branches cannot exceed the available tellers (SmallBranches * TellersSmall + LargeBranches * TellersLarge \u2264 TotalTellers)."", ""formulation"": ""SmallBranches \\times TellersSmall + LargeBranches \\times TellersLarge \\leq TotalTellers"", ""code"": {""gurobipy"": ""model.addConstr(SmallBranches * TellersSmall + LargeBranches * TellersLarge <= TotalTellers)""}}, {""description"": ""The total number of customers served by small and large branches must be at least the minimum required (SmallBranches * CustomersSmall + LargeBranches * CustomersLarge \u2265 MinCustomers)."", ""formulation"": ""SmallBranches \\times CustomersSmall + LargeBranches \\times CustomersLarge \\geq MinCustomers"", ""code"": {""gurobipy"": ""model.addConstr(SmallBranches * CustomersSmall + LargeBranches * CustomersLarge >= MinCustomers)""}}], ""objective"": {""description"": ""Minimize the total number of branches built (SmallBranches + LargeBranches)."", ""formulation"": ""Min \\ SmallBranches + LargeBranches"", ""code"": {""gurobipy"": ""model.setObjective(SmallBranches + LargeBranches, GRB.MINIMIZE)""}}}","{""CustomersSmall"": 50, ""TellersSmall"": 10, ""CustomersLarge"": 100, ""TellersLarge"": 15, ""TotalTellers"": 200, ""MinCustomers"": 1200}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A bank can build small and large branches to serve their customers. A small
branch can serve CustomersSmall customers per day and requires TellersSmall bank
tellers. A large branch can serve CustomersLarge customers per day and requires
TellersLarge bank tellers. The bank has available TotalTellers bank tellers and
needs to be able to serve at least MinCustomers customers per day. They aim to
minimize the total number of branches built.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/62/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CustomersSmall @Def: Number of customers a small branch can serve per day @Shape: [] 
CustomersSmall = data['CustomersSmall']
# @Parameter TellersSmall @Def: Number of tellers required by a small branch @Shape: [] 
TellersSmall = data['TellersSmall']
# @Parameter CustomersLarge @Def: Number of customers a large branch can serve per day @Shape: [] 
CustomersLarge = data['CustomersLarge']
# @Parameter TellersLarge @Def: Number of tellers required by a large branch @Shape: [] 
TellersLarge = data['TellersLarge']
# @Parameter TotalTellers @Def: Total number of available bank tellers @Shape: [] 
TotalTellers = data['TotalTellers']
# @Parameter MinCustomers @Def: Minimum number of customers that need to be served per day @Shape: [] 
MinCustomers = data['MinCustomers']

# Variables 
# @Variable SmallBranches @Def: The number of small branches @Shape: [] 
SmallBranches = model.addVar(vtype=GRB.INTEGER, name=""SmallBranches"")
# @Variable LargeBranches @Def: The number of large branches @Shape: [] 
LargeBranches = model.addVar(vtype=GRB.INTEGER, name=""LargeBranches"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of tellers required by small and large branches cannot exceed the available tellers (SmallBranches * TellersSmall + LargeBranches * TellersLarge ≤ TotalTellers).
model.addConstr(SmallBranches * TellersSmall + LargeBranches * TellersLarge <= TotalTellers)
# @Constraint Constr_2 @Def: The total number of customers served by small and large branches must be at least the minimum required (SmallBranches * CustomersSmall + LargeBranches * CustomersLarge ≥ MinCustomers).
model.addConstr(SmallBranches * CustomersSmall + LargeBranches * CustomersLarge >= MinCustomers)

# Objective 
# @Objective Objective @Def: Minimize the total number of branches built (SmallBranches + LargeBranches).
model.setObjective(SmallBranches + LargeBranches, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SmallBranches'] = SmallBranches.x
variables['LargeBranches'] = LargeBranches.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A shipping company can purchase regular and hybrid vans to make deliveries. A regular van can deliver 500 packages per day and produces 200 units of pollutants. A hybrid van can deliver 300 packages per day and produces 100 units of pollutants. Due to a new environmental law, they can produce at most 7000 units of pollutants per day. However, the company needs to be able to deliver at least 20000 packages per day. How many of each type of van should they buy to minimize the total number of vans needed?","{""variables"": {""RegularVans"": 10.0, ""HybridVans"": 50.0}, ""objective"": 60.0}","{""parametrized_description"": ""A shipping company can purchase RegularVans and HybridVans to make deliveries. Each RegularVan delivers PackagesDeliveredRegular packages per day and produces PollutantsRegular units of pollutants, while each HybridVan delivers PackagesDeliveredHybrid packages per day and produces PollutantsHybrid units of pollutants. The company must deliver at least MinPackages packages per day and ensure that total pollutants do not exceed MaxPollutants units per day. The objective is to determine the number of RegularVans and HybridVans to purchase in order to minimize the total number of vans used."", ""keywords"": [""N.A.""], ""parameters"": {""PackagesDeliveredRegular"": {""description"": ""Number of packages a regular van can deliver per day"", ""shape"": []}, ""PackagesDeliveredHybrid"": {""description"": ""Number of packages a hybrid van can deliver per day"", ""shape"": []}, ""PollutantsRegular"": {""description"": ""Number of pollutant units produced by a regular van per day"", ""shape"": []}, ""PollutantsHybrid"": {""description"": ""Number of pollutant units produced by a hybrid van per day"", ""shape"": []}, ""MaxPollutants"": {""description"": ""Maximum allowed pollutant units per day"", ""shape"": []}, ""MinPackages"": {""description"": ""Minimum required number of packages per day"", ""shape"": []}}, ""variables"": {""RegularVans"": {""description"": ""The number of regular vans used per day"", ""type"": ""continuous"", ""shape"": []}, ""HybridVans"": {""description"": ""The number of hybrid vans used per day"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The company must deliver at least MinPackages packages per day."", ""formulation"": ""RegularVans \\times PackagesDeliveredRegular + HybridVans \\times PackagesDeliveredHybrid \\geq MinPackages"", ""code"": {""gurobipy"": ""model.addConstr(RegularVans * PackagesDeliveredRegular + HybridVans * PackagesDeliveredHybrid >= MinPackages)""}}, {""description"": ""Ensure that total pollutants do not exceed MaxPollutants units per day."", ""formulation"": ""PollutantsRegular \\cdot RegularVans + PollutantsHybrid \\cdot HybridVans \\leq MaxPollutants"", ""code"": {""gurobipy"": ""model.addConstr(PollutantsRegular * RegularVans + PollutantsHybrid * HybridVans <= MaxPollutants)""}}], ""objective"": {""description"": ""Minimize the total number of vans used."", ""formulation"": ""\\min \\, RegularVans + HybridVans"", ""code"": {""gurobipy"": ""model.setObjective(RegularVans + HybridVans, GRB.MINIMIZE)""}}}","{""PackagesDeliveredRegular"": 500, ""PackagesDeliveredHybrid"": 300, ""PollutantsRegular"": 200, ""PollutantsHybrid"": 100, ""MaxPollutants"": 7000, ""MinPackages"": 20000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A shipping company can purchase RegularVans and HybridVans to make deliveries.
Each RegularVan delivers PackagesDeliveredRegular packages per day and produces
PollutantsRegular units of pollutants, while each HybridVan delivers
PackagesDeliveredHybrid packages per day and produces PollutantsHybrid units of
pollutants. The company must deliver at least MinPackages packages per day and
ensure that total pollutants do not exceed MaxPollutants units per day. The
objective is to determine the number of RegularVans and HybridVans to purchase
in order to minimize the total number of vans used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/63/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter PackagesDeliveredRegular @Def: Number of packages a regular van can deliver per day @Shape: [] 
PackagesDeliveredRegular = data['PackagesDeliveredRegular']
# @Parameter PackagesDeliveredHybrid @Def: Number of packages a hybrid van can deliver per day @Shape: [] 
PackagesDeliveredHybrid = data['PackagesDeliveredHybrid']
# @Parameter PollutantsRegular @Def: Number of pollutant units produced by a regular van per day @Shape: [] 
PollutantsRegular = data['PollutantsRegular']
# @Parameter PollutantsHybrid @Def: Number of pollutant units produced by a hybrid van per day @Shape: [] 
PollutantsHybrid = data['PollutantsHybrid']
# @Parameter MaxPollutants @Def: Maximum allowed pollutant units per day @Shape: [] 
MaxPollutants = data['MaxPollutants']
# @Parameter MinPackages @Def: Minimum required number of packages per day @Shape: [] 
MinPackages = data['MinPackages']

# Variables 
# @Variable RegularVans @Def: The number of regular vans used per day @Shape: [] 
RegularVans = model.addVar(vtype=GRB.INTEGER, name=""RegularVans"")
# @Variable HybridVans @Def: The number of hybrid vans used per day @Shape: [] 
HybridVans = model.addVar(vtype=GRB.INTEGER, name=""HybridVans"")

# Constraints 
# @Constraint Constr_1 @Def: The company must deliver at least MinPackages packages per day.
model.addConstr(RegularVans * PackagesDeliveredRegular + HybridVans * PackagesDeliveredHybrid >= MinPackages)
# @Constraint Constr_2 @Def: Ensure that total pollutants do not exceed MaxPollutants units per day.
model.addConstr(PollutantsRegular * RegularVans + PollutantsHybrid * HybridVans <= MaxPollutants)

# Objective 
# @Objective Objective @Def: Minimize the total number of vans used.
model.setObjective(RegularVans + HybridVans, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['RegularVans'] = RegularVans.x
variables['HybridVans'] = HybridVans.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"In order to make carbon dioxide, wood is burned using two processes, with a catalyst and without a catalyst. The process with a catalyst requires 10 units of wood and 20 units of oxygen to make 15 units of carbon dioxide. The process without a catalyst requires 15 units of wood and 12 units of oxygen to make 18 units of carbon dioxide. There are 300 units of wood and 300 units of oxygen available. How many of each process should be used to maximize the amount of carbon dioxide produced?","{""variables"": {""ProcessUsage"": {""0"": 5.0, ""1"": 16.666666666666668}}, ""objective"": 375.0}","{""parametrized_description"": ""To maximize the production of carbon dioxide, wood is burned using NumProcesses different processes. Each process requires WoodRequiredPerProcess units of wood and OxygenRequiredPerProcess units of oxygen to produce CO2ProducedPerProcess units of carbon dioxide. The total available wood and oxygen are TotalWoodAvailable and TotalOxygenAvailable units, respectively. Determine the number of each process to use to maximize carbon dioxide production."", ""keywords"": [""N.A.""], ""parameters"": {""NumProcesses"": {""description"": ""Number of available processes"", ""shape"": []}, ""WoodRequiredPerProcess"": {""description"": ""Amount of wood required for each process"", ""shape"": [""NumProcesses""]}, ""OxygenRequiredPerProcess"": {""description"": ""Amount of oxygen required for each process"", ""shape"": [""NumProcesses""]}, ""CO2ProducedPerProcess"": {""description"": ""Amount of carbon dioxide produced by each process"", ""shape"": [""NumProcesses""]}, ""TotalWoodAvailable"": {""description"": ""Total amount of wood available"", ""shape"": []}, ""TotalOxygenAvailable"": {""description"": ""Total amount of oxygen available"", ""shape"": []}}, ""variables"": {""ProcessUsage"": {""description"": ""The amount of each process to be used"", ""type"": ""continuous"", ""shape"": [""NumProcesses""]}}, ""constraints"": [{""description"": ""The total wood consumed by all processes cannot exceed TotalWoodAvailable."", ""formulation"": ""\\sum_{i=1}^{NumProcesses} WoodRequiredPerProcess_i \\cdot ProcessUsage_i \\leq TotalWoodAvailable"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(WoodRequiredPerProcess[i] * ProcessUsage[i] for i in range(NumProcesses)) <= TotalWoodAvailable)""}}, {""description"": ""The total oxygen consumed by all processes cannot exceed TotalOxygenAvailable."", ""formulation"": ""\\sum_{i=1}^{\\text{NumProcesses}} \\text{ProcessUsage}_i \\cdot \\text{OxygenRequiredPerProcess}_i \\leq \\text{TotalOxygenAvailable}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ProcessUsage[i] * OxygenRequiredPerProcess[i] for i in range(NumProcesses)) <= TotalOxygenAvailable)""}}], ""objective"": {""description"": ""Maximize the total carbon dioxide production by summing the carbon dioxide produced by each process."", ""formulation"": ""Max \\sum_{i=1}^{NumProcesses} CO2ProducedPerProcess_i \\times ProcessUsage_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(CO2ProducedPerProcess[i] * ProcessUsage[i] for i in range(NumProcesses)), GRB.MAXIMIZE)""}}}","{""NumProcesses"": 2, ""WoodRequiredPerProcess"": [10, 15], ""OxygenRequiredPerProcess"": [20, 12], ""CO2ProducedPerProcess"": [15, 18], ""TotalWoodAvailable"": 300, ""TotalOxygenAvailable"": 300}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
To maximize the production of carbon dioxide, wood is burned using NumProcesses
different processes. Each process requires WoodRequiredPerProcess units of wood
and OxygenRequiredPerProcess units of oxygen to produce CO2ProducedPerProcess
units of carbon dioxide. The total available wood and oxygen are
TotalWoodAvailable and TotalOxygenAvailable units, respectively. Determine the
number of each process to use to maximize carbon dioxide production.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/64/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumProcesses @Def: Number of available processes @Shape: [] 
NumProcesses = data['NumProcesses']
# @Parameter WoodRequiredPerProcess @Def: Amount of wood required for each process @Shape: ['NumProcesses'] 
WoodRequiredPerProcess = data['WoodRequiredPerProcess']
# @Parameter OxygenRequiredPerProcess @Def: Amount of oxygen required for each process @Shape: ['NumProcesses'] 
OxygenRequiredPerProcess = data['OxygenRequiredPerProcess']
# @Parameter CO2ProducedPerProcess @Def: Amount of carbon dioxide produced by each process @Shape: ['NumProcesses'] 
CO2ProducedPerProcess = data['CO2ProducedPerProcess']
# @Parameter TotalWoodAvailable @Def: Total amount of wood available @Shape: [] 
TotalWoodAvailable = data['TotalWoodAvailable']
# @Parameter TotalOxygenAvailable @Def: Total amount of oxygen available @Shape: [] 
TotalOxygenAvailable = data['TotalOxygenAvailable']

# Variables 
# @Variable ProcessUsage @Def: The amount of each process to be used @Shape: ['NumProcesses'] 
ProcessUsage = model.addVars(NumProcesses, vtype=GRB.CONTINUOUS, name=""ProcessUsage"")

# Constraints 
# @Constraint Constr_1 @Def: The total wood consumed by all processes cannot exceed TotalWoodAvailable.
model.addConstr(quicksum(WoodRequiredPerProcess[i] * ProcessUsage[i] for i in range(NumProcesses)) <= TotalWoodAvailable)
# @Constraint Constr_2 @Def: The total oxygen consumed by all processes cannot exceed TotalOxygenAvailable.
model.addConstr(quicksum(ProcessUsage[i] * OxygenRequiredPerProcess[i] for i in range(NumProcesses)) <= TotalOxygenAvailable)

# Objective 
# @Objective Objective @Def: Maximize the total carbon dioxide production by summing the carbon dioxide produced by each process.
model.setObjective(quicksum(CO2ProducedPerProcess[i] * ProcessUsage[i] for i in range(NumProcesses)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ProcessUsage'] = {i: ProcessUsage[i].X for i in range(NumProcesses)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A tea estate has available 500 acres of land and they need to pick the tea leaves either using a traditional machine or modern machine. For each acre of land, the traditional machine can pick 30 kg of tea leaves, creates 10 kg of waste, and requires 20 liters of fuel. For each acre of land, the modern machine can pick 40 kg of tea leaves, creates 15 kg of waste, and requires 15 liters of fuel. The estate has available 9000 liters of fuel can handle at most 6000 kg of waste. For how many acres should each machine be used to maximize the amount of tea leaves that can be picked?","{""variables"": {""AcresUsed"": [300.0, 200.0]}, ""objective"": 17000.0}","{""parametrized_description"": ""A tea estate has TotalAcres of land and needs to pick tea leaves using NumMachineTypes machine types. For each acre, the i-th machine can pick PickRate[i] amount of tea leaves, creates WasteRate[i] amount of waste, and requires FuelRate[i] amount of fuel. The estate has TotalFuel available fuel and can handle at most MaxWaste waste. Determine how many acres each machine should be used to maximize the amount of tea leaves picked."", ""keywords"": [""N.A.""], ""parameters"": {""TotalAcres"": {""description"": ""Total available land in acres"", ""shape"": []}, ""TotalFuel"": {""description"": ""Total available fuel in liters"", ""shape"": []}, ""MaxWaste"": {""description"": ""Maximum allowable waste in kilograms"", ""shape"": []}, ""NumMachineTypes"": {""description"": ""Number of machine types"", ""shape"": []}, ""PickRate"": {""description"": ""Amount of tea leaves picked per acre by each machine type"", ""shape"": [""NumMachineTypes""]}, ""WasteRate"": {""description"": ""Amount of waste created per acre by each machine type"", ""shape"": [""NumMachineTypes""]}, ""FuelRate"": {""description"": ""Amount of fuel required per acre by each machine type"", ""shape"": [""NumMachineTypes""]}}, ""variables"": {""AcresUsed"": {""description"": ""The number of acres used by each machine type"", ""type"": ""continuous"", ""shape"": [""NumMachineTypes""]}}, ""constraints"": [{""description"": ""The total fuel used by all machine types cannot exceed TotalFuel."", ""formulation"": ""\\sum_{i=1}^{\\text{NumMachineTypes}} FuelRate_i \\times AcresUsed_i \\leq TotalFuel"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(FuelRate[i] * AcresUsed[i] for i in range(NumMachineTypes)) <= TotalFuel)""}}, {""description"": ""The total waste generated by all machine types cannot exceed MaxWaste."", ""formulation"": ""\\sum_{i=1}^{NumMachineTypes} WasteRate_i \\cdot AcresUsed_i \\leq MaxWaste"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(WasteRate[i] * AcresUsed[i] for i in range(NumMachineTypes)) <= MaxWaste)""}}, {""description"": ""The total acres allocated to all machine types cannot exceed TotalAcres."", ""formulation"": ""\\sum_{m=1}^{\\text{NumMachineTypes}} \\text{AcresUsed}_m \\leq \\text{TotalAcres}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(AcresUsed[m] for m in range(NumMachineTypes)) <= TotalAcres)""}}], ""objective"": {""description"": ""The amount of tea leaves picked is the sum of PickRate[i] multiplied by the number of acres allocated to each machine type. The objective is to maximize the amount of tea leaves picked."", ""formulation"": ""Max \\sum_{i=1}^{NumMachineTypes} PickRate_i \\times AcresUsed_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(PickRate[i] * AcresUsed[i] for i in range(NumMachineTypes)), GRB.MAXIMIZE)""}}}","{""TotalAcres"": 500, ""TotalFuel"": 9000, ""MaxWaste"": 6000, ""NumMachineTypes"": 2, ""PickRate"": [30, 40], ""WasteRate"": [10, 15], ""FuelRate"": [20, 15]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A tea estate has TotalAcres of land and needs to pick tea leaves using
NumMachineTypes machine types. For each acre, the i-th machine can pick
PickRate[i] amount of tea leaves, creates WasteRate[i] amount of waste, and
requires FuelRate[i] amount of fuel. The estate has TotalFuel available fuel and
can handle at most MaxWaste waste. Determine how many acres each machine should
be used to maximize the amount of tea leaves picked.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/65/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter TotalAcres @Def: Total available land in acres @Shape: [] 
TotalAcres = data['TotalAcres']
# @Parameter TotalFuel @Def: Total available fuel in liters @Shape: [] 
TotalFuel = data['TotalFuel']
# @Parameter MaxWaste @Def: Maximum allowable waste in kilograms @Shape: [] 
MaxWaste = data['MaxWaste']
# @Parameter NumMachineTypes @Def: Number of machine types @Shape: [] 
NumMachineTypes = data['NumMachineTypes']
# @Parameter PickRate @Def: Amount of tea leaves picked per acre by each machine type @Shape: ['NumMachineTypes'] 
PickRate = data['PickRate']
# @Parameter WasteRate @Def: Amount of waste created per acre by each machine type @Shape: ['NumMachineTypes'] 
WasteRate = data['WasteRate']
# @Parameter FuelRate @Def: Amount of fuel required per acre by each machine type @Shape: ['NumMachineTypes'] 
FuelRate = data['FuelRate']
    
# Variables 
# @Variable AcresUsed @Def: The number of acres used by each machine type @Shape: ['NumMachineTypes'] 
AcresUsed = model.addVars(NumMachineTypes, vtype=GRB.CONTINUOUS, name=""AcresUsed"")
    
# Constraints 
# @Constraint Constr_1 @Def: The total fuel used by all machine types cannot exceed TotalFuel.
model.addConstr(quicksum(FuelRate[i] * AcresUsed[i] for i in range(NumMachineTypes)) <= TotalFuel)
# @Constraint Constr_2 @Def: The total waste generated by all machine types cannot exceed MaxWaste.
model.addConstr(quicksum(WasteRate[i] * AcresUsed[i] for i in range(NumMachineTypes)) <= MaxWaste)
# @Constraint Constr_3 @Def: The total acres allocated to all machine types cannot exceed TotalAcres.
model.addConstr(quicksum(AcresUsed[m] for m in range(NumMachineTypes)) <= TotalAcres)
    
# Objective 
# @Objective Objective @Def: The amount of tea leaves picked is the sum of PickRate[i] multiplied by the number of acres allocated to each machine type. The objective is to maximize the amount of tea leaves picked.
model.setObjective(quicksum(PickRate[i] * AcresUsed[i] for i in range(NumMachineTypes)), GRB.MAXIMIZE)
    
# Solve 
model.optimize()
    
# Extract solution 
solution = {}
variables = {}
objective = []
variables['AcresUsed'] = [AcresUsed[i].X for i in range(NumMachineTypes)]
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A grilled cheese shop sells a light and heavy grilled cheese sandwich. A light grilled cheese sandwich requires 2 slices of bread and 3 slices of cheese. A heavy grilled cheese sandwich requires 3 slices of bread and 5 slices of cheese. Since most people who come to the store love grilled cheese, the store must make at least 3 times as many heavy grilled cheese sandwiches as light grilled cheese sandwiches. The store has available 300 slices of bread and 500 slices of cheese. If a light grilled cheese sandwich takes 10 minutes to make and a heavy grilled cheese sandwich takes 15 minutes to make, how many of each should they make to minimize the total production time?","{""variables"": {""LightSandwiches"": 0.0, ""HeavySandwiches"": 0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A grilled cheese shop sells Light and Heavy grilled cheese sandwiches. A Light grilled cheese sandwich requires BreadPerLight slices of bread and CheesePerLight slices of cheese. A Heavy grilled cheese sandwich requires BreadPerHeavy slices of bread and CheesePerHeavy slices of cheese. The store must make at least MinHeavyToLightRatio times as many Heavy grilled cheese sandwiches as Light grilled cheese sandwiches. The store has TotalBread slices of bread and TotalCheese slices of cheese available. A Light grilled cheese sandwich takes TimePerLight minutes to make and a Heavy grilled cheese sandwich takes TimePerHeavy minutes to make. The objective is to minimize the total production time."", ""keywords"": [""N.A.""], ""parameters"": {""BreadPerLight"": {""description"": ""Number of slices of bread required to make one light grilled cheese sandwich"", ""shape"": []}, ""CheesePerLight"": {""description"": ""Number of slices of cheese required to make one light grilled cheese sandwich"", ""shape"": []}, ""BreadPerHeavy"": {""description"": ""Number of slices of bread required to make one heavy grilled cheese sandwich"", ""shape"": []}, ""CheesePerHeavy"": {""description"": ""Number of slices of cheese required to make one heavy grilled cheese sandwich"", ""shape"": []}, ""MinHeavyToLightRatio"": {""description"": ""Minimum ratio of heavy grilled cheese sandwiches to light grilled cheese sandwiches"", ""shape"": []}, ""TotalBread"": {""description"": ""Total number of slices of bread available"", ""shape"": []}, ""TotalCheese"": {""description"": ""Total number of slices of cheese available"", ""shape"": []}, ""TimePerLight"": {""description"": ""Time in minutes to make one light grilled cheese sandwich"", ""shape"": []}, ""TimePerHeavy"": {""description"": ""Time in minutes to make one heavy grilled cheese sandwich"", ""shape"": []}}, ""variables"": {""LightSandwiches"": {""description"": ""The number of light grilled cheese sandwiches produced"", ""type"": ""continuous"", ""shape"": []}, ""HeavySandwiches"": {""description"": ""The number of heavy grilled cheese sandwiches produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of bread slices used for Light and Heavy sandwiches does not exceed TotalBread."", ""formulation"": ""BreadPerLight \\cdot LightSandwiches + BreadPerHeavy \\cdot HeavySandwiches \\leq TotalBread"", ""code"": {""gurobipy"": ""model.addConstr(BreadPerLight * LightSandwiches + BreadPerHeavy * HeavySandwiches <= TotalBread)""}}, {""description"": ""The total number of cheese slices used for Light and Heavy sandwiches does not exceed TotalCheese."", ""formulation"": ""CheesePerLight \\times LightSandwiches + CheesePerHeavy \\times HeavySandwiches \\leq TotalCheese"", ""code"": {""gurobipy"": ""model.addConstr(CheesePerLight * LightSandwiches + CheesePerHeavy * HeavySandwiches <= TotalCheese)""}}, {""description"": ""The number of Heavy grilled cheese sandwiches is at least MinHeavyToLightRatio times the number of Light grilled cheese sandwiches."", ""formulation"": ""HeavySandwiches \\ge MinHeavyToLightRatio \\times LightSandwiches"", ""code"": {""gurobipy"": ""model.addConstr(HeavySandwiches >= MinHeavyToLightRatio * LightSandwiches)""}}], ""objective"": {""description"": ""Total production time is the sum of the production times for Light and Heavy grilled cheese sandwiches. The objective is to minimize the total production time."", ""formulation"": ""Min \\ TimePerLight \\times LightSandwiches + TimePerHeavy \\times HeavySandwiches"", ""code"": {""gurobipy"": ""model.setObjective(TimePerLight * LightSandwiches + TimePerHeavy * HeavySandwiches, GRB.MINIMIZE)""}}}","{""BreadPerLight"": 2, ""CheesePerLight"": 3, ""BreadPerHeavy"": 3, ""CheesePerHeavy"": 5, ""MinHeavyToLightRatio"": 3, ""TotalBread"": 300, ""TotalCheese"": 500, ""TimePerLight"": 10, ""TimePerHeavy"": 15}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A grilled cheese shop sells Light and Heavy grilled cheese sandwiches. A Light
grilled cheese sandwich requires BreadPerLight slices of bread and
CheesePerLight slices of cheese. A Heavy grilled cheese sandwich requires
BreadPerHeavy slices of bread and CheesePerHeavy slices of cheese. The store
must make at least MinHeavyToLightRatio times as many Heavy grilled cheese
sandwiches as Light grilled cheese sandwiches. The store has TotalBread slices
of bread and TotalCheese slices of cheese available. A Light grilled cheese
sandwich takes TimePerLight minutes to make and a Heavy grilled cheese sandwich
takes TimePerHeavy minutes to make. The objective is to minimize the total
production time.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/66/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter BreadPerLight @Def: Number of slices of bread required to make one light grilled cheese sandwich @Shape: [] 
BreadPerLight = data['BreadPerLight']
# @Parameter CheesePerLight @Def: Number of slices of cheese required to make one light grilled cheese sandwich @Shape: [] 
CheesePerLight = data['CheesePerLight']
# @Parameter BreadPerHeavy @Def: Number of slices of bread required to make one heavy grilled cheese sandwich @Shape: [] 
BreadPerHeavy = data['BreadPerHeavy']
# @Parameter CheesePerHeavy @Def: Number of slices of cheese required to make one heavy grilled cheese sandwich @Shape: [] 
CheesePerHeavy = data['CheesePerHeavy']
# @Parameter MinHeavyToLightRatio @Def: Minimum ratio of heavy grilled cheese sandwiches to light grilled cheese sandwiches @Shape: [] 
MinHeavyToLightRatio = data['MinHeavyToLightRatio']
# @Parameter TotalBread @Def: Total number of slices of bread available @Shape: [] 
TotalBread = data['TotalBread']
# @Parameter TotalCheese @Def: Total number of slices of cheese available @Shape: [] 
TotalCheese = data['TotalCheese']
# @Parameter TimePerLight @Def: Time in minutes to make one light grilled cheese sandwich @Shape: [] 
TimePerLight = data['TimePerLight']
# @Parameter TimePerHeavy @Def: Time in minutes to make one heavy grilled cheese sandwich @Shape: [] 
TimePerHeavy = data['TimePerHeavy']

# Variables 
# @Variable LightSandwiches @Def: The number of light grilled cheese sandwiches produced @Shape: [] 
LightSandwiches = model.addVar(vtype=GRB.CONTINUOUS, name=""LightSandwiches"")
# @Variable HeavySandwiches @Def: The number of heavy grilled cheese sandwiches produced @Shape: [] 
HeavySandwiches = model.addVar(vtype=GRB.CONTINUOUS, name=""HeavySandwiches"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of bread slices used for Light and Heavy sandwiches does not exceed TotalBread.
model.addConstr(BreadPerLight * LightSandwiches + BreadPerHeavy * HeavySandwiches <= TotalBread)
# @Constraint Constr_2 @Def: The total number of cheese slices used for Light and Heavy sandwiches does not exceed TotalCheese.
model.addConstr(CheesePerLight * LightSandwiches + CheesePerHeavy * HeavySandwiches <= TotalCheese)
# @Constraint Constr_3 @Def: The number of Heavy grilled cheese sandwiches is at least MinHeavyToLightRatio times the number of Light grilled cheese sandwiches.
model.addConstr(HeavySandwiches >= MinHeavyToLightRatio * LightSandwiches)

# Objective 
# @Objective Objective @Def: Total production time is the sum of the production times for Light and Heavy grilled cheese sandwiches. The objective is to minimize the total production time.
model.setObjective(TimePerLight * LightSandwiches + TimePerHeavy * HeavySandwiches, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['LightSandwiches'] = LightSandwiches.x
variables['HeavySandwiches'] = HeavySandwiches.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A post office is buying stamping machines and they can buy a dual or single model stamping machine. A dual model stamping machine can stamp 50 letters per minute while a single model stamping machine can stamp 30 letters per minute. The dual model stamping machine requires 20 units of glue per minute while the single model stamping machine requires 15 units of glue per minute. Since the single model stamping machine is quieter, the number of single model stamping machines must be more than the number of dual model stamping machines. Further, the post office wants to make sure they can stamp at least 300 letters per minute and use at most 135 units of glue per minute. How many of each stamping machine should they purchase to minimize the total number of stamping machines?","{""variables"": {""SingleStampMachines"": 5.0, ""DualStampMachines"": 3.0}, ""objective"": 8.0}","{""parametrized_description"": ""A post office is purchasing dual and single model stamping machines. A dual model stamping machine stamps DualStampRate letters per minute and uses DualGlueUsage units of glue per minute. A single model stamping machine stamps SingleStampRate letters per minute and uses SingleGlueUsage units of glue per minute. The number of single model stamping machines must exceed the number of dual model stamping machines. The post office must stamp at least MinTotalLetters letters per minute and use at most MaxGlueUsage units of glue per minute. The objective is to minimize the total number of stamping machines purchased."", ""keywords"": [""N.A.""], ""parameters"": {""DualStampRate"": {""description"": ""Stamping rate of dual model stamping machine (letters per minute)"", ""shape"": []}, ""DualGlueUsage"": {""description"": ""Glue usage rate of dual model stamping machine (units per minute)"", ""shape"": []}, ""SingleStampRate"": {""description"": ""Stamping rate of single model stamping machine (letters per minute)"", ""shape"": []}, ""SingleGlueUsage"": {""description"": ""Glue usage rate of single model stamping machine (units per minute)"", ""shape"": []}, ""MinTotalLetters"": {""description"": ""Minimum total letters to be stamped per minute"", ""shape"": []}, ""MaxGlueUsage"": {""description"": ""Maximum total glue usage per minute"", ""shape"": []}}, ""variables"": {""SingleStampMachines"": {""description"": ""The number of single model stamping machines"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""DualStampMachines"": {""description"": ""The number of dual model stamping machines"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The number of single model stamping machines must exceed the number of dual model stamping machines."", ""formulation"": ""SingleStampMachines \\geq DualStampMachines + 1"", ""code"": {""gurobipy"": ""model.addConstr(SingleStampMachines >= DualStampMachines + 1)""}}, {""description"": ""The post office must stamp at least MinTotalLetters letters per minute."", ""formulation"": ""SingleStampRate \\cdot SingleStampMachines + DualStampRate \\cdot DualStampMachines \\geq MinTotalLetters"", ""code"": {""gurobipy"": ""model.addConstr(SingleStampRate * SingleStampMachines + DualStampRate * DualStampMachines >= MinTotalLetters)""}}, {""description"": ""The post office must use at most MaxGlueUsage units of glue per minute."", ""formulation"": ""SingleGlueUsage \\cdot SingleStampMachines + DualGlueUsage \\cdot DualStampMachines \\leq MaxGlueUsage"", ""code"": {""gurobipy"": ""model.addConstr(SingleGlueUsage * SingleStampMachines + DualGlueUsage * DualStampMachines <= MaxGlueUsage)""}}], ""objective"": {""description"": ""Minimize the total number of stamping machines purchased."", ""formulation"": ""Min \\left( SingleStampMachines + DualStampMachines \\right)"", ""code"": {""gurobipy"": ""model.setObjective(SingleStampMachines + DualStampMachines, GRB.MINIMIZE)""}}}","{""DualStampRate"": 50, ""DualGlueUsage"": 20, ""SingleStampRate"": 30, ""SingleGlueUsage"": 15, ""MinTotalLetters"": 300, ""MaxGlueUsage"": 135}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A post office is purchasing dual and single model stamping machines. A dual
model stamping machine stamps DualStampRate letters per minute and uses
DualGlueUsage units of glue per minute. A single model stamping machine stamps
SingleStampRate letters per minute and uses SingleGlueUsage units of glue per
minute. The number of single model stamping machines must exceed the number of
dual model stamping machines. The post office must stamp at least
MinTotalLetters letters per minute and use at most MaxGlueUsage units of glue
per minute. The objective is to minimize the total number of stamping machines
purchased.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/67/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter DualStampRate @Def: Stamping rate of dual model stamping machine (letters per minute) @Shape: [] 
DualStampRate = data['DualStampRate']
# @Parameter DualGlueUsage @Def: Glue usage rate of dual model stamping machine (units per minute) @Shape: [] 
DualGlueUsage = data['DualGlueUsage']
# @Parameter SingleStampRate @Def: Stamping rate of single model stamping machine (letters per minute) @Shape: [] 
SingleStampRate = data['SingleStampRate']
# @Parameter SingleGlueUsage @Def: Glue usage rate of single model stamping machine (units per minute) @Shape: [] 
SingleGlueUsage = data['SingleGlueUsage']
# @Parameter MinTotalLetters @Def: Minimum total letters to be stamped per minute @Shape: [] 
MinTotalLetters = data['MinTotalLetters']
# @Parameter MaxGlueUsage @Def: Maximum total glue usage per minute @Shape: [] 
MaxGlueUsage = data['MaxGlueUsage']

# Variables 
# @Variable SingleStampMachines @Def: The number of single model stamping machines @Shape: ['Integer'] 
SingleStampMachines = model.addVar(vtype=GRB.INTEGER, name=""SingleStampMachines"")
# @Variable DualStampMachines @Def: The number of dual model stamping machines @Shape: ['Integer'] 
DualStampMachines = model.addVar(vtype=GRB.INTEGER, name=""DualStampMachines"")

# Constraints 
# @Constraint Constr_1 @Def: The number of single model stamping machines must exceed the number of dual model stamping machines.
model.addConstr(SingleStampMachines >= DualStampMachines + 1)
# @Constraint Constr_2 @Def: The post office must stamp at least MinTotalLetters letters per minute.
model.addConstr(SingleStampRate * SingleStampMachines + DualStampRate * DualStampMachines >= MinTotalLetters)
# @Constraint Constr_3 @Def: The post office must use at most MaxGlueUsage units of glue per minute.
model.addConstr(SingleGlueUsage * SingleStampMachines + DualGlueUsage * DualStampMachines <= MaxGlueUsage)

# Objective 
# @Objective Objective @Def: Minimize the total number of stamping machines purchased.
model.setObjective(SingleStampMachines + DualStampMachines, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SingleStampMachines'] = SingleStampMachines.x
variables['DualStampMachines'] = DualStampMachines.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A banana company sells their bananas in small and large crates. A small crate can hold 20 bananas while a large crate can hole 50 bananas. Since large crates are more manageable, the number of large crates must be at least twice the number of small crates. However, at least 5 small crates should be used. If the company has available 500 bananas, how many of each crate should the company use to maximize the total number of crates produced?",{},"{""parametrized_description"": ""A banana company sells their bananas in small and large crates. A small crate can hold CapacitySmallCrate bananas while a large crate can hold CapacityLargeCrate bananas. The number of large crates must be at least LargeToSmallRatio times the number of small crates. At least MinSmallCrates should be used. If the company has available TotalBananas bananas, how many of each crate should the company use to maximize the total number of crates produced?"", ""keywords"": [""N.A.""], ""parameters"": {""CapacitySmallCrate"": {""description"": ""Number of bananas a small crate can hold"", ""shape"": []}, ""CapacityLargeCrate"": {""description"": ""Number of bananas a large crate can hold"", ""shape"": []}, ""TotalBananas"": {""description"": ""Total number of bananas available"", ""shape"": []}, ""MinSmallCrates"": {""description"": ""Minimum number of small crates to be used"", ""shape"": []}, ""LargeToSmallRatio"": {""description"": ""Minimum multiple of small crates that large crates must be"", ""shape"": []}}, ""variables"": {""SmallCrates"": {""description"": ""The number of small crates"", ""type"": ""continuous"", ""shape"": []}, ""LargeCrates"": {""description"": ""The number of large crates"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of large crates must be at least LargeToSmallRatio times the number of small crates."", ""formulation"": ""LargeCrates \\geq LargeToSmallRatio \\times SmallCrates"", ""code"": {""gurobipy"": ""model.addConstr(LargeCrates >= LargeToSmallRatio * SmallCrates)""}}, {""description"": ""At least MinSmallCrates should be used."", ""formulation"": ""SmallCrates \\geq MinSmallCrates"", ""code"": {""gurobipy"": ""model.addConstr(SmallCrates >= MinSmallCrates)""}}, {""description"": ""The total number of bananas used by small and large crates cannot exceed TotalBananas."", ""formulation"": ""CapacitySmallCrate \\times SmallCrates + CapacityLargeCrate \\times LargeCrates \\leq TotalBananas"", ""code"": {""gurobipy"": ""model.addConstr(CapacitySmallCrate * SmallCrates + CapacityLargeCrate * LargeCrates <= TotalBananas)""}}], ""objective"": {""description"": ""The total number of crates produced is the sum of small and large crates. The objective is to maximize the total number of crates produced."", ""formulation"": ""Max \\ SmallCrates + LargeCrates"", ""code"": {""gurobipy"": ""model.setObjective(SmallCrates + LargeCrates, GRB.MAXIMIZE)""}}}","{""CapacitySmallCrate"": 20, ""CapacityLargeCrate"": 50, ""TotalBananas"": 500, ""MinSmallCrates"": 5, ""LargeToSmallRatio"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A banana company sells their bananas in small and large crates. A small crate
can hold CapacitySmallCrate bananas while a large crate can hold
CapacityLargeCrate bananas. The number of large crates must be at least
LargeToSmallRatio times the number of small crates. At least MinSmallCrates
should be used. If the company has available TotalBananas bananas, how many of
each crate should the company use to maximize the total number of crates
produced?
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/68/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CapacitySmallCrate @Def: Number of bananas a small crate can hold @Shape: [] 
CapacitySmallCrate = data['CapacitySmallCrate']
# @Parameter CapacityLargeCrate @Def: Number of bananas a large crate can hold @Shape: [] 
CapacityLargeCrate = data['CapacityLargeCrate']
# @Parameter TotalBananas @Def: Total number of bananas available @Shape: [] 
TotalBananas = data['TotalBananas']
# @Parameter MinSmallCrates @Def: Minimum number of small crates to be used @Shape: [] 
MinSmallCrates = data['MinSmallCrates']
# @Parameter LargeToSmallRatio @Def: Minimum multiple of small crates that large crates must be @Shape: [] 
LargeToSmallRatio = data['LargeToSmallRatio']

# Variables 
# @Variable SmallCrates @Def: The number of small crates @Shape: [] 
SmallCrates = model.addVar(vtype=GRB.INTEGER, lb=MinSmallCrates, name=""SmallCrates"")
# @Variable LargeCrates @Def: The number of large crates @Shape: [] 
LargeCrates = model.addVar(vtype=GRB.INTEGER, name=""LargeCrates"")

# Constraints 
# @Constraint Constr_1 @Def: The number of large crates must be at least LargeToSmallRatio times the number of small crates.
model.addConstr(LargeCrates >= LargeToSmallRatio * SmallCrates)
# @Constraint Constr_2 @Def: At least MinSmallCrates should be used.
model.addConstr(SmallCrates >= MinSmallCrates)
# @Constraint Constr_3 @Def: The total number of bananas used by small and large crates cannot exceed TotalBananas.
model.addConstr(CapacitySmallCrate * SmallCrates + CapacityLargeCrate * LargeCrates <= TotalBananas)

# Objective 
# @Objective Objective @Def: The total number of crates produced is the sum of small and large crates. The objective is to maximize the total number of crates produced.
model.setObjective(SmallCrates + LargeCrates, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SmallCrates'] = SmallCrates.x
variables['LargeCrates'] = LargeCrates.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A crepe store sells chocolate and peanut butter crepes. A chocolate crepe requires 3 units of chocolate spread and 6 units of crepe mix. A peanut butter crepe requires 4 units of peanut butter spread and 7 units of crepe mix. Recently, the peanut butter crepe has been more popular and therefore the number of peanut butter crepes made must exceed the number of chocolate crepes made. However at least 25% of the crepes made should be chocolate. The store has available 400 units of chocolate spread and 450 units of peanut butter spread. How many of each should the store make to minimize the total amount of crepe mix needed?","{""variables"": {""NumberOfChocolateCrepes"": 1.0, ""NumberOfPeanutButterCrepes"": 2.0}, ""objective"": 20.0}","{""parametrized_description"": ""A crepe store produces two types of crepes: chocolate and peanut butter. Each chocolate crepe requires ChocolateSpreadPerChocolateCrepe units of chocolate spread and CrepeMixPerChocolateCrepe units of crepe mix. Each peanut butter crepe requires PeanutButterSpreadPerPeanutButterCrepe units of peanut butter spread and CrepeMixPerPeanutButterCrepe units of crepe mix. The number of peanut butter crepes produced must exceed the number of chocolate crepes, and at least MinimumProportionChocolateCrepes proportion of the total crepes must be chocolate. The store has TotalAvailableChocolateSpread units of chocolate spread and TotalAvailablePeanutButterSpread units of peanut butter spread available. The objective is to determine the number of each type of crepe to minimize the total amount of crepe mix used."", ""keywords"": [""N.A.""], ""parameters"": {""ChocolateSpreadPerChocolateCrepe"": {""description"": ""Amount of chocolate spread required to make one chocolate crepe"", ""shape"": []}, ""PeanutButterSpreadPerPeanutButterCrepe"": {""description"": ""Amount of peanut butter spread required to make one peanut butter crepe"", ""shape"": []}, ""CrepeMixPerChocolateCrepe"": {""description"": ""Amount of crepe mix required to make one chocolate crepe"", ""shape"": []}, ""CrepeMixPerPeanutButterCrepe"": {""description"": ""Amount of crepe mix required to make one peanut butter crepe"", ""shape"": []}, ""TotalAvailableChocolateSpread"": {""description"": ""Total available units of chocolate spread"", ""shape"": []}, ""TotalAvailablePeanutButterSpread"": {""description"": ""Total available units of peanut butter spread"", ""shape"": []}, ""MinimumProportionChocolateCrepes"": {""description"": ""Minimum proportion of crepes that must be chocolate"", ""shape"": []}}, ""variables"": {""NumberOfChocolateCrepes"": {""description"": ""The number of chocolate crepes made"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfPeanutButterCrepes"": {""description"": ""The number of peanut butter crepes made"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total amount of chocolate spread used is equal to ChocolateSpreadPerChocolateCrepe multiplied by the number of chocolate crepes. This must not exceed TotalAvailableChocolateSpread."", ""formulation"": ""ChocolateSpreadPerChocolateCrepe \\times NumberOfChocolateCrepes \\leq TotalAvailableChocolateSpread"", ""code"": {""gurobipy"": ""model.addConstr(ChocolateSpreadPerChocolateCrepe * NumberOfChocolateCrepes <= TotalAvailableChocolateSpread)""}}, {""description"": ""The total amount of peanut butter spread used is equal to PeanutButterSpreadPerPeanutButterCrepe multiplied by the number of peanut butter crepes. This must not exceed TotalAvailablePeanutButterSpread."", ""formulation"": ""PeanutButterSpreadPerPeanutButterCrepe \\times NumberOfPeanutButterCrepes \\leq TotalAvailablePeanutButterSpread"", ""code"": {""gurobipy"": ""model.addConstr(PeanutButterSpreadPerPeanutButterCrepe * NumberOfPeanutButterCrepes <= TotalAvailablePeanutButterSpread)""}}, {""description"": ""The number of peanut butter crepes produced must exceed the number of chocolate crepes."", ""formulation"": ""NumberOfPeanutButterCrepes \\geq NumberOfChocolateCrepes + 1"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfPeanutButterCrepes >= NumberOfChocolateCrepes + 1)""}}, {""description"": ""At least MinimumProportionChocolateCrepes proportion of the total crepes produced must be chocolate crepes."", ""formulation"": ""NumberOfChocolateCrepes \\geq MinimumProportionChocolateCrepes \\cdot (NumberOfChocolateCrepes + NumberOfPeanutButterCrepes)"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfChocolateCrepes >= MinimumProportionChocolateCrepes * (NumberOfChocolateCrepes + NumberOfPeanutButterCrepes))""}}], ""objective"": {""description"": ""Minimize the total amount of crepe mix used, which is the sum of CrepeMixPerChocolateCrepe multiplied by the number of chocolate crepes and CrepeMixPerPeanutButterCrepe multiplied by the number of peanut butter crepes."", ""formulation"": ""Min \\ CrepeMixPerChocolateCrepe \\times NumberOfChocolateCrepes + CrepeMixPerPeanutButterCrepe \\times NumberOfPeanutButterCrepes"", ""code"": {""gurobipy"": ""model.setObjective(CrepeMixPerChocolateCrepe * NumberOfChocolateCrepes + CrepeMixPerPeanutButterCrepe * NumberOfPeanutButterCrepes, GRB.MINIMIZE)""}}}","{""ChocolateSpreadPerChocolateCrepe"": 3, ""PeanutButterSpreadPerPeanutButterCrepe"": 4, ""CrepeMixPerChocolateCrepe"": 6, ""CrepeMixPerPeanutButterCrepe"": 7, ""TotalAvailableChocolateSpread"": 400, ""TotalAvailablePeanutButterSpread"": 450, ""MinimumProportionChocolateCrepes"": 0.25}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A crepe store produces two types of crepes: chocolate and peanut butter. Each
chocolate crepe requires ChocolateSpreadPerChocolateCrepe units of chocolate
spread and CrepeMixPerChocolateCrepe units of crepe mix. Each peanut butter
crepe requires PeanutButterSpreadPerPeanutButterCrepe units of peanut butter
spread and CrepeMixPerPeanutButterCrepe units of crepe mix. The number of peanut
butter crepes produced must exceed the number of chocolate crepes, and at least
MinimumProportionChocolateCrepes proportion of the total crepes must be
chocolate. The store has TotalAvailableChocolateSpread units of chocolate spread
and TotalAvailablePeanutButterSpread units of peanut butter spread available.
The objective is to determine the number of each type of crepe to minimize the
total amount of crepe mix used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/69/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ChocolateSpreadPerChocolateCrepe @Def: Amount of chocolate spread required to make one chocolate crepe @Shape: [] 
ChocolateSpreadPerChocolateCrepe = data['ChocolateSpreadPerChocolateCrepe']
# @Parameter PeanutButterSpreadPerPeanutButterCrepe @Def: Amount of peanut butter spread required to make one peanut butter crepe @Shape: [] 
PeanutButterSpreadPerPeanutButterCrepe = data['PeanutButterSpreadPerPeanutButterCrepe']
# @Parameter CrepeMixPerChocolateCrepe @Def: Amount of crepe mix required to make one chocolate crepe @Shape: [] 
CrepeMixPerChocolateCrepe = data['CrepeMixPerChocolateCrepe']
# @Parameter CrepeMixPerPeanutButterCrepe @Def: Amount of crepe mix required to make one peanut butter crepe @Shape: [] 
CrepeMixPerPeanutButterCrepe = data['CrepeMixPerPeanutButterCrepe']
# @Parameter TotalAvailableChocolateSpread @Def: Total available units of chocolate spread @Shape: [] 
TotalAvailableChocolateSpread = data['TotalAvailableChocolateSpread']
# @Parameter TotalAvailablePeanutButterSpread @Def: Total available units of peanut butter spread @Shape: [] 
TotalAvailablePeanutButterSpread = data['TotalAvailablePeanutButterSpread']
# @Parameter MinimumProportionChocolateCrepes @Def: Minimum proportion of crepes that must be chocolate @Shape: [] 
MinimumProportionChocolateCrepes = data['MinimumProportionChocolateCrepes']

# Variables 
# @Variable NumberOfChocolateCrepes @Def: The number of chocolate crepes made @Shape: [] 
NumberOfChocolateCrepes = model.addVar(vtype=GRB.INTEGER, name=""NumberOfChocolateCrepes"")
# @Variable NumberOfPeanutButterCrepes @Def: The number of peanut butter crepes made @Shape: [] 
NumberOfPeanutButterCrepes = model.addVar(vtype=GRB.INTEGER, name=""NumberOfPeanutButterCrepes"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of chocolate spread used is equal to ChocolateSpreadPerChocolateCrepe multiplied by the number of chocolate crepes. This must not exceed TotalAvailableChocolateSpread.
model.addConstr(ChocolateSpreadPerChocolateCrepe * NumberOfChocolateCrepes <= TotalAvailableChocolateSpread)
# @Constraint Constr_2 @Def: The total amount of peanut butter spread used is equal to PeanutButterSpreadPerPeanutButterCrepe multiplied by the number of peanut butter crepes. This must not exceed TotalAvailablePeanutButterSpread.
model.addConstr(PeanutButterSpreadPerPeanutButterCrepe * NumberOfPeanutButterCrepes <= TotalAvailablePeanutButterSpread)
# @Constraint Constr_3 @Def: The number of peanut butter crepes produced must exceed the number of chocolate crepes.
model.addConstr(NumberOfPeanutButterCrepes >= NumberOfChocolateCrepes + 1)
# @Constraint Constr_4 @Def: At least MinimumProportionChocolateCrepes proportion of the total crepes produced must be chocolate crepes.
model.addConstr(NumberOfChocolateCrepes >= MinimumProportionChocolateCrepes * (NumberOfChocolateCrepes + NumberOfPeanutButterCrepes))

# Objective 
# @Objective Objective @Def: Minimize the total amount of crepe mix used, which is the sum of CrepeMixPerChocolateCrepe multiplied by the number of chocolate crepes and CrepeMixPerPeanutButterCrepe multiplied by the number of peanut butter crepes.
model.setObjective(CrepeMixPerChocolateCrepe * NumberOfChocolateCrepes + CrepeMixPerPeanutButterCrepe * NumberOfPeanutButterCrepes, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfChocolateCrepes'] = NumberOfChocolateCrepes.x
variables['NumberOfPeanutButterCrepes'] = NumberOfPeanutButterCrepes.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A fire department employs regular and emergency fire fighters. A regular fire fighter works 10 hours per shift and earns $300. An emergency fire fighter works 6 hours per shift and earns $100. Due to wildfires in the region, the fire department needs at least 300 hours of fire fighter time. If the fire department has a budget of $7000, how many of each should the fire department hire to minimize the total number of fire fighters?","{""variables"": {""ShiftsPerType"": {""0"": 15.0, ""1"": 25.0}}, ""objective"": 40.0}","{""parametrized_description"": ""A fire department employs NumFireFighterTypes different fire fighter types. Each fire fighter type works HoursPerShift hours per shift and incurs CostPerShift cost per shift. The fire department needs at least TotalHoursRequired fire fighter hours and has a budget of Budget. The objective is to minimize the total number of fire fighters."", ""keywords"": [""N.A.""], ""parameters"": {""NumFireFighterTypes"": {""description"": ""Number of fire fighter types"", ""shape"": []}, ""HoursPerShift"": {""description"": ""Amount of hours each fire fighter type works per shift"", ""shape"": [""NumFireFighterTypes""]}, ""CostPerShift"": {""description"": ""Cost of each fire fighter type per shift"", ""shape"": [""NumFireFighterTypes""]}, ""TotalHoursRequired"": {""description"": ""Total required fire fighter hours"", ""shape"": []}, ""Budget"": {""description"": ""Total available budget"", ""shape"": []}}, ""variables"": {""ShiftsPerType"": {""description"": ""The number of shifts for each fire fighter type"", ""type"": ""continuous"", ""shape"": [""NumFireFighterTypes""]}}, ""constraints"": [{""description"": ""The fire department needs at least TotalHoursRequired fire fighter hours."", ""formulation"": ""\\sum_{i=1}^{\\text{NumFireFighterTypes}} \\text{HoursPerShift}_i \\text{ShiftsPerType}_i \\geq \\text{TotalHoursRequired}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(HoursPerShift[i] * ShiftsPerType[i] for i in range(NumFireFighterTypes)) >= TotalHoursRequired)""}}, {""description"": ""The fire department has a budget of Budget."", ""formulation"": ""\\sum_{t=1}^{NumFireFighterTypes} ShiftsPerType_t \\times CostPerShift_t \\leq Budget"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ShiftsPerType[t] * CostPerShift[t] for t in range(NumFireFighterTypes)) <= Budget)""}}], ""objective"": {""description"": ""Minimize the total number of fire fighters."", ""formulation"": ""Min \\sum_{t=1}^{\\text{NumFireFighterTypes}} \\text{ShiftsPerType}_{t}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ShiftsPerType[t] for t in range(NumFireFighterTypes)), GRB.MINIMIZE)""}}}","{""NumFireFighterTypes"": 2, ""HoursPerShift"": [10, 6], ""CostPerShift"": [300, 100], ""TotalHoursRequired"": 300, ""Budget"": 7000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A fire department employs NumFireFighterTypes different fire fighter types. Each
fire fighter type works HoursPerShift hours per shift and incurs CostPerShift
cost per shift. The fire department needs at least TotalHoursRequired fire
fighter hours and has a budget of Budget. The objective is to minimize the total
number of fire fighters.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/70/parameters.json"", ""r"") as f:
    data = json.load(f)
        
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumFireFighterTypes @Def: Number of fire fighter types @Shape: [] 
NumFireFighterTypes = data['NumFireFighterTypes']
# @Parameter HoursPerShift @Def: Amount of hours each fire fighter type works per shift @Shape: ['NumFireFighterTypes'] 
HoursPerShift = data['HoursPerShift']
# @Parameter CostPerShift @Def: Cost of each fire fighter type per shift @Shape: ['NumFireFighterTypes'] 
CostPerShift = data['CostPerShift']
# @Parameter TotalHoursRequired @Def: Total required fire fighter hours @Shape: [] 
TotalHoursRequired = data['TotalHoursRequired']
# @Parameter Budget @Def: Total available budget @Shape: [] 
Budget = data['Budget']

# Variables 
# @Variable ShiftsPerType @Def: The number of shifts for each fire fighter type @Shape: ['NumFireFighterTypes'] 
ShiftsPerType = model.addVars(NumFireFighterTypes, vtype=GRB.INTEGER, name=""ShiftsPerType"")

# Constraints 
# @Constraint Constr_1 @Def: The fire department needs at least TotalHoursRequired fire fighter hours.
model.addConstr(quicksum(HoursPerShift[i] * ShiftsPerType[i] for i in range(NumFireFighterTypes)) >= TotalHoursRequired)
# @Constraint Constr_2 @Def: The fire department has a budget of Budget.
model.addConstr(quicksum(ShiftsPerType[t] * CostPerShift[t] for t in range(NumFireFighterTypes)) <= Budget)

# Objective 
# @Objective Objective @Def: Minimize the total number of fire fighters.
model.setObjective(quicksum(ShiftsPerType[t] for t in range(NumFireFighterTypes)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ShiftsPerType'] = {i: ShiftsPerType[i].x for i in range(NumFireFighterTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A mall buys two types of hand sanitizer machines, a motion activated one and a manual one. The motion activated one can deliver 50 drops per minute and consumes 30 kWh. The manual one can deliver 75 drops per minute and consumes 20 kWh. Since the motion activated one is more hygienic, at most 40% of the machines can be manual. In addition, at least 3 should be motion activated. If the mall must be able to deliver at least 1000 drops per minute and can use at most 500 kWh per minute, how many of each machine should they buy to minimize the total number of machines?","{""variables"": {""ManualMachines"": 6.0, ""MotionActivatedMachines"": 11.0, ""TotalMachines"": 17.0}, ""objective"": 17.0}","{""parametrized_description"": ""Determine the number of motion activated machines and manual machines to minimize the total number of machines, ensuring that the number of manual machines does not exceed MaxManualPercentage of the total machines, at least MinMotionActivatedMachines are motion activated, the combined drop rate is at least MinTotalDrops, and the total energy consumption does not exceed MaxTotalEnergy."", ""keywords"": [""N.A.""], ""parameters"": {""MotionActivatedDropRate"": {""description"": ""Drop rate (drops per minute) of motion activated machine"", ""shape"": []}, ""MotionActivatedEnergyConsumption"": {""description"": ""Energy consumption (kWh) of motion activated machine"", ""shape"": []}, ""ManualDropRate"": {""description"": ""Drop rate (drops per minute) of manual machine"", ""shape"": []}, ""ManualEnergyConsumption"": {""description"": ""Energy consumption (kWh) of manual machine"", ""shape"": []}, ""MaxManualPercentage"": {""description"": ""Maximum percentage of machines that can be manual"", ""shape"": []}, ""MinMotionActivatedMachines"": {""description"": ""Minimum number of motion activated machines"", ""shape"": []}, ""MinTotalDrops"": {""description"": ""Minimum total drop delivery (drops per minute)"", ""shape"": []}, ""MaxTotalEnergy"": {""description"": ""Maximum total energy consumption (kWh per minute)"", ""shape"": []}}, ""variables"": {""ManualMachines"": {""description"": ""The number of manual machines"", ""type"": ""continuous"", ""shape"": []}, ""MotionActivatedMachines"": {""description"": ""The number of motion activated machines"", ""type"": ""continuous"", ""shape"": []}, ""TotalMachines"": {""description"": ""The total number of machines"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of manual machines does not exceed MaxManualPercentage of the total machines."", ""formulation"": ""ManualMachines \\leq MaxManualPercentage \\times (ManualMachines + MotionActivatedMachines)"", ""code"": {""gurobipy"": ""model.addConstr((1 - MaxManualPercentage) * ManualMachines - MaxManualPercentage * MotionActivatedMachines <= 0)""}}, {""description"": ""At least MinMotionActivatedMachines are motion activated."", ""formulation"": ""MotionActivatedMachines \\geq MinMotionActivatedMachines"", ""code"": {""gurobipy"": ""model.addConstr(MotionActivatedMachines >= MinMotionActivatedMachines)""}}, {""description"": ""The combined drop rate is at least MinTotalDrops."", ""formulation"": ""MotionActivatedDropRate \\times MotionActivatedMachines + ManualDropRate \\times ManualMachines \\geq MinTotalDrops"", ""code"": {""gurobipy"": ""model.addConstr(MotionActivatedDropRate * MotionActivatedMachines + ManualDropRate * ManualMachines >= MinTotalDrops)""}}, {""description"": ""The total energy consumption does not exceed MaxTotalEnergy."", ""formulation"": ""ManualMachines \\cdot ManualEnergyConsumption + MotionActivatedMachines \\cdot MotionActivatedEnergyConsumption \\leq MaxTotalEnergy"", ""code"": {""gurobipy"": ""model.addConstr(ManualMachines * ManualEnergyConsumption + MotionActivatedMachines * MotionActivatedEnergyConsumption <= MaxTotalEnergy)""}}, {""description"": ""The total number of machines is equal to the sum of manual and motion-activated machines."", ""formulation"": ""TotalMachines = ManualMachines + MotionActivatedMachines"", ""code"": {""gurobipy"": ""model.addConstr(TotalMachines == ManualMachines + MotionActivatedMachines)""}}], ""objective"": {""description"": ""Minimize the total number of machines."", ""formulation"": ""Minimize\\ TotalMachines"", ""code"": {""gurobipy"": ""model.setObjective(TotalMachines, GRB.MINIMIZE)""}}}","{""MotionActivatedDropRate"": 50, ""MotionActivatedEnergyConsumption"": 30, ""ManualDropRate"": 75, ""ManualEnergyConsumption"": 20, ""MaxManualPercentage"": 0.4, ""MinMotionActivatedMachines"": 3, ""MinTotalDrops"": 1000, ""MaxTotalEnergy"": 500}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Determine the number of motion activated machines and manual machines to
minimize the total number of machines, ensuring that the number of manual
machines does not exceed MaxManualPercentage of the total machines, at least
MinMotionActivatedMachines are motion activated, the combined drop rate is at
least MinTotalDrops, and the total energy consumption does not exceed
MaxTotalEnergy.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/71/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MotionActivatedDropRate @Def: Drop rate (drops per minute) of motion activated machine @Shape: [] 
MotionActivatedDropRate = data['MotionActivatedDropRate']
# @Parameter MotionActivatedEnergyConsumption @Def: Energy consumption (kWh) of motion activated machine @Shape: [] 
MotionActivatedEnergyConsumption = data['MotionActivatedEnergyConsumption']
# @Parameter ManualDropRate @Def: Drop rate (drops per minute) of manual machine @Shape: [] 
ManualDropRate = data['ManualDropRate']
# @Parameter ManualEnergyConsumption @Def: Energy consumption (kWh) of manual machine @Shape: [] 
ManualEnergyConsumption = data['ManualEnergyConsumption']
# @Parameter MaxManualPercentage @Def: Maximum percentage of machines that can be manual @Shape: [] 
MaxManualPercentage = data['MaxManualPercentage']
# @Parameter MinMotionActivatedMachines @Def: Minimum number of motion activated machines @Shape: [] 
MinMotionActivatedMachines = data['MinMotionActivatedMachines']
# @Parameter MinTotalDrops @Def: Minimum total drop delivery (drops per minute) @Shape: [] 
MinTotalDrops = data['MinTotalDrops']
# @Parameter MaxTotalEnergy @Def: Maximum total energy consumption (kWh per minute) @Shape: [] 
MaxTotalEnergy = data['MaxTotalEnergy']

# Variables 
# @Variable ManualMachines @Def: The number of manual machines @Shape: [] 
ManualMachines = model.addVar(vtype=GRB.INTEGER, name=""ManualMachines"")
# @Variable MotionActivatedMachines @Def: The number of motion activated machines @Shape: [] 
MotionActivatedMachines = model.addVar(vtype=GRB.INTEGER, name=""MotionActivatedMachines"")
# @Variable TotalMachines @Def: The total number of machines @Shape: [] 
TotalMachines = model.addVar(vtype=GRB.INTEGER, name=""TotalMachines"")

# Constraints 
# @Constraint Constr_1 @Def: The number of manual machines does not exceed MaxManualPercentage of the total machines.
model.addConstr((1 - MaxManualPercentage) * ManualMachines - MaxManualPercentage * MotionActivatedMachines <= 0)
# @Constraint Constr_2 @Def: At least MinMotionActivatedMachines are motion activated.
model.addConstr(MotionActivatedMachines >= MinMotionActivatedMachines)
# @Constraint Constr_3 @Def: The combined drop rate is at least MinTotalDrops.
model.addConstr(MotionActivatedDropRate * MotionActivatedMachines + ManualDropRate * ManualMachines >= MinTotalDrops)
# @Constraint Constr_4 @Def: The total energy consumption does not exceed MaxTotalEnergy.
model.addConstr(ManualMachines * ManualEnergyConsumption + MotionActivatedMachines * MotionActivatedEnergyConsumption <= MaxTotalEnergy)
# @Constraint Constr_5 @Def: The total number of machines is equal to the sum of manual and motion-activated machines.
model.addConstr(TotalMachines == ManualMachines + MotionActivatedMachines)

# Objective 
# @Objective Objective @Def: Minimize the total number of machines.
model.setObjective(TotalMachines, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ManualMachines'] = ManualMachines.x
variables['MotionActivatedMachines'] = MotionActivatedMachines.x
variables['TotalMachines'] = TotalMachines.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A hot dog company can build two types of butcher shops, a small shop and a large shop. A small shop can make 30 hot dogs per day and requires 2 workers. A large shop can make 70 hot dogs per day and requires 4 workers. The company must make at least 500 hot dogs per day but they only have available 30 workers. How many of each butcher shop should the company build to minimize the total number of butcher shops?","{""variables"": {""NumberOfSmallShops"": 1.0, ""NumberOfLargeShops"": 7.0}, ""objective"": 8.0}","{""parametrized_description"": ""A company can build two types of butcher shops: small shops that produce HotDogsPerSmallShop hot dogs per day and require WorkersPerSmallShop workers each, and large shops that produce HotDogsPerLargeShop hot dogs per day and require WorkersPerLargeShop workers each. The company must produce at least MinimumHotDogsPerDay hot dogs per day and has AvailableWorkers workers available. The objective is to minimize the total number of butcher shops built."", ""keywords"": [""N.A.""], ""parameters"": {""HotDogsPerSmallShop"": {""description"": ""Number of hot dogs produced per small shop per day"", ""shape"": []}, ""WorkersPerSmallShop"": {""description"": ""Number of workers required for a small shop"", ""shape"": []}, ""HotDogsPerLargeShop"": {""description"": ""Number of hot dogs produced per large shop per day"", ""shape"": []}, ""WorkersPerLargeShop"": {""description"": ""Number of workers required for a large shop"", ""shape"": []}, ""MinimumHotDogsPerDay"": {""description"": ""Minimum number of hot dogs to be produced per day"", ""shape"": []}, ""AvailableWorkers"": {""description"": ""Total number of available workers"", ""shape"": []}}, ""variables"": {""NumberOfSmallShops"": {""description"": ""Number of small shops"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfLargeShops"": {""description"": ""Number of large shops"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""HotDogsPerSmallShop * NumberOfSmallShops + HotDogsPerLargeShop * NumberOfLargeShops >= MinimumHotDogsPerDay"", ""formulation"": ""HotDogsPerSmallShop \\cdot NumberOfSmallShops + HotDogsPerLargeShop \\cdot NumberOfLargeShops \\geq MinimumHotDogsPerDay"", ""code"": {""gurobipy"": ""model.addConstr(HotDogsPerSmallShop * NumberOfSmallShops + HotDogsPerLargeShop * NumberOfLargeShops >= MinimumHotDogsPerDay)""}}, {""description"": ""WorkersPerSmallShop * NumberOfSmallShops + WorkersPerLargeShop * NumberOfLargeShops <= AvailableWorkers"", ""formulation"": ""WorkersPerSmallShop \\cdot NumberOfSmallShops + WorkersPerLargeShop \\cdot NumberOfLargeShops \\leq AvailableWorkers"", ""code"": {""gurobipy"": ""model.addConstr(WorkersPerSmallShop * NumberOfSmallShops + WorkersPerLargeShop * NumberOfLargeShops <= AvailableWorkers)""}}], ""objective"": {""description"": ""Minimize the total number of butcher shops built, calculated as NumberOfSmallShops + NumberOfLargeShops."", ""formulation"": ""\\min (NumberOfSmallShops + NumberOfLargeShops)"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfSmallShops + NumberOfLargeShops, GRB.MINIMIZE)""}}}","{""HotDogsPerSmallShop"": 30, ""WorkersPerSmallShop"": 2, ""HotDogsPerLargeShop"": 70, ""WorkersPerLargeShop"": 4, ""MinimumHotDogsPerDay"": 500, ""AvailableWorkers"": 30}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company can build two types of butcher shops: small shops that produce
HotDogsPerSmallShop hot dogs per day and require WorkersPerSmallShop workers
each, and large shops that produce HotDogsPerLargeShop hot dogs per day and
require WorkersPerLargeShop workers each. The company must produce at least
MinimumHotDogsPerDay hot dogs per day and has AvailableWorkers workers
available. The objective is to minimize the total number of butcher shops built.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/72/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter HotDogsPerSmallShop @Def: Number of hot dogs produced per small shop per day @Shape: [] 
HotDogsPerSmallShop = data['HotDogsPerSmallShop']
# @Parameter WorkersPerSmallShop @Def: Number of workers required for a small shop @Shape: [] 
WorkersPerSmallShop = data['WorkersPerSmallShop']
# @Parameter HotDogsPerLargeShop @Def: Number of hot dogs produced per large shop per day @Shape: [] 
HotDogsPerLargeShop = data['HotDogsPerLargeShop']
# @Parameter WorkersPerLargeShop @Def: Number of workers required for a large shop @Shape: [] 
WorkersPerLargeShop = data['WorkersPerLargeShop']
# @Parameter MinimumHotDogsPerDay @Def: Minimum number of hot dogs to be produced per day @Shape: [] 
MinimumHotDogsPerDay = data['MinimumHotDogsPerDay']
# @Parameter AvailableWorkers @Def: Total number of available workers @Shape: [] 
AvailableWorkers = data['AvailableWorkers']

# Variables 
# @Variable NumberOfSmallShops @Def: Number of small shops @Shape: [] 
NumberOfSmallShops = model.addVar(vtype=GRB.INTEGER, name=""NumberOfSmallShops"")
# @Variable NumberOfLargeShops @Def: Number of large shops @Shape: [] 
NumberOfLargeShops = model.addVar(vtype=GRB.INTEGER, name=""NumberOfLargeShops"")

# Constraints 
# @Constraint Constr_1 @Def: HotDogsPerSmallShop * NumberOfSmallShops + HotDogsPerLargeShop * NumberOfLargeShops >= MinimumHotDogsPerDay
model.addConstr(HotDogsPerSmallShop * NumberOfSmallShops + HotDogsPerLargeShop * NumberOfLargeShops >= MinimumHotDogsPerDay)
# @Constraint Constr_2 @Def: WorkersPerSmallShop * NumberOfSmallShops + WorkersPerLargeShop * NumberOfLargeShops <= AvailableWorkers
model.addConstr(WorkersPerSmallShop * NumberOfSmallShops + WorkersPerLargeShop * NumberOfLargeShops <= AvailableWorkers)

# Objective 
# @Objective Objective @Def: Minimize the total number of butcher shops built, calculated as NumberOfSmallShops + NumberOfLargeShops.
model.setObjective(NumberOfSmallShops + NumberOfLargeShops, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfSmallShops'] = NumberOfSmallShops.x
variables['NumberOfLargeShops'] = NumberOfLargeShops.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An airport buys two types of vehicles, a 4-wheeler and 3-wheeler, to help move luggage. A 4-wheeler vehicle can move 60 luggage per day and produces 30 units of pollutant per day. A 3-wheeler vehicle can move 40 luggage per day and produces 15 units of pollutant per day. The airport needs to be able to move at least 1000 luggage per day. To avoid over-polluting the airport, they can produce at most 430 units of pollutant per day. How many of each vehicle should the airport buy to minimize the total number of vehicles needed.  ","{""variables"": {""NumberOfVehicles"": {""0"": 6.0, ""1"": 16.0}}, ""objective"": 22.0}","{""parametrized_description"": ""An airport buys NumVehicleTypes types of vehicles. Each vehicle type can move LuggageCapacity luggage per day and produces PollutantPerVehicleType units of pollutant per day. The airport needs to move at least MinLuggageRequired luggage per day and can produce at most MaxPollutantAllowed units of pollutant per day. Determine the number of each vehicle type to minimize the total number of vehicles needed."", ""keywords"": [""N.A.""], ""parameters"": {""NumVehicleTypes"": {""description"": ""Number of vehicle types"", ""shape"": []}, ""MinLuggageRequired"": {""description"": ""Minimum number of luggage to move per day"", ""shape"": []}, ""MaxPollutantAllowed"": {""description"": ""Maximum pollutant allowed per day"", ""shape"": []}, ""LuggageCapacity"": {""description"": ""Luggage capacity per vehicle type per day"", ""shape"": [""NumVehicleTypes""]}, ""PollutantPerVehicleType"": {""description"": ""Pollutant produced per vehicle type per day"", ""shape"": [""NumVehicleTypes""]}}, ""variables"": {""NumberOfVehicles"": {""description"": ""The number of vehicles of each type used per day"", ""type"": ""continuous"", ""shape"": [""NumVehicleTypes""]}}, ""constraints"": [{""description"": ""Each vehicle type can move LuggageCapacity luggage per day. The airport needs to move at least MinLuggageRequired luggage per day."", ""formulation"": ""\\sum_{i=1}^{NumVehicleTypes} LuggageCapacity_i \\cdot NumberOfVehicles_i \\geq MinLuggageRequired"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(LuggageCapacity[i] * NumberOfVehicles[i] for i in range(NumVehicleTypes)) >= MinLuggageRequired)""}}, {""description"": ""Each vehicle type produces PollutantPerVehicleType units of pollutant per day. The airport can produce at most MaxPollutantAllowed units of pollutant per day."", ""formulation"": ""\\sum_{t=1}^{NumVehicleTypes} PollutantPerVehicleType_t \\cdot NumberOfVehicles_t \\leq MaxPollutantAllowed"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(PollutantPerVehicleType[t] * NumberOfVehicles[t] for t in range(NumVehicleTypes)) <= MaxPollutantAllowed)""}}], ""objective"": {""description"": ""The objective is to minimize the total number of vehicles needed."", ""formulation"": ""Min \\sum_{i=1}^{NumVehicleTypes} NumberOfVehicles_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(NumberOfVehicles[i] for i in range(NumVehicleTypes)), GRB.MINIMIZE)""}}}","{""NumVehicleTypes"": 2, ""MinLuggageRequired"": 1000, ""MaxPollutantAllowed"": 430, ""LuggageCapacity"": [60, 40], ""PollutantPerVehicleType"": [30, 15]}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
An airport buys NumVehicleTypes types of vehicles. Each vehicle type can move
LuggageCapacity luggage per day and produces PollutantPerVehicleType units of
pollutant per day. The airport needs to move at least MinLuggageRequired luggage
per day and can produce at most MaxPollutantAllowed units of pollutant per day.
Determine the number of each vehicle type to minimize the total number of
vehicles needed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/73/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumVehicleTypes @Def: Number of vehicle types @Shape: [] 
NumVehicleTypes = data['NumVehicleTypes']
# @Parameter MinLuggageRequired @Def: Minimum number of luggage to move per day @Shape: [] 
MinLuggageRequired = data['MinLuggageRequired']
# @Parameter MaxPollutantAllowed @Def: Maximum pollutant allowed per day @Shape: [] 
MaxPollutantAllowed = data['MaxPollutantAllowed']
# @Parameter LuggageCapacity @Def: Luggage capacity per vehicle type per day @Shape: ['NumVehicleTypes'] 
LuggageCapacity = data['LuggageCapacity']
# @Parameter PollutantPerVehicleType @Def: Pollutant produced per vehicle type per day @Shape: ['NumVehicleTypes'] 
PollutantPerVehicleType = data['PollutantPerVehicleType']

# Variables 
# @Variable NumberOfVehicles @Def: The number of vehicles of each type used per day @Shape: ['NumVehicleTypes'] 
NumberOfVehicles = model.addVars(NumVehicleTypes, vtype=GRB.INTEGER, name=""NumberOfVehicles"")

# Constraints 
# @Constraint Constr_1 @Def: Each vehicle type can move LuggageCapacity luggage per day. The airport needs to move at least MinLuggageRequired luggage per day.
model.addConstr(quicksum(LuggageCapacity[i] * NumberOfVehicles[i] for i in range(NumVehicleTypes)) >= MinLuggageRequired)
# @Constraint Constr_2 @Def: Each vehicle type produces PollutantPerVehicleType units of pollutant per day. The airport can produce at most MaxPollutantAllowed units of pollutant per day.
model.addConstr(quicksum(PollutantPerVehicleType[t] * NumberOfVehicles[t] for t in range(NumVehicleTypes)) <= MaxPollutantAllowed)

# Objective 
# @Objective Objective @Def: The objective is to minimize the total number of vehicles needed.
model.setObjective(quicksum(NumberOfVehicles[i] for i in range(NumVehicleTypes)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfVehicles'] = model.getAttr(""X"", NumberOfVehicles)
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A scientist is conducting two experiments to produce electricity, experiment alpha and experiment beta. In experiment alpha, 3 units of metal and 5 units of acid are required to produce 8 units of electricity. In experiment beta, 5 units of metal and 4 units of acid are required to produced 10 units of electricity. The lab has 800 units of metal and 750 units of acid available. How many of each experiment should the scientist conduct to maximize the total amount of electricity produced?","{""variables"": {""ConductExperiment"": {""0"": 42.30769230769231, ""1"": 134.6153846153846}}, ""objective"": 1684.6153846153848}","{""parametrized_description"": ""A scientist is conducting NumExperiments different experiments to produce electricity. Each experiment i produces ElectricityProduced[i] units of electricity and requires specific amounts of NumResources types of resources as defined by ResourceRequired[j][i]. The laboratory has ResourceAvailable[j] units of each resource available. The scientist aims to determine the number of each experiment to conduct in order to maximize the total electricity produced."", ""keywords"": [""N.A.""], ""parameters"": {""NumExperiments"": {""description"": ""Number of experiments"", ""shape"": []}, ""NumResources"": {""description"": ""Number of resource types"", ""shape"": []}, ""ResourceAvailable"": {""description"": ""Amount of resource j available"", ""shape"": [""NumResources""]}, ""ResourceRequired"": {""description"": ""Amount of resource j required for experiment i"", ""shape"": [""NumResources"", ""NumExperiments""]}, ""ElectricityProduced"": {""description"": ""Amount of electricity produced by experiment i"", ""shape"": [""NumExperiments""]}}, ""variables"": {""ConductExperiment"": {""description"": ""The number of times each experiment is conducted"", ""type"": ""continuous"", ""shape"": [""NumExperiments""]}}, ""constraints"": [{""description"": ""The total metal required for all experiments does not exceed the available metal."", ""formulation"": ""\\sum_{i=1}^{NumExperiments} ResourceRequired_{\\text{Metal},i} \\cdot ConductExperiment_i \\leq ResourceAvailable_{\\text{Metal}}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ResourceRequired[0][i] * ConductExperiment[i] for i in range(NumExperiments)) <= ResourceAvailable[0])""}}, {""description"": ""The total acid required for all experiments does not exceed the available acid."", ""formulation"": ""\\sum_{i=1}^{\\text{NumExperiments}} \\text{ResourceRequired}_{\\text{acid}, i} \\cdot \\text{ConductExperiment}_i \\leq \\text{ResourceAvailable}_{\\text{acid}}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ResourceRequired['acid'][i] * ConductExperiment[i] for i in range(NumExperiments)) <= ResourceAvailable['acid'])""}}], ""objective"": {""description"": ""Maximize the total electricity produced by conducting the experiments."", ""formulation"": ""Max \\sum_{i=1}^{NumExperiments} ConductExperiment_{i} \\times ElectricityProduced_{i}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ConductExperiment[i] * ElectricityProduced[i] for i in range(NumExperiments)), GRB.MAXIMIZE)""}}}","{""NumExperiments"": 2, ""NumResources"": 2, ""ResourceAvailable"": [800, 750], ""ResourceRequired"": [[3, 5], [5, 4]], ""ElectricityProduced"": [8, 10]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A scientist is conducting NumExperiments different experiments to produce
electricity. Each experiment i produces ElectricityProduced[i] units of
electricity and requires specific amounts of NumResources types of resources as
defined by ResourceRequired[j][i]. The laboratory has ResourceAvailable[j] units
of each resource available. The scientist aims to determine the number of each
experiment to conduct in order to maximize the total electricity produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/74/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumExperiments @Def: Number of experiments @Shape: [] 
NumExperiments = data['NumExperiments']
# @Parameter NumResources @Def: Number of resource types @Shape: [] 
NumResources = data['NumResources']
# @Parameter ResourceAvailable @Def: Amount of resource j available @Shape: ['NumResources'] 
ResourceAvailable = data['ResourceAvailable']
# @Parameter ResourceRequired @Def: Amount of resource j required for experiment i @Shape: ['NumResources', 'NumExperiments'] 
ResourceRequired = data['ResourceRequired']
# @Parameter ElectricityProduced @Def: Amount of electricity produced by experiment i @Shape: ['NumExperiments'] 
ElectricityProduced = data['ElectricityProduced']

# Variables 
# @Variable ConductExperiment @Def: The number of times each experiment is conducted @Shape: ['NumExperiments'] 
ConductExperiment = model.addVars(NumExperiments, vtype=GRB.CONTINUOUS, name=""ConductExperiment"")

# Constraints 
# @Constraint Constr_1 @Def: The total metal required for all experiments does not exceed the available metal.
model.addConstr(quicksum(ResourceRequired[0][i] * ConductExperiment[i] for i in range(NumExperiments)) <= ResourceAvailable[0])
# @Constraint Constr_2 @Def: The total acid required for all experiments does not exceed the available acid.
model.addConstr(quicksum(ResourceRequired[1][i] * ConductExperiment[i] for i in range(NumExperiments)) <= ResourceAvailable[1])

# Objective 
# @Objective Objective @Def: Maximize the total electricity produced by conducting the experiments.
model.setObjective(quicksum(ConductExperiment[i] * ElectricityProduced[i] for i in range(NumExperiments)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ConductExperiment'] = {i: ConductExperiment[i].X for i in range(NumExperiments)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A man fishes in a 250 acre lake and can catch fish either using a net or fishing line. For each acre of the lake, using a net will catch 8 fish and requires 4 units of bait but also causes 2 units of pain for the fisherman. For each acre of the lake, using a fishing line will catch 5 fish and requires 3 units of bait but also causes 1 unit of pain for the fisherman. The fisherman has available 800 units of bait and can tolerate at most 350 units of pain. For how many acres each should he use each fishing method to maximize the amount of fish he can catch?","{""variables"": {""AcresNet"": 50.0, ""AcresLine"": 200.0}, ""objective"": 1400.0}","{""parametrized_description"": ""A man fishes in a lake of TotalLakeArea acres and can catch fish either using a net or fishing line. For each acre of the lake, using a net will catch FishPerAcreNet fish and requires BaitPerAcreNet units of bait but also causes PainPerAcreNet units of pain for the fisherman. For each acre of the lake, using a fishing line will catch FishPerAcreLine fish and requires BaitPerAcreLine units of bait but also causes PainPerAcreLine units of pain for the fisherman. The fisherman has available TotalAvailableBait units of bait and can tolerate at most MaxTotalPain units of pain. Determine the number of acres to allocate to each fishing method to maximize the number of fish caught."", ""keywords"": [""N.A.""], ""parameters"": {""TotalLakeArea"": {""description"": ""Total area of the lake in acres"", ""shape"": []}, ""FishPerAcreNet"": {""description"": ""Number of fish caught per acre using a net"", ""shape"": []}, ""BaitPerAcreNet"": {""description"": ""Units of bait required per acre using a net"", ""shape"": []}, ""PainPerAcreNet"": {""description"": ""Units of pain caused per acre using a net"", ""shape"": []}, ""FishPerAcreLine"": {""description"": ""Number of fish caught per acre using a fishing line"", ""shape"": []}, ""BaitPerAcreLine"": {""description"": ""Units of bait required per acre using a fishing line"", ""shape"": []}, ""PainPerAcreLine"": {""description"": ""Units of pain caused per acre using a fishing line"", ""shape"": []}, ""TotalAvailableBait"": {""description"": ""Total available units of bait"", ""shape"": []}, ""MaxTotalPain"": {""description"": ""Maximum tolerable units of pain"", ""shape"": []}}, ""variables"": {""AcresNet"": {""description"": ""Number of acres allocated to net"", ""type"": ""continuous"", ""shape"": [""Continuous""]}, ""AcresLine"": {""description"": ""Number of acres allocated to fishing line"", ""type"": ""continuous"", ""shape"": [""Continuous""]}}, ""constraints"": [{""description"": ""The total number of acres allocated to net and fishing line must equal TotalLakeArea."", ""formulation"": ""AcresNet + AcresLine = TotalLakeArea"", ""code"": {""gurobipy"": ""model.addConstr(AcresNet + AcresLine == TotalLakeArea)""}}, {""description"": ""The total bait used by net and fishing line cannot exceed TotalAvailableBait units."", ""formulation"": ""BaitPerAcreNet \\cdot AcresNet + BaitPerAcreLine \\cdot AcresLine \\leq TotalAvailableBait"", ""code"": {""gurobipy"": ""model.addConstr(BaitPerAcreNet * AcresNet + BaitPerAcreLine * AcresLine <= TotalAvailableBait)""}}, {""description"": ""The total pain caused by net and fishing line cannot exceed MaxTotalPain units."", ""formulation"": ""PainPerAcreNet \\cdot AcresNet + PainPerAcreLine \\cdot AcresLine \\leq MaxTotalPain"", ""code"": {""gurobipy"": ""model.addConstr(PainPerAcreNet * AcresNet + PainPerAcreLine * AcresLine <= MaxTotalPain)""}}], ""objective"": {""description"": ""The total number of fish caught is the sum of the fish caught using net and fishing line. The objective is to maximize the total number of fish caught while adhering to constraints on bait usage and pain tolerance."", ""formulation"": ""Max \\, FishPerAcreNet \\times AcresNet + FishPerAcreLine \\times AcresLine"", ""code"": {""gurobipy"": ""model.setObjective(FishPerAcreNet * AcresNet + FishPerAcreLine * AcresLine, GRB.MAXIMIZE)""}}}","{""TotalLakeArea"": 250, ""FishPerAcreNet"": 8, ""BaitPerAcreNet"": 4, ""PainPerAcreNet"": 2, ""FishPerAcreLine"": 5, ""BaitPerAcreLine"": 3, ""PainPerAcreLine"": 1, ""TotalAvailableBait"": 800, ""MaxTotalPain"": 350}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A man fishes in a lake of TotalLakeArea acres and can catch fish either using a
net or fishing line. For each acre of the lake, using a net will catch
FishPerAcreNet fish and requires BaitPerAcreNet units of bait but also causes
PainPerAcreNet units of pain for the fisherman. For each acre of the lake, using
a fishing line will catch FishPerAcreLine fish and requires BaitPerAcreLine
units of bait but also causes PainPerAcreLine units of pain for the fisherman.
The fisherman has available TotalAvailableBait units of bait and can tolerate at
most MaxTotalPain units of pain. Determine the number of acres to allocate to
each fishing method to maximize the number of fish caught.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/75/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalLakeArea @Def: Total area of the lake in acres @Shape: [] 
TotalLakeArea = data['TotalLakeArea']
# @Parameter FishPerAcreNet @Def: Number of fish caught per acre using a net @Shape: [] 
FishPerAcreNet = data['FishPerAcreNet']
# @Parameter BaitPerAcreNet @Def: Units of bait required per acre using a net @Shape: [] 
BaitPerAcreNet = data['BaitPerAcreNet']
# @Parameter PainPerAcreNet @Def: Units of pain caused per acre using a net @Shape: [] 
PainPerAcreNet = data['PainPerAcreNet']
# @Parameter FishPerAcreLine @Def: Number of fish caught per acre using a fishing line @Shape: [] 
FishPerAcreLine = data['FishPerAcreLine']
# @Parameter BaitPerAcreLine @Def: Units of bait required per acre using a fishing line @Shape: [] 
BaitPerAcreLine = data['BaitPerAcreLine']
# @Parameter PainPerAcreLine @Def: Units of pain caused per acre using a fishing line @Shape: [] 
PainPerAcreLine = data['PainPerAcreLine']
# @Parameter TotalAvailableBait @Def: Total available units of bait @Shape: [] 
TotalAvailableBait = data['TotalAvailableBait']
# @Parameter MaxTotalPain @Def: Maximum tolerable units of pain @Shape: [] 
MaxTotalPain = data['MaxTotalPain']

# Variables 
# @Variable AcresNet @Def: Number of acres allocated to net @Shape: ['Continuous'] 
AcresNet = model.addVar(vtype=GRB.CONTINUOUS, name=""AcresNet"")
# @Variable AcresLine @Def: Number of acres allocated to fishing line @Shape: ['Continuous'] 
AcresLine = model.addVar(vtype=GRB.CONTINUOUS, name=""AcresLine"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of acres allocated to net and fishing line must equal TotalLakeArea.
model.addConstr(AcresNet + AcresLine == TotalLakeArea)
# @Constraint Constr_2 @Def: The total bait used by net and fishing line cannot exceed TotalAvailableBait units.
model.addConstr(BaitPerAcreNet * AcresNet + BaitPerAcreLine * AcresLine <= TotalAvailableBait)
# @Constraint Constr_3 @Def: The total pain caused by net and fishing line cannot exceed MaxTotalPain units.
model.addConstr(PainPerAcreNet * AcresNet + PainPerAcreLine * AcresLine <= MaxTotalPain)

# Objective 
# @Objective Objective @Def: The total number of fish caught is the sum of the fish caught using net and fishing line. The objective is to maximize the total number of fish caught while adhering to constraints on bait usage and pain tolerance.
model.setObjective(FishPerAcreNet * AcresNet + FishPerAcreLine * AcresLine, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['AcresNet'] = AcresNet.x
variables['AcresLine'] = AcresLine.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A coffee shop sells mochas and regular coffees. Each mocha requires 3 units of coffee powder and 6 units of milk. Each regular coffee requires 6 units of coffee powder and 2 units of milk. The shop has available 400 units of coffee powder and 500 units of milk. Making a mocha takes 5 minutes and making a regular coffee takes 3 minutes. Since mochas are more popular among people, the shop must make at least 3 times as many mochas as regular coffees. How many of each should they make to minimize the total production time?","{""variables"": {""NumMocha"": -0.0, ""NumRegularCoffee"": -0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A coffee shop produces two products, Mochas and Regular Coffees. Each Mocha requires CoffeePowderPerMocha units of coffee powder and MilkPerMocha units of milk. Each Regular Coffee requires CoffeePowderPerRegularCoffee units of coffee powder and MilkPerRegularCoffee units of milk. The shop has AvailableCoffeePowder units of coffee powder and AvailableMilk units of milk available. Producing one Mocha takes TimePerMocha minutes and one Regular Coffee takes TimePerRegularCoffee minutes. The number of Mochas produced must be at least MochaToRegularRatio times the number of Regular Coffees produced. Determine the number of Mochas and Regular Coffees to produce to minimize the total production time."", ""keywords"": [""N.A.""], ""parameters"": {""CoffeePowderPerMocha"": {""description"": ""Amount of coffee powder required to produce one mocha"", ""shape"": []}, ""MilkPerMocha"": {""description"": ""Amount of milk required to produce one mocha"", ""shape"": []}, ""CoffeePowderPerRegularCoffee"": {""description"": ""Amount of coffee powder required to produce one regular coffee"", ""shape"": []}, ""MilkPerRegularCoffee"": {""description"": ""Amount of milk required to produce one regular coffee"", ""shape"": []}, ""AvailableCoffeePowder"": {""description"": ""Total available units of coffee powder"", ""shape"": []}, ""AvailableMilk"": {""description"": ""Total available units of milk"", ""shape"": []}, ""TimePerMocha"": {""description"": ""Time taken to produce one mocha"", ""shape"": []}, ""TimePerRegularCoffee"": {""description"": ""Time taken to produce one regular coffee"", ""shape"": []}, ""MochaToRegularRatio"": {""description"": ""Minimum multiple of mochas required compared to regular coffees"", ""shape"": []}}, ""variables"": {""NumMocha"": {""description"": ""The number of Mochas produced"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumRegularCoffee"": {""description"": ""The number of Regular Coffees produced"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total coffee powder used by Mochas and Regular Coffees does not exceed AvailableCoffeePowder."", ""formulation"": ""CoffeePowderPerMocha \\cdot NumMocha + CoffeePowderPerRegularCoffee \\cdot NumRegularCoffee \\leq AvailableCoffeePowder"", ""code"": {""gurobipy"": ""model.addConstr(CoffeePowderPerMocha * NumMocha + CoffeePowderPerRegularCoffee * NumRegularCoffee <= AvailableCoffeePowder)""}}, {""description"": ""The total milk used by Mochas and Regular Coffees does not exceed AvailableMilk."", ""formulation"": ""MilkPerMocha \\times NumMocha + MilkPerRegularCoffee \\times NumRegularCoffee \\leq AvailableMilk"", ""code"": {""gurobipy"": ""model.addConstr(MilkPerMocha * NumMocha + MilkPerRegularCoffee * NumRegularCoffee <= AvailableMilk)""}}, {""description"": ""The number of Mochas produced is at least MochaToRegularRatio times the number of Regular Coffees produced."", ""formulation"": ""NumMocha \\geq MochaToRegularRatio \\times NumRegularCoffee"", ""code"": {""gurobipy"": ""model.addConstr(NumMocha >= MochaToRegularRatio * NumRegularCoffee)""}}], ""objective"": {""description"": ""Minimize the total production time, which is the sum of (TimePerMocha \u00d7 number of Mochas) and (TimePerRegularCoffee \u00d7 number of Regular Coffees)."", ""formulation"": ""Min\\ TimePerMocha \\times NumMocha + TimePerRegularCoffee \\times NumRegularCoffee"", ""code"": {""gurobipy"": ""model.setObjective(TimePerMocha * NumMocha + TimePerRegularCoffee * NumRegularCoffee, GRB.MINIMIZE)""}}}","{""CoffeePowderPerMocha"": 3, ""MilkPerMocha"": 6, ""CoffeePowderPerRegularCoffee"": 6, ""MilkPerRegularCoffee"": 2, ""AvailableCoffeePowder"": 400, ""AvailableMilk"": 500, ""TimePerMocha"": 5, ""TimePerRegularCoffee"": 3, ""MochaToRegularRatio"": 3}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A coffee shop produces two products, Mochas and Regular Coffees. Each Mocha
requires CoffeePowderPerMocha units of coffee powder and MilkPerMocha units of
milk. Each Regular Coffee requires CoffeePowderPerRegularCoffee units of coffee
powder and MilkPerRegularCoffee units of milk. The shop has
AvailableCoffeePowder units of coffee powder and AvailableMilk units of milk
available. Producing one Mocha takes TimePerMocha minutes and one Regular Coffee
takes TimePerRegularCoffee minutes. The number of Mochas produced must be at
least MochaToRegularRatio times the number of Regular Coffees produced.
Determine the number of Mochas and Regular Coffees to produce to minimize the
total production time.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/76/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CoffeePowderPerMocha @Def: Amount of coffee powder required to produce one mocha @Shape: [] 
CoffeePowderPerMocha = data['CoffeePowderPerMocha']
# @Parameter MilkPerMocha @Def: Amount of milk required to produce one mocha @Shape: [] 
MilkPerMocha = data['MilkPerMocha']
# @Parameter CoffeePowderPerRegularCoffee @Def: Amount of coffee powder required to produce one regular coffee @Shape: [] 
CoffeePowderPerRegularCoffee = data['CoffeePowderPerRegularCoffee']
# @Parameter MilkPerRegularCoffee @Def: Amount of milk required to produce one regular coffee @Shape: [] 
MilkPerRegularCoffee = data['MilkPerRegularCoffee']
# @Parameter AvailableCoffeePowder @Def: Total available units of coffee powder @Shape: [] 
AvailableCoffeePowder = data['AvailableCoffeePowder']
# @Parameter AvailableMilk @Def: Total available units of milk @Shape: [] 
AvailableMilk = data['AvailableMilk']
# @Parameter TimePerMocha @Def: Time taken to produce one mocha @Shape: [] 
TimePerMocha = data['TimePerMocha']
# @Parameter TimePerRegularCoffee @Def: Time taken to produce one regular coffee @Shape: [] 
TimePerRegularCoffee = data['TimePerRegularCoffee']
# @Parameter MochaToRegularRatio @Def: Minimum multiple of mochas required compared to regular coffees @Shape: [] 
MochaToRegularRatio = data['MochaToRegularRatio']

# Variables 
# @Variable NumMocha @Def: The number of Mochas produced @Shape: ['Integer'] 
NumMocha = model.addVar(vtype=GRB.INTEGER, name=""NumMocha"")
# @Variable NumRegularCoffee @Def: The number of Regular Coffees produced @Shape: ['Integer'] 
NumRegularCoffee = model.addVar(vtype=GRB.INTEGER, name=""NumRegularCoffee"")

# Constraints 
# @Constraint Constr_1 @Def: The total coffee powder used by Mochas and Regular Coffees does not exceed AvailableCoffeePowder.
model.addConstr(CoffeePowderPerMocha * NumMocha + CoffeePowderPerRegularCoffee * NumRegularCoffee <= AvailableCoffeePowder)
# @Constraint Constr_2 @Def: The total milk used by Mochas and Regular Coffees does not exceed AvailableMilk.
model.addConstr(MilkPerMocha * NumMocha + MilkPerRegularCoffee * NumRegularCoffee <= AvailableMilk)
# @Constraint Constr_3 @Def: The number of Mochas produced is at least MochaToRegularRatio times the number of Regular Coffees produced.
model.addConstr(NumMocha >= MochaToRegularRatio * NumRegularCoffee)

# Objective 
# @Objective Objective @Def: Minimize the total production time, which is the sum of (TimePerMocha × number of Mochas) and (TimePerRegularCoffee × number of Regular Coffees).
model.setObjective(TimePerMocha * NumMocha + TimePerRegularCoffee * NumRegularCoffee, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumMocha'] = NumMocha.x
variables['NumRegularCoffee'] = NumRegularCoffee.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A butcher shop is buying meat slicers for their shop, a manual and automatic slicer. The manual slicer can cut 5 slices per minute while the automatic slicer can cut 8 slices per minute. In addition, to make sure all the parts operate smoothly, the manual slicer requires 3 units of grease per minute while the automatic slicer requires 6 units of grease per minute. Since the automatic slicer does not need someone to operate it, the number of manual slicers must be less than the number of automatic slicers. In addition, the butcher shop needs to be able to cut at least 50 slices per minute but can use at most 35 units of grease per minute. How many of each slicer should the butcher shop buy to minimize the total number of slicers in the shop?",{},"{""parametrized_description"": ""The butcher shop purchases a certain number of Manual and Automatic slicers. Each Manual slicer can cut ManualSliceRate slices per minute and requires ManualGreaseRate units of grease per minute. Each Automatic slicer can cut AutomaticSliceRate slices per minute and requires AutomaticGreaseRate units of grease per minute. The total number of slices cut per minute must be at least MinimumSlicesPerMinute. The total grease usage per minute must not exceed MaximumGreasePerMinute. Additionally, the number of Manual slicers must be less than the number of Automatic slicers. The objective is to minimize the total number of slicers."", ""keywords"": [""N.A.""], ""parameters"": {""ManualSliceRate"": {""description"": ""The number of slices a manual slicer can cut per minute"", ""shape"": []}, ""AutomaticSliceRate"": {""description"": ""The number of slices an automatic slicer can cut per minute"", ""shape"": []}, ""ManualGreaseRate"": {""description"": ""The number of units of grease a manual slicer requires per minute"", ""shape"": []}, ""AutomaticGreaseRate"": {""description"": ""The number of units of grease an automatic slicer requires per minute"", ""shape"": []}, ""MinimumSlicesPerMinute"": {""description"": ""The minimum number of slices the shop needs to cut per minute"", ""shape"": []}, ""MaximumGreasePerMinute"": {""description"": ""The maximum number of units of grease the shop can use per minute"", ""shape"": []}}, ""variables"": {""NumberManualSlicers"": {""description"": ""The number of manual slicers"", ""type"": ""continuous"", ""shape"": []}, ""NumberAutomaticSlicers"": {""description"": ""The number of automatic slicers"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of slices cut per minute by manual and automatic slicers must be at least MinimumSlicesPerMinute."", ""formulation"": ""ManualSliceRate \\cdot NumberManualSlicers + AutomaticSliceRate \\cdot NumberAutomaticSlicers \\geq MinimumSlicesPerMinute"", ""code"": {""gurobipy"": ""model.addConstr(ManualSliceRate * NumberManualSlicers + AutomaticSliceRate * NumberAutomaticSlicers >= MinimumSlicesPerMinute)""}}, {""description"": ""The total grease usage per minute by manual and automatic slicers must not exceed MaximumGreasePerMinute."", ""formulation"": ""ManualGreaseRate \\cdot NumberManualSlicers + AutomaticGreaseRate \\cdot NumberAutomaticSlicers \\leq MaximumGreasePerMinute"", ""code"": {""gurobipy"": ""model.addConstr(ManualGreaseRate * NumberManualSlicers + AutomaticGreaseRate * NumberAutomaticSlicers <= MaximumGreasePerMinute)""}}, {""description"": ""The number of Manual slicers must be less than the number of Automatic slicers."", ""formulation"": ""NumberManualSlicers \\leq NumberAutomaticSlicers - 1"", ""code"": {""gurobipy"": ""model.addConstr(NumberManualSlicers <= NumberAutomaticSlicers - 1)""}}], ""objective"": {""description"": ""The total number of slicers is the sum of manual and automatic slicers. The objective is to minimize the total number of slicers."", ""formulation"": ""Min \\ NumberManualSlicers + NumberAutomaticSlicers"", ""code"": {""gurobipy"": ""model.setObjective(NumberManualSlicers + NumberAutomaticSlicers, GRB.MINIMIZE)""}}}","{""ManualSliceRate"": 5, ""AutomaticSliceRate"": 8, ""ManualGreaseRate"": 3, ""AutomaticGreaseRate"": 6, ""MinimumSlicesPerMinute"": 50, ""MaximumGreasePerMinute"": 35}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
The butcher shop purchases a certain number of Manual and Automatic slicers.
Each Manual slicer can cut ManualSliceRate slices per minute and requires
ManualGreaseRate units of grease per minute. Each Automatic slicer can cut
AutomaticSliceRate slices per minute and requires AutomaticGreaseRate units of
grease per minute. The total number of slices cut per minute must be at least
MinimumSlicesPerMinute. The total grease usage per minute must not exceed
MaximumGreasePerMinute. Additionally, the number of Manual slicers must be less
than the number of Automatic slicers. The objective is to minimize the total
number of slicers.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/77/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ManualSliceRate @Def: The number of slices a manual slicer can cut per minute @Shape: [] 
ManualSliceRate = data['ManualSliceRate']
# @Parameter AutomaticSliceRate @Def: The number of slices an automatic slicer can cut per minute @Shape: [] 
AutomaticSliceRate = data['AutomaticSliceRate']
# @Parameter ManualGreaseRate @Def: The number of units of grease a manual slicer requires per minute @Shape: [] 
ManualGreaseRate = data['ManualGreaseRate']
# @Parameter AutomaticGreaseRate @Def: The number of units of grease an automatic slicer requires per minute @Shape: [] 
AutomaticGreaseRate = data['AutomaticGreaseRate']
# @Parameter MinimumSlicesPerMinute @Def: The minimum number of slices the shop needs to cut per minute @Shape: [] 
MinimumSlicesPerMinute = data['MinimumSlicesPerMinute']
# @Parameter MaximumGreasePerMinute @Def: The maximum number of units of grease the shop can use per minute @Shape: [] 
MaximumGreasePerMinute = data['MaximumGreasePerMinute']

# Variables 
# @Variable NumberManualSlicers @Def: The number of manual slicers @Shape: [] 
NumberManualSlicers = model.addVar(vtype=GRB.INTEGER, lb=0, name=""NumberManualSlicers"")
# @Variable NumberAutomaticSlicers @Def: The number of automatic slicers @Shape: [] 
NumberAutomaticSlicers = model.addVar(vtype=GRB.INTEGER, name=""NumberAutomaticSlicers"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of slices cut per minute by manual and automatic slicers must be at least MinimumSlicesPerMinute.
model.addConstr(ManualSliceRate * NumberManualSlicers + AutomaticSliceRate * NumberAutomaticSlicers >= MinimumSlicesPerMinute)
# @Constraint Constr_2 @Def: The total grease usage per minute by manual and automatic slicers must not exceed MaximumGreasePerMinute.
model.addConstr(ManualGreaseRate * NumberManualSlicers + AutomaticGreaseRate * NumberAutomaticSlicers <= MaximumGreasePerMinute)
# @Constraint Constr_3 @Def: The number of Manual slicers must be less than the number of Automatic slicers.
model.addConstr(NumberManualSlicers <= NumberAutomaticSlicers - 1)

# Objective 
# @Objective Objective @Def: The total number of slicers is the sum of manual and automatic slicers. The objective is to minimize the total number of slicers.
model.setObjective(NumberManualSlicers + NumberAutomaticSlicers, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberManualSlicers'] = NumberManualSlicers.x
variables['NumberAutomaticSlicers'] = NumberAutomaticSlicers.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A water company sells water in glass and plastic bottles. A glass bottle can hole 500 ml of water while a plastic bottle can hold 750 ml of water. Because most customer prefer plastic bottles, the number of plastic bottles must be at least 3 times the number of glass bottles. However, there must be at least 20 glass bottles. If the company has available 250000 ml of water, how many of each bottle should be made to maximize the total number of bottles?","{""variables"": {""PlasticBottles"": 274.0, ""GlassBottles"": 89.0}, ""objective"": 363.0}","{""parametrized_description"": ""A water company sells glass and plastic bottles. Each glass bottle can hold GlassBottleCapacity milliliters of water while each plastic bottle can hold PlasticBottleCapacity milliliters of water. The number of plastic bottles must be at least MinPlasticRatio times the number of glass bottles. There must be at least MinGlassBottles glass bottles. The company has TotalWater milliliters of water available. Determine the number of each type of bottle to maximize the total number of bottles."", ""keywords"": [""N.A.""], ""parameters"": {""GlassBottleCapacity"": {""description"": ""The capacity of a glass bottle in milliliters"", ""shape"": []}, ""PlasticBottleCapacity"": {""description"": ""The capacity of a plastic bottle in milliliters"", ""shape"": []}, ""MinPlasticRatio"": {""description"": ""The minimum ratio of plastic bottles to glass bottles"", ""shape"": []}, ""MinGlassBottles"": {""description"": ""The minimum number of glass bottles required"", ""shape"": []}, ""TotalWater"": {""description"": ""Total volume of water available in milliliters"", ""shape"": []}}, ""variables"": {""PlasticBottles"": {""description"": ""The number of plastic bottles"", ""type"": ""continuous"", ""shape"": []}, ""GlassBottles"": {""description"": ""The number of glass bottles"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of plastic bottles must be at least MinPlasticRatio times the number of glass bottles."", ""formulation"": ""PlasticBottles \\geq MinPlasticRatio \\times GlassBottles"", ""code"": {""gurobipy"": ""model.addConstr(PlasticBottles >= MinPlasticRatio * GlassBottles)""}}, {""description"": ""There must be at least MinGlassBottles glass bottles."", ""formulation"": ""GlassBottles \\geq MinGlassBottles"", ""code"": {""gurobipy"": ""model.addConstr(GlassBottles >= MinGlassBottles)""}}, {""description"": ""The total volume of water used by the glass and plastic bottles must not exceed TotalWater milliliters."", ""formulation"": ""GlassBottles \\times GlassBottleCapacity + PlasticBottles \\times PlasticBottleCapacity \\leq TotalWater"", ""code"": {""gurobipy"": ""model.addConstr(GlassBottles * GlassBottleCapacity + PlasticBottles * PlasticBottleCapacity <= TotalWater)""}}], ""objective"": {""description"": ""Maximize the total number of bottles, which is the sum of the number of glass bottles and plastic bottles."", ""formulation"": ""Max \\left( PlasticBottles + GlassBottles \\right)"", ""code"": {""gurobipy"": ""model.setObjective(PlasticBottles + GlassBottles, GRB.MAXIMIZE)""}}}","{""GlassBottleCapacity"": 500, ""PlasticBottleCapacity"": 750, ""MinPlasticRatio"": 3, ""MinGlassBottles"": 20, ""TotalWater"": 250000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A water company sells glass and plastic bottles. Each glass bottle can hold
GlassBottleCapacity milliliters of water while each plastic bottle can hold
PlasticBottleCapacity milliliters of water. The number of plastic bottles must
be at least MinPlasticRatio times the number of glass bottles. There must be at
least MinGlassBottles glass bottles. The company has TotalWater milliliters of
water available. Determine the number of each type of bottle to maximize the
total number of bottles.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/78/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter GlassBottleCapacity @Def: The capacity of a glass bottle in milliliters @Shape: [] 
GlassBottleCapacity = data['GlassBottleCapacity']
# @Parameter PlasticBottleCapacity @Def: The capacity of a plastic bottle in milliliters @Shape: [] 
PlasticBottleCapacity = data['PlasticBottleCapacity']
# @Parameter MinPlasticRatio @Def: The minimum ratio of plastic bottles to glass bottles @Shape: [] 
MinPlasticRatio = data['MinPlasticRatio']
# @Parameter MinGlassBottles @Def: The minimum number of glass bottles required @Shape: [] 
MinGlassBottles = data['MinGlassBottles']
# @Parameter TotalWater @Def: Total volume of water available in milliliters @Shape: [] 
TotalWater = data['TotalWater']

# Variables 
# @Variable PlasticBottles @Def: The number of plastic bottles @Shape: [] 
PlasticBottles = model.addVar(vtype=GRB.INTEGER, name=""PlasticBottles"")
# @Variable GlassBottles @Def: The number of glass bottles @Shape: [] 
GlassBottles = model.addVar(vtype=GRB.INTEGER, name=""GlassBottles"", lb=MinGlassBottles)

# Constraints 
# @Constraint Constr_1 @Def: The number of plastic bottles must be at least MinPlasticRatio times the number of glass bottles.
model.addConstr(PlasticBottles >= MinPlasticRatio * GlassBottles)
# @Constraint Constr_2 @Def: There must be at least MinGlassBottles glass bottles.
model.addConstr(GlassBottles >= MinGlassBottles)
# @Constraint Constr_3 @Def: The total volume of water used by the glass and plastic bottles must not exceed TotalWater milliliters.
model.addConstr(GlassBottles * GlassBottleCapacity + PlasticBottles * PlasticBottleCapacity <= TotalWater)

# Objective 
# @Objective Objective @Def: Maximize the total number of bottles, which is the sum of the number of glass bottles and plastic bottles.
model.setObjective(PlasticBottles + GlassBottles, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['PlasticBottles'] = PlasticBottles.x
variables['GlassBottles'] = GlassBottles.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An Indian restaurant makes goat and chicken curry. Each bowl of goat curry requires 3 units of goat meat and 6 units of the curry base. Each bowl of chicken curry requires 5 units of chicken meat and 5 units of the curry base. The restaurant has available 1500 units of goat meat and 2000 units of chicken meat. At least 25% of the bowls made must be chicken curry. Since goat curry is more popular, the number of goat curry bowls must be larger than the number of chicken curry bowls. How many of each type of curry bowl should be made to minimize the total amount of curry base used?",{},"{""parametrized_description"": ""A restaurant produces two types of curry: goat curry and chicken curry. Each bowl of goat curry requires GoatMeatPerGoatCurry units of goat meat and CurryBasePerGoatCurry units of curry base. Each bowl of chicken curry requires ChickenMeatPerChickenCurry units of chicken meat and CurryBasePerChickenCurry units of curry base. The restaurant has TotalGoatMeatAvailable units of goat meat and TotalChickenMeatAvailable units of chicken meat available. At least MinChickenCurryPercentage of the total curry bowls produced must be chicken curry. Additionally, the number of goat curry bowls produced must be greater than the number of chicken curry bowls. The objective is to determine the number of bowls of each type of curry to produce in order to minimize the total units of curry base used."", ""keywords"": [""N.A.""], ""parameters"": {""GoatMeatPerGoatCurry"": {""description"": ""Units of goat meat required to produce one bowl of goat curry"", ""shape"": []}, ""ChickenMeatPerChickenCurry"": {""description"": ""Units of chicken meat required to produce one bowl of chicken curry"", ""shape"": []}, ""CurryBasePerGoatCurry"": {""description"": ""Units of curry base required to produce one bowl of goat curry"", ""shape"": []}, ""CurryBasePerChickenCurry"": {""description"": ""Units of curry base required to produce one bowl of chicken curry"", ""shape"": []}, ""TotalGoatMeatAvailable"": {""description"": ""Total available units of goat meat"", ""shape"": []}, ""TotalChickenMeatAvailable"": {""description"": ""Total available units of chicken meat"", ""shape"": []}, ""MinChickenCurryPercentage"": {""description"": ""Minimum percentage of curry bowls that must be chicken curry"", ""shape"": []}}, ""variables"": {""NumGoatCurry"": {""description"": ""The number of bowls of goat curry"", ""type"": ""continuous"", ""shape"": [""integer""]}, ""NumChickenCurry"": {""description"": ""The number of bowls of chicken curry"", ""type"": ""continuous"", ""shape"": [""integer""]}}, ""constraints"": [{""description"": ""Each bowl of goat curry requires GoatMeatPerGoatCurry units of goat meat, and the total goat meat used cannot exceed TotalGoatMeatAvailable units."", ""formulation"": ""GoatMeatPerGoatCurry \\times NumGoatCurry \\leq TotalGoatMeatAvailable"", ""code"": {""gurobipy"": ""model.addConstr(GoatMeatPerGoatCurry * NumGoatCurry <= TotalGoatMeatAvailable)""}}, {""description"": ""Each bowl of chicken curry requires ChickenMeatPerChickenCurry units of chicken meat, and the total chicken meat used cannot exceed TotalChickenMeatAvailable units."", ""formulation"": ""ChickenMeatPerChickenCurry \\times NumChickenCurry \\leq TotalChickenMeatAvailable"", ""code"": {""gurobipy"": ""model.addConstr(ChickenMeatPerChickenCurry * NumChickenCurry <= TotalChickenMeatAvailable)""}}, {""description"": ""At least MinChickenCurryPercentage of the total curry bowls produced must be chicken curry."", ""formulation"": ""NumChickenCurry \\geq MinChickenCurryPercentage \\cdot (NumChickenCurry + NumGoatCurry)"", ""code"": {""gurobipy"": ""model.addConstr(NumChickenCurry >= MinChickenCurryPercentage * (NumChickenCurry + NumGoatCurry))""}}, {""description"": ""The number of goat curry bowls produced must be greater than the number of chicken curry bowls."", ""formulation"": ""NumGoatCurry \\geq NumChickenCurry + 1"", ""code"": {""gurobipy"": ""model.addConstr(NumGoatCurry >= NumChickenCurry + 1)""}}], ""objective"": {""description"": ""Minimize the total units of curry base used, calculated as (CurryBasePerGoatCurry * number of goat curry bowls) + (CurryBasePerChickenCurry * number of chicken curry bowls)."", ""formulation"": ""Min CurryBasePerGoatCurry \\times NumGoatCurry + CurryBasePerChickenCurry \\times NumChickenCurry"", ""code"": {""gurobipy"": ""model.setObjective(CurryBasePerGoatCurry * NumGoatCurry + CurryBasePerChickenCurry * NumChickenCurry, GRB.MINIMIZE)""}}}","{""GoatMeatPerGoatCurry"": 3, ""ChickenMeatPerChickenCurry"": 5, ""CurryBasePerGoatCurry"": 6, ""CurryBasePerChickenCurry"": 5, ""TotalGoatMeatAvailable"": 1500, ""TotalChickenMeatAvailable"": 2000, ""MinChickenCurryPercentage"": 25}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A restaurant produces two types of curry: goat curry and chicken curry. Each
bowl of goat curry requires GoatMeatPerGoatCurry units of goat meat and
CurryBasePerGoatCurry units of curry base. Each bowl of chicken curry requires
ChickenMeatPerChickenCurry units of chicken meat and CurryBasePerChickenCurry
units of curry base. The restaurant has TotalGoatMeatAvailable units of goat
meat and TotalChickenMeatAvailable units of chicken meat available. At least
MinChickenCurryPercentage of the total curry bowls produced must be chicken
curry. Additionally, the number of goat curry bowls produced must be greater
than the number of chicken curry bowls. The objective is to determine the number
of bowls of each type of curry to produce in order to minimize the total units
of curry base used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/79/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter GoatMeatPerGoatCurry @Def: Units of goat meat required to produce one bowl of goat curry @Shape: [] 
GoatMeatPerGoatCurry = data['GoatMeatPerGoatCurry']
# @Parameter ChickenMeatPerChickenCurry @Def: Units of chicken meat required to produce one bowl of chicken curry @Shape: [] 
ChickenMeatPerChickenCurry = data['ChickenMeatPerChickenCurry']
# @Parameter CurryBasePerGoatCurry @Def: Units of curry base required to produce one bowl of goat curry @Shape: [] 
CurryBasePerGoatCurry = data['CurryBasePerGoatCurry']
# @Parameter CurryBasePerChickenCurry @Def: Units of curry base required to produce one bowl of chicken curry @Shape: [] 
CurryBasePerChickenCurry = data['CurryBasePerChickenCurry']
# @Parameter TotalGoatMeatAvailable @Def: Total available units of goat meat @Shape: [] 
TotalGoatMeatAvailable = data['TotalGoatMeatAvailable']
# @Parameter TotalChickenMeatAvailable @Def: Total available units of chicken meat @Shape: [] 
TotalChickenMeatAvailable = data['TotalChickenMeatAvailable']
# @Parameter MinChickenCurryPercentage @Def: Minimum percentage of curry bowls that must be chicken curry @Shape: [] 
MinChickenCurryPercentage = data['MinChickenCurryPercentage']

# Variables 
# @Variable NumGoatCurry @Def: The number of bowls of goat curry @Shape: ['integer'] 
NumGoatCurry = model.addVar(vtype=GRB.INTEGER, name=""NumGoatCurry"")
# @Variable NumChickenCurry @Def: The number of bowls of chicken curry @Shape: ['integer'] 
NumChickenCurry = model.addVar(vtype=GRB.INTEGER, name=""NumChickenCurry"")

# Constraints 
# @Constraint Constr_1 @Def: Each bowl of goat curry requires GoatMeatPerGoatCurry units of goat meat, and the total goat meat used cannot exceed TotalGoatMeatAvailable units.
model.addConstr(GoatMeatPerGoatCurry * NumGoatCurry <= TotalGoatMeatAvailable)
# @Constraint Constr_2 @Def: Each bowl of chicken curry requires ChickenMeatPerChickenCurry units of chicken meat, and the total chicken meat used cannot exceed TotalChickenMeatAvailable units.
model.addConstr(ChickenMeatPerChickenCurry * NumChickenCurry <= TotalChickenMeatAvailable)
# @Constraint Constr_3 @Def: At least MinChickenCurryPercentage of the total curry bowls produced must be chicken curry.
model.addConstr(NumChickenCurry >= MinChickenCurryPercentage * (NumChickenCurry + NumGoatCurry))
# @Constraint Constr_4 @Def: The number of goat curry bowls produced must be greater than the number of chicken curry bowls.
model.addConstr(NumGoatCurry >= NumChickenCurry + 1)

# Objective 
# @Objective Objective @Def: Minimize the total units of curry base used, calculated as (CurryBasePerGoatCurry * number of goat curry bowls) + (CurryBasePerChickenCurry * number of chicken curry bowls).
model.setObjective(CurryBasePerGoatCurry * NumGoatCurry + CurryBasePerChickenCurry * NumChickenCurry, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumGoatCurry'] = NumGoatCurry.x
variables['NumChickenCurry'] = NumChickenCurry.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An accounting firm employs part time workers and full time workers. Full time workers work 8 hours per shift while part time workers work 4 hours per shift. In addition, full time workers are paid $300 per shift while part time workers are paid $100 per shift. Currently, the accounting firm has a project requiring 500 hours of labor. If the firm has a budget of $15000, how many of each type of worker should be scheduled to minimize the total number of workers.","{""variables"": {""NumFullTimeWorkers"": 25.0, ""NumPartTimeWorkers"": 75.0}, ""objective"": 100.0}","{""parametrized_description"": ""An accounting firm employs full time workers and part time workers. Each full time worker works FullTimeHoursPerShift hours per shift and is paid FullTimePayPerShift per shift, while each part time worker works PartTimeHoursPerShift hours per shift and is paid PartTimePayPerShift per shift. The firm has a project requiring LaborHoursRequired hours of labor and has a budget of TotalBudget. The firm should schedule a number of full time and part time workers to minimize the total number of workers."", ""keywords"": [""N.A.""], ""parameters"": {""FullTimeHoursPerShift"": {""description"": ""The number of hours a full time worker works per shift"", ""shape"": []}, ""PartTimeHoursPerShift"": {""description"": ""The number of hours a part time worker works per shift"", ""shape"": []}, ""FullTimePayPerShift"": {""description"": ""The amount paid to a full time worker per shift"", ""shape"": []}, ""PartTimePayPerShift"": {""description"": ""The amount paid to a part time worker per shift"", ""shape"": []}, ""LaborHoursRequired"": {""description"": ""The total labor hours required for the project"", ""shape"": []}, ""TotalBudget"": {""description"": ""The total budget available for labor costs"", ""shape"": []}}, ""variables"": {""NumFullTimeWorkers"": {""description"": ""The number of full-time workers"", ""type"": ""continuous"", ""shape"": []}, ""NumPartTimeWorkers"": {""description"": ""The number of part-time workers"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total labor hours provided by full-time workers and part-time workers must meet or exceed LaborHoursRequired."", ""formulation"": ""FullTimeHoursPerShift \\cdot NumFullTimeWorkers + PartTimeHoursPerShift \\cdot NumPartTimeWorkers \\geq LaborHoursRequired"", ""code"": {""gurobipy"": ""model.addConstr(FullTimeHoursPerShift * NumFullTimeWorkers + PartTimeHoursPerShift * NumPartTimeWorkers >= LaborHoursRequired)""}}, {""description"": ""The total labor costs for full-time workers and part-time workers must not exceed TotalBudget."", ""formulation"": ""NumFullTimeWorkers \\cdot FullTimePayPerShift + NumPartTimeWorkers \\cdot PartTimePayPerShift \\leq TotalBudget"", ""code"": {""gurobipy"": ""model.addConstr(NumFullTimeWorkers * FullTimePayPerShift + NumPartTimeWorkers * PartTimePayPerShift <= TotalBudget)""}}], ""objective"": {""description"": ""Minimize the total number of workers, which is the sum of full-time and part-time workers."", ""formulation"": ""Min \\left( NumFullTimeWorkers + NumPartTimeWorkers \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumFullTimeWorkers + NumPartTimeWorkers, GRB.MINIMIZE)""}}}","{""FullTimeHoursPerShift"": 8, ""PartTimeHoursPerShift"": 4, ""FullTimePayPerShift"": 300, ""PartTimePayPerShift"": 100, ""LaborHoursRequired"": 500, ""TotalBudget"": 15000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
An accounting firm employs full time workers and part time workers. Each full
time worker works FullTimeHoursPerShift hours per shift and is paid
FullTimePayPerShift per shift, while each part time worker works
PartTimeHoursPerShift hours per shift and is paid PartTimePayPerShift per shift.
The firm has a project requiring LaborHoursRequired hours of labor and has a
budget of TotalBudget. The firm should schedule a number of full time and part
time workers to minimize the total number of workers.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/80/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter FullTimeHoursPerShift @Def: The number of hours a full time worker works per shift @Shape: [] 
FullTimeHoursPerShift = data['FullTimeHoursPerShift']
# @Parameter PartTimeHoursPerShift @Def: The number of hours a part time worker works per shift @Shape: [] 
PartTimeHoursPerShift = data['PartTimeHoursPerShift']
# @Parameter FullTimePayPerShift @Def: The amount paid to a full time worker per shift @Shape: [] 
FullTimePayPerShift = data['FullTimePayPerShift']
# @Parameter PartTimePayPerShift @Def: The amount paid to a part time worker per shift @Shape: [] 
PartTimePayPerShift = data['PartTimePayPerShift']
# @Parameter LaborHoursRequired @Def: The total labor hours required for the project @Shape: [] 
LaborHoursRequired = data['LaborHoursRequired']
# @Parameter TotalBudget @Def: The total budget available for labor costs @Shape: [] 
TotalBudget = data['TotalBudget']

# Variables 
# @Variable NumFullTimeWorkers @Def: The number of full-time workers @Shape: [] 
NumFullTimeWorkers = model.addVar(vtype=GRB.INTEGER, name=""NumFullTimeWorkers"")
# @Variable NumPartTimeWorkers @Def: The number of part-time workers @Shape: [] 
NumPartTimeWorkers = model.addVar(vtype=GRB.INTEGER, name=""NumPartTimeWorkers"")

# Constraints 
# @Constraint Constr_1 @Def: The total labor hours provided by full-time workers and part-time workers must meet or exceed LaborHoursRequired.
model.addConstr(FullTimeHoursPerShift * NumFullTimeWorkers + PartTimeHoursPerShift * NumPartTimeWorkers >= LaborHoursRequired)
# @Constraint Constr_2 @Def: The total labor costs for full-time workers and part-time workers must not exceed TotalBudget.
model.addConstr(NumFullTimeWorkers * FullTimePayPerShift + NumPartTimeWorkers * PartTimePayPerShift <= TotalBudget)

# Objective 
# @Objective Objective @Def: Minimize the total number of workers, which is the sum of full-time and part-time workers.
model.setObjective(NumFullTimeWorkers + NumPartTimeWorkers, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumFullTimeWorkers'] = NumFullTimeWorkers.x
variables['NumPartTimeWorkers'] = NumPartTimeWorkers.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A factory has two machines, A and B. Each day, machine A can make 30 items and consumes 100 kWh. Machine B can make 50 items and consumes 120 kWh per day. The factory must produce at least 1000 items per day and has 3000 kWh of electricity available per day. Since there are not many workers that can operate both machines, at most 30% of the machines must be of type B. Further, at least 5 machines of type A should be used. How many of each machine should be used to minimize the total number of machines?","{""variables"": {""NumberA"": 20.0, ""NumberB"": 8.0}, ""objective"": 28.0}","{""parametrized_description"": ""A factory has two types of machines, A and B. Each day, machine A can produce ProductionA items and consumes EnergyA kWh. Machine B can produce ProductionB items and consumes EnergyB kWh per day. The factory must produce at least MinProduction items per day and has MaxEnergy kWh of electricity available per day. Due to limited workers, at most MaxPercentB of the machines can be of type B. Additionally, at least MinA machines of type A must be used. The objective is to determine the number of each machine to minimize the total number of machines."", ""keywords"": [""N.A.""], ""parameters"": {""ProductionA"": {""description"": ""Production rate of Machine A in items per day"", ""shape"": []}, ""ProductionB"": {""description"": ""Production rate of Machine B in items per day"", ""shape"": []}, ""EnergyA"": {""description"": ""Energy consumption of Machine A in kWh per day"", ""shape"": []}, ""EnergyB"": {""description"": ""Energy consumption of Machine B in kWh per day"", ""shape"": []}, ""MinProduction"": {""description"": ""Minimum required production in items per day"", ""shape"": []}, ""MaxEnergy"": {""description"": ""Maximum available energy in kWh per day"", ""shape"": []}, ""MaxPercentB"": {""description"": ""Maximum percentage of machines that can be of type B"", ""shape"": []}, ""MinA"": {""description"": ""Minimum number of machines of type A"", ""shape"": []}}, ""variables"": {""NumberA"": {""description"": ""The number of machines of type A"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberB"": {""description"": ""The number of machines of type B"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total production by machines of type A and B must be at least MinProduction items per day."", ""formulation"": ""ProductionA \\times NumberA + ProductionB \\times NumberB \\geq MinProduction"", ""code"": {""gurobipy"": ""model.addConstr(ProductionA * NumberA + ProductionB * NumberB >= MinProduction)""}}, {""description"": ""The total energy consumption by machines of type A and B must not exceed MaxEnergy kWh per day."", ""formulation"": ""EnergyA \\times NumberA + EnergyB \\times NumberB \\leq MaxEnergy"", ""code"": {""gurobipy"": ""model.addConstr(EnergyA * NumberA + EnergyB * NumberB <= MaxEnergy)""}}, {""description"": ""At most MaxPercentB percentage of the machines can be of type B."", ""formulation"": ""(1 - MaxPercentB) \\cdot NumberB \\leq MaxPercentB \\cdot NumberA"", ""code"": {""gurobipy"": ""model.addConstr((1 - MaxPercentB) * NumberB <= MaxPercentB * NumberA)""}}, {""description"": ""At least MinA machines of type A must be used."", ""formulation"": ""NumberA \\geq MinA"", ""code"": {""gurobipy"": ""model.addConstr(NumberA >= MinA)""}}], ""objective"": {""description"": ""Minimize the total number of machines of type A and B used in the factory."", ""formulation"": ""Min \\ NumberA + NumberB"", ""code"": {""gurobipy"": ""model.setObjective(NumberA + NumberB, GRB.MINIMIZE)""}}}","{""ProductionA"": 30, ""ProductionB"": 50, ""EnergyA"": 100, ""EnergyB"": 120, ""MinProduction"": 1000, ""MaxEnergy"": 3000, ""MaxPercentB"": 0.3, ""MinA"": 5}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A factory has two types of machines, A and B. Each day, machine A can produce
ProductionA items and consumes EnergyA kWh. Machine B can produce ProductionB
items and consumes EnergyB kWh per day. The factory must produce at least
MinProduction items per day and has MaxEnergy kWh of electricity available per
day. Due to limited workers, at most MaxPercentB of the machines can be of type
B. Additionally, at least MinA machines of type A must be used. The objective is
to determine the number of each machine to minimize the total number of
machines.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/81/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProductionA @Def: Production rate of Machine A in items per day @Shape: [] 
ProductionA = data['ProductionA']
# @Parameter ProductionB @Def: Production rate of Machine B in items per day @Shape: [] 
ProductionB = data['ProductionB']
# @Parameter EnergyA @Def: Energy consumption of Machine A in kWh per day @Shape: [] 
EnergyA = data['EnergyA']
# @Parameter EnergyB @Def: Energy consumption of Machine B in kWh per day @Shape: [] 
EnergyB = data['EnergyB']
# @Parameter MinProduction @Def: Minimum required production in items per day @Shape: [] 
MinProduction = data['MinProduction']
# @Parameter MaxEnergy @Def: Maximum available energy in kWh per day @Shape: [] 
MaxEnergy = data['MaxEnergy']
# @Parameter MaxPercentB @Def: Maximum percentage of machines that can be of type B @Shape: [] 
MaxPercentB = data['MaxPercentB']
# @Parameter MinA @Def: Minimum number of machines of type A @Shape: [] 
MinA = data['MinA']

# Variables 
# @Variable NumberA @Def: The number of machines of type A @Shape: ['Integer'] 
NumberA = model.addVar(vtype=GRB.INTEGER, lb=MinA, name=""NumberA"")
# @Variable NumberB @Def: The number of machines of type B @Shape: ['Integer'] 
NumberB = model.addVar(vtype=GRB.INTEGER, name=""NumberB"")

# Constraints 
# @Constraint Constr_1 @Def: The total production by machines of type A and B must be at least MinProduction items per day.
model.addConstr(ProductionA * NumberA + ProductionB * NumberB >= MinProduction)
# @Constraint Constr_2 @Def: The total energy consumption by machines of type A and B must not exceed MaxEnergy kWh per day.
model.addConstr(EnergyA * NumberA + EnergyB * NumberB <= MaxEnergy)
# @Constraint Constr_3 @Def: At most MaxPercentB percentage of the machines can be of type B.
model.addConstr((1 - MaxPercentB) * NumberB <= MaxPercentB * NumberA)
# @Constraint Constr_4 @Def: At least MinA machines of type A must be used.
model.addConstr(NumberA >= MinA)

# Objective 
# @Objective Objective @Def: Minimize the total number of machines of type A and B used in the factory.
model.setObjective(NumberA + NumberB, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberA'] = NumberA.x
variables['NumberB'] = NumberB.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A toy company can build two factory types, a medium sized factory and a small factory. A medium sized factory can make 50 toys per day and requires 3 operators. A small factory can make 35 toys per day and requires 2 operators. The company must make at least 250 toys per day but they only have available 16 operators. How many of each factory should the company build to minimize the total number of factories?","{""variables"": {""NumberOfFactories"": {""0"": 5.0, ""1"": -0.0}}, ""objective"": 5.0}","{""parametrized_description"": ""A company can build NumFactoryTypes different factory types. Each factory type i has a production rate of ProductionRate[i] toys per day and requires OperatorRequirement[i] operators. The company must produce at least TotalProductionRequirement toys per day and has a total of TotalAvailableOperators operators available. Determine the number of each factory type to build to minimize the total number of factories."", ""keywords"": [""N.A.""], ""parameters"": {""NumFactoryTypes"": {""description"": ""Number of factory types"", ""shape"": []}, ""ProductionRate"": {""description"": ""Production rate of each factory type (toys per day)"", ""shape"": [""NumFactoryTypes""]}, ""OperatorRequirement"": {""description"": ""Number of operators required for each factory type"", ""shape"": [""NumFactoryTypes""]}, ""TotalProductionRequirement"": {""description"": ""Minimum number of toys required per day"", ""shape"": []}, ""TotalAvailableOperators"": {""description"": ""Total number of available operators"", ""shape"": []}}, ""variables"": {""NumberOfFactories"": {""description"": ""The number of factories of each type"", ""type"": ""continuous"", ""shape"": [""NumFactoryTypes""]}}, ""constraints"": [{""description"": ""The total production must be at least TotalProductionRequirement toys per day. This is achieved by ensuring that the sum of ProductionRate[i] multiplied by the number of factories of each type i is greater than or equal to TotalProductionRequirement."", ""formulation"": ""\\sum_{i=1}^{\\text{NumFactoryTypes}} \\text{ProductionRate}_i \\times \\text{NumberOfFactories}_i \\geq \\text{TotalProductionRequirement}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ProductionRate[i] * NumberOfFactories[i] for i in range(NumFactoryTypes)) >= TotalProductionRequirement)""}}, {""description"": ""The total number of operators used must not exceed TotalAvailableOperators. This is ensured by making sure that the sum of OperatorRequirement[i] multiplied by the number of factories of each type i is less than or equal to TotalAvailableOperators."", ""formulation"": ""\\sum_{i=1}^{\\text{NumFactoryTypes}} \\text{OperatorRequirement}_i \\cdot \\text{NumberOfFactories}_i \\leq \\text{TotalAvailableOperators}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(OperatorRequirement[i] * NumberOfFactories[i] for i in range(NumFactoryTypes)) <= TotalAvailableOperators)""}}], ""objective"": {""description"": ""Minimize the total number of factories built. This is done by minimizing the sum of the number of factories of each type."", ""formulation"": ""Min \\sum_{i=1}^{NumFactoryTypes} NumberOfFactories_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(NumberOfFactories[i] for i in range(NumFactoryTypes)), GRB.MINIMIZE)""}}}","{""NumFactoryTypes"": 2, ""ProductionRate"": [50, 35], ""OperatorRequirement"": [3, 2], ""TotalProductionRequirement"": 250, ""TotalAvailableOperators"": 16}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company can build NumFactoryTypes different factory types. Each factory type i
has a production rate of ProductionRate[i] toys per day and requires
OperatorRequirement[i] operators. The company must produce at least
TotalProductionRequirement toys per day and has a total of
TotalAvailableOperators operators available. Determine the number of each
factory type to build to minimize the total number of factories.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/82/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumFactoryTypes @Def: Number of factory types @Shape: [] 
NumFactoryTypes = data['NumFactoryTypes']
# @Parameter ProductionRate @Def: Production rate of each factory type (toys per day) @Shape: ['NumFactoryTypes'] 
ProductionRate = data['ProductionRate']
# @Parameter OperatorRequirement @Def: Number of operators required for each factory type @Shape: ['NumFactoryTypes'] 
OperatorRequirement = data['OperatorRequirement']
# @Parameter TotalProductionRequirement @Def: Minimum number of toys required per day @Shape: [] 
TotalProductionRequirement = data['TotalProductionRequirement']
# @Parameter TotalAvailableOperators @Def: Total number of available operators @Shape: [] 
TotalAvailableOperators = data['TotalAvailableOperators']

# Variables 
# @Variable NumberOfFactories @Def: The number of factories of each type @Shape: ['NumFactoryTypes'] 
NumberOfFactories = model.addVars(NumFactoryTypes, vtype=GRB.INTEGER, name=""NumberOfFactories"")

# Constraints 
# @Constraint Constr_1 @Def: The total production must be at least TotalProductionRequirement toys per day. This is achieved by ensuring that the sum of ProductionRate[i] multiplied by the number of factories of each type i is greater than or equal to TotalProductionRequirement.
model.addConstr(quicksum(ProductionRate[i] * NumberOfFactories[i] for i in range(NumFactoryTypes)) >= TotalProductionRequirement)
# @Constraint Constr_2 @Def: The total number of operators used must not exceed TotalAvailableOperators. This is ensured by making sure that the sum of OperatorRequirement[i] multiplied by the number of factories of each type i is less than or equal to TotalAvailableOperators.
model.addConstr(quicksum(OperatorRequirement[i] * NumberOfFactories[i] for i in range(NumFactoryTypes)) <= TotalAvailableOperators)

# Objective 
# @Objective Objective @Def: Minimize the total number of factories built. This is done by minimizing the sum of the number of factories of each type.
model.setObjective(quicksum(NumberOfFactories[i] for i in range(NumFactoryTypes)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfFactories'] = {i: NumberOfFactories[i].x for i in range(NumFactoryTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A chemical plant can buy two types of generators, generator A and generator B, which use two different processes to generate hydrogen. Generator A uses an electrolysis process and produces 40 cubic meters of hydrogen as well as 300 units of pollutants every day. Generator B uses a fermentation process to produce 30 cubic meters of hydrogen per day while outputting 200 units of pollutants. The chemical plant must make a minimum of 1000 cubic meters of hydrogen per day but due to environmental restrictions they can produce at most 3000 units of pollutant. How many of each type of generator should they buy to minimize the number of generators needed?",{},"{""parametrized_description"": ""A chemical plant can purchase two types of generators, Generator A and Generator B, which use different processes to generate hydrogen. Generator A produces HydrogenProductionA amount of hydrogen and PollutantOutputA units of pollutants per day. Generator B produces HydrogenProductionB amount of hydrogen and PollutantOutputB units of pollutants per day. The plant must produce at least MinHydrogenRequired amount of hydrogen per day and can produce at most MaxPollutantAllowed units of pollutants per day. The objective is to minimize the total number of generators purchased."", ""keywords"": [""N.A.""], ""parameters"": {""HydrogenProductionA"": {""description"": ""Amount of hydrogen produced per day by generator A"", ""shape"": []}, ""PollutantOutputA"": {""description"": ""Amount of pollutants produced per day by generator A"", ""shape"": []}, ""HydrogenProductionB"": {""description"": ""Amount of hydrogen produced per day by generator B"", ""shape"": []}, ""PollutantOutputB"": {""description"": ""Amount of pollutants produced per day by generator B"", ""shape"": []}, ""MinHydrogenRequired"": {""description"": ""Minimum hydrogen required per day"", ""shape"": []}, ""MaxPollutantAllowed"": {""description"": ""Maximum pollutants allowed per day"", ""shape"": []}}, ""variables"": {""NumberOfGeneratorA"": {""description"": ""The number of Generator A used per day"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfGeneratorB"": {""description"": ""The number of Generator B used per day"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total hydrogen produced by Generator A and Generator B must be at least MinHydrogenRequired per day."", ""formulation"": ""HydrogenProductionA \\cdot NumberOfGeneratorA + HydrogenProductionB \\cdot NumberOfGeneratorB \\geq MinHydrogenRequired"", ""code"": {""gurobipy"": ""model.addConstr(HydrogenProductionA * NumberOfGeneratorA + HydrogenProductionB * NumberOfGeneratorB >= MinHydrogenRequired)""}}, {""description"": ""The total pollutant output from Generator A and Generator B must be at most MaxPollutantAllowed units per day."", ""formulation"": ""NumberOfGeneratorA \\cdot PollutantOutputA + NumberOfGeneratorB \\cdot PollutantOutputB \\leq MaxPollutantAllowed"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfGeneratorA * PollutantOutputA + NumberOfGeneratorB * PollutantOutputB <= MaxPollutantAllowed)""}}], ""objective"": {""description"": ""Minimize the total number of generators purchased."", ""formulation"": ""Min \\left( NumberOfGeneratorA + NumberOfGeneratorB \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfGeneratorA + NumberOfGeneratorB, GRB.MINIMIZE)""}}}","{""HydrogenProductionA"": 40, ""PollutantOutputA"": 300, ""HydrogenProductionB"": 30, ""PollutantOutputB"": 200, ""MinHydrogenRequired"": 1000, ""MaxPollutantAllowed"": 3000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A chemical plant can purchase two types of generators, Generator A and Generator
B, which use different processes to generate hydrogen. Generator A produces
HydrogenProductionA amount of hydrogen and PollutantOutputA units of pollutants
per day. Generator B produces HydrogenProductionB amount of hydrogen and
PollutantOutputB units of pollutants per day. The plant must produce at least
MinHydrogenRequired amount of hydrogen per day and can produce at most
MaxPollutantAllowed units of pollutants per day. The objective is to minimize
the total number of generators purchased.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/83/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter HydrogenProductionA @Def: Amount of hydrogen produced per day by generator A @Shape: [] 
HydrogenProductionA = data['HydrogenProductionA']
# @Parameter PollutantOutputA @Def: Amount of pollutants produced per day by generator A @Shape: [] 
PollutantOutputA = data['PollutantOutputA']
# @Parameter HydrogenProductionB @Def: Amount of hydrogen produced per day by generator B @Shape: [] 
HydrogenProductionB = data['HydrogenProductionB']
# @Parameter PollutantOutputB @Def: Amount of pollutants produced per day by generator B @Shape: [] 
PollutantOutputB = data['PollutantOutputB']
# @Parameter MinHydrogenRequired @Def: Minimum hydrogen required per day @Shape: [] 
MinHydrogenRequired = data['MinHydrogenRequired']
# @Parameter MaxPollutantAllowed @Def: Maximum pollutants allowed per day @Shape: [] 
MaxPollutantAllowed = data['MaxPollutantAllowed']

# Variables 
# @Variable NumberOfGeneratorA @Def: The number of Generator A used per day @Shape: [] 
NumberOfGeneratorA = model.addVar(vtype=GRB.INTEGER, name=""NumberOfGeneratorA"")
# @Variable NumberOfGeneratorB @Def: The number of Generator B used per day @Shape: [] 
NumberOfGeneratorB = model.addVar(vtype=GRB.INTEGER, name=""NumberOfGeneratorB"")

# Constraints 
# @Constraint Constr_1 @Def: The total hydrogen produced by Generator A and Generator B must be at least MinHydrogenRequired per day.
model.addConstr(HydrogenProductionA * NumberOfGeneratorA + HydrogenProductionB * NumberOfGeneratorB >= MinHydrogenRequired)
# @Constraint Constr_2 @Def: The total pollutant output from Generator A and Generator B must be at most MaxPollutantAllowed units per day.
model.addConstr(NumberOfGeneratorA * PollutantOutputA + NumberOfGeneratorB * PollutantOutputB <= MaxPollutantAllowed)

# Objective 
# @Objective Objective @Def: Minimize the total number of generators purchased.
model.setObjective(NumberOfGeneratorA + NumberOfGeneratorB, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfGeneratorA'] = NumberOfGeneratorA.x
variables['NumberOfGeneratorB'] = NumberOfGeneratorB.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"There are two chemical reactions, chemical reaction A and chemical reaction B. Chemical reaction A requires 5 units of rare inert gas and 6 units of treated water to produce 10 units of a rare compound. Chemical reaction B requires 7 units of rare inert gas and 3 units of treater water to produce 8 units of a rare compound. There are 1000 units of the rare inert gas and 800 units of treated water available in the lab. How many reactions of each type should be done to maximize the amount of rare compound produced?","{""variables"": {""NumberReactions"": {""0"": 96.2962962962963, ""1"": 74.07407407407406}}, ""objective"": 1555.5555555555557}","{""parametrized_description"": ""There are NumReactions different chemical reactions. Each reaction requires ResourceRequirement units of each of the NumResources types of resources and produces ProductionPerReaction units of a rare compound. There are ResourceAvailable units of each resource available in the lab. Determine the number of reactions of each type to maximize the total amount of the rare compound produced."", ""keywords"": [""N.A.""], ""parameters"": {""NumReactions"": {""description"": ""Number of reaction types"", ""shape"": []}, ""NumResources"": {""description"": ""Number of resource types"", ""shape"": []}, ""ResourceRequirement"": {""description"": ""Units of resource j required for reaction i"", ""shape"": [""NumReactions"", ""NumResources""]}, ""ProductionPerReaction"": {""description"": ""Units of rare compound produced by reaction i"", ""shape"": [""NumReactions""]}, ""ResourceAvailable"": {""description"": ""Total units of resource j available"", ""shape"": [""NumResources""]}}, ""variables"": {""NumberReactions"": {""description"": ""The number of reactions of type i"", ""type"": ""continuous"", ""shape"": [""NumReactions""]}}, ""constraints"": [{""description"": ""For each resource type, the total units used by all reactions cannot exceed the available ResourceAvailable units. Specifically, for each resource j, the sum of (ResourceRequirement[i][j] * number of reactions of type i) across all reactions i must be less than or equal to ResourceAvailable[j]."", ""formulation"": ""\\sum_{i=1}^{NumReactions} ResourceRequirement[i][j] \\cdot NumberReactions[i] \\leq ResourceAvailable[j]"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(ResourceRequirement[i][j] * NumberReactions[i] for i in range(NumReactions)) <= ResourceAvailable[j] for j in range(NumResources)), name='ResourceUsage')""}}, {""description"": ""The number of reactions of each type must be non-negative."", ""formulation"": ""NumberReactions \\geq 0"", ""code"": {""gurobipy"": ""model.addConstrs((NumberReactions[i] >= 0 for i in range(NumReactions)))""}}], ""objective"": {""description"": ""The total amount of the rare compound produced is the sum of (ProductionPerReaction[i] * number of reactions of type i) across all reactions i. The objective is to maximize the total amount of the rare compound produced."", ""formulation"": ""Max \\sum_{i=1}^{\\text{NumReactions}} \\text{ProductionPerReaction}_i \\times \\text{NumberReactions}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProductionPerReaction[i] * NumberReactions[i] for i in range(NumReactions)), GRB.MAXIMIZE)""}}}","{""NumReactions"": 2, ""NumResources"": 2, ""ResourceRequirement"": [[5, 6], [7, 3]], ""ProductionPerReaction"": [10, 8], ""ResourceAvailable"": [1000, 800]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
There are NumReactions different chemical reactions. Each reaction requires
ResourceRequirement units of each of the NumResources types of resources and
produces ProductionPerReaction units of a rare compound. There are
ResourceAvailable units of each resource available in the lab. Determine the
number of reactions of each type to maximize the total amount of the rare
compound produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/84/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumReactions @Def: Number of reaction types @Shape: [] 
NumReactions = data['NumReactions']
# @Parameter NumResources @Def: Number of resource types @Shape: [] 
NumResources = data['NumResources']
# @Parameter ResourceRequirement @Def: Units of resource j required for reaction i @Shape: ['NumReactions', 'NumResources'] 
ResourceRequirement = data['ResourceRequirement']
# @Parameter ProductionPerReaction @Def: Units of rare compound produced by reaction i @Shape: ['NumReactions'] 
ProductionPerReaction = data['ProductionPerReaction']
# @Parameter ResourceAvailable @Def: Total units of resource j available @Shape: ['NumResources'] 
ResourceAvailable = data['ResourceAvailable']
    
# Variables 
# @Variable NumberReactions @Def: The number of reactions of type i @Shape: ['NumReactions'] 
NumberReactions = model.addVars(NumReactions, vtype=GRB.CONTINUOUS, name=""NumberReactions"")
    
# Constraints 
# @Constraint Constr_1 @Def: For each resource type, the total units used by all reactions cannot exceed the available ResourceAvailable units. Specifically, for each resource j, the sum of (ResourceRequirement[i][j] * number of reactions of type i) across all reactions i must be less than or equal to ResourceAvailable[j].
model.addConstrs((quicksum(ResourceRequirement[i][j] * NumberReactions[i] for i in range(NumReactions)) <= ResourceAvailable[j] for j in range(NumResources)), name='ResourceUsage')
# @Constraint Constr_2 @Def: The number of reactions of each type must be non-negative.
model.addConstrs((NumberReactions[i] >= 0 for i in range(NumReactions)))
    
# Objective 
# @Objective Objective @Def: The total amount of the rare compound produced is the sum of (ProductionPerReaction[i] * number of reactions of type i) across all reactions i. The objective is to maximize the total amount of the rare compound produced.
model.setObjective(quicksum(ProductionPerReaction[i] * NumberReactions[i] for i in range(NumReactions)), GRB.MAXIMIZE)
    
# Solve 
model.optimize()
    
# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberReactions'] = {i: NumberReactions[i].X for i in range(NumReactions)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A mining company has available a total of 100 square miles of mining sites and considering the use of two mining techniques: heap leaching and vat leaching. For each square mile of land, heap leaching technique can have a daily production of 3 tons of rare earth oxide per square miles but it also creates 8 tons of polluted wastewater and requires 10 extraction machines. On the other hand, vat leaching technique produces 5 tons of rare earth oxide per square miles per day while creating 17 tons of polluted wastewater and requiring 20 extraction machines. There are 100 machines available and due to environmental regulations, the amount of polluted wastewater must be at most 90 tons daily. Find the proportion of lands that use each mining technique in order to maximize the daily production of rare earth oxide.","{""variables"": {""LandAllocated"": {""0"": 10.0, ""1"": 0.0}}, ""objective"": 30.0}","{""parametrized_description"": ""A mining company allocates TotalLand square miles between NumTechniques mining techniques to maximize the total daily production of rare earth oxide. Each mining technique i has a ProductionRate[i] per square mile, generates WastewaterRate[i] tons of polluted wastewater per square mile daily, and requires MachinesRequired[i] extraction machines per square mile. The total number of extraction machines used must not exceed TotalMachines, and the total polluted wastewater produced must not exceed MaxWastewater tons daily."", ""keywords"": [""N.A.""], ""parameters"": {""TotalLand"": {""description"": ""Total land available for mining in square miles"", ""shape"": []}, ""TotalMachines"": {""description"": ""Total number of extraction machines available"", ""shape"": []}, ""MaxWastewater"": {""description"": ""Maximum allowed polluted wastewater per day in tons"", ""shape"": []}, ""NumTechniques"": {""description"": ""Number of mining techniques"", ""shape"": []}, ""ProductionRate"": {""description"": ""Daily production of rare earth oxide per square mile for each mining technique"", ""shape"": [""NumTechniques""]}, ""WastewaterRate"": {""description"": ""Daily polluted wastewater created per square mile for each mining technique"", ""shape"": [""NumTechniques""]}, ""MachinesRequired"": {""description"": ""Number of extraction machines required per square mile for each mining technique"", ""shape"": [""NumTechniques""]}}, ""variables"": {""LandAllocated"": {""description"": ""The amount of land allocated to each mining technique"", ""type"": ""continuous"", ""shape"": [""NumTechniques""]}}, ""constraints"": [{""description"": ""The total land allocated to all mining techniques cannot exceed TotalLand square miles."", ""formulation"": ""\\sum_{i=1}^{NumTechniques} LandAllocated_i \\leq TotalLand"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(LandAllocated[i] for i in range(NumTechniques)) <= TotalLand)""}}, {""description"": ""The total number of extraction machines required for all mining techniques cannot exceed TotalMachines."", ""formulation"": ""\\sum_{i=1}^{\\text{NumTechniques}} \\text{MachinesRequired}_i \\times \\text{LandAllocated}_i \\leq \\text{TotalMachines}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(MachinesRequired[i] * LandAllocated[i] for i in range(NumTechniques)) <= TotalMachines)""}}, {""description"": ""The total polluted wastewater produced by all mining techniques cannot exceed MaxWastewater tons daily."", ""formulation"": ""\\sum_{i=1}^{\\text{NumTechniques}} \\text{WastewaterRate}_i \\cdot \\text{LandAllocated}_i \\leq \\text{MaxWastewater}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(WastewaterRate[i] * LandAllocated[i] for i in range(NumTechniques)) <= MaxWastewater)""}}], ""objective"": {""description"": ""Maximize the total daily production of rare earth oxide."", ""formulation"": ""Max \\sum_{i=1}^{NumTechniques} ProductionRate_i \\cdot LandAllocated_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProductionRate[i] * LandAllocated[i] for i in range(NumTechniques)), GRB.MAXIMIZE)""}}}","{""TotalLand"": 100, ""TotalMachines"": 100, ""MaxWastewater"": 90, ""NumTechniques"": 2, ""ProductionRate"": [3, 5], ""WastewaterRate"": [8, 17], ""MachinesRequired"": [10, 20]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A mining company allocates TotalLand square miles between NumTechniques mining
techniques to maximize the total daily production of rare earth oxide. Each
mining technique i has a ProductionRate[i] per square mile, generates
WastewaterRate[i] tons of polluted wastewater per square mile daily, and
requires MachinesRequired[i] extraction machines per square mile. The total
number of extraction machines used must not exceed TotalMachines, and the total
polluted wastewater produced must not exceed MaxWastewater tons daily.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/85/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalLand @Def: Total land available for mining in square miles @Shape: [] 
TotalLand = data['TotalLand']
# @Parameter TotalMachines @Def: Total number of extraction machines available @Shape: [] 
TotalMachines = data['TotalMachines']
# @Parameter MaxWastewater @Def: Maximum allowed polluted wastewater per day in tons @Shape: [] 
MaxWastewater = data['MaxWastewater']
# @Parameter NumTechniques @Def: Number of mining techniques @Shape: [] 
NumTechniques = data['NumTechniques']
# @Parameter ProductionRate @Def: Daily production of rare earth oxide per square mile for each mining technique @Shape: ['NumTechniques'] 
ProductionRate = data['ProductionRate']
# @Parameter WastewaterRate @Def: Daily polluted wastewater created per square mile for each mining technique @Shape: ['NumTechniques'] 
WastewaterRate = data['WastewaterRate']
# @Parameter MachinesRequired @Def: Number of extraction machines required per square mile for each mining technique @Shape: ['NumTechniques'] 
MachinesRequired = data['MachinesRequired']

# Variables 
# @Variable LandAllocated @Def: The amount of land allocated to each mining technique @Shape: ['NumTechniques'] 
LandAllocated = model.addVars(NumTechniques, vtype=GRB.CONTINUOUS, name=""LandAllocated"")

# Constraints 
# @Constraint Constr_1 @Def: The total land allocated to all mining techniques cannot exceed TotalLand square miles.
model.addConstr(quicksum(LandAllocated[i] for i in range(NumTechniques)) <= TotalLand)
# @Constraint Constr_2 @Def: The total number of extraction machines required for all mining techniques cannot exceed TotalMachines.
model.addConstr(quicksum(MachinesRequired[i] * LandAllocated[i] for i in range(NumTechniques)) <= TotalMachines)
# @Constraint Constr_3 @Def: The total polluted wastewater produced by all mining techniques cannot exceed MaxWastewater tons daily.
model.addConstr(quicksum(WastewaterRate[i] * LandAllocated[i] for i in range(NumTechniques)) <= MaxWastewater)

# Objective 
# @Objective Objective @Def: Maximize the total daily production of rare earth oxide.
model.setObjective(quicksum(ProductionRate[i] * LandAllocated[i] for i in range(NumTechniques)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['LandAllocated'] = model.getAttr(""X"", LandAllocated)
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A small chocolate shop makes milk chocolate and dark chocolate bars. Milk chocolate bars require 4 units of cocoa and 7 units of milk. Dark chocolate bars require 6 units of cocoa and 3 units of milk. The shop has 2000 units of cocoa and 1750 units of milk available. In addition since milk chocolate sells better, at least 2 times as many milk chocolate bars need to be made as dark chocolate bars.  If making a milk chocolate bar takes 15 minutes and making a dark chocolate bar takes 12 mins, how many of each should the make to minimize total production time?","{""variables"": {""MilkBars"": -0.0, ""DarkBars"": -0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A chocolate shop produces two types of chocolate bars: milk and dark. Producing one milk chocolate bar requires CocoaPerMilkBar units of cocoa and MilkPerMilkBar units of milk. Producing one dark chocolate bar requires CocoaPerDarkBar units of cocoa and MilkPerDarkBar units of milk. The shop has TotalCocoa units of cocoa and TotalMilk units of milk available. At least MinMilkToDarkRatio times as many milk chocolate bars as dark chocolate bars must be produced. Producing one milk chocolate bar takes TimePerMilkBar minutes and producing one dark chocolate bar takes TimePerDarkBar minutes. The objective is to determine the number of each type of bar to produce in order to minimize the total production time."", ""keywords"": [""N.A.""], ""parameters"": {""CocoaPerMilkBar"": {""description"": ""Amount of cocoa required to produce one milk chocolate bar"", ""shape"": []}, ""MilkPerMilkBar"": {""description"": ""Amount of milk required to produce one milk chocolate bar"", ""shape"": []}, ""CocoaPerDarkBar"": {""description"": ""Amount of cocoa required to produce one dark chocolate bar"", ""shape"": []}, ""MilkPerDarkBar"": {""description"": ""Amount of milk required to produce one dark chocolate bar"", ""shape"": []}, ""TotalCocoa"": {""description"": ""Total units of cocoa available"", ""shape"": []}, ""TotalMilk"": {""description"": ""Total units of milk available"", ""shape"": []}, ""MinMilkToDarkRatio"": {""description"": ""Minimum ratio of milk chocolate bars to dark chocolate bars"", ""shape"": []}, ""TimePerMilkBar"": {""description"": ""Time required to produce one milk chocolate bar in minutes"", ""shape"": []}, ""TimePerDarkBar"": {""description"": ""Time required to produce one dark chocolate bar in minutes"", ""shape"": []}}, ""variables"": {""MilkBars"": {""description"": ""The number of milk chocolate bars produced"", ""type"": ""continuous"", ""shape"": []}, ""DarkBars"": {""description"": ""The number of dark chocolate bars produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total cocoa used to produce milk and dark chocolate bars does not exceed TotalCocoa units."", ""formulation"": ""CocoaPerMilkBar \\cdot MilkBars + CocoaPerDarkBar \\cdot DarkBars \\leq TotalCocoa"", ""code"": {""gurobipy"": ""model.addConstr(CocoaPerMilkBar * MilkBars + CocoaPerDarkBar * DarkBars <= TotalCocoa)""}}, {""description"": ""The total milk used to produce milk and dark chocolate bars does not exceed TotalMilk units."", ""formulation"": ""MilkPerMilkBar \\times MilkBars + MilkPerDarkBar \\times DarkBars \\leq TotalMilk"", ""code"": {""gurobipy"": ""model.addConstr(MilkPerMilkBar * MilkBars + MilkPerDarkBar * DarkBars <= TotalMilk)""}}, {""description"": ""The number of milk chocolate bars produced is at least MinMilkToDarkRatio times the number of dark chocolate bars produced."", ""formulation"": ""MilkBars \\geq MinMilkToDarkRatio \\times DarkBars"", ""code"": {""gurobipy"": ""model.addConstr(MilkBars >= MinMilkToDarkRatio * DarkBars)""}}], ""objective"": {""description"": ""Minimize the total production time, which is the sum of the time required to produce the milk and dark chocolate bars."", ""formulation"": ""Min MilkBars \\times TimePerMilkBar + DarkBars \\times TimePerDarkBar"", ""code"": {""gurobipy"": ""model.setObjective(MilkBars * TimePerMilkBar + DarkBars * TimePerDarkBar, GRB.MINIMIZE)""}}}","{""CocoaPerMilkBar"": 4, ""MilkPerMilkBar"": 7, ""CocoaPerDarkBar"": 6, ""MilkPerDarkBar"": 3, ""TotalCocoa"": 2000, ""TotalMilk"": 1750, ""MinMilkToDarkRatio"": 2, ""TimePerMilkBar"": 15, ""TimePerDarkBar"": 12}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A chocolate shop produces two types of chocolate bars: milk and dark. Producing
one milk chocolate bar requires CocoaPerMilkBar units of cocoa and
MilkPerMilkBar units of milk. Producing one dark chocolate bar requires
CocoaPerDarkBar units of cocoa and MilkPerDarkBar units of milk. The shop has
TotalCocoa units of cocoa and TotalMilk units of milk available. At least
MinMilkToDarkRatio times as many milk chocolate bars as dark chocolate bars must
be produced. Producing one milk chocolate bar takes TimePerMilkBar minutes and
producing one dark chocolate bar takes TimePerDarkBar minutes. The objective is
to determine the number of each type of bar to produce in order to minimize the
total production time.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/86/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CocoaPerMilkBar @Def: Amount of cocoa required to produce one milk chocolate bar @Shape: [] 
CocoaPerMilkBar = data['CocoaPerMilkBar']
# @Parameter MilkPerMilkBar @Def: Amount of milk required to produce one milk chocolate bar @Shape: [] 
MilkPerMilkBar = data['MilkPerMilkBar']
# @Parameter CocoaPerDarkBar @Def: Amount of cocoa required to produce one dark chocolate bar @Shape: [] 
CocoaPerDarkBar = data['CocoaPerDarkBar']
# @Parameter MilkPerDarkBar @Def: Amount of milk required to produce one dark chocolate bar @Shape: [] 
MilkPerDarkBar = data['MilkPerDarkBar']
# @Parameter TotalCocoa @Def: Total units of cocoa available @Shape: [] 
TotalCocoa = data['TotalCocoa']
# @Parameter TotalMilk @Def: Total units of milk available @Shape: [] 
TotalMilk = data['TotalMilk']
# @Parameter MinMilkToDarkRatio @Def: Minimum ratio of milk chocolate bars to dark chocolate bars @Shape: [] 
MinMilkToDarkRatio = data['MinMilkToDarkRatio']
# @Parameter TimePerMilkBar @Def: Time required to produce one milk chocolate bar in minutes @Shape: [] 
TimePerMilkBar = data['TimePerMilkBar']
# @Parameter TimePerDarkBar @Def: Time required to produce one dark chocolate bar in minutes @Shape: [] 
TimePerDarkBar = data['TimePerDarkBar']

# Variables 
# @Variable MilkBars @Def: The number of milk chocolate bars produced @Shape: [] 
MilkBars = model.addVar(vtype=GRB.INTEGER, name=""MilkBars"")
# @Variable DarkBars @Def: The number of dark chocolate bars produced @Shape: [] 
DarkBars = model.addVar(vtype=GRB.INTEGER, name=""DarkBars"")

# Constraints 
# @Constraint Constr_1 @Def: The total cocoa used to produce milk and dark chocolate bars does not exceed TotalCocoa units.
model.addConstr(CocoaPerMilkBar * MilkBars + CocoaPerDarkBar * DarkBars <= TotalCocoa)
# @Constraint Constr_2 @Def: The total milk used to produce milk and dark chocolate bars does not exceed TotalMilk units.
model.addConstr(MilkPerMilkBar * MilkBars + MilkPerDarkBar * DarkBars <= TotalMilk)
# @Constraint Constr_3 @Def: The number of milk chocolate bars produced is at least MinMilkToDarkRatio times the number of dark chocolate bars produced.
model.addConstr(MilkBars >= MinMilkToDarkRatio * DarkBars)

# Objective 
# @Objective Objective @Def: Minimize the total production time, which is the sum of the time required to produce the milk and dark chocolate bars.
model.setObjective(MilkBars * TimePerMilkBar + DarkBars * TimePerDarkBar, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['MilkBars'] = MilkBars.x
variables['DarkBars'] = DarkBars.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An office is buying printers for their headquarters, a premium model and regular model. The premium model can print 30 pages per minute while the regular model can print 20 pages per minute. In addition, the premium model requires 4 units of ink per minute while the regular model requires 3 units of ink per minute. The office wants to make sure that at least 200 pages can be printed per minute and that at most 35 units of ink are used per minute.  Since the premium model is more user friendly, the number regular printers must be less than the number of premium printers. How many of each printer should be bought to minimize the total number of printers in the office?","{""variables"": {""NumPrinters"": {""0"": 7.0, ""1"": -0.0}}, ""objective"": 7.0}","{""parametrized_description"": ""An office purchases NumPrinterTypes different printer types, each with a specific PrintingSpeed and InkUsage. The office must ensure that the total pages printed per minute is at least MinPagesPerMinute and that the total ink used per minute does not exceed MaxInkPerMinute. Additionally, the quantity of one printer type must be greater than the quantity of another printer type. The objective is to minimize the total number of printers purchased."", ""keywords"": [""N.A.""], ""parameters"": {""NumPrinterTypes"": {""description"": ""Number of different printer types"", ""shape"": []}, ""PrintingSpeed"": {""description"": ""Pages printed per minute by each printer type"", ""shape"": [""NumPrinterTypes""]}, ""InkUsage"": {""description"": ""Ink units used per minute by each printer type"", ""shape"": [""NumPrinterTypes""]}, ""MinPagesPerMinute"": {""description"": ""Minimum number of pages to be printed per minute"", ""shape"": []}, ""MaxInkPerMinute"": {""description"": ""Maximum number of ink units allowed per minute"", ""shape"": []}}, ""variables"": {""NumPrinters"": {""description"": ""Number of printers for each printer type"", ""type"": ""continuous"", ""shape"": [""NumPrinterTypes""]}}, ""constraints"": [{""description"": ""The total pages printed per minute must be at least MinPagesPerMinute."", ""formulation"": ""\\sum_{j=1}^{NumPrinterTypes} PrintingSpeed_j \\cdot NumPrinters_j \\geq MinPagesPerMinute"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(PrintingSpeed[j] * NumPrinters[j] for j in range(NumPrinterTypes)) >= MinPagesPerMinute)""}}, {""description"": ""The total ink used per minute must not exceed MaxInkPerMinute."", ""formulation"": ""\\sum_{i=1}^{NumPrinterTypes} NumPrinters_i \\times InkUsage_i \\leq MaxInkPerMinute"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(NumPrinters[i] * InkUsage[i] for i in range(NumPrinterTypes)) <= MaxInkPerMinute)""}}, {""description"": ""The quantity of one printer type must be greater than the quantity of another printer type."", ""formulation"": ""NumPrinters_{i} \\geq NumPrinters_{j}"", ""code"": {""gurobipy"": ""model.addConstr(NumPrinters[i] >= NumPrinters[j], name=\""PrinterTypeConstraint\"")""}}], ""objective"": {""description"": ""The objective is to minimize the total number of printers purchased."", ""formulation"": ""Min \\sum_{i=1}^{NumPrinterTypes} NumPrinters_{i}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(NumPrinters[i] for i in range(NumPrinterTypes)), GRB.MINIMIZE)""}}}","{""NumPrinterTypes"": 2, ""PrintingSpeed"": [30, 20], ""InkUsage"": [4, 3], ""MinPagesPerMinute"": 200, ""MaxInkPerMinute"": 35}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
An office purchases NumPrinterTypes different printer types, each with a
specific PrintingSpeed and InkUsage. The office must ensure that the total pages
printed per minute is at least MinPagesPerMinute and that the total ink used per
minute does not exceed MaxInkPerMinute. Additionally, the quantity of one
printer type must be greater than the quantity of another printer type. The
objective is to minimize the total number of printers purchased.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/87/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumPrinterTypes @Def: Number of different printer types @Shape: [] 
NumPrinterTypes = data['NumPrinterTypes']
# @Parameter PrintingSpeed @Def: Pages printed per minute by each printer type @Shape: ['NumPrinterTypes'] 
PrintingSpeed = data['PrintingSpeed']
# @Parameter InkUsage @Def: Ink units used per minute by each printer type @Shape: ['NumPrinterTypes'] 
InkUsage = data['InkUsage']
# @Parameter MinPagesPerMinute @Def: Minimum number of pages to be printed per minute @Shape: [] 
MinPagesPerMinute = data['MinPagesPerMinute']
# @Parameter MaxInkPerMinute @Def: Maximum number of ink units allowed per minute @Shape: [] 
MaxInkPerMinute = data['MaxInkPerMinute']

# Variables 
# @Variable NumPrinters @Def: Number of printers for each printer type @Shape: ['NumPrinterTypes'] 
NumPrinters = model.addVars(NumPrinterTypes, vtype=GRB.INTEGER, name=""NumPrinters"")

# Constraints 
# @Constraint Constr_1 @Def: The total pages printed per minute must be at least MinPagesPerMinute.
model.addConstr(quicksum(PrintingSpeed[j] * NumPrinters[j] for j in range(NumPrinterTypes)) >= MinPagesPerMinute)
# @Constraint Constr_2 @Def: The total ink used per minute must not exceed MaxInkPerMinute.
model.addConstr(quicksum(NumPrinters[i] * InkUsage[i] for i in range(NumPrinterTypes)) <= MaxInkPerMinute)
# @Constraint Constr_3 @Def: The quantity of one printer type must be greater than the quantity of another printer type.
i = 0  # Define i
j = 1  # Define j
model.addConstr(NumPrinters[i] >= NumPrinters[j], name=""PrinterTypeConstraint"")

# Objective 
# @Objective Objective @Def: The objective is to minimize the total number of printers purchased.
model.setObjective(quicksum(NumPrinters[i] for i in range(NumPrinterTypes)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumPrinters'] = {k: v.X for k, v in NumPrinters.items()}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A vine company sells vine in vintage and regular bottles. A vintage bottle can hold 500 ml of vine while a regular bottle can hold 750 ml of vine. The company has available 100000 ml of vine. Because vintage bottles are mostly bought by collectors, the number of regular bottles must be at least 4 times as much as the number of vintage bottles. However, at least 10 vintage bottles must be made. How many of each should be made to maximize the total number of bottles produced?","{""variables"": {""NumberVintageBottles"": 28.0, ""NumberRegularBottles"": 114.0}, ""objective"": 142.0}","{""parametrized_description"": ""A vine company sells two types of bottles: vintage and regular. A vintage bottle holds VintageBottleCapacity milliliters of vine, while a regular bottle holds RegularBottleCapacity milliliters of vine. The company has TotalAvailableVine milliliters of vine available. The number of regular bottles must be at least RegularToVintageMinRatio times the number of vintage bottles. Additionally, at least MinVintageBottles vintage bottles must be produced. The objective is to maximize the total number of bottles produced."", ""keywords"": [""N.A.""], ""parameters"": {""VintageBottleCapacity"": {""description"": ""Capacity of a vintage bottle in milliliters"", ""shape"": []}, ""RegularBottleCapacity"": {""description"": ""Capacity of a regular bottle in milliliters"", ""shape"": []}, ""TotalAvailableVine"": {""description"": ""Total available vine in milliliters"", ""shape"": []}, ""RegularToVintageMinRatio"": {""description"": ""Minimum ratio of regular bottles to vintage bottles"", ""shape"": []}, ""MinVintageBottles"": {""description"": ""Minimum number of vintage bottles to be produced"", ""shape"": []}}, ""variables"": {""NumberVintageBottles"": {""description"": ""The number of vintage bottles to produce"", ""type"": ""continuous"", ""shape"": []}, ""NumberRegularBottles"": {""description"": ""The number of regular bottles to produce"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total amount of vine used by vintage and regular bottles must not exceed TotalAvailableVine milliliters."", ""formulation"": ""NumberVintageBottles \\times VintageBottleCapacity + NumberRegularBottles \\times RegularBottleCapacity \\leq TotalAvailableVine"", ""code"": {""gurobipy"": ""model.addConstr(VintageBottleCapacity * NumberVintageBottles + RegularBottleCapacity * NumberRegularBottles <= TotalAvailableVine)""}}, {""description"": ""The number of regular bottles must be at least RegularToVintageMinRatio times the number of vintage bottles."", ""formulation"": ""NumberRegularBottles \\geq RegularToVintageMinRatio \\times NumberVintageBottles"", ""code"": {""gurobipy"": ""model.addConstr(NumberRegularBottles >= RegularToVintageMinRatio * NumberVintageBottles)""}}, {""description"": ""At least MinVintageBottles vintage bottles must be produced."", ""formulation"": ""NumberVintageBottles \\geq MinVintageBottles"", ""code"": {""gurobipy"": ""model.addConstr(NumberVintageBottles >= MinVintageBottles)""}}], ""objective"": {""description"": ""Maximize the total number of bottles produced."", ""formulation"": ""Max \\left( NumberVintageBottles + NumberRegularBottles \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumberVintageBottles + NumberRegularBottles, GRB.MAXIMIZE)""}}}","{""VintageBottleCapacity"": 500, ""RegularBottleCapacity"": 750, ""TotalAvailableVine"": 100000, ""RegularToVintageMinRatio"": 4, ""MinVintageBottles"": 10}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A vine company sells two types of bottles: vintage and regular. A vintage bottle
holds VintageBottleCapacity milliliters of vine, while a regular bottle holds
RegularBottleCapacity milliliters of vine. The company has TotalAvailableVine
milliliters of vine available. The number of regular bottles must be at least
RegularToVintageMinRatio times the number of vintage bottles. Additionally, at
least MinVintageBottles vintage bottles must be produced. The objective is to
maximize the total number of bottles produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/88/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter VintageBottleCapacity @Def: Capacity of a vintage bottle in milliliters @Shape: [] 
VintageBottleCapacity = data['VintageBottleCapacity']
# @Parameter RegularBottleCapacity @Def: Capacity of a regular bottle in milliliters @Shape: [] 
RegularBottleCapacity = data['RegularBottleCapacity']
# @Parameter TotalAvailableVine @Def: Total available vine in milliliters @Shape: [] 
TotalAvailableVine = data['TotalAvailableVine']
# @Parameter RegularToVintageMinRatio @Def: Minimum ratio of regular bottles to vintage bottles @Shape: [] 
RegularToVintageMinRatio = data['RegularToVintageMinRatio']
# @Parameter MinVintageBottles @Def: Minimum number of vintage bottles to be produced @Shape: [] 
MinVintageBottles = data['MinVintageBottles']

# Variables 
# @Variable NumberVintageBottles @Def: The number of vintage bottles to produce @Shape: [] 
NumberVintageBottles = model.addVar(vtype=GRB.INTEGER, lb=MinVintageBottles, name=""NumberVintageBottles"")
# @Variable NumberRegularBottles @Def: The number of regular bottles to produce @Shape: [] 
NumberRegularBottles = model.addVar(vtype=GRB.INTEGER, name=""NumberRegularBottles"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of vine used by vintage and regular bottles must not exceed TotalAvailableVine milliliters.
model.addConstr(VintageBottleCapacity * NumberVintageBottles + RegularBottleCapacity * NumberRegularBottles <= TotalAvailableVine)
# @Constraint Constr_2 @Def: The number of regular bottles must be at least RegularToVintageMinRatio times the number of vintage bottles.
model.addConstr(NumberRegularBottles >= RegularToVintageMinRatio * NumberVintageBottles)
# @Constraint Constr_3 @Def: At least MinVintageBottles vintage bottles must be produced.
model.addConstr(NumberVintageBottles >= MinVintageBottles)

# Objective 
# @Objective Objective @Def: Maximize the total number of bottles produced.
model.setObjective(NumberVintageBottles + NumberRegularBottles, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberVintageBottles'] = NumberVintageBottles.x
variables['NumberRegularBottles'] = NumberRegularBottles.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A candy company is making peach flavored candy and cherry flavored candy. Each pack of peach flavored candy requires 3 units of peach flavoring and 5 units of special syrup. Each pack of cherry flavored candy requires 5 units of cherry flavoring and 4 units of special syrup. The company has available 3000 units of peach flavoring and 4000 units of cherry flavoring. Peach candy is much more popular and thus the number of peach candy packs must be larger than the number of cherry candy packs. In addition, at least 30% of the pack must be cherry flavored. How many of each should be made to minimize the total amount of special syrup used?","{""variables"": {""NumberOfPeachPacks"": 0.0, ""NumberOfCherryPacks"": 0.0}, ""objective"": 0.0}","{""parametrized_description"": ""The company produces two types of candy packs: peach and cherry. Each pack of peach candy requires PeachFlavoringPerPack units of peach flavoring and SpecialSyrupPerPackPeach units of special syrup. Each pack of cherry candy requires CherryFlavoringPerPack units of cherry flavoring and SpecialSyrupPerPackCherry units of special syrup. The company has AvailablePeachFlavoring units of peach flavoring and AvailableCherryFlavoring units of cherry flavoring available. The number of peach candy packs produced must be greater than the number of cherry candy packs, and at least MinimumCherryPercentage fraction of the total packs must be cherry flavored. The objective is to determine the number of each type of pack to minimize the total amount of special syrup used."", ""keywords"": [""N.A.""], ""parameters"": {""AvailablePeachFlavoring"": {""description"": ""Units of peach flavoring available"", ""shape"": []}, ""AvailableCherryFlavoring"": {""description"": ""Units of cherry flavoring available"", ""shape"": []}, ""PeachFlavoringPerPack"": {""description"": ""Units of peach flavoring required per pack of peach candy"", ""shape"": []}, ""CherryFlavoringPerPack"": {""description"": ""Units of cherry flavoring required per pack of cherry candy"", ""shape"": []}, ""SpecialSyrupPerPackPeach"": {""description"": ""Units of special syrup required per pack of peach candy"", ""shape"": []}, ""SpecialSyrupPerPackCherry"": {""description"": ""Units of special syrup required per pack of cherry candy"", ""shape"": []}, ""MinimumCherryPercentage"": {""description"": ""Minimum fraction of packs that must be cherry flavored"", ""shape"": []}}, ""variables"": {""NumberOfPeachPacks"": {""description"": ""The number of peach packs to produce"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfCherryPacks"": {""description"": ""The number of cherry packs to produce"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total peach flavoring used (PeachFlavoringPerPack * number of peach packs) must not exceed AvailablePeachFlavoring."", ""formulation"": ""PeachFlavoringPerPack \\times NumberOfPeachPacks \\leq AvailablePeachFlavoring"", ""code"": {""gurobipy"": ""model.addConstr(PeachFlavoringPerPack * NumberOfPeachPacks <= AvailablePeachFlavoring)""}}, {""description"": ""The total cherry flavoring used (CherryFlavoringPerPack * number of cherry packs) must not exceed AvailableCherryFlavoring."", ""formulation"": ""CherryFlavoringPerPack \\cdot NumberOfCherryPacks \\leq AvailableCherryFlavoring"", ""code"": {""gurobipy"": ""model.addConstr(CherryFlavoringPerPack * NumberOfCherryPacks <= AvailableCherryFlavoring)""}}, {""description"": ""The number of peach candy packs produced must be greater than the number of cherry candy packs produced."", ""formulation"": ""NumberOfPeachPacks \\geq NumberOfCherryPacks"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfPeachPacks >= NumberOfCherryPacks)""}}, {""description"": ""At least MinimumCherryPercentage fraction of the total candy packs produced must be cherry flavored."", ""formulation"": ""NumberOfCherryPacks \\geq MinimumCherryPercentage \\times (NumberOfCherryPacks + NumberOfPeachPacks)"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfCherryPacks >= MinimumCherryPercentage * (NumberOfCherryPacks + NumberOfPeachPacks))""}}], ""objective"": {""description"": ""Minimize the total amount of special syrup used, which is calculated as (SpecialSyrupPerPackPeach * number of peach packs) + (SpecialSyrupPerPackCherry * number of cherry packs)."", ""formulation"": ""Min \\left( SpecialSyrupPerPackPeach \\times NumberOfPeachPacks + SpecialSyrupPerPackCherry \\times NumberOfCherryPacks \\right )"", ""code"": {""gurobipy"": ""model.setObjective(SpecialSyrupPerPackPeach * NumberOfPeachPacks + SpecialSyrupPerPackCherry * NumberOfCherryPacks, GRB.MINIMIZE)""}}}","{""AvailablePeachFlavoring"": 3000, ""AvailableCherryFlavoring"": 4000, ""PeachFlavoringPerPack"": 3, ""CherryFlavoringPerPack"": 5, ""SpecialSyrupPerPackPeach"": 5, ""SpecialSyrupPerPackCherry"": 4, ""MinimumCherryPercentage"": 0.3}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
The company produces two types of candy packs: peach and cherry. Each pack of
peach candy requires PeachFlavoringPerPack units of peach flavoring and
SpecialSyrupPerPackPeach units of special syrup. Each pack of cherry candy
requires CherryFlavoringPerPack units of cherry flavoring and
SpecialSyrupPerPackCherry units of special syrup. The company has
AvailablePeachFlavoring units of peach flavoring and AvailableCherryFlavoring
units of cherry flavoring available. The number of peach candy packs produced
must be greater than the number of cherry candy packs, and at least
MinimumCherryPercentage fraction of the total packs must be cherry flavored. The
objective is to determine the number of each type of pack to minimize the total
amount of special syrup used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/89/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter AvailablePeachFlavoring @Def: Units of peach flavoring available @Shape: [] 
AvailablePeachFlavoring = data['AvailablePeachFlavoring']
# @Parameter AvailableCherryFlavoring @Def: Units of cherry flavoring available @Shape: [] 
AvailableCherryFlavoring = data['AvailableCherryFlavoring']
# @Parameter PeachFlavoringPerPack @Def: Units of peach flavoring required per pack of peach candy @Shape: [] 
PeachFlavoringPerPack = data['PeachFlavoringPerPack']
# @Parameter CherryFlavoringPerPack @Def: Units of cherry flavoring required per pack of cherry candy @Shape: [] 
CherryFlavoringPerPack = data['CherryFlavoringPerPack']
# @Parameter SpecialSyrupPerPackPeach @Def: Units of special syrup required per pack of peach candy @Shape: [] 
SpecialSyrupPerPackPeach = data['SpecialSyrupPerPackPeach']
# @Parameter SpecialSyrupPerPackCherry @Def: Units of special syrup required per pack of cherry candy @Shape: [] 
SpecialSyrupPerPackCherry = data['SpecialSyrupPerPackCherry']
# @Parameter MinimumCherryPercentage @Def: Minimum fraction of packs that must be cherry flavored @Shape: [] 
MinimumCherryPercentage = data['MinimumCherryPercentage']

# Variables 
# @Variable NumberOfPeachPacks @Def: The number of peach packs to produce @Shape: [] 
NumberOfPeachPacks = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfPeachPacks"")
# @Variable NumberOfCherryPacks @Def: The number of cherry packs to produce @Shape: [] 
NumberOfCherryPacks = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfCherryPacks"")

# Constraints 
# @Constraint Constr_1 @Def: The total peach flavoring used (PeachFlavoringPerPack * number of peach packs) must not exceed AvailablePeachFlavoring.
model.addConstr(PeachFlavoringPerPack * NumberOfPeachPacks <= AvailablePeachFlavoring)
# @Constraint Constr_2 @Def: The total cherry flavoring used (CherryFlavoringPerPack * number of cherry packs) must not exceed AvailableCherryFlavoring.
model.addConstr(CherryFlavoringPerPack * NumberOfCherryPacks <= AvailableCherryFlavoring)
# @Constraint Constr_3 @Def: The number of peach candy packs produced must be greater than the number of cherry candy packs produced.
model.addConstr(NumberOfPeachPacks >= NumberOfCherryPacks)
# @Constraint Constr_4 @Def: At least MinimumCherryPercentage fraction of the total candy packs produced must be cherry flavored.
model.addConstr(NumberOfCherryPacks >= MinimumCherryPercentage * (NumberOfCherryPacks + NumberOfPeachPacks))

# Objective 
# @Objective Objective @Def: Minimize the total amount of special syrup used, which is calculated as (SpecialSyrupPerPackPeach * number of peach packs) + (SpecialSyrupPerPackCherry * number of cherry packs).
model.setObjective(SpecialSyrupPerPackPeach * NumberOfPeachPacks + SpecialSyrupPerPackCherry * NumberOfCherryPacks, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfPeachPacks'] = NumberOfPeachPacks.x
variables['NumberOfCherryPacks'] = NumberOfCherryPacks.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A patient in the hospital can take two pills, Pill 1 and Pill 2. Per pill, pill 1 provides 0.2 units of pain medication and 0.3 units of anxiety medication. Per pill, pill 2 provides 0.6 units of pain medication and 0.2 units of anxiety medication. In addition, pill 1 causes 0.3 units of discharge while pill 2 causes 0.1 units of discharge. At most 6 units of pain medication can be provided and at least 3 units of anxiety medication must be provided. How many pills of each should the patient be given to minimize the total amount of discharge?","{""variables"": {""NumberOfPills"": {""0"": 5.0, ""1"": 8.0}}, ""objective"": 2.3}","{""parametrized_description"": ""A patient can take NumPillTypes different pills. Each pill type provides PainMedicationPerPill units of pain medication and AnxietyMedicationPerPill units of anxiety medication. Additionally, each pill type causes DischargePerPill units of discharge. The total amount of pain medication provided must not exceed MaxPainMedication, and the total amount of anxiety medication provided must be at least MinAnxietyMedication. The goal is to determine the number of pills of each type to minimize the total discharge."", ""keywords"": [""N.A.""], ""parameters"": {""NumPillTypes"": {""description"": ""Number of pill types"", ""shape"": []}, ""PainMedicationPerPill"": {""description"": ""Amount of pain medication provided by one unit of each pill type"", ""shape"": [""NumPillTypes""]}, ""AnxietyMedicationPerPill"": {""description"": ""Amount of anxiety medication provided by one unit of each pill type"", ""shape"": [""NumPillTypes""]}, ""DischargePerPill"": {""description"": ""Amount of discharge caused by one unit of each pill type"", ""shape"": [""NumPillTypes""]}, ""MaxPainMedication"": {""description"": ""Maximum units of pain medication allowed"", ""shape"": []}, ""MinAnxietyMedication"": {""description"": ""Minimum units of anxiety medication required"", ""shape"": []}}, ""variables"": {""NumberOfPills"": {""description"": ""The number of pills of each type"", ""type"": ""continuous"", ""shape"": [""NumPillTypes""]}}, ""constraints"": [{""description"": ""The total amount of pain medication provided, calculated as the sum of PainMedicationPerPill multiplied by the number of pills of each type, must not exceed MaxPainMedication."", ""formulation"": ""\\sum_{j=1}^{NumPillTypes} PainMedicationPerPill_j \\times NumberOfPills_j \\leq MaxPainMedication"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(PainMedicationPerPill[j] * NumberOfPills[j] for j in range(NumPillTypes)) <= MaxPainMedication)""}}, {""description"": ""The total amount of anxiety medication provided, calculated as the sum of AnxietyMedicationPerPill multiplied by the number of pills of each type, must be at least MinAnxietyMedication."", ""formulation"": ""\\sum_{j=1}^{\\text{NumPillTypes}} \\text{AnxietyMedicationPerPill}_j \\times \\text{NumberOfPills}_j \\geq \\text{MinAnxietyMedication}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(AnxietyMedicationPerPill[j] * NumberOfPills[j] for j in range(NumPillTypes)) >= MinAnxietyMedication)""}}], ""objective"": {""description"": ""The objective is to minimize the total discharge, which is calculated as the sum of DischargePerPill multiplied by the number of pills of each type."", ""formulation"": ""Min \\sum_{i=1}^{\\text{NumPillTypes}} \\text{DischargePerPill}_i \\times \\text{NumberOfPills}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(DischargePerPill[i] * NumberOfPills[i] for i in range(NumPillTypes)), GRB.MINIMIZE)""}}}","{""NumPillTypes"": 2, ""PainMedicationPerPill"": [0.2, 0.6], ""AnxietyMedicationPerPill"": [0.3, 0.2], ""DischargePerPill"": [0.3, 0.1], ""MaxPainMedication"": 6, ""MinAnxietyMedication"": 3}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A patient can take NumPillTypes different pills. Each pill type provides
PainMedicationPerPill units of pain medication and AnxietyMedicationPerPill
units of anxiety medication. Additionally, each pill type causes
DischargePerPill units of discharge. The total amount of pain medication
provided must not exceed MaxPainMedication, and the total amount of anxiety
medication provided must be at least MinAnxietyMedication. The goal is to
determine the number of pills of each type to minimize the total discharge.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/90/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumPillTypes @Def: Number of pill types @Shape: [] 
NumPillTypes = data['NumPillTypes']
# @Parameter PainMedicationPerPill @Def: Amount of pain medication provided by one unit of each pill type @Shape: ['NumPillTypes'] 
PainMedicationPerPill = data['PainMedicationPerPill']
# @Parameter AnxietyMedicationPerPill @Def: Amount of anxiety medication provided by one unit of each pill type @Shape: ['NumPillTypes'] 
AnxietyMedicationPerPill = data['AnxietyMedicationPerPill']
# @Parameter DischargePerPill @Def: Amount of discharge caused by one unit of each pill type @Shape: ['NumPillTypes'] 
DischargePerPill = data['DischargePerPill']
# @Parameter MaxPainMedication @Def: Maximum units of pain medication allowed @Shape: [] 
MaxPainMedication = data['MaxPainMedication']
# @Parameter MinAnxietyMedication @Def: Minimum units of anxiety medication required @Shape: [] 
MinAnxietyMedication = data['MinAnxietyMedication']

# Variables 
# @Variable NumberOfPills @Def: The number of pills of each type @Shape: ['NumPillTypes'] 
NumberOfPills = model.addVars(NumPillTypes, vtype=GRB.INTEGER, name=""NumberOfPills"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of pain medication provided, calculated as the sum of PainMedicationPerPill multiplied by the number of pills of each type, must not exceed MaxPainMedication.
model.addConstr(quicksum(PainMedicationPerPill[j] * NumberOfPills[j] for j in range(NumPillTypes)) <= MaxPainMedication)
# @Constraint Constr_2 @Def: The total amount of anxiety medication provided, calculated as the sum of AnxietyMedicationPerPill multiplied by the number of pills of each type, must be at least MinAnxietyMedication.
model.addConstr(quicksum(AnxietyMedicationPerPill[j] * NumberOfPills[j] for j in range(NumPillTypes)) >= MinAnxietyMedication)

# Objective 
# @Objective Objective @Def: The objective is to minimize the total discharge, which is calculated as the sum of DischargePerPill multiplied by the number of pills of each type.
model.setObjective(quicksum(DischargePerPill[i] * NumberOfPills[i] for i in range(NumPillTypes)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
# variables['NumberOfPills'] = NumberOfPills.x
variables['NumberOfPills'] = {j: NumberOfPills[j].x for j in range(NumPillTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A man on a strict diet only drinks meal replacement drinks from two brands, alpha and omega. The alpha brand drink contains 30 grams of protein, 20 grams of sugar, and 350 calories per bottle. The omega brand drink contains 20 grams of protein, 15 grams of sugar, and 300 calories per bottle. The man wants to get at least 100 grams of protein and 2000 calories. In addition, because the omega brand drink contains tiny amounts of caffeine, at most 35% of the drink should be omega brand. How many bottles of each should he drink to minimize his sugar intake?","{""variables"": {""QuantityAlpha"": 3.909774436090226, ""QuantityOmega"": 2.1052631578947367}, ""objective"": 109.77443609022556}","{""parametrized_description"": ""A man selects quantities of alpha and omega brand meal replacement drink bottles to minimize the total sugar intake, calculated as SugarAlpha multiplied by the number of alpha bottles plus SugarOmega multiplied by the number of omega bottles. The selection must ensure that the total protein intake, which is ProteinAlpha times the number of alpha bottles plus ProteinOmega times the number of omega bottles, is at least MinProtein. Additionally, the total calorie intake, defined as CaloriesAlpha times the number of alpha bottles plus CaloriesOmega times the number of omega bottles, must be at least MinCalories. Furthermore, the proportion of omega brand bottles should not exceed MaxOmegaFraction of the total number of bottles consumed."", ""keywords"": [""N.A.""], ""parameters"": {""ProteinAlpha"": {""description"": ""Amount of protein per bottle of the alpha brand drink"", ""shape"": []}, ""SugarAlpha"": {""description"": ""Amount of sugar per bottle of the alpha brand drink"", ""shape"": []}, ""CaloriesAlpha"": {""description"": ""Number of calories per bottle of the alpha brand drink"", ""shape"": []}, ""ProteinOmega"": {""description"": ""Amount of protein per bottle of the omega brand drink"", ""shape"": []}, ""SugarOmega"": {""description"": ""Amount of sugar per bottle of the omega brand drink"", ""shape"": []}, ""CaloriesOmega"": {""description"": ""Number of calories per bottle of the omega brand drink"", ""shape"": []}, ""MinProtein"": {""description"": ""Minimum total protein required"", ""shape"": []}, ""MinCalories"": {""description"": ""Minimum total calories required"", ""shape"": []}, ""MaxOmegaFraction"": {""description"": ""Maximum proportion of omega brand drinks allowed"", ""shape"": []}}, ""variables"": {""QuantityAlpha"": {""description"": ""The number of alpha brand drink bottles"", ""type"": ""continuous"", ""shape"": []}, ""QuantityOmega"": {""description"": ""The number of omega brand drink bottles"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total protein intake from alpha and omega bottles must be at least MinProtein."", ""formulation"": ""ProteinAlpha \\times QuantityAlpha + ProteinOmega \\times QuantityOmega \\geq MinProtein"", ""code"": {""gurobipy"": ""model.addConstr(ProteinAlpha * QuantityAlpha + ProteinOmega * QuantityOmega >= MinProtein)""}}, {""description"": ""The total calorie intake from alpha and omega bottles must be at least MinCalories."", ""formulation"": ""CaloriesAlpha \\times QuantityAlpha + CaloriesOmega \\times QuantityOmega \\geq MinCalories"", ""code"": {""gurobipy"": ""model.addConstr(CaloriesAlpha * QuantityAlpha + CaloriesOmega * QuantityOmega >= MinCalories)""}}, {""description"": ""The proportion of omega brand bottles must not exceed MaxOmegaFraction of the total number of bottles consumed."", ""formulation"": ""QuantityOmega \\leq MaxOmegaFraction \\times (QuantityAlpha + QuantityOmega)"", ""code"": {""gurobipy"": ""model.addConstr((1 - MaxOmegaFraction) * QuantityOmega <= MaxOmegaFraction * QuantityAlpha)""}}], ""objective"": {""description"": ""Minimize the total sugar intake, calculated as SugarAlpha multiplied by the number of alpha bottles plus SugarOmega multiplied by the number of omega bottles."", ""formulation"": ""Min \\ SugarAlpha \\cdot QuantityAlpha + SugarOmega \\cdot QuantityOmega"", ""code"": {""gurobipy"": ""model.setObjective(SugarAlpha * QuantityAlpha + SugarOmega * QuantityOmega, GRB.MINIMIZE)""}}}","{""ProteinAlpha"": 30, ""SugarAlpha"": 20, ""CaloriesAlpha"": 350, ""ProteinOmega"": 20, ""SugarOmega"": 15, ""CaloriesOmega"": 300, ""MinProtein"": 100, ""MinCalories"": 2000, ""MaxOmegaFraction"": 0.35}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A man selects quantities of alpha and omega brand meal replacement drink bottles
to minimize the total sugar intake, calculated as SugarAlpha multiplied by the
number of alpha bottles plus SugarOmega multiplied by the number of omega
bottles. The selection must ensure that the total protein intake, which is
ProteinAlpha times the number of alpha bottles plus ProteinOmega times the
number of omega bottles, is at least MinProtein. Additionally, the total calorie
intake, defined as CaloriesAlpha times the number of alpha bottles plus
CaloriesOmega times the number of omega bottles, must be at least MinCalories.
Furthermore, the proportion of omega brand bottles should not exceed
MaxOmegaFraction of the total number of bottles consumed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/91/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProteinAlpha @Def: Amount of protein per bottle of the alpha brand drink @Shape: [] 
ProteinAlpha = data['ProteinAlpha']
# @Parameter SugarAlpha @Def: Amount of sugar per bottle of the alpha brand drink @Shape: [] 
SugarAlpha = data['SugarAlpha']
# @Parameter CaloriesAlpha @Def: Number of calories per bottle of the alpha brand drink @Shape: [] 
CaloriesAlpha = data['CaloriesAlpha']
# @Parameter ProteinOmega @Def: Amount of protein per bottle of the omega brand drink @Shape: [] 
ProteinOmega = data['ProteinOmega']
# @Parameter SugarOmega @Def: Amount of sugar per bottle of the omega brand drink @Shape: [] 
SugarOmega = data['SugarOmega']
# @Parameter CaloriesOmega @Def: Number of calories per bottle of the omega brand drink @Shape: [] 
CaloriesOmega = data['CaloriesOmega']
# @Parameter MinProtein @Def: Minimum total protein required @Shape: [] 
MinProtein = data['MinProtein']
# @Parameter MinCalories @Def: Minimum total calories required @Shape: [] 
MinCalories = data['MinCalories']
# @Parameter MaxOmegaFraction @Def: Maximum proportion of omega brand drinks allowed @Shape: [] 
MaxOmegaFraction = data['MaxOmegaFraction']

# Variables 
# @Variable QuantityAlpha @Def: The number of alpha brand drink bottles @Shape: [] 
QuantityAlpha = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityAlpha"")
# @Variable QuantityOmega @Def: The number of omega brand drink bottles @Shape: [] 
QuantityOmega = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityOmega"")

# Constraints 
# @Constraint Constr_1 @Def: The total protein intake from alpha and omega bottles must be at least MinProtein.
model.addConstr(ProteinAlpha * QuantityAlpha + ProteinOmega * QuantityOmega >= MinProtein)
# @Constraint Constr_2 @Def: The total calorie intake from alpha and omega bottles must be at least MinCalories.
model.addConstr(CaloriesAlpha * QuantityAlpha + CaloriesOmega * QuantityOmega >= MinCalories)
# @Constraint Constr_3 @Def: The proportion of omega brand bottles must not exceed MaxOmegaFraction of the total number of bottles consumed.
model.addConstr((1 - MaxOmegaFraction) * QuantityOmega <= MaxOmegaFraction * QuantityAlpha)

# Objective 
# @Objective Objective @Def: Minimize the total sugar intake, calculated as SugarAlpha multiplied by the number of alpha bottles plus SugarOmega multiplied by the number of omega bottles.
model.setObjective(SugarAlpha * QuantityAlpha + SugarOmega * QuantityOmega, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityAlpha'] = QuantityAlpha.x
variables['QuantityOmega'] = QuantityOmega.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A summer camps does science experiments in two pre filled beakers, beaker 1 and beaker 2. Beaker 1 uses 4 units of flour and 6 units of special liquid to make 5 units of slime. Beaker 2 uses 6 units of flour and 3 units of special liquid to make 3 units of slime.  However, beaker 1 creates 4 units of waste while beaker 2 creates 2 units of waste. The summer camp has available 150 units of flour and 100 units of special liquid. If at most 30 units of waste can be produced, how many of each beaker should be used to maximize the amount of slime produced?","{""variables"": {""FlourUsedPerBeaker"": {""0"": 0.0, ""1"": 15.0}}, ""objective"": 45.0}","{""parametrized_description"": ""The summer camp uses NumBeakers different types of beakers. Each beaker type i consumes FlourUsagePerBeaker[i] units of flour and SpecialLiquidUsagePerBeaker[i] units of special liquid to produce SlimeProducedPerBeaker[i] units of slime and WasteProducedPerBeaker[i] units of waste. The camp has FlourAvailable units of flour and SpecialLiquidAvailable units of special liquid available. The total waste produced must not exceed MaxWasteAllowed. The goal is to determine how many beakers of each type to use to maximize the total amount of slime produced."", ""keywords"": [""N.A.""], ""parameters"": {""NumBeakers"": {""description"": ""Number of beakers"", ""shape"": []}, ""FlourAvailable"": {""description"": ""Amount of flour available"", ""shape"": []}, ""SpecialLiquidAvailable"": {""description"": ""Amount of special liquid available"", ""shape"": []}, ""MaxWasteAllowed"": {""description"": ""Maximum amount of waste allowed"", ""shape"": []}, ""FlourUsagePerBeaker"": {""description"": ""Amount of flour used by each beaker"", ""shape"": [""NumBeakers""]}, ""SpecialLiquidUsagePerBeaker"": {""description"": ""Amount of special liquid used by each beaker"", ""shape"": [""NumBeakers""]}, ""SlimeProducedPerBeaker"": {""description"": ""Amount of slime produced by each beaker"", ""shape"": [""NumBeakers""]}, ""WasteProducedPerBeaker"": {""description"": ""Amount of waste produced by each beaker"", ""shape"": [""NumBeakers""]}}, ""variables"": {""FlourUsedPerBeaker"": {""description"": ""The amount of flour used by beaker i"", ""type"": ""continuous"", ""shape"": [""NumBeakers""]}}, ""constraints"": [{""description"": ""The total amount of flour used by all beakers does not exceed FlourAvailable."", ""formulation"": ""\\sum_{i=1}^{\\text{NumBeakers}} \\text{FlourUsedPerBeaker}_i \\leq \\text{FlourAvailable}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(FlourUsedPerBeaker[i] for i in range(NumBeakers)) <= FlourAvailable)""}}, {""description"": ""The total amount of special liquid used by all beakers does not exceed SpecialLiquidAvailable."", ""formulation"": ""\\sum_{i=1}^{NumBeakers} SpecialLiquidUsagePerBeaker_i \\cdot FlourUsedPerBeaker_i \\leq SpecialLiquidAvailable"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(SpecialLiquidUsagePerBeaker[i] * FlourUsedPerBeaker[i] for i in range(NumBeakers)) <= SpecialLiquidAvailable)""}}, {""description"": ""The total amount of waste produced by all beakers does not exceed MaxWasteAllowed."", ""formulation"": ""\\sum_{i=1}^{\\text{NumBeakers}} WasteProducedPerBeaker_i \\cdot FlourUsedPerBeaker_i \\leq MaxWasteAllowed"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(WasteProducedPerBeaker[i] * FlourUsedPerBeaker[i] for i in range(NumBeakers)) <= MaxWasteAllowed)""}}], ""objective"": {""description"": ""The total amount of slime produced by all beakers is maximized."", ""formulation"": ""Max \\sum_{i=1}^{NumBeakers} SlimeProducedPerBeaker_i \\cdot FlourUsedPerBeaker_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(SlimeProducedPerBeaker[i] * FlourUsedPerBeaker[i] for i in range(NumBeakers)), GRB.MAXIMIZE)""}}}","{""NumBeakers"": 2, ""FlourAvailable"": 150, ""SpecialLiquidAvailable"": 100, ""MaxWasteAllowed"": 30, ""FlourUsagePerBeaker"": [4, 6], ""SpecialLiquidUsagePerBeaker"": [6, 3], ""SlimeProducedPerBeaker"": [5, 3], ""WasteProducedPerBeaker"": [4, 2]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
The summer camp uses NumBeakers different types of beakers. Each beaker type i
consumes FlourUsagePerBeaker[i] units of flour and
SpecialLiquidUsagePerBeaker[i] units of special liquid to produce
SlimeProducedPerBeaker[i] units of slime and WasteProducedPerBeaker[i] units of
waste. The camp has FlourAvailable units of flour and SpecialLiquidAvailable
units of special liquid available. The total waste produced must not exceed
MaxWasteAllowed. The goal is to determine how many beakers of each type to use
to maximize the total amount of slime produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/92/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumBeakers @Def: Number of beakers @Shape: [] 
NumBeakers = data['NumBeakers']
# @Parameter FlourAvailable @Def: Amount of flour available @Shape: [] 
FlourAvailable = data['FlourAvailable']
# @Parameter SpecialLiquidAvailable @Def: Amount of special liquid available @Shape: [] 
SpecialLiquidAvailable = data['SpecialLiquidAvailable']
# @Parameter MaxWasteAllowed @Def: Maximum amount of waste allowed @Shape: [] 
MaxWasteAllowed = data['MaxWasteAllowed']
# @Parameter FlourUsagePerBeaker @Def: Amount of flour used by each beaker @Shape: ['NumBeakers'] 
FlourUsagePerBeaker = data['FlourUsagePerBeaker']
# @Parameter SpecialLiquidUsagePerBeaker @Def: Amount of special liquid used by each beaker @Shape: ['NumBeakers'] 
SpecialLiquidUsagePerBeaker = data['SpecialLiquidUsagePerBeaker']
# @Parameter SlimeProducedPerBeaker @Def: Amount of slime produced by each beaker @Shape: ['NumBeakers'] 
SlimeProducedPerBeaker = data['SlimeProducedPerBeaker']
# @Parameter WasteProducedPerBeaker @Def: Amount of waste produced by each beaker @Shape: ['NumBeakers'] 
WasteProducedPerBeaker = data['WasteProducedPerBeaker']

# Variables 
# @Variable FlourUsedPerBeaker @Def: The amount of flour used by beaker i @Shape: ['NumBeakers'] 
FlourUsedPerBeaker = model.addVars(NumBeakers, vtype=GRB.CONTINUOUS, name=""FlourUsedPerBeaker"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of flour used by all beakers does not exceed FlourAvailable.
model.addConstr(quicksum(FlourUsedPerBeaker[i] for i in range(NumBeakers)) <= FlourAvailable)
# @Constraint Constr_2 @Def: The total amount of special liquid used by all beakers does not exceed SpecialLiquidAvailable.
model.addConstr(quicksum(SpecialLiquidUsagePerBeaker[i] * FlourUsedPerBeaker[i] for i in range(NumBeakers)) <= SpecialLiquidAvailable)
# @Constraint Constr_3 @Def: The total amount of waste produced by all beakers does not exceed MaxWasteAllowed.
model.addConstr(quicksum(WasteProducedPerBeaker[i] * FlourUsedPerBeaker[i] for i in range(NumBeakers)) <= MaxWasteAllowed)

# Objective 
# @Objective Objective @Def: The total amount of slime produced by all beakers is maximized.
model.setObjective(quicksum(SlimeProducedPerBeaker[i] * FlourUsedPerBeaker[i] for i in range(NumBeakers)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['FlourUsedPerBeaker'] = {i: FlourUsedPerBeaker[i].X for i in range(NumBeakers)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"An dog hospital has 2000 units of tooth medication to make both small and large bones. A small bone requires 10 units of tooth medication and 12 units of meat. A large bone requires 15 units of tooth medication and 15 units of meat. Since most dogs prefer the small bones, at least 50% of the bones made must be small. In addition, the hospital must make at least 30 large bones. How many of each bone should be made to minimize the amount of meat needed?","{""variables"": {""SmallBones"": 30.0, ""LargeBones"": 30.0}, ""objective"": 810.0}","{""parametrized_description"": ""A dog hospital has TotalToothMedication units of tooth medication available to produce both small and large bones. Each small bone requires ToothMedicationPerSmallBone units of tooth medication and MeatPerSmallBone units of meat. Each large bone requires ToothMedicationPerLargeBone units of tooth medication and MeatPerLargeBone units of meat. At least MinProportionSmallBones proportion of the bones produced must be small. Additionally, the hospital must produce at least MinLargeBones large bones. Determine the number of small and large bones to produce to minimize the total amount of meat used."", ""keywords"": [""N.A.""], ""parameters"": {""TotalToothMedication"": {""description"": ""Total units of tooth medication available for making bones"", ""shape"": []}, ""ToothMedicationPerSmallBone"": {""description"": ""Units of tooth medication required to make one small bone"", ""shape"": []}, ""MeatPerSmallBone"": {""description"": ""Units of meat required to make one small bone"", ""shape"": []}, ""ToothMedicationPerLargeBone"": {""description"": ""Units of tooth medication required to make one large bone"", ""shape"": []}, ""MeatPerLargeBone"": {""description"": ""Units of meat required to make one large bone"", ""shape"": []}, ""MinProportionSmallBones"": {""description"": ""Minimum proportion of bones that must be small"", ""shape"": []}, ""MinLargeBones"": {""description"": ""Minimum number of large bones to be made"", ""shape"": []}}, ""variables"": {""SmallBones"": {""description"": ""The number of small bones produced"", ""type"": ""continuous"", ""shape"": []}, ""LargeBones"": {""description"": ""The number of large bones produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total tooth medication used to produce small and large bones cannot exceed TotalToothMedication units."", ""formulation"": ""ToothMedicationPerSmallBone \\cdot SmallBones + ToothMedicationPerLargeBone \\cdot LargeBones \\leq TotalToothMedication"", ""code"": {""gurobipy"": ""model.addConstr(ToothMedicationPerSmallBone * SmallBones + ToothMedicationPerLargeBone * LargeBones <= TotalToothMedication)""}}, {""description"": ""At least MinProportionSmallBones proportion of the bones produced must be small."", ""formulation"": ""SmallBones \\geq MinProportionSmallBones \\cdot (SmallBones + LargeBones)"", ""code"": {""gurobipy"": ""model.addConstr(SmallBones >= MinProportionSmallBones * (SmallBones + LargeBones), 'MinProportionSmallBones')""}}, {""description"": ""The hospital must produce at least MinLargeBones large bones."", ""formulation"": ""LargeBones \\geq MinLargeBones"", ""code"": {""gurobipy"": ""model.addConstr(LargeBones >= MinLargeBones)""}}], ""objective"": {""description"": ""Minimize the total amount of meat used in producing small and large bones."", ""formulation"": ""Min \\ MeatPerSmallBone \\cdot SmallBones + MeatPerLargeBone \\cdot LargeBones"", ""code"": {""gurobipy"": ""model.setObjective(MeatPerSmallBone * SmallBones + MeatPerLargeBone * LargeBones, GRB.MINIMIZE)""}}}","{""TotalToothMedication"": 2000, ""ToothMedicationPerSmallBone"": 10, ""MeatPerSmallBone"": 12, ""ToothMedicationPerLargeBone"": 15, ""MeatPerLargeBone"": 15, ""MinProportionSmallBones"": 0.5, ""MinLargeBones"": 30}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A dog hospital has TotalToothMedication units of tooth medication available to
produce both small and large bones. Each small bone requires
ToothMedicationPerSmallBone units of tooth medication and MeatPerSmallBone units
of meat. Each large bone requires ToothMedicationPerLargeBone units of tooth
medication and MeatPerLargeBone units of meat. At least MinProportionSmallBones
proportion of the bones produced must be small. Additionally, the hospital must
produce at least MinLargeBones large bones. Determine the number of small and
large bones to produce to minimize the total amount of meat used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/93/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalToothMedication @Def: Total units of tooth medication available for making bones @Shape: [] 
TotalToothMedication = data['TotalToothMedication']
# @Parameter ToothMedicationPerSmallBone @Def: Units of tooth medication required to make one small bone @Shape: [] 
ToothMedicationPerSmallBone = data['ToothMedicationPerSmallBone']
# @Parameter MeatPerSmallBone @Def: Units of meat required to make one small bone @Shape: [] 
MeatPerSmallBone = data['MeatPerSmallBone']
# @Parameter ToothMedicationPerLargeBone @Def: Units of tooth medication required to make one large bone @Shape: [] 
ToothMedicationPerLargeBone = data['ToothMedicationPerLargeBone']
# @Parameter MeatPerLargeBone @Def: Units of meat required to make one large bone @Shape: [] 
MeatPerLargeBone = data['MeatPerLargeBone']
# @Parameter MinProportionSmallBones @Def: Minimum proportion of bones that must be small @Shape: [] 
MinProportionSmallBones = data['MinProportionSmallBones']
# @Parameter MinLargeBones @Def: Minimum number of large bones to be made @Shape: [] 
MinLargeBones = data['MinLargeBones']

# Variables 
# @Variable SmallBones @Def: The number of small bones produced @Shape: [] 
SmallBones = model.addVar(vtype=GRB.INTEGER, name=""SmallBones"")
# @Variable LargeBones @Def: The number of large bones produced @Shape: [] 
LargeBones = model.addVar(vtype=GRB.INTEGER, name=""LargeBones"")

# Constraints 
# @Constraint Constr_1 @Def: The total tooth medication used to produce small and large bones cannot exceed TotalToothMedication units.
model.addConstr(ToothMedicationPerSmallBone * SmallBones + ToothMedicationPerLargeBone * LargeBones <= TotalToothMedication)
# @Constraint Constr_2 @Def: At least MinProportionSmallBones proportion of the bones produced must be small.
model.addConstr(SmallBones >= MinProportionSmallBones * (SmallBones + LargeBones), 'MinProportionSmallBones')
# @Constraint Constr_3 @Def: The hospital must produce at least MinLargeBones large bones.
model.addConstr(LargeBones >= MinLargeBones)

# Objective 
# @Objective Objective @Def: Minimize the total amount of meat used in producing small and large bones.
model.setObjective(MeatPerSmallBone * SmallBones + MeatPerLargeBone * LargeBones, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SmallBones'] = SmallBones.x
variables['LargeBones'] = LargeBones.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A scientist in the arctic needs to get enough vitamin D and vitamin C in his diet by drinking orange and apple juice. Each box of orange juice contains 10 units of vitamin D and 8 units of vitamin C. Each box of apple juice contains 12 units of vitamin D and 6 units of vitamin C. Since the scientist prefers apple juice, he must drink at least 3 times as many apple juice boxes and orange juice boxes. However, he must also drink at least 3 orange juice boxes. To avoid a vitamin C overdose, the scientist can consume at most 300 units of vitamin C. How many of each juice box should he drink to maximize his total vitamin D intake?","{""variables"": {""NumberOfAppleJuiceBoxes"": 46.0, ""NumberOfOrangeJuiceBoxes"": 3.0}, ""objective"": 582.0}","{""parametrized_description"": ""A scientist needs to determine the number of orange juice boxes and apple juice boxes to consume. Each orange juice box provides VitaminDOrange units of vitamin D and VitaminCOrange units of vitamin C. Each apple juice box provides VitaminDApple units of vitamin D and VitaminCApple units of vitamin C. The number of apple juice boxes must be at least PreferenceRatio times the number of orange juice boxes. The scientist must consume at least MinimumOrangeBoxes orange juice boxes. To prevent vitamin C overdose, the total vitamin C intake must not exceed MaxVitaminC. The objective is to maximize the total vitamin D intake."", ""keywords"": [""N.A.""], ""parameters"": {""VitaminDOrange"": {""description"": ""Amount of vitamin D in each box of orange juice"", ""shape"": []}, ""VitaminCOrange"": {""description"": ""Amount of vitamin C in each box of orange juice"", ""shape"": []}, ""VitaminDApple"": {""description"": ""Amount of vitamin D in each box of apple juice"", ""shape"": []}, ""VitaminCApple"": {""description"": ""Amount of vitamin C in each box of apple juice"", ""shape"": []}, ""PreferenceRatio"": {""description"": ""Minimum ratio of apple juice boxes to orange juice boxes"", ""shape"": []}, ""MinimumOrangeBoxes"": {""description"": ""Minimum number of orange juice boxes to be consumed"", ""shape"": []}, ""MaxVitaminC"": {""description"": ""Maximum allowed units of vitamin C intake"", ""shape"": []}}, ""variables"": {""NumberOfAppleJuiceBoxes"": {""description"": ""The number of apple juice boxes"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfOrangeJuiceBoxes"": {""description"": ""The number of orange juice boxes"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of apple juice boxes must be at least PreferenceRatio times the number of orange juice boxes."", ""formulation"": ""NumberOfAppleJuiceBoxes \\geq PreferenceRatio \\times NumberOfOrangeJuiceBoxes"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfAppleJuiceBoxes >= PreferenceRatio * NumberOfOrangeJuiceBoxes)""}}, {""description"": ""The scientist must consume at least MinimumOrangeBoxes orange juice boxes."", ""formulation"": ""NumberOfOrangeJuiceBoxes \\geq MinimumOrangeBoxes"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfOrangeJuiceBoxes >= MinimumOrangeBoxes)""}}, {""description"": ""The total vitamin C intake from orange and apple juice boxes must not exceed MaxVitaminC."", ""formulation"": ""VitaminCOrange \\cdot NumberOfOrangeJuiceBoxes + VitaminCApple \\cdot NumberOfAppleJuiceBoxes \\leq MaxVitaminC"", ""code"": {""gurobipy"": ""model.addConstr(VitaminCOrange * NumberOfOrangeJuiceBoxes + VitaminCApple * NumberOfAppleJuiceBoxes <= MaxVitaminC)""}}], ""objective"": {""description"": ""Total vitamin D intake is the sum of the vitamin D provided by orange juice boxes and the vitamin D provided by apple juice boxes. The objective is to maximize the total vitamin D intake."", ""formulation"": ""Max \\left( NumberOfAppleJuiceBoxes \\times VitaminDApple + NumberOfOrangeJuiceBoxes \\times VitaminDOrange \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfAppleJuiceBoxes * VitaminDApple + NumberOfOrangeJuiceBoxes * VitaminDOrange, GRB.MAXIMIZE)""}}}","{""VitaminDOrange"": 10, ""VitaminCOrange"": 8, ""VitaminDApple"": 12, ""VitaminCApple"": 6, ""PreferenceRatio"": 3, ""MinimumOrangeBoxes"": 3, ""MaxVitaminC"": 300}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A scientist needs to determine the number of orange juice boxes and apple juice
boxes to consume. Each orange juice box provides VitaminDOrange units of vitamin
D and VitaminCOrange units of vitamin C. Each apple juice box provides
VitaminDApple units of vitamin D and VitaminCApple units of vitamin C. The
number of apple juice boxes must be at least PreferenceRatio times the number of
orange juice boxes. The scientist must consume at least MinimumOrangeBoxes
orange juice boxes. To prevent vitamin C overdose, the total vitamin C intake
must not exceed MaxVitaminC. The objective is to maximize the total vitamin D
intake.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/94/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter VitaminDOrange @Def: Amount of vitamin D in each box of orange juice @Shape: [] 
VitaminDOrange = data['VitaminDOrange']
# @Parameter VitaminCOrange @Def: Amount of vitamin C in each box of orange juice @Shape: [] 
VitaminCOrange = data['VitaminCOrange']
# @Parameter VitaminDApple @Def: Amount of vitamin D in each box of apple juice @Shape: [] 
VitaminDApple = data['VitaminDApple']
# @Parameter VitaminCApple @Def: Amount of vitamin C in each box of apple juice @Shape: [] 
VitaminCApple = data['VitaminCApple']
# @Parameter PreferenceRatio @Def: Minimum ratio of apple juice boxes to orange juice boxes @Shape: [] 
PreferenceRatio = data['PreferenceRatio']
# @Parameter MinimumOrangeBoxes @Def: Minimum number of orange juice boxes to be consumed @Shape: [] 
MinimumOrangeBoxes = data['MinimumOrangeBoxes']
# @Parameter MaxVitaminC @Def: Maximum allowed units of vitamin C intake @Shape: [] 
MaxVitaminC = data['MaxVitaminC']

# Variables 
# @Variable NumberOfAppleJuiceBoxes @Def: The number of apple juice boxes @Shape: [] 
NumberOfAppleJuiceBoxes = model.addVar(vtype=GRB.INTEGER, name=""NumberOfAppleJuiceBoxes"")
# @Variable NumberOfOrangeJuiceBoxes @Def: The number of orange juice boxes @Shape: [] 
NumberOfOrangeJuiceBoxes = model.addVar(vtype=GRB.INTEGER, name=""NumberOfOrangeJuiceBoxes"")

# Constraints 
# @Constraint Constr_1 @Def: The number of apple juice boxes must be at least PreferenceRatio times the number of orange juice boxes.
model.addConstr(NumberOfAppleJuiceBoxes >= PreferenceRatio * NumberOfOrangeJuiceBoxes)
# @Constraint Constr_2 @Def: The scientist must consume at least MinimumOrangeBoxes orange juice boxes.
model.addConstr(NumberOfOrangeJuiceBoxes >= MinimumOrangeBoxes)
# @Constraint Constr_3 @Def: The total vitamin C intake from orange and apple juice boxes must not exceed MaxVitaminC.
model.addConstr(VitaminCOrange * NumberOfOrangeJuiceBoxes + VitaminCApple * NumberOfAppleJuiceBoxes <= MaxVitaminC)

# Objective 
# @Objective Objective @Def: Total vitamin D intake is the sum of the vitamin D provided by orange juice boxes and the vitamin D provided by apple juice boxes. The objective is to maximize the total vitamin D intake.
model.setObjective(NumberOfAppleJuiceBoxes * VitaminDApple + NumberOfOrangeJuiceBoxes * VitaminDOrange, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfAppleJuiceBoxes'] = NumberOfAppleJuiceBoxes.x
variables['NumberOfOrangeJuiceBoxes'] = NumberOfOrangeJuiceBoxes.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A cleaning company uses a cleansing chemical and odor-removing chemical to clean a house. Each unit of the cleansing chemical takes 4 units to be effective while each unit of the odor-removing chemical takes 6 minutes to be effective. The company must use at least 100 units of the cleansing chemical. In total, at least 300 units of chemicals can be used per house. Further, because the cleansing chemical is strong, there can be at most twice the amount of cleansing chemical as odor-removing chemical. How many units of each should be used to minimize the total time it takes for a house to be cleaned?","{""variables"": {""CleansingChemicalUnits"": 100.0, ""OdorRemovingChemicalUnits"": 50.0}, ""objective"": 700.0}","{""parametrized_description"": ""A cleaning company uses a cleansing chemical and an odor-removing chemical to clean a house. Each unit of the cleansing chemical requires CleansingChemicalTime to be effective, while each unit of the odor-removing chemical requires OdorRemovingChemicalTime to be effective. The company must use at least MinCleansingUnits of the cleansing chemical. The total number of chemical units used per house cannot exceed MaxTotalUnits. Additionally, the number of cleansing chemical units used cannot exceed MaxCleansingToOdorRatio times the number of odor-removing chemical units used. Determine the number of units of each chemical to minimize the total time it takes for a house to be cleaned."", ""keywords"": [""N.A.""], ""parameters"": {""CleansingChemicalTime"": {""description"": ""Time it takes for one unit of cleansing chemical to be effective"", ""shape"": []}, ""OdorRemovingChemicalTime"": {""description"": ""Time it takes for one unit of odor-removing chemical to be effective"", ""shape"": []}, ""MinCleansingUnits"": {""description"": ""Minimum number of units of cleansing chemical to be used per house"", ""shape"": []}, ""MaxTotalUnits"": {""description"": ""Maximum total number of chemical units used per house"", ""shape"": []}, ""MaxCleansingToOdorRatio"": {""description"": ""Maximum ratio of cleansing chemical units to odor-removing chemical units"", ""shape"": []}}, ""variables"": {""CleansingChemicalUnits"": {""description"": ""The number of units of cleansing chemical used per house"", ""type"": ""continuous"", ""shape"": []}, ""OdorRemovingChemicalUnits"": {""description"": ""The number of units of odor-removing chemical used per house"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The company must use at least MinCleansingUnits of the cleansing chemical per house."", ""formulation"": ""CleansingChemicalUnits \\geq MinCleansingUnits"", ""code"": {""gurobipy"": ""model.addConstr(CleansingChemicalUnits >= MinCleansingUnits)""}}, {""description"": ""The total number of chemical units used per house cannot exceed MaxTotalUnits."", ""formulation"": ""CleansingChemicalUnits + OdorRemovingChemicalUnits \\leq MaxTotalUnits"", ""code"": {""gurobipy"": ""model.addConstr(CleansingChemicalUnits + OdorRemovingChemicalUnits <= MaxTotalUnits)""}}, {""description"": ""The number of cleansing chemical units used cannot exceed MaxCleansingToOdorRatio times the number of odor-removing chemical units used."", ""formulation"": ""CleansingChemicalUnits \\leq MaxCleansingToOdorRatio \\cdot OdorRemovingChemicalUnits"", ""code"": {""gurobipy"": ""model.addConstr(CleansingChemicalUnits <= MaxCleansingToOdorRatio * OdorRemovingChemicalUnits)""}}], ""objective"": {""description"": ""Minimize the total cleaning time, which is the sum of CleansingChemicalTime multiplied by the number of cleansing chemical units and OdorRemovingChemicalTime multiplied by the number of odor-removing chemical units."", ""formulation"": ""Min CleansingChemicalTime \\cdot CleansingChemicalUnits + OdorRemovingChemicalTime \\cdot OdorRemovingChemicalUnits"", ""code"": {""gurobipy"": ""model.setObjective(CleansingChemicalTime * CleansingChemicalUnits + OdorRemovingChemicalTime * OdorRemovingChemicalUnits, GRB.MINIMIZE)""}}}","{""CleansingChemicalTime"": 4, ""OdorRemovingChemicalTime"": 6, ""MinCleansingUnits"": 100, ""MaxTotalUnits"": 300, ""MaxCleansingToOdorRatio"": 2}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A cleaning company uses a cleansing chemical and an odor-removing chemical to
clean a house. Each unit of the cleansing chemical requires
CleansingChemicalTime to be effective, while each unit of the odor-removing
chemical requires OdorRemovingChemicalTime to be effective. The company must use
at least MinCleansingUnits of the cleansing chemical. The total number of
chemical units used per house cannot exceed MaxTotalUnits. Additionally, the
number of cleansing chemical units used cannot exceed MaxCleansingToOdorRatio
times the number of odor-removing chemical units used. Determine the number of
units of each chemical to minimize the total time it takes for a house to be
cleaned.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/95/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CleansingChemicalTime @Def: Time it takes for one unit of cleansing chemical to be effective @Shape: [] 
CleansingChemicalTime = data['CleansingChemicalTime']
# @Parameter OdorRemovingChemicalTime @Def: Time it takes for one unit of odor-removing chemical to be effective @Shape: [] 
OdorRemovingChemicalTime = data['OdorRemovingChemicalTime']
# @Parameter MinCleansingUnits @Def: Minimum number of units of cleansing chemical to be used per house @Shape: [] 
MinCleansingUnits = data['MinCleansingUnits']
# @Parameter MaxTotalUnits @Def: Maximum total number of chemical units used per house @Shape: [] 
MaxTotalUnits = data['MaxTotalUnits']
# @Parameter MaxCleansingToOdorRatio @Def: Maximum ratio of cleansing chemical units to odor-removing chemical units @Shape: [] 
MaxCleansingToOdorRatio = data['MaxCleansingToOdorRatio']

# Variables 
# @Variable CleansingChemicalUnits @Def: The number of units of cleansing chemical used per house @Shape: [] 
CleansingChemicalUnits = model.addVar(vtype=GRB.CONTINUOUS, lb=MinCleansingUnits, ub=MaxTotalUnits, name=""CleansingChemicalUnits"")
# @Variable OdorRemovingChemicalUnits @Def: The number of units of odor-removing chemical used per house @Shape: [] 
OdorRemovingChemicalUnits = model.addVar(vtype=GRB.CONTINUOUS, name=""OdorRemovingChemicalUnits"")

# Constraints 
# @Constraint Constr_1 @Def: The company must use at least MinCleansingUnits of the cleansing chemical per house.
model.addConstr(CleansingChemicalUnits >= MinCleansingUnits)
# @Constraint Constr_2 @Def: The total number of chemical units used per house cannot exceed MaxTotalUnits.
model.addConstr(CleansingChemicalUnits + OdorRemovingChemicalUnits <= MaxTotalUnits)
# @Constraint Constr_3 @Def: The number of cleansing chemical units used cannot exceed MaxCleansingToOdorRatio times the number of odor-removing chemical units used.
model.addConstr(CleansingChemicalUnits <= MaxCleansingToOdorRatio * OdorRemovingChemicalUnits)

# Objective 
# @Objective Objective @Def: Minimize the total cleaning time, which is the sum of CleansingChemicalTime multiplied by the number of cleansing chemical units and OdorRemovingChemicalTime multiplied by the number of odor-removing chemical units.
model.setObjective(CleansingChemicalTime * CleansingChemicalUnits + OdorRemovingChemicalTime * OdorRemovingChemicalUnits, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['CleansingChemicalUnits'] = CleansingChemicalUnits.x
variables['OdorRemovingChemicalUnits'] = OdorRemovingChemicalUnits.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A drug company is making allergy pills and fever reducing pills in two factories, factory 1 and factory 2. Factory 1 produces 20 allergy pills and 15 fever reducing pills per hour. Factory 2 produces 10 allergy pills and 30 fever reducing pills per hour.  Factory 1 is much more efficient and only requires 20 units of a rare compound while factory 2 requires 30 units of a rare compound. The company only has available 1000 units of the rare compound. If the company must make at least 700 allergy pills and 600 fever reducing pills, how many hours should each factory be run to minimize the total time needed?","{""variables"": {""OperationalLevel"": {""0"": 27.5, ""1"": 15.0}, ""MaxOperatingHours"": 27.5}, ""objective"": 27.5}","{""parametrized_description"": ""A drug company operates NumFactories factories to produce NumProducts products. Each factory j has a ProductionRate[i][j] for each product i per hour. Each factory j requires ResourceRequirement[j] units of a rare compound per hour. The company has TotalResource units of the rare compound available. The company must produce at least MinProduction[i] units of each product i. Determine the operating hours for each factory to minimize the total time needed."", ""keywords"": [""N.A.""], ""parameters"": {""NumFactories"": {""description"": ""Number of factories"", ""shape"": []}, ""NumProducts"": {""description"": ""Number of product types"", ""shape"": []}, ""ProductionRate"": {""description"": ""Production rate of product i in factory j per hour"", ""shape"": [""NumProducts"", ""NumFactories""]}, ""ResourceRequirement"": {""description"": ""Resource requirement of factory j per hour"", ""shape"": [""NumFactories""]}, ""TotalResource"": {""description"": ""Total available units of the rare compound"", ""shape"": []}, ""MinProduction"": {""description"": ""Minimum required production of product i"", ""shape"": [""NumProducts""]}}, ""variables"": {""OperationalLevel"": {""description"": ""The operational level of each factory j"", ""type"": ""continuous"", ""shape"": [""NumFactories""]}, ""MaxOperatingHours"": {""description"": ""The maximum operating hours across all factories"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""Each factory requires ResourceRequirement[j] units of the rare compound per hour. The total consumption of the rare compound across all factories cannot exceed TotalResource units."", ""formulation"": ""\\sum_{j=1}^{\\text{NumFactories}} \\text{ResourceRequirement}_j \\cdot \\text{OperationalLevel}_j \\leq \\text{TotalResource}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ResourceRequirement[j] * OperationalLevel[j] for j in range(NumFactories)) <= TotalResource)""}}, {""description"": ""Each factory j produces ProductionRate[i][j] units of product i per hour. The total production of each product i across all factories must be at least MinProduction[i] units."", ""formulation"": ""\\sum_{j=1}^{\\text{NumFactories}} \\text{ProductionRate}_{i,j} \\cdot \\text{OperationalLevel}_j \\geq \\text{MinProduction}_i"", ""code"": {""gurobipy"": ""model.addConstrs(\n    (quicksum(ProductionRate[i][j] * OperationalLevel[j] for j in range(NumFactories)) \n     >= MinProduction[i] for i in range(NumProducts)),\n    name=\""MinProduction\""\n)""}}], ""objective"": {""description"": ""Minimize the maximum operating hours across all factories required to meet the minimum production requirements while adhering to the limited availability of the rare compound."", ""formulation"": ""Min \\ MaxOperatingHours \\n OperationalLevel_j \\leq MaxOperatingHours \\quad \\forall j"", ""code"": {""gurobipy"": ""model.setObjective(MaxOperatingHours, GRB.MINIMIZE)""}}}","{""NumFactories"": 2, ""NumProducts"": 2, ""ProductionRate"": [[20, 10], [15, 30]], ""ResourceRequirement"": [20, 30], ""TotalResource"": 1000, ""MinProduction"": [700, 600]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A drug company operates NumFactories factories to produce NumProducts products.
Each factory j has a ProductionRate[i][j] for each product i per hour. Each
factory j requires ResourceRequirement[j] units of a rare compound per hour. The
company has TotalResource units of the rare compound available. The company must
produce at least MinProduction[i] units of each product i. Determine the
operating hours for each factory to minimize the total time needed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/96/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumFactories @Def: Number of factories @Shape: [] 
NumFactories = data['NumFactories']
# @Parameter NumProducts @Def: Number of product types @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter ProductionRate @Def: Production rate of product i in factory j per hour @Shape: ['NumProducts', 'NumFactories'] 
ProductionRate = data['ProductionRate']
# @Parameter ResourceRequirement @Def: Resource requirement of factory j per hour @Shape: ['NumFactories'] 
ResourceRequirement = data['ResourceRequirement']
# @Parameter TotalResource @Def: Total available units of the rare compound @Shape: [] 
TotalResource = data['TotalResource']
# @Parameter MinProduction @Def: Minimum required production of product i @Shape: ['NumProducts'] 
MinProduction = data['MinProduction']
    
# Variables 
# @Variable OperationalLevel @Def: The operational level of each factory j @Shape: ['NumFactories'] 
OperationalLevel = model.addVars(NumFactories, vtype=GRB.CONTINUOUS, name=""OperationalLevel"")
# @Variable MaxOperatingHours @Def: The maximum operating hours across all factories @Shape: [] 
MaxOperatingHours = model.addVar(vtype=GRB.CONTINUOUS, name=""MaxOperatingHours"")
        
# Constraints 
# @Constraint Constr_1 @Def: Each factory requires ResourceRequirement[j] units of the rare compound per hour. The total consumption of the rare compound across all factories cannot exceed TotalResource units.
model.addConstr(quicksum(ResourceRequirement[j] * OperationalLevel[j] for j in range(NumFactories)) <= TotalResource)
# @Constraint Constr_2 @Def: Each factory j produces ProductionRate[i][j] units of product i per hour. The total production of each product i across all factories must be at least MinProduction[i] units.
model.addConstrs(
    (quicksum(ProductionRate[i][j] * OperationalLevel[j] for j in range(NumFactories)) 
     >= MinProduction[i] for i in range(NumProducts)),
    name=""MinProduction""
)

# Add constraints to link MaxOperatingHours with OperationalLevel
model.addConstrs((OperationalLevel[j] <= MaxOperatingHours for j in range(NumFactories)), name=""MaxOperatingHoursConstr"")
    
# Objective 
# @Objective Objective @Def: Minimize the maximum operating hours across all factories required to meet the minimum production requirements while adhering to the limited availability of the rare compound.
model.setObjective(MaxOperatingHours, GRB.MINIMIZE)
    
# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['OperationalLevel'] = {j: OperationalLevel[j].X for j in range(NumFactories)}
variables['MaxOperatingHours'] = MaxOperatingHours.X
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A doctor recommends her patient eat more fish and chicken to increase her protein and iron intake. Each fish meal contains 10 units of protein and 12 units of iron. Each chicken meal contains 15 units of protein and 8 units of iron. The patient needs to consume at least 130 units of protein and 120 units of iron. Since the chicken meal is less expensive, the patient prefers to consume at least twice as many chicken meals as fish meals. If each fish meal contains 7 units of fat and each chicken meal contains 10 units of fat, how many meals of each should she eat to minimize her fat intake?","{""variables"": {""FishMeals"": 4.0, ""ChickenMeals"": 9.0}, ""objective"": 118.0}","{""parametrized_description"": ""A patient selects a number of FishMeals and ChickenMeals to minimize the total fat intake, which is calculated as FatPerFishMeal multiplied by FishMeals plus FatPerChickenMeal multiplied by ChickenMeals. This selection must satisfy the following constraints: the total protein intake, calculated as ProteinPerFishMeal multiplied by FishMeals plus ProteinPerChickenMeal multiplied by ChickenMeals, must be at least MinimumProtein; the total iron intake, calculated as IronPerFishMeal multiplied by FishMeals plus IronPerChickenMeal multiplied by ChickenMeals, must be at least MinimumIron; and the number of ChickenMeals must be at least ChickenToFishRatio multiplied by the number of FishMeals."", ""keywords"": [""N.A.""], ""parameters"": {""ProteinPerFishMeal"": {""description"": ""Protein per fish meal"", ""shape"": []}, ""ProteinPerChickenMeal"": {""description"": ""Protein per chicken meal"", ""shape"": []}, ""IronPerFishMeal"": {""description"": ""Iron per fish meal"", ""shape"": []}, ""IronPerChickenMeal"": {""description"": ""Iron per chicken meal"", ""shape"": []}, ""FatPerFishMeal"": {""description"": ""Fat per fish meal"", ""shape"": []}, ""FatPerChickenMeal"": {""description"": ""Fat per chicken meal"", ""shape"": []}, ""MinimumProtein"": {""description"": ""Minimum required protein"", ""shape"": []}, ""MinimumIron"": {""description"": ""Minimum required iron"", ""shape"": []}, ""ChickenToFishRatio"": {""description"": ""Minimum ratio of chicken meals to fish meals"", ""shape"": []}}, ""variables"": {""FishMeals"": {""description"": ""The number of fish meals"", ""type"": ""continuous"", ""shape"": []}, ""ChickenMeals"": {""description"": ""The number of chicken meals"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total protein intake, calculated as ProteinPerFishMeal multiplied by FishMeals plus ProteinPerChickenMeal multiplied by ChickenMeals, must be at least MinimumProtein."", ""formulation"": ""ProteinPerFishMeal \\times FishMeals + ProteinPerChickenMeal \\times ChickenMeals \\geq MinimumProtein"", ""code"": {""gurobipy"": ""model.addConstr(ProteinPerFishMeal * FishMeals + ProteinPerChickenMeal * ChickenMeals >= MinimumProtein)""}}, {""description"": ""The total iron intake, calculated as IronPerFishMeal multiplied by FishMeals plus IronPerChickenMeal multiplied by ChickenMeals, must be at least MinimumIron."", ""formulation"": ""IronPerFishMeal \\cdot FishMeals + IronPerChickenMeal \\cdot ChickenMeals \\geq MinimumIron"", ""code"": {""gurobipy"": ""model.addConstr(IronPerFishMeal * FishMeals + IronPerChickenMeal * ChickenMeals >= MinimumIron)""}}, {""description"": ""The number of ChickenMeals must be at least ChickenToFishRatio multiplied by the number of FishMeals."", ""formulation"": ""ChickenMeals \\geq ChickenToFishRatio \\times FishMeals"", ""code"": {""gurobipy"": ""model.addConstr(ChickenMeals >= ChickenToFishRatio * FishMeals)""}}], ""objective"": {""description"": ""Minimize the total fat intake, calculated as FatPerFishMeal multiplied by FishMeals plus FatPerChickenMeal multiplied by ChickenMeals."", ""formulation"": ""Min FatPerFishMeal \\cdot FishMeals + FatPerChickenMeal \\cdot ChickenMeals"", ""code"": {""gurobipy"": ""model.setObjective(FatPerFishMeal * FishMeals + FatPerChickenMeal * ChickenMeals, GRB.MINIMIZE)""}}}","{""ProteinPerFishMeal"": 10, ""ProteinPerChickenMeal"": 15, ""IronPerFishMeal"": 12, ""IronPerChickenMeal"": 8, ""FatPerFishMeal"": 7, ""FatPerChickenMeal"": 10, ""MinimumProtein"": 130, ""MinimumIron"": 120, ""ChickenToFishRatio"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A patient selects a number of FishMeals and ChickenMeals to minimize the total
fat intake, which is calculated as FatPerFishMeal multiplied by FishMeals plus
FatPerChickenMeal multiplied by ChickenMeals. This selection must satisfy the
following constraints: the total protein intake, calculated as
ProteinPerFishMeal multiplied by FishMeals plus ProteinPerChickenMeal multiplied
by ChickenMeals, must be at least MinimumProtein; the total iron intake,
calculated as IronPerFishMeal multiplied by FishMeals plus IronPerChickenMeal
multiplied by ChickenMeals, must be at least MinimumIron; and the number of
ChickenMeals must be at least ChickenToFishRatio multiplied by the number of
FishMeals.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/97/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProteinPerFishMeal @Def: Protein per fish meal @Shape: [] 
ProteinPerFishMeal = data['ProteinPerFishMeal']
# @Parameter ProteinPerChickenMeal @Def: Protein per chicken meal @Shape: [] 
ProteinPerChickenMeal = data['ProteinPerChickenMeal']
# @Parameter IronPerFishMeal @Def: Iron per fish meal @Shape: [] 
IronPerFishMeal = data['IronPerFishMeal']
# @Parameter IronPerChickenMeal @Def: Iron per chicken meal @Shape: [] 
IronPerChickenMeal = data['IronPerChickenMeal']
# @Parameter FatPerFishMeal @Def: Fat per fish meal @Shape: [] 
FatPerFishMeal = data['FatPerFishMeal']
# @Parameter FatPerChickenMeal @Def: Fat per chicken meal @Shape: [] 
FatPerChickenMeal = data['FatPerChickenMeal']
# @Parameter MinimumProtein @Def: Minimum required protein @Shape: [] 
MinimumProtein = data['MinimumProtein']
# @Parameter MinimumIron @Def: Minimum required iron @Shape: [] 
MinimumIron = data['MinimumIron']
# @Parameter ChickenToFishRatio @Def: Minimum ratio of chicken meals to fish meals @Shape: [] 
ChickenToFishRatio = data['ChickenToFishRatio']

# Variables 
# @Variable FishMeals @Def: The number of fish meals @Shape: [] 
FishMeals = model.addVar(vtype=GRB.CONTINUOUS, name=""FishMeals"")
# @Variable ChickenMeals @Def: The number of chicken meals @Shape: [] 
ChickenMeals = model.addVar(vtype=GRB.INTEGER, name=""ChickenMeals"")

# Constraints 
# @Constraint Constr_1 @Def: The total protein intake, calculated as ProteinPerFishMeal multiplied by FishMeals plus ProteinPerChickenMeal multiplied by ChickenMeals, must be at least MinimumProtein.
model.addConstr(ProteinPerFishMeal * FishMeals + ProteinPerChickenMeal * ChickenMeals >= MinimumProtein)
# @Constraint Constr_2 @Def: The total iron intake, calculated as IronPerFishMeal multiplied by FishMeals plus IronPerChickenMeal multiplied by ChickenMeals, must be at least MinimumIron.
model.addConstr(IronPerFishMeal * FishMeals + IronPerChickenMeal * ChickenMeals >= MinimumIron)
# @Constraint Constr_3 @Def: The number of ChickenMeals must be at least ChickenToFishRatio multiplied by the number of FishMeals.
model.addConstr(ChickenMeals >= ChickenToFishRatio * FishMeals)

# Objective 
# @Objective Objective @Def: Minimize the total fat intake, calculated as FatPerFishMeal multiplied by FishMeals plus FatPerChickenMeal multiplied by ChickenMeals.
model.setObjective(FatPerFishMeal * FishMeals + FatPerChickenMeal * ChickenMeals, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['FishMeals'] = FishMeals.x
variables['ChickenMeals'] = ChickenMeals.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A pharmaceutical company makes skin cream in batches, a regular batch and premium batch, to sell to hospitals. The regular batch requires 50 units of medicinal ingredients and 40 units of rehydration product. A premium batch requires 40 units of medicinal ingredients and 60 units of rehydration product. The company has available 3000 units of medicinal ingredients and 3500 units of rehydration product. Since the premium batch sells better, the number of regular batches must be less than the number of premium batches. In addition, the company must make at least 10 regular batches. If a regular batch can treat 50 people and a premium batch can treat 30 people, how many of each batch should be made to maximize the number of people that can be treated?","{""variables"": {""RegularBatches"": 32.0, ""PremiumBatches"": 35.0}, ""objective"": 2650.0}","{""parametrized_description"": ""A pharmaceutical company produces regular and premium batches. Each regular batch requires MedicinalIngredientPerRegularBatch units of medicinal ingredients and RehydrationProductPerRegularBatch units of rehydration product. Each premium batch requires MedicinalIngredientPerPremiumBatch units of medicinal ingredients and RehydrationProductPerPremiumBatch units of rehydration product. The company has TotalMedicinalIngredients units of medicinal ingredients and TotalRehydrationProduct units of rehydration product available. The number of regular batches produced must be at least MinRegularBatches and less than the number of premium batches. Each regular batch can treat PeopleTreatedPerRegularBatch people and each premium batch can treat PeopleTreatedPerPremiumBatch people. The objective is to determine the number of regular and premium batches to produce in order to maximize the total number of people treated."", ""keywords"": [""N.A.""], ""parameters"": {""MedicinalIngredientPerRegularBatch"": {""description"": ""Units of medicinal ingredients required to produce one regular batch"", ""shape"": []}, ""RehydrationProductPerRegularBatch"": {""description"": ""Units of rehydration product required to produce one regular batch"", ""shape"": []}, ""MedicinalIngredientPerPremiumBatch"": {""description"": ""Units of medicinal ingredients required to produce one premium batch"", ""shape"": []}, ""RehydrationProductPerPremiumBatch"": {""description"": ""Units of rehydration product required to produce one premium batch"", ""shape"": []}, ""TotalMedicinalIngredients"": {""description"": ""Total available units of medicinal ingredients"", ""shape"": []}, ""TotalRehydrationProduct"": {""description"": ""Total available units of rehydration product"", ""shape"": []}, ""MinRegularBatches"": {""description"": ""Minimum number of regular batches to produce"", ""shape"": []}, ""PeopleTreatedPerRegularBatch"": {""description"": ""Number of people treated by one regular batch"", ""shape"": []}, ""PeopleTreatedPerPremiumBatch"": {""description"": ""Number of people treated by one premium batch"", ""shape"": []}}, ""variables"": {""RegularBatches"": {""description"": ""The number of regular batches produced"", ""type"": ""continuous"", ""shape"": []}, ""PremiumBatches"": {""description"": ""The number of premium batches produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total units of medicinal ingredients used by regular and premium batches cannot exceed TotalMedicinalIngredients."", ""formulation"": ""RegularBatches \\times MedicinalIngredientPerRegularBatch + PremiumBatches \\times MedicinalIngredientPerPremiumBatch \\leq TotalMedicinalIngredients"", ""code"": {""gurobipy"": ""model.addConstr(RegularBatches * MedicinalIngredientPerRegularBatch + PremiumBatches * MedicinalIngredientPerPremiumBatch <= TotalMedicinalIngredients)""}}, {""description"": ""The total units of rehydration product used by regular and premium batches cannot exceed TotalRehydrationProduct."", ""formulation"": ""RehydrationProductPerRegularBatch \\times RegularBatches + RehydrationProductPerPremiumBatch \\times PremiumBatches \\leq TotalRehydrationProduct"", ""code"": {""gurobipy"": ""model.addConstr(RehydrationProductPerRegularBatch * RegularBatches + RehydrationProductPerPremiumBatch * PremiumBatches <= TotalRehydrationProduct)""}}, {""description"": ""The number of regular batches produced must be at least MinRegularBatches."", ""formulation"": ""RegularBatches \\geq MinRegularBatches"", ""code"": {""gurobipy"": ""model.addConstr(RegularBatches >= MinRegularBatches)""}}, {""description"": ""The number of regular batches produced must be less than the number of premium batches."", ""formulation"": ""RegularBatches \\leq PremiumBatches - 1"", ""code"": {""gurobipy"": ""model.addConstr(RegularBatches <= PremiumBatches - 1)""}}], ""objective"": {""description"": ""The total number of people treated is the sum of (PeopleTreatedPerRegularBatch multiplied by the number of regular batches) and (PeopleTreatedPerPremiumBatch multiplied by the number of premium batches). The objective is to maximize the total number of people treated."", ""formulation"": ""Max \\; PeopleTreatedPerRegularBatch \\cdot RegularBatches + PeopleTreatedPerPremiumBatch \\cdot PremiumBatches"", ""code"": {""gurobipy"": ""model.setObjective(PeopleTreatedPerRegularBatch * RegularBatches + PeopleTreatedPerPremiumBatch * PremiumBatches, GRB.MAXIMIZE)""}}}","{""MedicinalIngredientPerRegularBatch"": 50, ""RehydrationProductPerRegularBatch"": 40, ""MedicinalIngredientPerPremiumBatch"": 40, ""RehydrationProductPerPremiumBatch"": 60, ""TotalMedicinalIngredients"": 3000, ""TotalRehydrationProduct"": 3500, ""MinRegularBatches"": 10, ""PeopleTreatedPerRegularBatch"": 50, ""PeopleTreatedPerPremiumBatch"": 30}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A pharmaceutical company produces regular and premium batches. Each regular
batch requires MedicinalIngredientPerRegularBatch units of medicinal ingredients
and RehydrationProductPerRegularBatch units of rehydration product. Each premium
batch requires MedicinalIngredientPerPremiumBatch units of medicinal ingredients
and RehydrationProductPerPremiumBatch units of rehydration product. The company
has TotalMedicinalIngredients units of medicinal ingredients and
TotalRehydrationProduct units of rehydration product available. The number of
regular batches produced must be at least MinRegularBatches and less than the
number of premium batches. Each regular batch can treat
PeopleTreatedPerRegularBatch people and each premium batch can treat
PeopleTreatedPerPremiumBatch people. The objective is to determine the number of
regular and premium batches to produce in order to maximize the total number of
people treated.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/98/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MedicinalIngredientPerRegularBatch @Def: Units of medicinal ingredients required to produce one regular batch @Shape: [] 
MedicinalIngredientPerRegularBatch = data['MedicinalIngredientPerRegularBatch']
# @Parameter RehydrationProductPerRegularBatch @Def: Units of rehydration product required to produce one regular batch @Shape: [] 
RehydrationProductPerRegularBatch = data['RehydrationProductPerRegularBatch']
# @Parameter MedicinalIngredientPerPremiumBatch @Def: Units of medicinal ingredients required to produce one premium batch @Shape: [] 
MedicinalIngredientPerPremiumBatch = data['MedicinalIngredientPerPremiumBatch']
# @Parameter RehydrationProductPerPremiumBatch @Def: Units of rehydration product required to produce one premium batch @Shape: [] 
RehydrationProductPerPremiumBatch = data['RehydrationProductPerPremiumBatch']
# @Parameter TotalMedicinalIngredients @Def: Total available units of medicinal ingredients @Shape: [] 
TotalMedicinalIngredients = data['TotalMedicinalIngredients']
# @Parameter TotalRehydrationProduct @Def: Total available units of rehydration product @Shape: [] 
TotalRehydrationProduct = data['TotalRehydrationProduct']
# @Parameter MinRegularBatches @Def: Minimum number of regular batches to produce @Shape: [] 
MinRegularBatches = data['MinRegularBatches']
# @Parameter PeopleTreatedPerRegularBatch @Def: Number of people treated by one regular batch @Shape: [] 
PeopleTreatedPerRegularBatch = data['PeopleTreatedPerRegularBatch']
# @Parameter PeopleTreatedPerPremiumBatch @Def: Number of people treated by one premium batch @Shape: [] 
PeopleTreatedPerPremiumBatch = data['PeopleTreatedPerPremiumBatch']

# Variables 
# @Variable RegularBatches @Def: The number of regular batches produced @Shape: [] 
RegularBatches = model.addVar(vtype=GRB.INTEGER, name=""RegularBatches"")
# @Variable PremiumBatches @Def: The number of premium batches produced @Shape: [] 
PremiumBatches = model.addVar(vtype=GRB.INTEGER, name=""PremiumBatches"")

# Constraints 
# @Constraint Constr_1 @Def: The total units of medicinal ingredients used by regular and premium batches cannot exceed TotalMedicinalIngredients.
model.addConstr(RegularBatches * MedicinalIngredientPerRegularBatch + PremiumBatches * MedicinalIngredientPerPremiumBatch <= TotalMedicinalIngredients)
# @Constraint Constr_2 @Def: The total units of rehydration product used by regular and premium batches cannot exceed TotalRehydrationProduct.
model.addConstr(RehydrationProductPerRegularBatch * RegularBatches + RehydrationProductPerPremiumBatch * PremiumBatches <= TotalRehydrationProduct)
# @Constraint Constr_3 @Def: The number of regular batches produced must be at least MinRegularBatches.
model.addConstr(RegularBatches >= MinRegularBatches)
# @Constraint Constr_4 @Def: The number of regular batches produced must be less than the number of premium batches.
model.addConstr(RegularBatches <= PremiumBatches - 1)

# Objective 
# @Objective Objective @Def: The total number of people treated is the sum of (PeopleTreatedPerRegularBatch multiplied by the number of regular batches) and (PeopleTreatedPerPremiumBatch multiplied by the number of premium batches). The objective is to maximize the total number of people treated.
model.setObjective(PeopleTreatedPerRegularBatch * RegularBatches + PeopleTreatedPerPremiumBatch * PremiumBatches, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['RegularBatches'] = RegularBatches.x
variables['PremiumBatches'] = PremiumBatches.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A clinic takes patient blood pressure either using an automatic machine or a manual machine. The automatic machine takes 10 minutes per patient while the manual machine takes 15 minutes per patient. Since the automatic machine frequently breaks, at least twice as many patients must have their blood pressure taken by the manual machine than the automatic machine. However, at least 20 patient can be processed by the automatic machine. If the clinic is open for 20000 minutes, maximize the number of patients whose blood pressure can be taken.","{""variables"": {""AutomaticPatients"": 500.0, ""ManualPatients"": 1000.0}, ""objective"": 1500.0}","{""parametrized_description"": ""A clinic processes patients using an automatic machine and a manual machine. Let A represent the number of patients processed by the automatic machine and M represent the number of patients processed by the manual machine. The total processing time, calculated as AutomaticMachineTimePerPatient multiplied by A plus ManualMachineTimePerPatient multiplied by M, must not exceed TotalAvailableTime. Additionally, the number of patients processed by the manual machine must be at least ManualPatientMinRatio times A, and the automatic machine must process at least AutomaticMachineMinimumPatients. The objective is to maximize the total number of patients, which is the sum of A and M."", ""keywords"": [""N.A.""], ""parameters"": {""AutomaticMachineTimePerPatient"": {""description"": ""Time taken by the automatic machine to process one patient."", ""shape"": []}, ""ManualMachineTimePerPatient"": {""description"": ""Time taken by the manual machine to process one patient."", ""shape"": []}, ""ManualPatientMinRatio"": {""description"": ""Minimum ratio of manual machine patients to automatic machine patients."", ""shape"": []}, ""AutomaticMachineMinimumPatients"": {""description"": ""Minimum number of patients that must be processed by the automatic machine."", ""shape"": []}, ""TotalAvailableTime"": {""description"": ""Total available time for the clinic in minutes."", ""shape"": []}}, ""variables"": {""AutomaticPatients"": {""description"": ""The number of patients processed by the automatic machine"", ""type"": ""continuous"", ""shape"": []}, ""ManualPatients"": {""description"": ""The number of patients processed by the manual machine"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""AutomaticMachineTimePerPatient multiplied by A plus ManualMachineTimePerPatient multiplied by M does not exceed TotalAvailableTime."", ""formulation"": ""AutomaticMachineTimePerPatient \\cdot AutomaticPatients + ManualMachineTimePerPatient \\cdot ManualPatients \\leq TotalAvailableTime"", ""code"": {""gurobipy"": ""model.addConstr(AutomaticMachineTimePerPatient * AutomaticPatients + ManualMachineTimePerPatient * ManualPatients <= TotalAvailableTime)""}}, {""description"": ""The number of patients processed by the manual machine must be at least ManualPatientMinRatio times A."", ""formulation"": ""ManualPatients \\geq ManualPatientMinRatio \\times AutomaticPatients"", ""code"": {""gurobipy"": ""model.addConstr(ManualPatients >= ManualPatientMinRatio * AutomaticPatients)""}}, {""description"": ""A must be at least AutomaticMachineMinimumPatients."", ""formulation"": ""AutomaticPatients \\geq AutomaticMachineMinimumPatients"", ""code"": {""gurobipy"": ""model.addConstr(AutomaticPatients >= AutomaticMachineMinimumPatients)""}}], ""objective"": {""description"": ""Maximize the total number of patients, which is the sum of A and M."", ""formulation"": ""Max AutomaticPatients + ManualPatients"", ""code"": {""gurobipy"": ""model.setObjective(AutomaticPatients + ManualPatients, GRB.MAXIMIZE)""}}}","{""AutomaticMachineTimePerPatient"": 10, ""ManualMachineTimePerPatient"": 15, ""ManualPatientMinRatio"": 2, ""AutomaticMachineMinimumPatients"": 20, ""TotalAvailableTime"": 20000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A clinic processes patients using an automatic machine and a manual machine. Let
A represent the number of patients processed by the automatic machine and M
represent the number of patients processed by the manual machine. The total
processing time, calculated as AutomaticMachineTimePerPatient multiplied by A
plus ManualMachineTimePerPatient multiplied by M, must not exceed
TotalAvailableTime. Additionally, the number of patients processed by the manual
machine must be at least ManualPatientMinRatio times A, and the automatic
machine must process at least AutomaticMachineMinimumPatients. The objective is
to maximize the total number of patients, which is the sum of A and M.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/99/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter AutomaticMachineTimePerPatient @Def: Time taken by the automatic machine to process one patient. @Shape: [] 
AutomaticMachineTimePerPatient = data['AutomaticMachineTimePerPatient']
# @Parameter ManualMachineTimePerPatient @Def: Time taken by the manual machine to process one patient. @Shape: [] 
ManualMachineTimePerPatient = data['ManualMachineTimePerPatient']
# @Parameter ManualPatientMinRatio @Def: Minimum ratio of manual machine patients to automatic machine patients. @Shape: [] 
ManualPatientMinRatio = data['ManualPatientMinRatio']
# @Parameter AutomaticMachineMinimumPatients @Def: Minimum number of patients that must be processed by the automatic machine. @Shape: [] 
AutomaticMachineMinimumPatients = data['AutomaticMachineMinimumPatients']
# @Parameter TotalAvailableTime @Def: Total available time for the clinic in minutes. @Shape: [] 
TotalAvailableTime = data['TotalAvailableTime']

# Variables 
# @Variable AutomaticPatients @Def: The number of patients processed by the automatic machine @Shape: [] 
AutomaticPatients = model.addVar(vtype=GRB.INTEGER, name=""AutomaticPatients"")
# @Variable ManualPatients @Def: The number of patients processed by the manual machine @Shape: [] 
ManualPatients = model.addVar(vtype=GRB.INTEGER, name=""ManualPatients"")

# Constraints 
# @Constraint Constr_1 @Def: AutomaticMachineTimePerPatient multiplied by A plus ManualMachineTimePerPatient multiplied by M does not exceed TotalAvailableTime.
model.addConstr(AutomaticMachineTimePerPatient * AutomaticPatients + ManualMachineTimePerPatient * ManualPatients <= TotalAvailableTime)
# @Constraint Constr_2 @Def: The number of patients processed by the manual machine must be at least ManualPatientMinRatio times A.
model.addConstr(ManualPatients >= ManualPatientMinRatio * AutomaticPatients)
# @Constraint Constr_3 @Def: A must be at least AutomaticMachineMinimumPatients.
model.addConstr(AutomaticPatients >= AutomaticMachineMinimumPatients)

# Objective 
# @Objective Objective @Def: Maximize the total number of patients, which is the sum of A and M.
model.setObjective(AutomaticPatients + ManualPatients, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['AutomaticPatients'] = AutomaticPatients.x
variables['ManualPatients'] = ManualPatients.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A patient with a sore throat can drink two syrups, syrup 1 and syrup 2 for treatment. Per serving, syrup 1 delivers 0.5 units of medicine to the throat and 0.4 units of medicine to the lungs. Per serving, syrup 2 delivers 0.2 units of medicine to the throat and 0.5 units of medicine to the lungs. Furthermore, syrup 1 contains 0.5 units of sugar while syrup 2 contains 0.3 units of sugar per serving. The patient can get at most 5 units of medicine for the throat and at least 4 units of medicine to the lungs. How many servings of each should the patient take to minimize his sugar intake?","{""variables"": {""Servings"": {""0"": 0.0, ""1"": 8.0}}, ""objective"": 2.4}","{""parametrized_description"": ""A patient can consume NumSyrups different syrups for treatment. For each syrup, a serving delivers MedicineThroatPerServing units of medicine to the throat and MedicineLungsPerServing units of medicine to the lungs. Each serving contains SugarPerServing units of sugar. The patient must receive no more than MaxMedicineThroat units of medicine for the throat and at least MinMedicineLungs units of medicine for the lungs. The objective is to determine the number of servings of each syrup to minimize total sugar intake."", ""keywords"": [""N.A.""], ""parameters"": {""NumSyrups"": {""description"": ""Number of available syrups"", ""shape"": []}, ""MedicineThroatPerServing"": {""description"": ""Amount of medicine delivered to the throat per serving of each syrup"", ""shape"": [""NumSyrups""]}, ""MedicineLungsPerServing"": {""description"": ""Amount of medicine delivered to the lungs per serving of each syrup"", ""shape"": [""NumSyrups""]}, ""SugarPerServing"": {""description"": ""Amount of sugar per serving of each syrup"", ""shape"": [""NumSyrups""]}, ""MaxMedicineThroat"": {""description"": ""Maximum total medicine allowed for the throat"", ""shape"": []}, ""MinMedicineLungs"": {""description"": ""Minimum total medicine required for the lungs"", ""shape"": []}}, ""variables"": {""Servings"": {""description"": ""The number of servings for each syrup"", ""type"": ""continuous"", ""shape"": [""NumSyrups""]}}, ""constraints"": [{""description"": ""The total amount of medicine delivered to the throat by all syrups must not exceed MaxMedicineThroat units."", ""formulation"": ""\\sum_{i=1}^{NumSyrups} MedicineThroatPerServing_i \\times Servings_i \\leq MaxMedicineThroat"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(MedicineThroatPerServing[i] * Servings[i] for i in range(NumSyrups)) <= MaxMedicineThroat)""}}, {""description"": ""The total amount of medicine delivered to the lungs by all syrups must be at least MinMedicineLungs units."", ""formulation"": ""\\sum_{i=1}^{NumSyrups} Servings_i \\times MedicineLungsPerServing_i \\geq MinMedicineLungs"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(Servings[i] * MedicineLungsPerServing[i] for i in range(NumSyrups)) >= MinMedicineLungs)""}}], ""objective"": {""description"": ""Minimize the total sugar intake, which is the sum of SugarPerServing units of sugar per serving multiplied by the number of servings of each syrup."", ""formulation"": ""Min \\sum_{i=1}^{NumSyrups} SugarPerServing_{i} \\times Servings_{i}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(SugarPerServing[i] * Servings[i] for i in range(NumSyrups)), GRB.MINIMIZE)""}}}","{""NumSyrups"": 2, ""MedicineThroatPerServing"": [0.5, 0.2], ""MedicineLungsPerServing"": [0.4, 0.5], ""SugarPerServing"": [0.5, 0.3], ""MaxMedicineThroat"": 5, ""MinMedicineLungs"": 4}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A patient can consume NumSyrups different syrups for treatment. For each syrup,
a serving delivers MedicineThroatPerServing units of medicine to the throat and
MedicineLungsPerServing units of medicine to the lungs. Each serving contains
SugarPerServing units of sugar. The patient must receive no more than
MaxMedicineThroat units of medicine for the throat and at least MinMedicineLungs
units of medicine for the lungs. The objective is to determine the number of
servings of each syrup to minimize total sugar intake.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/100/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumSyrups @Def: Number of available syrups @Shape: [] 
NumSyrups = data['NumSyrups']
# @Parameter MedicineThroatPerServing @Def: Amount of medicine delivered to the throat per serving of each syrup @Shape: ['NumSyrups'] 
MedicineThroatPerServing = data['MedicineThroatPerServing']
# @Parameter MedicineLungsPerServing @Def: Amount of medicine delivered to the lungs per serving of each syrup @Shape: ['NumSyrups'] 
MedicineLungsPerServing = data['MedicineLungsPerServing']
# @Parameter SugarPerServing @Def: Amount of sugar per serving of each syrup @Shape: ['NumSyrups'] 
SugarPerServing = data['SugarPerServing']
# @Parameter MaxMedicineThroat @Def: Maximum total medicine allowed for the throat @Shape: [] 
MaxMedicineThroat = data['MaxMedicineThroat']
# @Parameter MinMedicineLungs @Def: Minimum total medicine required for the lungs @Shape: [] 
MinMedicineLungs = data['MinMedicineLungs']

# Variables 
# @Variable Servings @Def: The number of servings for each syrup @Shape: ['NumSyrups'] 
Servings = model.addVars(NumSyrups, vtype=GRB.CONTINUOUS, name=""Servings"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of medicine delivered to the throat by all syrups must not exceed MaxMedicineThroat units.
model.addConstr(quicksum(MedicineThroatPerServing[i] * Servings[i] for i in range(NumSyrups)) <= MaxMedicineThroat)
# @Constraint Constr_2 @Def: The total amount of medicine delivered to the lungs by all syrups must be at least MinMedicineLungs units.
model.addConstr(quicksum(Servings[i] * MedicineLungsPerServing[i] for i in range(NumSyrups)) >= MinMedicineLungs)

# Objective 
# @Objective Objective @Def: Minimize the total sugar intake, which is the sum of SugarPerServing units of sugar per serving multiplied by the number of servings of each syrup.
model.setObjective(quicksum(SugarPerServing[i] * Servings[i] for i in range(NumSyrups)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Servings'] = {i: Servings[i].X for i in range(NumSyrups)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A sailor can eat either a crab cakes or a lobster roll for his meals. He needs to ensure he gets at least 80 units of vitamin A and 100 units of vitamin C. Each crab cake contains 5 units of vitamin A and 7 units of vitamin C. Each lobster roll contains 8 units of vitamin A and 4 units of vitamin C. In addition, since lobster is more expensive, at most 40% of his meals should be lobster rolls. If each crab cake contains 4 units of unsaturated fat and each lobster roll contains 6 units of unsaturated fat, how many of each should he eat to minimize his unsaturated fat intake?","{""variables"": {""QuantityCrabCake"": 13.333333333333332, ""QuantityLobsterRoll"": 1.6666666666666665}, ""objective"": 63.33333333333333}","{""parametrized_description"": ""Determine the quantities of crab cakes and lobster rolls that minimize the total unsaturated fat, where total unsaturated fat is calculated as UnsaturatedFatPerCrabCake multiplied by the number of crab cakes plus UnsaturatedFatPerLobsterRoll multiplied by the number of lobster rolls. Ensure that the total vitamin A intake is at least MinimumVitaminA, the total vitamin C intake is at least MinimumVitaminC, and the proportion of lobster rolls does not exceed MaximumLobsterFraction of the total meals."", ""keywords"": [""N.A.""], ""parameters"": {""MinimumVitaminA"": {""description"": ""Minimum required units of vitamin A"", ""shape"": []}, ""MinimumVitaminC"": {""description"": ""Minimum required units of vitamin C"", ""shape"": []}, ""VitaminAPerCrabCake"": {""description"": ""Units of vitamin A per crab cake"", ""shape"": []}, ""VitaminCPerCrabCake"": {""description"": ""Units of vitamin C per crab cake"", ""shape"": []}, ""VitaminAPerLobsterRoll"": {""description"": ""Units of vitamin A per lobster roll"", ""shape"": []}, ""VitaminCPerLobsterRoll"": {""description"": ""Units of vitamin C per lobster roll"", ""shape"": []}, ""UnsaturatedFatPerCrabCake"": {""description"": ""Units of unsaturated fat per crab cake"", ""shape"": []}, ""UnsaturatedFatPerLobsterRoll"": {""description"": ""Units of unsaturated fat per lobster roll"", ""shape"": []}, ""MaximumLobsterFraction"": {""description"": ""Maximum fraction of meals that can be lobster rolls"", ""shape"": []}}, ""variables"": {""QuantityCrabCake"": {""description"": ""The number of crab cakes"", ""type"": ""continuous"", ""shape"": []}, ""QuantityLobsterRoll"": {""description"": ""The number of lobster rolls"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total vitamin A intake from crab cakes and lobster rolls must be at least MinimumVitaminA."", ""formulation"": ""VitaminAPerCrabCake \\cdot QuantityCrabCake + VitaminAPerLobsterRoll \\cdot QuantityLobsterRoll \\geq MinimumVitaminA"", ""code"": {""gurobipy"": ""model.addConstr(VitaminAPerCrabCake * QuantityCrabCake + VitaminAPerLobsterRoll * QuantityLobsterRoll >= MinimumVitaminA)""}}, {""description"": ""The total vitamin C intake from crab cakes and lobster rolls must be at least MinimumVitaminC."", ""formulation"": ""VitaminCPerCrabCake QuantityCrabCake + VitaminCPerLobsterRoll QuantityLobsterRoll \\geq MinimumVitaminC"", ""code"": {""gurobipy"": ""model.addConstr(VitaminCPerCrabCake * QuantityCrabCake + VitaminCPerLobsterRoll * QuantityLobsterRoll >= MinimumVitaminC)""}}, {""description"": ""The proportion of lobster rolls in the total meals must not exceed MaximumLobsterFraction."", ""formulation"": ""QuantityLobsterRoll \\leq MaximumLobsterFraction \\times (QuantityCrabCake + QuantityLobsterRoll)"", ""code"": {""gurobipy"": ""model.addConstr(QuantityLobsterRoll <= MaximumLobsterFraction * (QuantityCrabCake + QuantityLobsterRoll))""}}], ""objective"": {""description"": ""Total unsaturated fat is calculated as UnsaturatedFatPerCrabCake multiplied by the number of crab cakes plus UnsaturatedFatPerLobsterRoll multiplied by the number of lobster rolls. The objective is to minimize the total unsaturated fat."", ""formulation"": ""Min UnsaturatedFatPerCrabCake \\cdot QuantityCrabCake + UnsaturatedFatPerLobsterRoll \\cdot QuantityLobsterRoll"", ""code"": {""gurobipy"": ""model.setObjective(UnsaturatedFatPerCrabCake * QuantityCrabCake + UnsaturatedFatPerLobsterRoll * QuantityLobsterRoll, GRB.MINIMIZE)""}}}","{""MinimumVitaminA"": 80, ""MinimumVitaminC"": 100, ""VitaminAPerCrabCake"": 5, ""VitaminCPerCrabCake"": 7, ""VitaminAPerLobsterRoll"": 8, ""VitaminCPerLobsterRoll"": 4, ""UnsaturatedFatPerCrabCake"": 4, ""UnsaturatedFatPerLobsterRoll"": 6, ""MaximumLobsterFraction"": 0.4}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Determine the quantities of crab cakes and lobster rolls that minimize the total
unsaturated fat, where total unsaturated fat is calculated as
UnsaturatedFatPerCrabCake multiplied by the number of crab cakes plus
UnsaturatedFatPerLobsterRoll multiplied by the number of lobster rolls. Ensure
that the total vitamin A intake is at least MinimumVitaminA, the total vitamin C
intake is at least MinimumVitaminC, and the proportion of lobster rolls does not
exceed MaximumLobsterFraction of the total meals.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/101/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MinimumVitaminA @Def: Minimum required units of vitamin A @Shape: [] 
MinimumVitaminA = data['MinimumVitaminA']
# @Parameter MinimumVitaminC @Def: Minimum required units of vitamin C @Shape: [] 
MinimumVitaminC = data['MinimumVitaminC']
# @Parameter VitaminAPerCrabCake @Def: Units of vitamin A per crab cake @Shape: [] 
VitaminAPerCrabCake = data['VitaminAPerCrabCake']
# @Parameter VitaminCPerCrabCake @Def: Units of vitamin C per crab cake @Shape: [] 
VitaminCPerCrabCake = data['VitaminCPerCrabCake']
# @Parameter VitaminAPerLobsterRoll @Def: Units of vitamin A per lobster roll @Shape: [] 
VitaminAPerLobsterRoll = data['VitaminAPerLobsterRoll']
# @Parameter VitaminCPerLobsterRoll @Def: Units of vitamin C per lobster roll @Shape: [] 
VitaminCPerLobsterRoll = data['VitaminCPerLobsterRoll']
# @Parameter UnsaturatedFatPerCrabCake @Def: Units of unsaturated fat per crab cake @Shape: [] 
UnsaturatedFatPerCrabCake = data['UnsaturatedFatPerCrabCake']
# @Parameter UnsaturatedFatPerLobsterRoll @Def: Units of unsaturated fat per lobster roll @Shape: [] 
UnsaturatedFatPerLobsterRoll = data['UnsaturatedFatPerLobsterRoll']
# @Parameter MaximumLobsterFraction @Def: Maximum fraction of meals that can be lobster rolls @Shape: [] 
MaximumLobsterFraction = data['MaximumLobsterFraction']

# Variables 
# @Variable QuantityCrabCake @Def: The number of crab cakes @Shape: [] 
QuantityCrabCake = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityCrabCake"")
# @Variable QuantityLobsterRoll @Def: The number of lobster rolls @Shape: [] 
QuantityLobsterRoll = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityLobsterRoll"")

# Constraints 
# @Constraint Constr_1 @Def: The total vitamin A intake from crab cakes and lobster rolls must be at least MinimumVitaminA.
model.addConstr(VitaminAPerCrabCake * QuantityCrabCake + VitaminAPerLobsterRoll * QuantityLobsterRoll >= MinimumVitaminA)
# @Constraint Constr_2 @Def: The total vitamin C intake from crab cakes and lobster rolls must be at least MinimumVitaminC.
model.addConstr(VitaminCPerCrabCake * QuantityCrabCake + VitaminCPerLobsterRoll * QuantityLobsterRoll >= MinimumVitaminC)
# @Constraint Constr_3 @Def: The proportion of lobster rolls in the total meals must not exceed MaximumLobsterFraction.
model.addConstr(QuantityLobsterRoll <= MaximumLobsterFraction * (QuantityCrabCake + QuantityLobsterRoll))

# Objective 
# @Objective Objective @Def: Total unsaturated fat is calculated as UnsaturatedFatPerCrabCake multiplied by the number of crab cakes plus UnsaturatedFatPerLobsterRoll multiplied by the number of lobster rolls. The objective is to minimize the total unsaturated fat.
model.setObjective(UnsaturatedFatPerCrabCake * QuantityCrabCake + UnsaturatedFatPerLobsterRoll * QuantityLobsterRoll, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityCrabCake'] = QuantityCrabCake.x
variables['QuantityLobsterRoll'] = QuantityLobsterRoll.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A science show preforms two different demonstrations, demonstration 1 and demonstration 2. In demonstration 1, 10 units of mint and 20 units of the active ingredient is used to make 25 units of minty foam. In demonstration 2, 12 units of mint and 15 units of the active ingredient is used to make 18 units of minty foam. In addition, demonstration 1 creates 5 units of black tar while demonstration 2 creates 3 units of black tar. The show has available 120 units of mint and 100 units of active ingredients. If at most 50 units of black tar can be produced, how many of each demonstration should be done to maximize the amount of minty foam produced?","{""variables"": {""DemonstrationUsed"": [5.0, 0.0]}, ""objective"": 125.0}","{""parametrized_description"": ""A show performs NumDemonstrations different demonstrations. Each demonstration i uses MintUsed[i] units of mint and ActiveIngredientUsed[i] units of active ingredient to produce FoamProduced[i] units of minty foam and BlackTarProduced[i] units of black tar. The show has TotalMintAvailable units of mint and TotalActiveIngredientAvailable units of active ingredient available. At most MaxBlackTarAllowed units of black tar can be produced. Determine the number of each demonstration to maximize the total minty foam produced."", ""keywords"": [""N.A.""], ""parameters"": {""NumDemonstrations"": {""description"": ""Number of demonstrations"", ""shape"": []}, ""MintUsed"": {""description"": ""Amount of mint used by each demonstration"", ""shape"": [""NumDemonstrations""]}, ""ActiveIngredientUsed"": {""description"": ""Amount of active ingredient used by each demonstration"", ""shape"": [""NumDemonstrations""]}, ""FoamProduced"": {""description"": ""Amount of minty foam produced by each demonstration"", ""shape"": [""NumDemonstrations""]}, ""BlackTarProduced"": {""description"": ""Amount of black tar produced by each demonstration"", ""shape"": [""NumDemonstrations""]}, ""TotalMintAvailable"": {""description"": ""Total units of mint available"", ""shape"": []}, ""TotalActiveIngredientAvailable"": {""description"": ""Total units of active ingredient available"", ""shape"": []}, ""MaxBlackTarAllowed"": {""description"": ""Maximum units of black tar allowed"", ""shape"": []}}, ""variables"": {""DemonstrationUsed"": {""description"": ""Number of times each demonstration is used"", ""type"": ""continuous"", ""shape"": [""NumDemonstrations""]}}, ""constraints"": [{""description"": ""The total amount of mint used by all demonstrations cannot exceed the total mint available."", ""formulation"": ""\\sum_{i=1}^{NumDemonstrations} MintUsed_i \\times DemonstrationUsed_i \\leq TotalMintAvailable"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(MintUsed[i] * DemonstrationUsed[i] for i in range(NumDemonstrations)) <= TotalMintAvailable)""}}, {""description"": ""The total amount of active ingredient used by all demonstrations cannot exceed the total active ingredient available."", ""formulation"": ""\\sum_{i=1}^{NumDemonstrations} ActiveIngredientUsed_i \\cdot DemonstrationUsed_i \\leq TotalActiveIngredientAvailable"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ActiveIngredientUsed[i] * DemonstrationUsed[i] for i in range(NumDemonstrations)) <= TotalActiveIngredientAvailable)""}}, {""description"": ""The total amount of black tar produced cannot exceed the maximum black tar allowed."", ""formulation"": ""\\sum_{j=1}^{NumDemonstrations} BlackTarProduced_{j} \\times DemonstrationUsed_{j} \\leq MaxBlackTarAllowed"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(BlackTarProduced[j] * DemonstrationUsed[j] for j in range(NumDemonstrations)) <= MaxBlackTarAllowed)""}}], ""objective"": {""description"": ""Maximize the total minty foam produced by all demonstrations."", ""formulation"": ""Max \\sum_{d=1}^{NumDemonstrations} FoamProduced_d \\cdot DemonstrationUsed_d"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(FoamProduced[d] * DemonstrationUsed[d] for d in range(NumDemonstrations)), GRB.MAXIMIZE)""}}}","{""NumDemonstrations"": 2, ""MintUsed"": [10, 12], ""ActiveIngredientUsed"": [20, 15], ""FoamProduced"": [25, 18], ""BlackTarProduced"": [5, 3], ""TotalMintAvailable"": 120, ""TotalActiveIngredientAvailable"": 100, ""MaxBlackTarAllowed"": 50}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A show performs NumDemonstrations different demonstrations. Each demonstration i
uses MintUsed[i] units of mint and ActiveIngredientUsed[i] units of active
ingredient to produce FoamProduced[i] units of minty foam and
BlackTarProduced[i] units of black tar. The show has TotalMintAvailable units of
mint and TotalActiveIngredientAvailable units of active ingredient available. At
most MaxBlackTarAllowed units of black tar can be produced. Determine the number
of each demonstration to maximize the total minty foam produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/102/parameters.json"", ""r"") as f:
    data = json.load(f)
        
# @Def: definition of a target
# @Shape: shape of a target
            
# Parameters 
# @Parameter NumDemonstrations @Def: Number of demonstrations @Shape: [] 
NumDemonstrations = data['NumDemonstrations']
# @Parameter MintUsed @Def: Amount of mint used by each demonstration @Shape: ['NumDemonstrations'] 
MintUsed = data['MintUsed']
# @Parameter ActiveIngredientUsed @Def: Amount of active ingredient used by each demonstration @Shape: ['NumDemonstrations'] 
ActiveIngredientUsed = data['ActiveIngredientUsed']
# @Parameter FoamProduced @Def: Amount of minty foam produced by each demonstration @Shape: ['NumDemonstrations'] 
FoamProduced = data['FoamProduced']
# @Parameter BlackTarProduced @Def: Amount of black tar produced by each demonstration @Shape: ['NumDemonstrations'] 
BlackTarProduced = data['BlackTarProduced']
# @Parameter TotalMintAvailable @Def: Total units of mint available @Shape: [] 
TotalMintAvailable = data['TotalMintAvailable']
# @Parameter TotalActiveIngredientAvailable @Def: Total units of active ingredient available @Shape: [] 
TotalActiveIngredientAvailable = data['TotalActiveIngredientAvailable']
# @Parameter MaxBlackTarAllowed @Def: Maximum units of black tar allowed @Shape: [] 
MaxBlackTarAllowed = data['MaxBlackTarAllowed']

# Variables 
# @Variable DemonstrationUsed @Def: Number of times each demonstration is used @Shape: ['NumDemonstrations'] 
DemonstrationUsed = model.addVars(NumDemonstrations, vtype=GRB.CONTINUOUS, name=""DemonstrationUsed"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of mint used by all demonstrations cannot exceed the total mint available.
model.addConstr(quicksum(MintUsed[i] * DemonstrationUsed[i] for i in range(NumDemonstrations)) <= TotalMintAvailable)
# @Constraint Constr_2 @Def: The total amount of active ingredient used by all demonstrations cannot exceed the total active ingredient available.
model.addConstr(quicksum(ActiveIngredientUsed[i] * DemonstrationUsed[i] for i in range(NumDemonstrations)) <= TotalActiveIngredientAvailable)
# @Constraint Constr_3 @Def: The total amount of black tar produced cannot exceed the maximum black tar allowed.
model.addConstr(quicksum(BlackTarProduced[j] * DemonstrationUsed[j] for j in range(NumDemonstrations)) <= MaxBlackTarAllowed)

# Objective 
# @Objective Objective @Def: Maximize the total minty foam produced by all demonstrations.
model.setObjective(quicksum(FoamProduced[d] * DemonstrationUsed[d] for d in range(NumDemonstrations)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['DemonstrationUsed'] = [DemonstrationUsed[i].x for i in range(NumDemonstrations)]
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A lab has 20000 mg of mRNA anti-viral available to make children's and adult vaccines. Each children's vaccine contains 50 mg of mRNA and 50 mg of fever suppressant. Each adult vaccine contains 75 mg of mRNA and 75 mg of fever suppressant. Since adult vaccines are more essential, at least 70% of vaccines should be adult vaccines. However, at least 50 children's vaccines should be made. How many of each vaccine should be made to minimize the amount of fever suppressant used?",{},"{""parametrized_description"": ""A lab has TotalAvailableMRNA available to produce children's and adult vaccines. Each children's vaccine requires MRNAPerChildrenVaccine of mRNA and FeverSuppressantPerChildrenVaccine of fever suppressant. Each adult vaccine requires MRNAPerAdultVaccine of mRNA and FeverSuppressantPerAdultVaccine of fever suppressant. At least MinAdultVaccineProportion of the total vaccines must be adult vaccines, and at least MinChildVaccines children's vaccines must be produced. The objective is to determine the number of each type of vaccine to minimize the total amount of fever suppressant used."", ""keywords"": [""N.A.""], ""parameters"": {""TotalAvailableMRNA"": {""description"": ""Total available mRNA"", ""shape"": []}, ""MRNAPerChildrenVaccine"": {""description"": ""Amount of mRNA required for each children's vaccine"", ""shape"": []}, ""MRNAPerAdultVaccine"": {""description"": ""Amount of mRNA required for each adult vaccine"", ""shape"": []}, ""FeverSuppressantPerChildrenVaccine"": {""description"": ""Amount of fever suppressant used in each children's vaccine"", ""shape"": []}, ""FeverSuppressantPerAdultVaccine"": {""description"": ""Amount of fever suppressant used in each adult vaccine"", ""shape"": []}, ""MinAdultVaccineProportion"": {""description"": ""Minimum proportion of vaccines that must be adult vaccines"", ""shape"": []}, ""MinChildVaccines"": {""description"": ""Minimum number of children's vaccines to be produced"", ""shape"": []}}, ""variables"": {""ChildrenVaccine"": {""description"": ""The number of children's vaccines to be produced"", ""type"": ""continuous"", ""shape"": []}, ""AdultVaccine"": {""description"": ""The number of adult vaccines to be produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total amount of mRNA used by children's and adult vaccines cannot exceed TotalAvailableMRNA."", ""formulation"": ""MRNAPerChildrenVaccine \\cdot ChildrenVaccine + MRNAPerAdultVaccine \\cdot AdultVaccine \\leq TotalAvailableMRNA"", ""code"": {""gurobipy"": ""model.addConstr(MRNAPerChildrenVaccine * ChildrenVaccine + MRNAPerAdultVaccine * AdultVaccine <= TotalAvailableMRNA)""}}, {""description"": ""At least MinAdultVaccineProportion of the total vaccines produced must be adult vaccines."", ""formulation"": ""AdultVaccine \\geq MinAdultVaccineProportion \\cdot (AdultVaccine + ChildrenVaccine)"", ""code"": {""gurobipy"": ""model.addConstr(AdultVaccine >= MinAdultVaccineProportion * (AdultVaccine + ChildrenVaccine))""}}, {""description"": ""At least MinChildVaccines children's vaccines must be produced."", ""formulation"": ""ChildrenVaccine \\geq MinChildVaccines"", ""code"": {""gurobipy"": ""model.addConstr(ChildrenVaccine >= MinChildVaccines, \""MinChildVaccinesConstraint\"")""}}], ""objective"": {""description"": ""Minimize the total amount of fever suppressant used, which is the sum of FeverSuppressantPerChildrenVaccine multiplied by the number of children's vaccines and FeverSuppressantPerAdultVaccine multiplied by the number of adult vaccines."", ""formulation"": ""Min \\, FeverSuppressantPerChildrenVaccine \\cdot ChildrenVaccine + FeverSuppressantPerAdultVaccine \\cdot AdultVaccine"", ""code"": {""gurobipy"": ""model.setObjective(FeverSuppressantPerChildrenVaccine * ChildrenVaccine + FeverSuppressantPerAdultVaccine * AdultVaccine, GRB.MINIMIZE)""}}}","{""TotalMRNAAvailable"": 20000, ""MRNAPerChildVaccine"": 50, ""MRNAPerAdultVaccine"": 75, ""FeverSuppressantPerChildVaccine"": 50, ""FeverSuppressantPerAdultVaccine"": 75, ""MinPercentageAdultVaccines"": 70, ""MinChildVaccines"": 50}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A lab has TotalMRNAAvailable amount of mRNA anti-viral available to make
children's and adult vaccines. Each children's vaccine contains
MRNAPerChildVaccine mRNA and FeverSuppressantPerChildVaccine fever suppressant.
Each adult vaccine contains MRNAPerAdultVaccine mRNA and
FeverSuppressantPerAdultVaccine fever suppressant. At least
MinPercentageAdultVaccines percent of vaccines should be adult vaccines. At
least MinChildVaccines children's vaccines should be made. Determine the number
of each vaccine to minimize the amount of fever suppressant used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/103/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalMRNAAvailable @Def: Total amount of mRNA anti-viral available @Shape: [] 
TotalMRNAAvailable = data['TotalMRNAAvailable']
# @Parameter MRNAPerChildVaccine @Def: Amount of mRNA per children vaccine @Shape: [] 
MRNAPerChildVaccine = data['MRNAPerChildVaccine']
# @Parameter MRNAPerAdultVaccine @Def: Amount of mRNA per adult vaccine @Shape: [] 
MRNAPerAdultVaccine = data['MRNAPerAdultVaccine']
# @Parameter FeverSuppressantPerChildVaccine @Def: Amount of fever suppressant per children vaccine @Shape: [] 
FeverSuppressantPerChildVaccine = data['FeverSuppressantPerChildVaccine']
# @Parameter FeverSuppressantPerAdultVaccine @Def: Amount of fever suppressant per adult vaccine @Shape: [] 
FeverSuppressantPerAdultVaccine = data['FeverSuppressantPerAdultVaccine']
# @Parameter MinPercentageAdultVaccines @Def: Minimum percentage of vaccines that should be adult vaccines @Shape: [] 
MinPercentageAdultVaccines = data['MinPercentageAdultVaccines']
# @Parameter MinChildVaccines @Def: Minimum number of children's vaccines to be made @Shape: [] 
MinChildVaccines = data['MinChildVaccines']

# Variables 
# @Variable NumChildVaccines @Def: The number of children's vaccines to produce @Shape: ['Continuous'] 
NumChildVaccines = model.addVar(vtype=GRB.CONTINUOUS, name=""NumChildVaccines"")
# @Variable NumAdultVaccines @Def: The number of adult vaccines to produce @Shape: ['Continuous'] 
NumAdultVaccines = model.addVar(vtype=GRB.CONTINUOUS, name=""NumAdultVaccines"")

# Constraints 
# @Constraint Constr_1 @Def: The total mRNA used for children's and adult vaccines cannot exceed TotalMRNAAvailable.
model.addConstr(MRNAPerChildVaccine * NumChildVaccines + MRNAPerAdultVaccine * NumAdultVaccines <= TotalMRNAAvailable)
# @Constraint Constr_2 @Def: At least MinPercentageAdultVaccines percent of the total vaccines must be adult vaccines.
model.addConstr(NumAdultVaccines >= MinPercentageAdultVaccines * (NumAdultVaccines + NumChildVaccines))
# @Constraint Constr_3 @Def: At least MinChildVaccines children's vaccines must be produced.
model.addConstr(NumChildVaccines >= MinChildVaccines)

# Objective 
# @Objective Objective @Def: Minimize the total amount of fever suppressant used, which is calculated as (FeverSuppressantPerChildVaccine * NumberOfChildrenVaccines) + (FeverSuppressantPerAdultVaccine * NumberOfAdultVaccines).
model.setObjective(FeverSuppressantPerChildVaccine * NumChildVaccines + FeverSuppressantPerAdultVaccine * NumAdultVaccines, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumChildVaccines'] = NumChildVaccines.x
variables['NumAdultVaccines'] = NumAdultVaccines.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A parent feeds their baby two flavors of baby food, apple and carrot, in order to meet the babies fat and folate requirements. Each serving of apple flavored baby food contains 2 units of fat and 5 units of folate. Each serving of carrot flavored baby food contains 4 units of fat and 3 units of folate. The baby does not like the carrot flavor, and therefore he must eat three times as many apple flavored baby food as carrot flavored baby food. However, he must eat at least 2 servings of carrot flavored baby food. If the baby can consume at most 100 units of folate, how many servings of each should he eat to maximize his fat intake?","{""variables"": {""AppleServings"": 16.666666666666668, ""CarrotServings"": 5.555555555555556}, ""objective"": 55.55555555555556}","{""parametrized_description"": ""Maximize the total fat intake, which is FatApple multiplied by the number of apple servings plus FatCarrot multiplied by the number of carrot servings. Subject to the constraint that the total folate intake, calculated as FolateApple multiplied by the number of apple servings plus FolateCarrot multiplied by the number of carrot servings, does not exceed MaxFolate. Additionally, the number of apple servings must be equal to AppleToCarrotRatio multiplied by the number of carrot servings, and the number of carrot servings must be at least MinCarrotServings."", ""keywords"": [""N.A.""], ""parameters"": {""FatApple"": {""description"": ""Fat units per serving of apple flavored baby food"", ""shape"": []}, ""FolateApple"": {""description"": ""Folate units per serving of apple flavored baby food"", ""shape"": []}, ""FatCarrot"": {""description"": ""Fat units per serving of carrot flavored baby food"", ""shape"": []}, ""FolateCarrot"": {""description"": ""Folate units per serving of carrot flavored baby food"", ""shape"": []}, ""AppleToCarrotRatio"": {""description"": ""Multiplier for the number of apple servings relative to carrot servings"", ""shape"": []}, ""MinCarrotServings"": {""description"": ""Minimum servings of carrot flavored baby food"", ""shape"": []}, ""MaxFolate"": {""description"": ""Maximum total folate units allowed"", ""shape"": []}}, ""variables"": {""AppleServings"": {""description"": ""The number of apple servings"", ""type"": ""continuous"", ""shape"": []}, ""CarrotServings"": {""description"": ""The number of carrot servings"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total folate intake (FolateApple * number of apple servings + FolateCarrot * number of carrot servings) does not exceed MaxFolate."", ""formulation"": ""FolateApple \\times AppleServings + FolateCarrot \\times CarrotServings \\leq MaxFolate"", ""code"": {""gurobipy"": ""model.addConstr(FolateApple * AppleServings + FolateCarrot * CarrotServings <= MaxFolate)""}}, {""description"": ""The number of apple servings is equal to AppleToCarrotRatio multiplied by the number of carrot servings."", ""formulation"": ""AppleServings = AppleToCarrotRatio \\times CarrotServings"", ""code"": {""gurobipy"": ""model.addConstr(AppleServings == AppleToCarrotRatio * CarrotServings)""}}, {""description"": ""The number of carrot servings is at least MinCarrotServings."", ""formulation"": ""CarrotServings \\geq MinCarrotServings"", ""code"": {""gurobipy"": ""model.addConstr(CarrotServings >= MinCarrotServings)""}}], ""objective"": {""description"": ""The total fat intake is FatApple * number of apple servings + FatCarrot * number of carrot servings. The objective is to maximize the total fat intake."", ""formulation"": ""Max FatApple \\times AppleServings + FatCarrot \\times CarrotServings"", ""code"": {""gurobipy"": ""model.setObjective(FatApple * AppleServings + FatCarrot * CarrotServings, GRB.MAXIMIZE)""}}}","{""FatApple"": 2, ""FolateApple"": 5, ""FatCarrot"": 4, ""FolateCarrot"": 3, ""AppleToCarrotRatio"": 3, ""MinCarrotServings"": 2, ""MaxFolate"": 100}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Maximize the total fat intake, which is FatApple multiplied by the number of
apple servings plus FatCarrot multiplied by the number of carrot servings.
Subject to the constraint that the total folate intake, calculated as
FolateApple multiplied by the number of apple servings plus FolateCarrot
multiplied by the number of carrot servings, does not exceed MaxFolate.
Additionally, the number of apple servings must be equal to AppleToCarrotRatio
multiplied by the number of carrot servings, and the number of carrot servings
must be at least MinCarrotServings.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/104/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter FatApple @Def: Fat units per serving of apple flavored baby food @Shape: [] 
FatApple = data['FatApple']
# @Parameter FolateApple @Def: Folate units per serving of apple flavored baby food @Shape: [] 
FolateApple = data['FolateApple']
# @Parameter FatCarrot @Def: Fat units per serving of carrot flavored baby food @Shape: [] 
FatCarrot = data['FatCarrot']
# @Parameter FolateCarrot @Def: Folate units per serving of carrot flavored baby food @Shape: [] 
FolateCarrot = data['FolateCarrot']
# @Parameter AppleToCarrotRatio @Def: Multiplier for the number of apple servings relative to carrot servings @Shape: [] 
AppleToCarrotRatio = data['AppleToCarrotRatio']
# @Parameter MinCarrotServings @Def: Minimum servings of carrot flavored baby food @Shape: [] 
MinCarrotServings = data['MinCarrotServings']
# @Parameter MaxFolate @Def: Maximum total folate units allowed @Shape: [] 
MaxFolate = data['MaxFolate']

# Variables 
# @Variable AppleServings @Def: The number of apple servings @Shape: [] 
AppleServings = model.addVar(vtype=GRB.CONTINUOUS, name=""AppleServings"")
# @Variable CarrotServings @Def: The number of carrot servings @Shape: [] 
CarrotServings = model.addVar(vtype=GRB.CONTINUOUS, lb=MinCarrotServings, name=""CarrotServings"")

# Constraints 
# @Constraint Constr_1 @Def: The total folate intake (FolateApple * number of apple servings + FolateCarrot * number of carrot servings) does not exceed MaxFolate.
model.addConstr(FolateApple * AppleServings + FolateCarrot * CarrotServings <= MaxFolate)
# @Constraint Constr_2 @Def: The number of apple servings is equal to AppleToCarrotRatio multiplied by the number of carrot servings.
model.addConstr(AppleServings == AppleToCarrotRatio * CarrotServings)
# @Constraint Constr_3 @Def: The number of carrot servings is at least MinCarrotServings.
model.addConstr(CarrotServings >= MinCarrotServings)

# Objective 
# @Objective Objective @Def: The total fat intake is FatApple * number of apple servings + FatCarrot * number of carrot servings. The objective is to maximize the total fat intake.
model.setObjective(FatApple * AppleServings + FatCarrot * CarrotServings, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['AppleServings'] = AppleServings.x
variables['CarrotServings'] = CarrotServings.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Both fertilizer and seeds need to be added to a lawn. One unit of fertilizer takes 0.5 minutes to be effective while one unit of seeds takes 1.5 minutes to be effective. There can be at most 300 units of fertilizer and seeds combined added to the lawn. In addition at least 50 units of fertilizer need to be added. Since the lawn is really patchy, there can be at most twice the amount of fertilizer as seeds. How many units of each should be added to minimize the total time it takes for the lawn to be ready?","{""variables"": {""FertilizerUnits"": 50.0, ""SeedsUnits"": 25.0, ""TotalTime"": 37.5}, ""objective"": 37.5}","{""parametrized_description"": ""Determine the number of fertilizer units and seed units to minimize the total time for the lawn to be ready, where the total time is the maximum of the fertilizer units multiplied by TimePerFertilizer and the seed units multiplied by TimePerSeeds. The combined units of fertilizer and seeds must not exceed MaxTotalUnits, the fertilizer units must be at least MinFertilizer, and the fertilizer units must not exceed MaxFertilizerRatio times the seed units."", ""keywords"": [""N.A.""], ""parameters"": {""TimePerFertilizer"": {""description"": ""Time one unit of fertilizer takes to be effective"", ""shape"": []}, ""TimePerSeeds"": {""description"": ""Time one unit of seeds takes to be effective"", ""shape"": []}, ""MaxTotalUnits"": {""description"": ""Maximum total units of fertilizer and seeds combined"", ""shape"": []}, ""MinFertilizer"": {""description"": ""Minimum units of fertilizer to be added"", ""shape"": []}, ""MaxFertilizerRatio"": {""description"": ""Maximum ratio of fertilizer to seeds"", ""shape"": []}}, ""variables"": {""FertilizerUnits"": {""description"": ""The number of units of fertilizer"", ""type"": ""continuous"", ""shape"": []}, ""SeedsUnits"": {""description"": ""The number of units of seeds"", ""type"": ""continuous"", ""shape"": []}, ""TotalTime"": {""description"": ""The total time for the lawn to be ready"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The combined units of fertilizer and seeds must not exceed MaxTotalUnits."", ""formulation"": ""FertilizerUnits + SeedsUnits \\leq MaxTotalUnits"", ""code"": {""gurobipy"": ""model.addConstr(FertilizerUnits + SeedsUnits <= MaxTotalUnits)""}}, {""description"": ""The fertilizer units must be at least MinFertilizer."", ""formulation"": ""FertilizerUnits \\geq MinFertilizer"", ""code"": {""gurobipy"": ""model.addConstr(FertilizerUnits >= MinFertilizer)""}}, {""description"": ""The fertilizer units must not exceed MaxFertilizerRatio times the seed units."", ""formulation"": ""FertilizerUnits \\leq MaxFertilizerRatio \\times SeedsUnits"", ""code"": {""gurobipy"": ""model.addConstr(FertilizerUnits <= MaxFertilizerRatio * SeedsUnits)""}}], ""objective"": {""description"": ""The total time is the maximum of (fertilizer units multiplied by TimePerFertilizer) and (seed units multiplied by TimePerSeeds). The objective is to minimize the total time for the lawn to be ready."", ""formulation"": ""Min \\ TotalTime \\n TotalTime \\geq FertilizerUnits \\times TimePerFertilizer \\n TotalTime \\geq SeedsUnits \\times TimePerSeeds"", ""code"": {""gurobipy"": ""model.setObjective(TotalTime, GRB.MINIMIZE)\nmodel.addConstr(TotalTime >= FertilizerUnits * TimePerFertilizer, \""Time_Fertilizer\"")\nmodel.addConstr(TotalTime >= SeedsUnits * TimePerSeeds, \""Time_Seeds\"")""}}}","{""TimePerFertilizer"": 0.5, ""TimePerSeeds"": 1.5, ""MaxTotalUnits"": 300, ""MinFertilizer"": 50, ""MaxFertilizerRatio"": 2}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Determine the number of fertilizer units and seed units to minimize the total
time for the lawn to be ready, where the total time is the maximum of the
fertilizer units multiplied by TimePerFertilizer and the seed units multiplied
by TimePerSeeds. The combined units of fertilizer and seeds must not exceed
MaxTotalUnits, the fertilizer units must be at least MinFertilizer, and the
fertilizer units must not exceed MaxFertilizerRatio times the seed units.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/105/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TimePerFertilizer @Def: Time one unit of fertilizer takes to be effective @Shape: [] 
TimePerFertilizer = data['TimePerFertilizer']
# @Parameter TimePerSeeds @Def: Time one unit of seeds takes to be effective @Shape: [] 
TimePerSeeds = data['TimePerSeeds']
# @Parameter MaxTotalUnits @Def: Maximum total units of fertilizer and seeds combined @Shape: [] 
MaxTotalUnits = data['MaxTotalUnits']
# @Parameter MinFertilizer @Def: Minimum units of fertilizer to be added @Shape: [] 
MinFertilizer = data['MinFertilizer']
# @Parameter MaxFertilizerRatio @Def: Maximum ratio of fertilizer to seeds @Shape: [] 
MaxFertilizerRatio = data['MaxFertilizerRatio']

# Variables 
# @Variable FertilizerUnits @Def: The number of units of fertilizer @Shape: [] 
FertilizerUnits = model.addVar(vtype=GRB.CONTINUOUS, lb=MinFertilizer, name=""FertilizerUnits"")
# @Variable SeedsUnits @Def: The number of units of seeds @Shape: [] 
SeedsUnits = model.addVar(vtype=GRB.CONTINUOUS, name=""SeedsUnits"")
# @Variable TotalTime @Def: The total time for the lawn to be ready @Shape: [] 
TotalTime = model.addVar(vtype=GRB.CONTINUOUS, name=""TotalTime"")

# Constraints 
# @Constraint Constr_1 @Def: The combined units of fertilizer and seeds must not exceed MaxTotalUnits.
model.addConstr(FertilizerUnits + SeedsUnits <= MaxTotalUnits)
# @Constraint Constr_2 @Def: The fertilizer units must be at least MinFertilizer.
model.addConstr(FertilizerUnits >= MinFertilizer)
# @Constraint Constr_3 @Def: The fertilizer units must not exceed MaxFertilizerRatio times the seed units.
model.addConstr(FertilizerUnits <= MaxFertilizerRatio * SeedsUnits)

# Objective 
# @Objective Objective @Def: The total time is the maximum of (fertilizer units multiplied by TimePerFertilizer) and (seed units multiplied by TimePerSeeds). The objective is to minimize the total time for the lawn to be ready.
model.setObjective(TotalTime, GRB.MINIMIZE)
model.addConstr(TotalTime >= FertilizerUnits * TimePerFertilizer, ""Time_Fertilizer"")
model.addConstr(TotalTime >= SeedsUnits * TimePerSeeds, ""Time_Seeds"")

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['FertilizerUnits'] = FertilizerUnits.x
variables['SeedsUnits'] = SeedsUnits.x
variables['TotalTime'] = TotalTime.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A pharmacy has two factories, factory 1 and factory 2, where they make acne cream and anti-bacterial cream. Factory 1 produces 12 units of acne cream and 15 units of anti-bacterial cream per hour. Factory 2 produces 20 units of acne cream and 10 units of anti-bacterial cream per hour. Factory 1 requires 30 units of base gel per hour while factory 2 requires 45 units of base gel per hour. The pharmacy has available 5000 units of base gel. Further, they must make at least 800 units of acne cream and 1000 units of anti-bacterial cream. How many hours should each factory be run to minimize the total time needed?","{""variables"": {""ProductionMatrix"": {""(0, 0)"": 1200.0, ""(0, 1)"": 1000.0, ""(1, 0)"": 0.0, ""(1, 1)"": 0.0}, ""MaxOperatingHours"": 0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A pharmacy operates NumFactories factories, each producing NumProducts different products. Each factory has a ProductionRate for each product in units per hour and requires BaseGelRequirement units of base gel per hour. The pharmacy has AvailableBaseGel units of base gel available. The production must satisfy the MinimumDemand for each product. The objective is to determine the number of hours each factory should be run to minimize the total time needed."", ""keywords"": [""N.A.""], ""parameters"": {""NumFactories"": {""description"": ""Number of factories"", ""shape"": []}, ""NumProducts"": {""description"": ""Number of products"", ""shape"": []}, ""ProductionRate"": {""description"": ""Production rate of a product by a factory in units per hour"", ""shape"": [""NumFactories"", ""NumProducts""]}, ""BaseGelRequirement"": {""description"": ""Base gel required per hour by a factory"", ""shape"": [""NumFactories""]}, ""AvailableBaseGel"": {""description"": ""Total available units of base gel"", ""shape"": []}, ""MinimumDemand"": {""description"": ""Minimum required units of each product"", ""shape"": [""NumProducts""]}}, ""variables"": {""ProductionMatrix"": {""description"": ""The production quantity of each product by each factory"", ""type"": ""continuous"", ""shape"": [""NumFactories"", ""NumProducts""]}, ""MaxOperatingHours"": {""description"": ""The maximum operating hours across all factories"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The production of each product by all factories combined must meet or exceed the MinimumDemand."", ""formulation"": ""\\sum_{f=1}^{\\\text{NumFactories}} \\text{ProductionMatrix}_{f, p} \\geq \\text{MinimumDemand}_p \\quad \\forall p"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(ProductionMatrix[f, p] for f in range(NumFactories)) >= MinimumDemand[p] for p in range(NumProducts)), name=\""Demand\"")""}}, {""description"": ""The total base gel required by all factories must not exceed the AvailableBaseGel."", ""formulation"": ""\\sum_{i=1}^{NumFactories} \\sum_{p=1}^{NumProducts} \\frac{BaseGelRequirement_{i}}{ProductionRate_{i,p}} \\cdot Production_{i,p} \\leq AvailableBaseGel"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(BaseGelRequirement[i] / ProductionRate[i][p] * ProductionMatrix[i, p] for i in range(NumFactories) for p in range(NumProducts)) <= AvailableBaseGel)""}}], ""objective"": {""description"": ""The objective is to minimize the maximum operating hours across all factories while meeting production requirements and adhering to base gel resource constraints."", ""formulation"": ""Min MaxOperatingHours"", ""code"": {""gurobipy"": ""model.setObjective(MaxOperatingHours, GRB.MINIMIZE)""}}}","{""NumFactories"": 2, ""NumProducts"": 2, ""ProductionRate"": [[12, 15], [20, 10]], ""BaseGelRequirement"": [30, 45], ""AvailableBaseGel"": 5000, ""MinimumDemand"": [800, 1000]}","# Code automatically generated from OptiMUS

# Problem type: LP
# Problem description
""""""
A pharmacy operates NumFactories factories, each producing NumProducts different
products. Each factory has a ProductionRate for each product in units per hour
and requires BaseGelRequirement units of base gel per hour. The pharmacy has
AvailableBaseGel units of base gel available. The production must satisfy the
MinimumDemand for each product. The objective is to determine the number of
hours each factory should be run to minimize the total time needed.
""""""
# Import necessary libraries
import json
from gurobipy import *

# Create a new model
model = Model()

# Load data
with open(
    ""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/106/parameters.json"",
    ""r"",
) as f:
    data = json.load(f)

# @Def: definition of a target
# @Shape: shape of a target

# Parameters
# @Parameter NumFactories @Def: Number of factories @Shape: []
NumFactories = data[""NumFactories""]
# @Parameter NumProducts @Def: Number of products @Shape: []
NumProducts = data[""NumProducts""]
# @Parameter ProductionRate @Def: Production rate of a product by a factory in units per hour @Shape: ['NumFactories', 'NumProducts']
ProductionRate = data[""ProductionRate""]
# @Parameter BaseGelRequirement @Def: Base gel required per hour by a factory @Shape: ['NumFactories']
BaseGelRequirement = data[""BaseGelRequirement""]
# @Parameter AvailableBaseGel @Def: Total available units of base gel @Shape: []
AvailableBaseGel = data[""AvailableBaseGel""]
# @Parameter MinimumDemand @Def: Minimum required units of each product @Shape: ['NumProducts']
MinimumDemand = data[""MinimumDemand""]

# Variables
# @Variable Production @Def: The production quantity of each product by each factory @Shape: ['NumFactories', 'NumProducts']
ProductionMatrix = model.addVars(
    NumFactories, NumProducts, vtype=GRB.CONTINUOUS, name=""ProductionMatrix""
)
# @Variable MaxOperatingHours @Def: The maximum operating hours across all factories @Shape: []
MaxOperatingHours = model.addVar(vtype=GRB.CONTINUOUS, name=""MaxOperatingHours"")

# Constraints
# @Constraint Constr_1 @Def: The production of each product by all factories combined must meet or exceed the MinimumDemand.
model.addConstrs(
    (
        quicksum(ProductionMatrix[f, p] for f in range(NumFactories))
        >= MinimumDemand[p]
        for p in range(NumProducts)
    ),
    name=""Demand"",
)
# @Constraint Constr_2 @Def: The total base gel required by all factories must not exceed the AvailableBaseGel.
model.addConstr(
    quicksum(
        BaseGelRequirement[i] / ProductionRate[i][p] * ProductionMatrix[i, p]
        for i in range(NumFactories)
        for p in range(NumProducts)
    )
    <= AvailableBaseGel
)

# Objective
# @Objective Objective @Def: The objective is to minimize the maximum operating hours across all factories while meeting production requirements and adhering to base gel resource constraints.
model.setObjective(MaxOperatingHours, GRB.MINIMIZE)

# Solve
model.optimize()

# Extract solution
solution = {}
variables = {}
objective = []
variables[""ProductionMatrix""] = {
    f""({k[0]}, {k[1]})"": v.x for k, v in ProductionMatrix.items()
}
variables[""MaxOperatingHours""] = MaxOperatingHours.x
solution[""variables""] = variables
solution[""objective""] = model.objVal
with open(""solution.json"", ""w"") as f:
    json.dump(solution, f, indent=4)
"
"A doctor recommends that a man eat burgers and pizza in order to put on weight. Each burger contains 10 units of fat and 300 calories. Each slice of pizza contains 8 units of fat and 250 calories. The man must get at least 130 units of fat and 3000 calories. Further, each burger contains 12 units of cholesterol while each slice of pizza contains 10 units of cholesterol. Since burgers are slightly more expensive, the man decides to eat at least twice as many slices of pizza as burgers. How many of each should he eat to minimize his cholesterol intake?","{""variables"": {""Burgers"": 5.0, ""PizzaSlices"": 10.0}, ""objective"": 160.0}","{""parametrized_description"": ""Let B represent the number of burgers and P represent the number of pizza slices. The objective is to minimize CholesterolPerBurger multiplied by B plus CholesterolPerPizzaSlice multiplied by P. This is subject to the constraints that FatPerBurger multiplied by B plus FatPerPizzaSlice multiplied by P is at least MinFat, CaloriesPerBurger multiplied by B plus CaloriesPerPizzaSlice multiplied by P is at least MinCalories, and P is at least MinPizzaToBurgerRatio multiplied by B."", ""keywords"": [""N.A.""], ""parameters"": {""FatPerBurger"": {""description"": ""Units of fat per burger"", ""shape"": []}, ""FatPerPizzaSlice"": {""description"": ""Units of fat per slice of pizza"", ""shape"": []}, ""CaloriesPerBurger"": {""description"": ""Calories per burger"", ""shape"": []}, ""CaloriesPerPizzaSlice"": {""description"": ""Calories per slice of pizza"", ""shape"": []}, ""CholesterolPerBurger"": {""description"": ""Units of cholesterol per burger"", ""shape"": []}, ""CholesterolPerPizzaSlice"": {""description"": ""Units of cholesterol per slice of pizza"", ""shape"": []}, ""MinFat"": {""description"": ""Minimum total units of fat required"", ""shape"": []}, ""MinCalories"": {""description"": ""Minimum total calories required"", ""shape"": []}, ""MinPizzaToBurgerRatio"": {""description"": ""Minimum ratio of slices of pizza to burgers"", ""shape"": []}}, ""variables"": {""Burgers"": {""description"": ""The number of burgers"", ""type"": ""continuous"", ""shape"": []}, ""PizzaSlices"": {""description"": ""The number of slices of pizza"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""FatPerBurger multiplied by B plus FatPerPizzaSlice multiplied by P is at least MinFat"", ""formulation"": ""FatPerBurger \\cdot Burgers + FatPerPizzaSlice \\cdot PizzaSlices \\geq MinFat"", ""code"": {""gurobipy"": ""model.addConstr(FatPerBurger * Burgers + FatPerPizzaSlice * PizzaSlices >= MinFat)""}}, {""description"": ""CaloriesPerBurger multiplied by B plus CaloriesPerPizzaSlice multiplied by P is at least MinCalories"", ""formulation"": ""CaloriesPerBurger \\cdot Burgers + CaloriesPerPizzaSlice \\cdot PizzaSlices \\geq MinCalories"", ""code"": {""gurobipy"": ""model.addConstr(CaloriesPerBurger * Burgers + CaloriesPerPizzaSlice * PizzaSlices >= MinCalories)""}}, {""description"": ""P is at least MinPizzaToBurgerRatio multiplied by B"", ""formulation"": ""PizzaSlices \\geq MinPizzaToBurgerRatio \\times Burgers"", ""code"": {""gurobipy"": ""model.addConstr(PizzaSlices >= MinPizzaToBurgerRatio * Burgers)""}}], ""objective"": {""description"": ""Minimize CholesterolPerBurger multiplied by B plus CholesterolPerPizzaSlice multiplied by P"", ""formulation"": ""Min CholesterolPerBurger \\times Burgers + CholesterolPerPizzaSlice \\times PizzaSlices"", ""code"": {""gurobipy"": ""model.setObjective(CholesterolPerBurger * Burgers + CholesterolPerPizzaSlice * PizzaSlices, GRB.MINIMIZE)""}}}","{""FatPerBurger"": 10, ""FatPerPizzaSlice"": 8, ""CaloriesPerBurger"": 300, ""CaloriesPerPizzaSlice"": 250, ""CholesterolPerBurger"": 12, ""CholesterolPerPizzaSlice"": 10, ""MinFat"": 130, ""MinCalories"": 3000, ""MinPizzaToBurgerRatio"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Let B represent the number of burgers and P represent the number of pizza
slices. The objective is to minimize CholesterolPerBurger multiplied by B plus
CholesterolPerPizzaSlice multiplied by P. This is subject to the constraints
that FatPerBurger multiplied by B plus FatPerPizzaSlice multiplied by P is at
least MinFat, CaloriesPerBurger multiplied by B plus CaloriesPerPizzaSlice
multiplied by P is at least MinCalories, and P is at least MinPizzaToBurgerRatio
multiplied by B.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/107/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter FatPerBurger @Def: Units of fat per burger @Shape: [] 
FatPerBurger = data['FatPerBurger']
# @Parameter FatPerPizzaSlice @Def: Units of fat per slice of pizza @Shape: [] 
FatPerPizzaSlice = data['FatPerPizzaSlice']
# @Parameter CaloriesPerBurger @Def: Calories per burger @Shape: [] 
CaloriesPerBurger = data['CaloriesPerBurger']
# @Parameter CaloriesPerPizzaSlice @Def: Calories per slice of pizza @Shape: [] 
CaloriesPerPizzaSlice = data['CaloriesPerPizzaSlice']
# @Parameter CholesterolPerBurger @Def: Units of cholesterol per burger @Shape: [] 
CholesterolPerBurger = data['CholesterolPerBurger']
# @Parameter CholesterolPerPizzaSlice @Def: Units of cholesterol per slice of pizza @Shape: [] 
CholesterolPerPizzaSlice = data['CholesterolPerPizzaSlice']
# @Parameter MinFat @Def: Minimum total units of fat required @Shape: [] 
MinFat = data['MinFat']
# @Parameter MinCalories @Def: Minimum total calories required @Shape: [] 
MinCalories = data['MinCalories']
# @Parameter MinPizzaToBurgerRatio @Def: Minimum ratio of slices of pizza to burgers @Shape: [] 
MinPizzaToBurgerRatio = data['MinPizzaToBurgerRatio']

# Variables 
# @Variable Burgers @Def: The number of burgers @Shape: [] 
Burgers = model.addVar(vtype=GRB.INTEGER, name=""Burgers"")
# @Variable PizzaSlices @Def: The number of slices of pizza @Shape: [] 
PizzaSlices = model.addVar(vtype=GRB.CONTINUOUS, name=""PizzaSlices"")

# Constraints 
# @Constraint Constr_1 @Def: FatPerBurger multiplied by B plus FatPerPizzaSlice multiplied by P is at least MinFat
model.addConstr(FatPerBurger * Burgers + FatPerPizzaSlice * PizzaSlices >= MinFat)
# @Constraint Constr_2 @Def: CaloriesPerBurger multiplied by B plus CaloriesPerPizzaSlice multiplied by P is at least MinCalories
model.addConstr(CaloriesPerBurger * Burgers + CaloriesPerPizzaSlice * PizzaSlices >= MinCalories)
# @Constraint Constr_3 @Def: P is at least MinPizzaToBurgerRatio multiplied by B
model.addConstr(PizzaSlices >= MinPizzaToBurgerRatio * Burgers)

# Objective 
# @Objective Objective @Def: Minimize CholesterolPerBurger multiplied by B plus CholesterolPerPizzaSlice multiplied by P
model.setObjective(CholesterolPerBurger * Burgers + CholesterolPerPizzaSlice * PizzaSlices, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Burgers'] = Burgers.x
variables['PizzaSlices'] = PizzaSlices.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A clinic makes batches of vitamin shots and pills. Each batch of vitamin shots requires 30 units of vitamin C and 40 units of vitamin D. Each batch of vitamin pills requires 50 units of vitamin C and 30 units of vitamin D. Since pills are more popular, the number of batches of vitamin pills must be larger than the number of batches of vitamin shots. Further, the clinic can make at most 10 batches of vitamin shots. The clinic has available 1200 units of vitamin C and 1500 units of vitamin D. If each batch of vitamin shots can supply 10 people and each batch of vitamin pills can supply 7 people, how many batches of each should be made to maximize the number of people that can be supplied?","{""variables"": {""BatchesShots"": 10.0, ""BatchesPills"": 18.0}, ""objective"": 226.0}","{""parametrized_description"": ""A clinic produces two products: vitamin shots and vitamin pills. Each batch of vitamin shots requires VitaminCShots units of vitamin C and VitaminDShots units of vitamin D. Each batch of vitamin pills requires VitaminCPills units of vitamin C and VitaminDPills units of vitamin D. The number of batches of vitamin pills must be greater than the number of batches of vitamin shots by at least MinBatchDifference. The clinic can produce at most MaxBatchesShots batches of vitamin shots. The clinic has AvailableVitaminC units of vitamin C and AvailableVitaminD units of vitamin D available. Each batch of vitamin shots can supply SupplyShots people and each batch of vitamin pills can supply SupplyPills people. The objective is to determine the number of batches of each product to maximize the number of people that can be supplied."", ""keywords"": [""N.A.""], ""parameters"": {""VitaminCShots"": {""description"": ""Amount of vitamin C required per batch of vitamin shots"", ""shape"": []}, ""VitaminDShots"": {""description"": ""Amount of vitamin D required per batch of vitamin shots"", ""shape"": []}, ""VitaminCPills"": {""description"": ""Amount of vitamin C required per batch of vitamin pills"", ""shape"": []}, ""VitaminDPills"": {""description"": ""Amount of vitamin D required per batch of vitamin pills"", ""shape"": []}, ""MaxBatchesShots"": {""description"": ""The maximum number of batches of vitamin shots that can be produced"", ""shape"": []}, ""AvailableVitaminC"": {""description"": ""Total available units of vitamin C"", ""shape"": []}, ""AvailableVitaminD"": {""description"": ""Total available units of vitamin D"", ""shape"": []}, ""SupplyShots"": {""description"": ""Number of people supplied per batch of vitamin shots"", ""shape"": []}, ""SupplyPills"": {""description"": ""Number of people supplied per batch of vitamin pills"", ""shape"": []}, ""MinBatchDifference"": {""description"": ""Minimum number of additional batches of vitamin pills compared to vitamin shots"", ""shape"": []}}, ""variables"": {""BatchesShots"": {""description"": ""The number of batches of vitamin shots produced"", ""type"": ""continuous"", ""shape"": [""integer""]}, ""BatchesPills"": {""description"": ""The number of batches of vitamin pills produced"", ""type"": ""continuous"", ""shape"": [""integer""]}}, ""constraints"": [{""description"": ""Each batch of vitamin shots requires VitaminCShots units of vitamin C and each batch of vitamin pills requires VitaminCPills units of vitamin C. The total vitamin C used cannot exceed AvailableVitaminC."", ""formulation"": ""VitaminCShots \\times BatchesShots + VitaminCPills \\times BatchesPills \\leq AvailableVitaminC"", ""code"": {""gurobipy"": ""model.addConstr(VitaminCShots * BatchesShots + VitaminCPills * BatchesPills <= AvailableVitaminC)""}}, {""description"": ""Each batch of vitamin shots requires VitaminDShots units of vitamin D and each batch of vitamin pills requires VitaminDPills units of vitamin D. The total vitamin D used cannot exceed AvailableVitaminD."", ""formulation"": ""VitaminDShots \\cdot BatchesShots + VitaminDPills \\cdot BatchesPills \\leq AvailableVitaminD"", ""code"": {""gurobipy"": ""model.addConstr(VitaminDShots * BatchesShots + VitaminDPills * BatchesPills <= AvailableVitaminD)""}}, {""description"": ""The number of batches of vitamin pills must exceed the number of batches of vitamin shots by at least MinBatchDifference."", ""formulation"": ""BatchesPills - BatchesShots \\ge MinBatchDifference"", ""code"": {""gurobipy"": ""model.addConstr(BatchesPills - BatchesShots >= MinBatchDifference)""}}, {""description"": ""The number of batches of vitamin shots produced cannot exceed MaxBatchesShots."", ""formulation"": ""BatchesShots \\leq MaxBatchesShots"", ""code"": {""gurobipy"": ""model.addConstr(BatchesShots <= MaxBatchesShots)""}}], ""objective"": {""description"": ""The total number of people supplied is the sum of the people supplied by vitamin shots and vitamin pills. The objective is to maximize this total number of people supplied."", ""formulation"": ""Max \\left( SupplyShots \\times BatchesShots + SupplyPills \\times BatchesPills \\right )"", ""code"": {""gurobipy"": ""model.setObjective(SupplyShots * BatchesShots + SupplyPills * BatchesPills, GRB.MAXIMIZE)""}}}","{""VitaminCShots"": 30, ""VitaminDShots"": 40, ""VitaminCPills"": 50, ""VitaminDPills"": 30, ""MaxBatchesShots"": 10, ""AvailableVitaminC"": 1200, ""AvailableVitaminD"": 1500, ""SupplyShots"": 10, ""SupplyPills"": 7, ""MinBatchDifference"": 1}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A clinic produces two products: vitamin shots and vitamin pills. Each batch of
vitamin shots requires VitaminCShots units of vitamin C and VitaminDShots units
of vitamin D. Each batch of vitamin pills requires VitaminCPills units of
vitamin C and VitaminDPills units of vitamin D. The number of batches of vitamin
pills must be greater than the number of batches of vitamin shots by at least
MinBatchDifference. The clinic can produce at most MaxBatchesShots batches of
vitamin shots. The clinic has AvailableVitaminC units of vitamin C and
AvailableVitaminD units of vitamin D available. Each batch of vitamin shots can
supply SupplyShots people and each batch of vitamin pills can supply SupplyPills
people. The objective is to determine the number of batches of each product to
maximize the number of people that can be supplied.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/108/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter VitaminCShots @Def: Amount of vitamin C required per batch of vitamin shots @Shape: [] 
VitaminCShots = data['VitaminCShots']
# @Parameter VitaminDShots @Def: Amount of vitamin D required per batch of vitamin shots @Shape: [] 
VitaminDShots = data['VitaminDShots']
# @Parameter VitaminCPills @Def: Amount of vitamin C required per batch of vitamin pills @Shape: [] 
VitaminCPills = data['VitaminCPills']
# @Parameter VitaminDPills @Def: Amount of vitamin D required per batch of vitamin pills @Shape: [] 
VitaminDPills = data['VitaminDPills']
# @Parameter MaxBatchesShots @Def: The maximum number of batches of vitamin shots that can be produced @Shape: [] 
MaxBatchesShots = data['MaxBatchesShots']
# @Parameter AvailableVitaminC @Def: Total available units of vitamin C @Shape: [] 
AvailableVitaminC = data['AvailableVitaminC']
# @Parameter AvailableVitaminD @Def: Total available units of vitamin D @Shape: [] 
AvailableVitaminD = data['AvailableVitaminD']
# @Parameter SupplyShots @Def: Number of people supplied per batch of vitamin shots @Shape: [] 
SupplyShots = data['SupplyShots']
# @Parameter SupplyPills @Def: Number of people supplied per batch of vitamin pills @Shape: [] 
SupplyPills = data['SupplyPills']
# @Parameter MinBatchDifference @Def: Minimum number of additional batches of vitamin pills compared to vitamin shots @Shape: [] 
MinBatchDifference = data['MinBatchDifference']

# Variables 
# @Variable BatchesShots @Def: The number of batches of vitamin shots produced @Shape: ['integer'] 
BatchesShots = model.addVar(vtype=GRB.INTEGER, name=""BatchesShots"", lb=0, ub=MaxBatchesShots)
# @Variable BatchesPills @Def: The number of batches of vitamin pills produced @Shape: ['integer'] 
BatchesPills = model.addVar(vtype=GRB.INTEGER, name=""BatchesPills"")

# Constraints 
# @Constraint Constr_1 @Def: Each batch of vitamin shots requires VitaminCShots units of vitamin C and each batch of vitamin pills requires VitaminCPills units of vitamin C. The total vitamin C used cannot exceed AvailableVitaminC.
model.addConstr(VitaminCShots * BatchesShots + VitaminCPills * BatchesPills <= AvailableVitaminC)
# @Constraint Constr_2 @Def: Each batch of vitamin shots requires VitaminDShots units of vitamin D and each batch of vitamin pills requires VitaminDPills units of vitamin D. The total vitamin D used cannot exceed AvailableVitaminD.
model.addConstr(VitaminDShots * BatchesShots + VitaminDPills * BatchesPills <= AvailableVitaminD)
# @Constraint Constr_3 @Def: The number of batches of vitamin pills must exceed the number of batches of vitamin shots by at least MinBatchDifference.
model.addConstr(BatchesPills - BatchesShots >= MinBatchDifference)
# @Constraint Constr_4 @Def: The number of batches of vitamin shots produced cannot exceed MaxBatchesShots.
model.addConstr(BatchesShots <= MaxBatchesShots)

# Objective 
# @Objective Objective @Def: The total number of people supplied is the sum of the people supplied by vitamin shots and vitamin pills. The objective is to maximize this total number of people supplied.
model.setObjective(SupplyShots * BatchesShots + SupplyPills * BatchesPills, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['BatchesShots'] = BatchesShots.x
variables['BatchesPills'] = BatchesPills.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A doctor's office takes the  temperature of patients one by one either by using an electronic or regular thermometer. The electronic thermometer takes 3 minutes to make a reading while the regular thermometer takes 2 minutes to make a reading. Since the electronic thermometer is more accurate, at least twice as many patients should have their temperature checked by the electronic thermometer than the regular thermometer. Since the electronic thermometer has a cooldown time, at least 50 patients should have their temperature checked by a regular thermometer. If the office is open for 15000 minutes, maximize the number of patients whose temperature can be taken?","{""variables"": {""ElectronicReadings"": 3750.0, ""RegularReadings"": 1875.0}, ""objective"": 5625.0}","{""parametrized_description"": ""A doctor's office takes the temperature of patients one by one using either an electronic or regular thermometer. The electronic thermometer takes TimeElectronicReading time per reading, while the regular thermometer takes TimeRegularReading time per reading. At least MinRatioElectronicToRegular times as many patients should have their temperature checked by the electronic thermometer as by the regular thermometer. Additionally, at least MinRegularPatients should have their temperature checked by the regular thermometer. Given TotalAvailableTime, maximize the number of patients whose temperature can be taken."", ""keywords"": [""N.A.""], ""parameters"": {""TimeElectronicReading"": {""description"": ""Time taken by electronic thermometer per reading"", ""shape"": []}, ""TimeRegularReading"": {""description"": ""Time taken by regular thermometer per reading"", ""shape"": []}, ""MinRatioElectronicToRegular"": {""description"": ""Minimum ratio of electronic thermometer uses to regular thermometer uses"", ""shape"": []}, ""MinRegularPatients"": {""description"": ""Minimum number of patients using regular thermometer"", ""shape"": []}, ""TotalAvailableTime"": {""description"": ""Total available time for temperature readings"", ""shape"": []}}, ""variables"": {""ElectronicReadings"": {""description"": ""The number of electronic thermometer readings"", ""type"": ""continuous"", ""shape"": []}, ""RegularReadings"": {""description"": ""The number of regular thermometer readings"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total time taken by electronic and regular thermometer readings cannot exceed TotalAvailableTime."", ""formulation"": ""TimeElectronicReading \\times ElectronicReadings + TimeRegularReading \\times RegularReadings \\leq TotalAvailableTime"", ""code"": {""gurobipy"": ""model.addConstr(TimeElectronicReading * ElectronicReadings + TimeRegularReading * RegularReadings <= TotalAvailableTime)""}}, {""description"": ""At least MinRatioElectronicToRegular times as many patients should have their temperature checked by the electronic thermometer as by the regular thermometer."", ""formulation"": ""ElectronicReadings \\geq MinRatioElectronicToRegular \\times RegularReadings"", ""code"": {""gurobipy"": ""model.addConstr(ElectronicReadings >= MinRatioElectronicToRegular * RegularReadings)""}}, {""description"": ""At least MinRegularPatients must have their temperature checked by the regular thermometer."", ""formulation"": ""RegularReadings \\geq MinRegularPatients"", ""code"": {""gurobipy"": ""model.addConstr(RegularReadings >= MinRegularPatients)""}}], ""objective"": {""description"": ""The number of patients processed is the sum of patients checked by electronic and regular thermometers. The objective is to maximize this total number of patients within the available time and usage constraints."", ""formulation"": ""Max \\; (ElectronicReadings + RegularReadings)"", ""code"": {""gurobipy"": ""model.setObjective(ElectronicReadings + RegularReadings, GRB.MAXIMIZE)""}}}","{""TimeElectronicReading"": 3, ""TimeRegularReading"": 2, ""MinRatioElectronicToRegular"": 2, ""MinRegularPatients"": 50, ""TotalAvailableTime"": 15000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A doctor's office takes the temperature of patients one by one using either an
electronic or regular thermometer. The electronic thermometer takes
TimeElectronicReading time per reading, while the regular thermometer takes
TimeRegularReading time per reading. At least MinRatioElectronicToRegular times
as many patients should have their temperature checked by the electronic
thermometer as by the regular thermometer. Additionally, at least
MinRegularPatients should have their temperature checked by the regular
thermometer. Given TotalAvailableTime, maximize the number of patients whose
temperature can be taken.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/109/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TimeElectronicReading @Def: Time taken by electronic thermometer per reading @Shape: [] 
TimeElectronicReading = data['TimeElectronicReading']
# @Parameter TimeRegularReading @Def: Time taken by regular thermometer per reading @Shape: [] 
TimeRegularReading = data['TimeRegularReading']
# @Parameter MinRatioElectronicToRegular @Def: Minimum ratio of electronic thermometer uses to regular thermometer uses @Shape: [] 
MinRatioElectronicToRegular = data['MinRatioElectronicToRegular']
# @Parameter MinRegularPatients @Def: Minimum number of patients using regular thermometer @Shape: [] 
MinRegularPatients = data['MinRegularPatients']
# @Parameter TotalAvailableTime @Def: Total available time for temperature readings @Shape: [] 
TotalAvailableTime = data['TotalAvailableTime']

# Variables 
# @Variable ElectronicReadings @Def: The number of electronic thermometer readings @Shape: [] 
ElectronicReadings = model.addVar(vtype=GRB.INTEGER, name=""ElectronicReadings"")
# @Variable RegularReadings @Def: The number of regular thermometer readings @Shape: [] 
RegularReadings = model.addVar(vtype=GRB.INTEGER, name=""RegularReadings"")

# Constraints 
# @Constraint Constr_1 @Def: The total time taken by electronic and regular thermometer readings cannot exceed TotalAvailableTime.
model.addConstr(TimeElectronicReading * ElectronicReadings + TimeRegularReading * RegularReadings <= TotalAvailableTime)
# @Constraint Constr_2 @Def: At least MinRatioElectronicToRegular times as many patients should have their temperature checked by the electronic thermometer as by the regular thermometer.
model.addConstr(ElectronicReadings >= MinRatioElectronicToRegular * RegularReadings)
# @Constraint Constr_3 @Def: At least MinRegularPatients must have their temperature checked by the regular thermometer.
model.addConstr(RegularReadings >= MinRegularPatients)

# Objective 
# @Objective Objective @Def: The number of patients processed is the sum of patients checked by electronic and regular thermometers. The objective is to maximize this total number of patients within the available time and usage constraints.
model.setObjective(ElectronicReadings + RegularReadings, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ElectronicReadings'] = ElectronicReadings.x
variables['RegularReadings'] = RegularReadings.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A patient can be hooked up to two machines to have medicine delivered, machine 1 and machine 2. Machine 1 delivers 0.5 units of medicine to the heart per minute and 0.8 units of medicine per minute to the brain. Machine 2 delivers 0.3 units of medicine per minute to the heart and 1 unit of medicine per minute to the brain. In addition however, machine 1 creates 0.3 units of waste per minute while machine 2 creates 0.5 units of waste per minute. If at most 8 units of medicine can be received by the heart and at least 4 units of medicine should be received by the brain, how many minutes should each machine be used to minimize the total amount of waste produced?","{""variables"": {""Machine1OperatingTime"": 5.0, ""Machine2OperatingTime"": 0.0}, ""objective"": 1.5}","{""parametrized_description"": ""A patient can be connected to two machines, Machine1 and Machine2, for certain durations. Machine1 delivers Machine1HeartDeliveryRate units of medicine to the heart per minute and Machine1BrainDeliveryRate units to the brain per minute, while producing Machine1WasteRate units of waste per minute. Machine2 delivers Machine2HeartDeliveryRate units of medicine to the heart per minute and Machine2BrainDeliveryRate units to the brain per minute, while producing Machine2WasteRate units of waste per minute. The total medicine delivered to the heart must not exceed HeartMedicineMax units, and the total medicine delivered to the brain must be at least BrainMedicineMin units. Determine the operating time for each machine to minimize the total waste produced."", ""keywords"": [""N.A.""], ""parameters"": {""Machine1HeartDeliveryRate"": {""description"": ""Units of medicine delivered to the heart per minute by machine 1"", ""shape"": []}, ""Machine1BrainDeliveryRate"": {""description"": ""Units of medicine delivered to the brain per minute by machine 1"", ""shape"": []}, ""Machine1WasteRate"": {""description"": ""Units of waste produced per minute by machine 1"", ""shape"": []}, ""Machine2HeartDeliveryRate"": {""description"": ""Units of medicine delivered to the heart per minute by machine 2"", ""shape"": []}, ""Machine2BrainDeliveryRate"": {""description"": ""Units of medicine delivered to the brain per minute by machine 2"", ""shape"": []}, ""Machine2WasteRate"": {""description"": ""Units of waste produced per minute by machine 2"", ""shape"": []}, ""HeartMedicineMax"": {""description"": ""Maximum units of medicine that can be received by the heart"", ""shape"": []}, ""BrainMedicineMin"": {""description"": ""Minimum units of medicine that should be received by the brain"", ""shape"": []}}, ""variables"": {""Machine1OperatingTime"": {""description"": ""The operating time of Machine 1 in minutes"", ""type"": ""continuous"", ""shape"": []}, ""Machine2OperatingTime"": {""description"": ""The operating time of Machine 2 in minutes"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total medicine delivered to the heart by Machine1 and Machine2 must not exceed HeartMedicineMax units."", ""formulation"": ""Machine1HeartDeliveryRate \\cdot Machine1OperatingTime + Machine2HeartDeliveryRate \\cdot Machine2OperatingTime \\leq HeartMedicineMax"", ""code"": {""gurobipy"": ""model.addConstr(Machine1HeartDeliveryRate * Machine1OperatingTime + Machine2HeartDeliveryRate * Machine2OperatingTime <= HeartMedicineMax)""}}, {""description"": ""The total medicine delivered to the brain by Machine1 and Machine2 must be at least BrainMedicineMin units."", ""formulation"": ""Machine1BrainDeliveryRate \\times Machine1OperatingTime + Machine2BrainDeliveryRate \\times Machine2OperatingTime \\geq BrainMedicineMin"", ""code"": {""gurobipy"": ""model.addConstr(Machine1BrainDeliveryRate * Machine1OperatingTime + Machine2BrainDeliveryRate * Machine2OperatingTime >= BrainMedicineMin)""}}], ""objective"": {""description"": ""The total waste produced is the sum of waste produced by Machine1 and Machine2. The objective is to minimize the total waste produced."", ""formulation"": ""Min \\ Machine1WasteRate \\times Machine1OperatingTime + Machine2WasteRate \\times Machine2OperatingTime"", ""code"": {""gurobipy"": ""model.setObjective(Machine1WasteRate * Machine1OperatingTime + Machine2WasteRate * Machine2OperatingTime, GRB.MINIMIZE)""}}}","{""Machine1HeartDeliveryRate"": 0.5, ""Machine1BrainDeliveryRate"": 0.8, ""Machine1WasteRate"": 0.3, ""Machine2HeartDeliveryRate"": 0.3, ""Machine2BrainDeliveryRate"": 1, ""Machine2WasteRate"": 0.5, ""HeartMedicineMax"": 8, ""BrainMedicineMin"": 4}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A patient can be connected to two machines, Machine1 and Machine2, for certain
durations. Machine1 delivers Machine1HeartDeliveryRate units of medicine to the
heart per minute and Machine1BrainDeliveryRate units to the brain per minute,
while producing Machine1WasteRate units of waste per minute. Machine2 delivers
Machine2HeartDeliveryRate units of medicine to the heart per minute and
Machine2BrainDeliveryRate units to the brain per minute, while producing
Machine2WasteRate units of waste per minute. The total medicine delivered to the
heart must not exceed HeartMedicineMax units, and the total medicine delivered
to the brain must be at least BrainMedicineMin units. Determine the operating
time for each machine to minimize the total waste produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/110/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter Machine1HeartDeliveryRate @Def: Units of medicine delivered to the heart per minute by machine 1 @Shape: [] 
Machine1HeartDeliveryRate = data['Machine1HeartDeliveryRate']
# @Parameter Machine1BrainDeliveryRate @Def: Units of medicine delivered to the brain per minute by machine 1 @Shape: [] 
Machine1BrainDeliveryRate = data['Machine1BrainDeliveryRate']
# @Parameter Machine1WasteRate @Def: Units of waste produced per minute by machine 1 @Shape: [] 
Machine1WasteRate = data['Machine1WasteRate']
# @Parameter Machine2HeartDeliveryRate @Def: Units of medicine delivered to the heart per minute by machine 2 @Shape: [] 
Machine2HeartDeliveryRate = data['Machine2HeartDeliveryRate']
# @Parameter Machine2BrainDeliveryRate @Def: Units of medicine delivered to the brain per minute by machine 2 @Shape: [] 
Machine2BrainDeliveryRate = data['Machine2BrainDeliveryRate']
# @Parameter Machine2WasteRate @Def: Units of waste produced per minute by machine 2 @Shape: [] 
Machine2WasteRate = data['Machine2WasteRate']
# @Parameter HeartMedicineMax @Def: Maximum units of medicine that can be received by the heart @Shape: [] 
HeartMedicineMax = data['HeartMedicineMax']
# @Parameter BrainMedicineMin @Def: Minimum units of medicine that should be received by the brain @Shape: [] 
BrainMedicineMin = data['BrainMedicineMin']

# Variables 
# @Variable Machine1OperatingTime @Def: The operating time of Machine 1 in minutes @Shape: [] 
Machine1OperatingTime = model.addVar(vtype=GRB.CONTINUOUS, name=""Machine1OperatingTime"")
# @Variable Machine2OperatingTime @Def: The operating time of Machine 2 in minutes @Shape: [] 
Machine2OperatingTime = model.addVar(vtype=GRB.CONTINUOUS, name=""Machine2OperatingTime"")

# Constraints 
# @Constraint Constr_1 @Def: The total medicine delivered to the heart by Machine1 and Machine2 must not exceed HeartMedicineMax units.
model.addConstr(Machine1HeartDeliveryRate * Machine1OperatingTime + Machine2HeartDeliveryRate * Machine2OperatingTime <= HeartMedicineMax)
# @Constraint Constr_2 @Def: The total medicine delivered to the brain by Machine1 and Machine2 must be at least BrainMedicineMin units.
model.addConstr(Machine1BrainDeliveryRate * Machine1OperatingTime + Machine2BrainDeliveryRate * Machine2OperatingTime >= BrainMedicineMin)

# Objective 
# @Objective Objective @Def: The total waste produced is the sum of waste produced by Machine1 and Machine2. The objective is to minimize the total waste produced.
model.setObjective(Machine1WasteRate * Machine1OperatingTime + Machine2WasteRate * Machine2OperatingTime, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Machine1OperatingTime'] = Machine1OperatingTime.x
variables['Machine2OperatingTime'] = Machine2OperatingTime.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A travelling salesman only eats ramen and fries. Each pack of ramen contains 400 calories, 20 grams of protein, and 100 mg of sodium. Each pack of fries contains 300 calories, 10 grams of protein, and 75 mg of sodium. Since fries are easier to eat while driving, at most 30% of his meals can be ramen. The salesman wants to ensure he eats at least 3000 calories and 80 grams of protein. How many of each should he eat to minimize his sodium intake?","{""variables"": {""NumRamenPacks"": 0.0, ""NumFriesPacks"": 10.0}, ""objective"": 750.0}","{""parametrized_description"": ""A salesman chooses quantities of ramen packs and fries packs to minimize the total sodium intake, which is the sum of SodiumPerRamenPack multiplied by the number of ramen packs and SodiumPerFriesPack multiplied by the number of fries packs. He must ensure that the total calories from ramen and fries are at least MinCalories, the total protein is at least MinProtein, and the number of ramen packs does not exceed MaxRamenMealRatio proportion of the total meals. All quantities of ramen and fries packs must be non-negative."", ""keywords"": [""N.A.""], ""parameters"": {""CaloriesPerRamenPack"": {""description"": ""Calories per pack of ramen"", ""shape"": []}, ""ProteinPerRamenPack"": {""description"": ""Protein per pack of ramen"", ""shape"": []}, ""SodiumPerRamenPack"": {""description"": ""Sodium per pack of ramen"", ""shape"": []}, ""CaloriesPerFriesPack"": {""description"": ""Calories per pack of fries"", ""shape"": []}, ""ProteinPerFriesPack"": {""description"": ""Protein per pack of fries"", ""shape"": []}, ""SodiumPerFriesPack"": {""description"": ""Sodium per pack of fries"", ""shape"": []}, ""MaxRamenMealRatio"": {""description"": ""Maximum proportion of meals that can be ramen"", ""shape"": []}, ""MinCalories"": {""description"": ""Minimum calories required"", ""shape"": []}, ""MinProtein"": {""description"": ""Minimum protein required"", ""shape"": []}}, ""variables"": {""NumRamenPacks"": {""description"": ""The number of ramen packs"", ""type"": ""continuous"", ""shape"": []}, ""NumFriesPacks"": {""description"": ""The number of fries packs"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total calories from ramen and fries must be at least MinCalories."", ""formulation"": ""CaloriesPerRamenPack \\cdot NumRamenPacks + CaloriesPerFriesPack \\cdot NumFriesPacks \\geq MinCalories"", ""code"": {""gurobipy"": ""model.addConstr(CaloriesPerRamenPack * NumRamenPacks + CaloriesPerFriesPack * NumFriesPacks >= MinCalories)""}}, {""description"": ""The total protein from ramen and fries must be at least MinProtein."", ""formulation"": ""ProteinPerRamenPack \\cdot NumRamenPacks + ProteinPerFriesPack \\cdot NumFriesPacks \\geq MinProtein"", ""code"": {""gurobipy"": ""model.addConstr(ProteinPerRamenPack * NumRamenPacks + ProteinPerFriesPack * NumFriesPacks >= MinProtein)""}}, {""description"": ""The number of ramen packs does not exceed MaxRamenMealRatio proportion of the total meals."", ""formulation"": ""NumRamenPacks \\leq MaxRamenMealRatio \\cdot (NumRamenPacks + NumFriesPacks)"", ""code"": {""gurobipy"": ""model.addConstr(NumRamenPacks <= MaxRamenMealRatio * (NumRamenPacks + NumFriesPacks))""}}, {""description"": ""Quantities of ramen and fries packs must be non-negative."", ""formulation"": ""NumRamenPacks \\geq 0 \\n NumFriesPacks \\geq 0"", ""code"": {""gurobipy"": ""model.addConstr(NumRamenPacks >= 0)\nmodel.addConstr(NumFriesPacks >= 0)""}}], ""objective"": {""description"": ""Minimize the total sodium intake, which is the sum of SodiumPerRamenPack multiplied by the number of ramen packs and SodiumPerFriesPack multiplied by the number of fries packs."", ""formulation"": ""Min \\ SodiumPerRamenPack \\times NumRamenPacks + SodiumPerFriesPack \\times NumFriesPacks"", ""code"": {""gurobipy"": ""model.setObjective(SodiumPerRamenPack * NumRamenPacks + SodiumPerFriesPack * NumFriesPacks, GRB.MINIMIZE)""}}}","{""CaloriesPerRamenPack"": 400, ""ProteinPerRamenPack"": 20, ""SodiumPerRamenPack"": 100, ""CaloriesPerFriesPack"": 300, ""ProteinPerFriesPack"": 10, ""SodiumPerFriesPack"": 75, ""MaxRamenMealRatio"": 0.3, ""MinCalories"": 3000, ""MinProtein"": 80}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A salesman chooses quantities of ramen packs and fries packs to minimize the
total sodium intake, which is the sum of SodiumPerRamenPack multiplied by the
number of ramen packs and SodiumPerFriesPack multiplied by the number of fries
packs. He must ensure that the total calories from ramen and fries are at least
MinCalories, the total protein is at least MinProtein, and the number of ramen
packs does not exceed MaxRamenMealRatio proportion of the total meals. All
quantities of ramen and fries packs must be non-negative.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/111/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CaloriesPerRamenPack @Def: Calories per pack of ramen @Shape: [] 
CaloriesPerRamenPack = data['CaloriesPerRamenPack']
# @Parameter ProteinPerRamenPack @Def: Protein per pack of ramen @Shape: [] 
ProteinPerRamenPack = data['ProteinPerRamenPack']
# @Parameter SodiumPerRamenPack @Def: Sodium per pack of ramen @Shape: [] 
SodiumPerRamenPack = data['SodiumPerRamenPack']
# @Parameter CaloriesPerFriesPack @Def: Calories per pack of fries @Shape: [] 
CaloriesPerFriesPack = data['CaloriesPerFriesPack']
# @Parameter ProteinPerFriesPack @Def: Protein per pack of fries @Shape: [] 
ProteinPerFriesPack = data['ProteinPerFriesPack']
# @Parameter SodiumPerFriesPack @Def: Sodium per pack of fries @Shape: [] 
SodiumPerFriesPack = data['SodiumPerFriesPack']
# @Parameter MaxRamenMealRatio @Def: Maximum proportion of meals that can be ramen @Shape: [] 
MaxRamenMealRatio = data['MaxRamenMealRatio']
# @Parameter MinCalories @Def: Minimum calories required @Shape: [] 
MinCalories = data['MinCalories']
# @Parameter MinProtein @Def: Minimum protein required @Shape: [] 
MinProtein = data['MinProtein']

# Variables 
# @Variable NumRamenPacks @Def: The number of ramen packs @Shape: [] 
NumRamenPacks = model.addVar(vtype=GRB.INTEGER, name=""NumRamenPacks"")
# @Variable NumFriesPacks @Def: The number of fries packs @Shape: [] 
NumFriesPacks = model.addVar(vtype=GRB.INTEGER, name=""NumFriesPacks"")

# Constraints 
# @Constraint Constr_1 @Def: The total calories from ramen and fries must be at least MinCalories.
model.addConstr(CaloriesPerRamenPack * NumRamenPacks + CaloriesPerFriesPack * NumFriesPacks >= MinCalories)
# @Constraint Constr_2 @Def: The total protein from ramen and fries must be at least MinProtein.
model.addConstr(ProteinPerRamenPack * NumRamenPacks + ProteinPerFriesPack * NumFriesPacks >= MinProtein)
# @Constraint Constr_3 @Def: The number of ramen packs does not exceed MaxRamenMealRatio proportion of the total meals.
model.addConstr(NumRamenPacks <= MaxRamenMealRatio * (NumRamenPacks + NumFriesPacks))
# @Constraint Constr_4 @Def: Quantities of ramen and fries packs must be non-negative.
model.addConstr(NumRamenPacks >= 0)
model.addConstr(NumFriesPacks >= 0)

# Objective 
# @Objective Objective @Def: Minimize the total sodium intake, which is the sum of SodiumPerRamenPack multiplied by the number of ramen packs and SodiumPerFriesPack multiplied by the number of fries packs.
model.setObjective(SodiumPerRamenPack * NumRamenPacks + SodiumPerFriesPack * NumFriesPacks, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumRamenPacks'] = NumRamenPacks.x
variables['NumFriesPacks'] = NumFriesPacks.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A science store makes two boxes, a cheap and expensive box. The cheap box contains 3 units of metal and 5 units of acid which can be mixed to create 8 units of foam. The expensive box contains 5 units of metal and 8 units of acid which can be mixed to create 10 units of foam. The cheap box however gives off 2 units of heat while the expensive box gives off 3 units of heat. The science store has available 200 units of metal and 300 units of acid. If at most 50 units of heat can be given off, how many of each box should the store make to maximize the amount of foam produced?","{""variables"": {""BoxesProduced"": [25.0, 0.0]}, ""objective"": 200.0}","{""parametrized_description"": ""A science store produces NumBoxTypes different box types. Each box type requires MetalPerBoxType units of metal and AcidPerBoxType units of acid to produce. Each box type generates FoamPerBoxType units of foam and emits HeatPerBoxType units of heat. The store has MetalAvailable units of metal and AcidAvailable units of acid available. The total heat emitted by all produced boxes must not exceed MaxHeat units. The objective is to determine the number of each box type to produce in order to maximize the total amount of foam produced."", ""keywords"": [""N.A.""], ""parameters"": {""MetalAvailable"": {""description"": ""Total units of metal available"", ""shape"": []}, ""AcidAvailable"": {""description"": ""Total units of acid available"", ""shape"": []}, ""MaxHeat"": {""description"": ""Maximum units of heat that can be given off"", ""shape"": []}, ""NumBoxTypes"": {""description"": ""Number of different box types"", ""shape"": []}, ""MetalPerBoxType"": {""description"": ""Units of metal required per box type"", ""shape"": [""NumBoxTypes""]}, ""AcidPerBoxType"": {""description"": ""Units of acid required per box type"", ""shape"": [""NumBoxTypes""]}, ""FoamPerBoxType"": {""description"": ""Units of foam produced per box type"", ""shape"": [""NumBoxTypes""]}, ""HeatPerBoxType"": {""description"": ""Units of heat given off per box type"", ""shape"": [""NumBoxTypes""]}}, ""variables"": {""BoxesProduced"": {""description"": ""The number of boxes produced for each box type"", ""type"": ""continuous"", ""shape"": [""NumBoxTypes""]}}, ""constraints"": [{""description"": ""The total metal used for production cannot exceed MetalAvailable units."", ""formulation"": ""\\sum_{i=1}^{NumBoxTypes} MetalPerBoxType_i \\times BoxesProduced_i \\leq MetalAvailable"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(MetalPerBoxType[i] * BoxesProduced[i] for i in range(NumBoxTypes)) <= MetalAvailable)""}}, {""description"": ""The total acid used for production cannot exceed AcidAvailable units."", ""formulation"": ""\\sum_{i=1}^{NumBoxTypes} AcidPerBoxType_i \\times BoxesProduced_i \\leq AcidAvailable"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(AcidPerBoxType[i] * BoxesProduced[i] for i in range(NumBoxTypes)) <= AcidAvailable)""}}, {""description"": ""The total heat emitted by all produced boxes must not exceed MaxHeat units."", ""formulation"": ""\\sum_{i=1}^{\\text{NumBoxTypes}} \\text{HeatPerBoxType}_i \\times \\text{BoxesProduced}_i \\leq \\text{MaxHeat}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(HeatPerBoxType[i] * BoxesProduced[i] for i in range(NumBoxTypes)) <= MaxHeat)""}}], ""objective"": {""description"": ""Maximize the total foam produced, which is the sum of FoamPerBoxType units multiplied by the number of each box type produced."", ""formulation"": ""Max \\sum_{i=1}^{\\text{NumBoxTypes}} \\text{FoamPerBoxType}_i \\times \\text{BoxesProduced}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(FoamPerBoxType[i] * BoxesProduced[i] for i in range(NumBoxTypes)), GRB.MAXIMIZE)""}}}","{""MetalAvailable"": 200, ""AcidAvailable"": 300, ""MaxHeat"": 50, ""NumBoxTypes"": 2, ""MetalPerBoxType"": [3, 5], ""AcidPerBoxType"": [5, 8], ""FoamPerBoxType"": [8, 10], ""HeatPerBoxType"": [2, 3]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A science store produces NumBoxTypes different box types. Each box type requires
MetalPerBoxType units of metal and AcidPerBoxType units of acid to produce. Each
box type generates FoamPerBoxType units of foam and emits HeatPerBoxType units of heat. The store has MetalAvailable units of metal and AcidAvailable units of 
acid available. The total heat emitted by all produced boxes must not exceed
MaxHeat units. The objective is to determine the number of each box type to
produce in order to maximize the total amount of foam produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/112/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter MetalAvailable @Def: Total units of metal available @Shape: [] 
MetalAvailable = data['MetalAvailable']
# @Parameter AcidAvailable @Def: Total units of acid available @Shape: [] 
AcidAvailable = data['AcidAvailable']
# @Parameter MaxHeat @Def: Maximum units of heat that can be given off @Shape: [] 
MaxHeat = data['MaxHeat']
# @Parameter NumBoxTypes @Def: Number of different box types @Shape: [] 
NumBoxTypes = data['NumBoxTypes']
# @Parameter MetalPerBoxType @Def: Units of metal required per box type @Shape: ['NumBoxTypes'] 
MetalPerBoxType = data['MetalPerBoxType']
# @Parameter AcidPerBoxType @Def: Units of acid required per box type @Shape: ['NumBoxTypes'] 
AcidPerBoxType = data['AcidPerBoxType']
# @Parameter FoamPerBoxType @Def: Units of foam produced per box type @Shape: ['NumBoxTypes'] 
FoamPerBoxType = data['FoamPerBoxType']
# @Parameter HeatPerBoxType @Def: Units of heat given off per box type @Shape: ['NumBoxTypes'] 
HeatPerBoxType = data['HeatPerBoxType']
    
# Variables 
# @Variable BoxesProduced @Def: The number of boxes produced for each box type @Shape: ['NumBoxTypes'] 
BoxesProduced = model.addVars(NumBoxTypes, vtype=GRB.CONTINUOUS, name=""BoxesProduced"")
    
# Constraints 
# @Constraint Constr_1 @Def: The total metal used for production cannot exceed MetalAvailable units.
model.addConstr(quicksum(MetalPerBoxType[i] * BoxesProduced[i] for i in range(NumBoxTypes)) <= MetalAvailable)
# @Constraint Constr_2 @Def: The total acid used for production cannot exceed AcidAvailable units.
model.addConstr(quicksum(AcidPerBoxType[i] * BoxesProduced[i] for i in range(NumBoxTypes)) <= AcidAvailable)
# @Constraint Constr_3 @Def: The total heat emitted by all produced boxes must not exceed MaxHeat units.
model.addConstr(quicksum(HeatPerBoxType[i] * BoxesProduced[i] for i in range(NumBoxTypes)) <= MaxHeat)
    
# Objective 
# @Objective Objective @Def: Maximize the total foam produced, which is the sum of FoamPerBoxType units multiplied by the number of each box type produced.
model.setObjective(quicksum(FoamPerBoxType[i] * BoxesProduced[i] for i in range(NumBoxTypes)), GRB.MAXIMIZE)
    
# Solve 
model.optimize()
    
# Extract solution 
solution = {}
variables = {}
objective = []
variables['BoxesProduced'] = [BoxesProduced[i].x for i in range(NumBoxTypes)]
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A pharmacy has 3000 mg of morphine to make painkillers and sleeping pills. Each painkiller pill requires 10 mg of morphine and 3 units of digestive medicine. Each sleeping pill requires 6 mg of morphine and 5 units of digestive medicine. The pharmacy needs to make at least 50 painkiller pills. Since sleeping pills are more popular, at least 70% of the pills should be sleeping pills. How many of each should the pharmacy make to minimize the total amount of digestive medicine needed?","{""variables"": {""PainkillerPills"": 50.0, ""SleepingPills"": 116.66666666666663}, ""objective"": 733.3333333333331}","{""parametrized_description"": ""A pharmacy has TotalMorphine amount of morphine to produce painkiller and sleeping pills. Each painkiller pill requires MorphinePerPainkiller of morphine and DigestiveMedicinePerPainkiller units of digestive medicine. Each sleeping pill requires MorphinePerSleepingPill of morphine and DigestiveMedicinePerSleepingPill units of digestive medicine. The pharmacy must produce at least MinPainkillerPills painkiller pills. Additionally, at least MinSleepingPillsProportion proportion of the total pills produced should be sleeping pills. The objective is to determine the number of each type of pill to produce in order to minimize the total amount of digestive medicine used."", ""keywords"": [""N.A.""], ""parameters"": {""TotalMorphine"": {""description"": ""Total amount of morphine available"", ""shape"": []}, ""MorphinePerPainkiller"": {""description"": ""Amount of morphine required for one painkiller pill"", ""shape"": []}, ""MorphinePerSleepingPill"": {""description"": ""Amount of morphine required for one sleeping pill"", ""shape"": []}, ""DigestiveMedicinePerPainkiller"": {""description"": ""Amount of digestive medicine required for one painkiller pill"", ""shape"": []}, ""DigestiveMedicinePerSleepingPill"": {""description"": ""Amount of digestive medicine required for one sleeping pill"", ""shape"": []}, ""MinPainkillerPills"": {""description"": ""Minimum number of painkiller pills to be produced"", ""shape"": []}, ""MinSleepingPillsProportion"": {""description"": ""Minimum proportion of pills that should be sleeping pills"", ""shape"": []}}, ""variables"": {""PainkillerPills"": {""description"": ""The number of painkiller pills to be produced"", ""type"": ""continuous"", ""shape"": []}, ""SleepingPills"": {""description"": ""The number of sleeping pills to be produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total amount of morphine used for producing painkiller and sleeping pills does not exceed TotalMorphine."", ""formulation"": ""MorphinePerPainkiller \\cdot PainkillerPills + MorphinePerSleepingPill \\cdot SleepingPills \\leq TotalMorphine"", ""code"": {""gurobipy"": ""model.addConstr(MorphinePerPainkiller * PainkillerPills + MorphinePerSleepingPill * SleepingPills <= TotalMorphine)""}}, {""description"": ""At least MinPainkillerPills painkiller pills must be produced."", ""formulation"": ""PainkillerPills \\geq MinPainkillerPills"", ""code"": {""gurobipy"": ""model.addConstr(PainkillerPills >= MinPainkillerPills)""}}, {""description"": ""At least MinSleepingPillsProportion proportion of the total pills produced must be sleeping pills."", ""formulation"": ""SleepingPills \\geq MinSleepingPillsProportion \\times (PainkillerPills + SleepingPills)"", ""code"": {""gurobipy"": ""model.addConstr(SleepingPills >= MinSleepingPillsProportion * (PainkillerPills + SleepingPills))""}}], ""objective"": {""description"": ""The total amount of digestive medicine used is the sum of DigestiveMedicinePerPainkiller times the number of painkiller pills and DigestiveMedicinePerSleepingPill times the number of sleeping pills. The objective is to minimize the total amount of digestive medicine used."", ""formulation"": ""Min \\ DigestiveMedicinePerPainkiller \\times PainkillerPills + DigestiveMedicinePerSleepingPill \\times SleepingPills"", ""code"": {""gurobipy"": ""model.setObjective(DigestiveMedicinePerPainkiller * PainkillerPills + DigestiveMedicinePerSleepingPill * SleepingPills, GRB.MINIMIZE)""}}}","{""TotalMorphine"": 3000, ""MorphinePerPainkiller"": 10, ""MorphinePerSleepingPill"": 6, ""DigestiveMedicinePerPainkiller"": 3, ""DigestiveMedicinePerSleepingPill"": 5, ""MinPainkillerPills"": 50, ""MinSleepingPillsProportion"": 0.7}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A pharmacy has TotalMorphine amount of morphine to produce painkiller and
sleeping pills. Each painkiller pill requires MorphinePerPainkiller of morphine
and DigestiveMedicinePerPainkiller units of digestive medicine. Each sleeping
pill requires MorphinePerSleepingPill of morphine and
DigestiveMedicinePerSleepingPill units of digestive medicine. The pharmacy must
produce at least MinPainkillerPills painkiller pills. Additionally, at least
MinSleepingPillsProportion proportion of the total pills produced should be
sleeping pills. The objective is to determine the number of each type of pill to
produce in order to minimize the total amount of digestive medicine used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/113/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalMorphine @Def: Total amount of morphine available @Shape: [] 
TotalMorphine = data['TotalMorphine']
# @Parameter MorphinePerPainkiller @Def: Amount of morphine required for one painkiller pill @Shape: [] 
MorphinePerPainkiller = data['MorphinePerPainkiller']
# @Parameter MorphinePerSleepingPill @Def: Amount of morphine required for one sleeping pill @Shape: [] 
MorphinePerSleepingPill = data['MorphinePerSleepingPill']
# @Parameter DigestiveMedicinePerPainkiller @Def: Amount of digestive medicine required for one painkiller pill @Shape: [] 
DigestiveMedicinePerPainkiller = data['DigestiveMedicinePerPainkiller']
# @Parameter DigestiveMedicinePerSleepingPill @Def: Amount of digestive medicine required for one sleeping pill @Shape: [] 
DigestiveMedicinePerSleepingPill = data['DigestiveMedicinePerSleepingPill']
# @Parameter MinPainkillerPills @Def: Minimum number of painkiller pills to be produced @Shape: [] 
MinPainkillerPills = data['MinPainkillerPills']
# @Parameter MinSleepingPillsProportion @Def: Minimum proportion of pills that should be sleeping pills @Shape: [] 
MinSleepingPillsProportion = data['MinSleepingPillsProportion']

# Variables 
# @Variable PainkillerPills @Def: The number of painkiller pills to be produced @Shape: [] 
PainkillerPills = model.addVar(vtype=GRB.INTEGER, lb=MinPainkillerPills, name=""PainkillerPills"")
# @Variable SleepingPills @Def: The number of sleeping pills to be produced @Shape: [] 
SleepingPills = model.addVar(vtype=GRB.CONTINUOUS, name=""SleepingPills"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of morphine used for producing painkiller and sleeping pills does not exceed TotalMorphine.
model.addConstr(MorphinePerPainkiller * PainkillerPills + MorphinePerSleepingPill * SleepingPills <= TotalMorphine)
# @Constraint Constr_2 @Def: At least MinPainkillerPills painkiller pills must be produced.
model.addConstr(PainkillerPills >= MinPainkillerPills)
# @Constraint Constr_3 @Def: At least MinSleepingPillsProportion proportion of the total pills produced must be sleeping pills.
model.addConstr(SleepingPills >= MinSleepingPillsProportion * (PainkillerPills + SleepingPills))

# Objective 
# @Objective Objective @Def: The total amount of digestive medicine used is the sum of DigestiveMedicinePerPainkiller times the number of painkiller pills and DigestiveMedicinePerSleepingPill times the number of sleeping pills. The objective is to minimize the total amount of digestive medicine used.
model.setObjective(DigestiveMedicinePerPainkiller * PainkillerPills + DigestiveMedicinePerSleepingPill * SleepingPills, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['PainkillerPills'] = PainkillerPills.x
variables['SleepingPills'] = SleepingPills.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A boy needs to get enough magnesium and zinc in his diet by eating chewable gummies and taking pills. Each gummy contains 3 units of magnesium and 4 units of zinc. Each pill contains 2 units of magnesium and 5 units of zinc. The boy must take at least 10 pills. Since he prefers gummies more, he must eat at least 3 times the amount of gummies as pills. If the boy can consume at most 200 units of magnesium, how many of each should he eat to maximize his zinc intake?","{""variables"": {""NumberOfGummies"": 54.54545454545455, ""NumberOfPills"": 18.181818181818187}, ""objective"": 309.0909090909091}","{""parametrized_description"": ""A subject must determine the number of gummies and the number of pills to consume in order to maximize the total zinc intake, which is calculated as UnitsZincPerGummy multiplied by the number of gummies plus UnitsZincPerPill multiplied by the number of pills. The consumption must satisfy the following constraints: the total magnesium intake, calculated as UnitsMagnesiumPerGummy multiplied by the number of gummies plus UnitsMagnesiumPerPill multiplied by the number of pills, does not exceed MaximumUnitsOfMagnesium; the number of pills is at least MinimumNumberOfPills; and the number of gummies is at least MinimumGummiesToPillsRatio times the number of pills."", ""keywords"": [""N.A.""], ""parameters"": {""UnitsMagnesiumPerGummy"": {""description"": ""Units of magnesium per gummy"", ""shape"": []}, ""UnitsZincPerGummy"": {""description"": ""Units of zinc per gummy"", ""shape"": []}, ""UnitsMagnesiumPerPill"": {""description"": ""Units of magnesium per pill"", ""shape"": []}, ""UnitsZincPerPill"": {""description"": ""Units of zinc per pill"", ""shape"": []}, ""MinimumNumberOfPills"": {""description"": ""Minimum number of pills"", ""shape"": []}, ""MinimumGummiesToPillsRatio"": {""description"": ""Minimum gummies to pills ratio"", ""shape"": []}, ""MaximumUnitsOfMagnesium"": {""description"": ""Maximum units of magnesium consumption"", ""shape"": []}}, ""variables"": {""NumberOfGummies"": {""description"": ""The number of gummies"", ""type"": ""continuous"", ""shape"": [""Continuous""]}, ""NumberOfPills"": {""description"": ""The number of pills"", ""type"": ""continuous"", ""shape"": [""Continuous""]}}, ""constraints"": [{""description"": ""The total magnesium intake, calculated as UnitsMagnesiumPerGummy multiplied by the number of gummies plus UnitsMagnesiumPerPill multiplied by the number of pills, does not exceed MaximumUnitsOfMagnesium."", ""formulation"": ""UnitsMagnesiumPerGummy \\cdot NumberOfGummies + UnitsMagnesiumPerPill \\cdot NumberOfPills \\leq MaximumUnitsOfMagnesium"", ""code"": {""gurobipy"": ""model.addConstr(UnitsMagnesiumPerGummy * NumberOfGummies + UnitsMagnesiumPerPill * NumberOfPills <= MaximumUnitsOfMagnesium)""}}, {""description"": ""The number of pills is at least MinimumNumberOfPills."", ""formulation"": ""NumberOfPills \\geq MinimumNumberOfPills"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfPills >= MinimumNumberOfPills)""}}, {""description"": ""The number of gummies is at least MinimumGummiesToPillsRatio times the number of pills."", ""formulation"": ""NumberOfGummies \\geq MinimumGummiesToPillsRatio \\times NumberOfPills"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfGummies >= MinimumGummiesToPillsRatio * NumberOfPills)""}}], ""objective"": {""description"": ""The total zinc intake is the sum of UnitsZincPerGummy multiplied by the number of gummies plus UnitsZincPerPill multiplied by the number of pills. The objective is to maximize the total zinc intake."", ""formulation"": ""Max \\ UnitsZincPerGummy \\cdot NumberOfGummies + UnitsZincPerPill \\cdot NumberOfPills"", ""code"": {""gurobipy"": ""model.setObjective(UnitsZincPerGummy * NumberOfGummies + UnitsZincPerPill * NumberOfPills, GRB.MAXIMIZE)""}}}","{""UnitsMagnesiumPerGummy"": 3, ""UnitsZincPerGummy"": 4, ""UnitsMagnesiumPerPill"": 2, ""UnitsZincPerPill"": 5, ""MinimumNumberOfPills"": 10, ""MinimumGummiesToPillsRatio"": 3, ""MaximumUnitsOfMagnesium"": 200}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A subject must determine the number of gummies and the number of pills to
consume in order to maximize the total zinc intake, which is calculated as
UnitsZincPerGummy multiplied by the number of gummies plus UnitsZincPerPill
multiplied by the number of pills. The consumption must satisfy the following
constraints: the total magnesium intake, calculated as UnitsMagnesiumPerGummy
multiplied by the number of gummies plus UnitsMagnesiumPerPill multiplied by the
number of pills, does not exceed MaximumUnitsOfMagnesium; the number of pills is
at least MinimumNumberOfPills; and the number of gummies is at least
MinimumGummiesToPillsRatio times the number of pills.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/114/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter UnitsMagnesiumPerGummy @Def: Units of magnesium per gummy @Shape: [] 
UnitsMagnesiumPerGummy = data['UnitsMagnesiumPerGummy']
# @Parameter UnitsZincPerGummy @Def: Units of zinc per gummy @Shape: [] 
UnitsZincPerGummy = data['UnitsZincPerGummy']
# @Parameter UnitsMagnesiumPerPill @Def: Units of magnesium per pill @Shape: [] 
UnitsMagnesiumPerPill = data['UnitsMagnesiumPerPill']
# @Parameter UnitsZincPerPill @Def: Units of zinc per pill @Shape: [] 
UnitsZincPerPill = data['UnitsZincPerPill']
# @Parameter MinimumNumberOfPills @Def: Minimum number of pills @Shape: [] 
MinimumNumberOfPills = data['MinimumNumberOfPills']
# @Parameter MinimumGummiesToPillsRatio @Def: Minimum gummies to pills ratio @Shape: [] 
MinimumGummiesToPillsRatio = data['MinimumGummiesToPillsRatio']
# @Parameter MaximumUnitsOfMagnesium @Def: Maximum units of magnesium consumption @Shape: [] 
MaximumUnitsOfMagnesium = data['MaximumUnitsOfMagnesium']

# Variables 
# @Variable NumberOfGummies @Def: The number of gummies @Shape: ['Continuous'] 
NumberOfGummies = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfGummies"")
# @Variable NumberOfPills @Def: The number of pills @Shape: ['Continuous'] 
NumberOfPills = model.addVar(lb=MinimumNumberOfPills, vtype=GRB.CONTINUOUS, name=""NumberOfPills"")

# Constraints 
# @Constraint Constr_1 @Def: The total magnesium intake, calculated as UnitsMagnesiumPerGummy multiplied by the number of gummies plus UnitsMagnesiumPerPill multiplied by the number of pills, does not exceed MaximumUnitsOfMagnesium.
model.addConstr(UnitsMagnesiumPerGummy * NumberOfGummies + UnitsMagnesiumPerPill * NumberOfPills <= MaximumUnitsOfMagnesium)
# @Constraint Constr_2 @Def: The number of pills is at least MinimumNumberOfPills.
model.addConstr(NumberOfPills >= MinimumNumberOfPills)
# @Constraint Constr_3 @Def: The number of gummies is at least MinimumGummiesToPillsRatio times the number of pills.
model.addConstr(NumberOfGummies >= MinimumGummiesToPillsRatio * NumberOfPills)

# Objective 
# @Objective Objective @Def: The total zinc intake is the sum of UnitsZincPerGummy multiplied by the number of gummies plus UnitsZincPerPill multiplied by the number of pills. The objective is to maximize the total zinc intake.
model.setObjective(UnitsZincPerGummy * NumberOfGummies + UnitsZincPerPill * NumberOfPills, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfGummies'] = NumberOfGummies.x
variables['NumberOfPills'] = NumberOfPills.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A patient takes anxiety medication and anti-depressants one after the other. Each unit of anxiety medication takes 3 minutes to be effective while each unit of anti-depressant takes 5 minutes to be effective. The patient must take at least 100 units of medication and at least 30 should be anxiety medication. Since the anxiety medication is strong, the patient can take at most twice the amount of anxiety medication as anti-depressants. How many units of each should the patient take to minimize the total time it take for the medication to be effective?","{""variables"": {""AnxietyUnits"": 66.66666666666667, ""AntidepressantUnits"": 33.333333333333336}, ""objective"": 366.6666666666667}","{""parametrized_description"": ""A patient takes anxiety medication and anti-depressants sequentially. Each unit of anxiety medication takes TimePerAnxietyUnit time to be effective, while each unit of anti-depressant takes TimePerAntidepressantUnit time to be effective. The patient must take at least MinimumTotalUnits of medication, with at least MinimumAnxietyUnits being anxiety medication. Additionally, the amount of anxiety medication cannot exceed MaximumAnxietyToAntidepressantRatio times the amount of anti-depressants. The objective is to determine the number of units of each medication to minimize the total time until the medications become effective."", ""keywords"": [""N.A.""], ""parameters"": {""TimePerAnxietyUnit"": {""description"": ""Time it takes for one unit of anxiety medication to be effective"", ""shape"": []}, ""TimePerAntidepressantUnit"": {""description"": ""Time it takes for one unit of anti-depressant to be effective"", ""shape"": []}, ""MinimumTotalUnits"": {""description"": ""Minimum total units of medication the patient must take"", ""shape"": []}, ""MinimumAnxietyUnits"": {""description"": ""Minimum units of anxiety medication the patient must take"", ""shape"": []}, ""MaximumAnxietyToAntidepressantRatio"": {""description"": ""Maximum ratio of anxiety medication units to anti-depressant units"", ""shape"": []}}, ""variables"": {""AnxietyUnits"": {""description"": ""Units of anxiety medication the patient takes"", ""type"": ""continuous"", ""shape"": []}, ""AntidepressantUnits"": {""description"": ""Units of anti-depressant medication the patient takes"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The patient must take at least MinimumTotalUnits of medication."", ""formulation"": ""AnxietyUnits + AntidepressantUnits \\geq MinimumTotalUnits"", ""code"": {""gurobipy"": ""model.addConstr(AnxietyUnits + AntidepressantUnits >= MinimumTotalUnits)""}}, {""description"": ""At least MinimumAnxietyUnits must be anxiety medication."", ""formulation"": ""AnxietyUnits \\geq MinimumAnxietyUnits"", ""code"": {""gurobipy"": ""model.addConstr(AnxietyUnits >= MinimumAnxietyUnits)""}}, {""description"": ""The amount of anxiety medication cannot exceed MaximumAnxietyToAntidepressantRatio times the amount of anti-depressants."", ""formulation"": ""AnxietyUnits \\leq MaximumAnxietyToAntidepressantRatio \\times AntidepressantUnits"", ""code"": {""gurobipy"": ""model.addConstr(AnxietyUnits <= MaximumAnxietyToAntidepressantRatio * AntidepressantUnits)""}}], ""objective"": {""description"": ""Minimize the total time until the medications become effective, calculated as (Number of Anxiety Units \u00d7 TimePerAnxietyUnit) + (Number of Anti-depressant Units \u00d7 TimePerAntidepressantUnit)."", ""formulation"": ""Min \\left( AnxietyUnits \\times TimePerAnxietyUnit + AntidepressantUnits \\times TimePerAntidepressantUnit \\right )"", ""code"": {""gurobipy"": ""model.setObjective(AnxietyUnits * TimePerAnxietyUnit + AntidepressantUnits * TimePerAntidepressantUnit, GRB.MINIMIZE)""}}}","{""TimePerAnxietyUnit"": 3, ""TimePerAntidepressantUnit"": 5, ""MinimumTotalUnits"": 100, ""MinimumAnxietyUnits"": 30, ""MaximumAnxietyToAntidepressantRatio"": 2}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A patient takes anxiety medication and anti-depressants sequentially. Each unit
of anxiety medication takes TimePerAnxietyUnit time to be effective, while each
unit of anti-depressant takes TimePerAntidepressantUnit time to be effective.
The patient must take at least MinimumTotalUnits of medication, with at least
MinimumAnxietyUnits being anxiety medication. Additionally, the amount of
anxiety medication cannot exceed MaximumAnxietyToAntidepressantRatio times the
amount of anti-depressants. The objective is to determine the number of units of
each medication to minimize the total time until the medications become
effective.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/115/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TimePerAnxietyUnit @Def: Time it takes for one unit of anxiety medication to be effective @Shape: [] 
TimePerAnxietyUnit = data['TimePerAnxietyUnit']
# @Parameter TimePerAntidepressantUnit @Def: Time it takes for one unit of anti-depressant to be effective @Shape: [] 
TimePerAntidepressantUnit = data['TimePerAntidepressantUnit']
# @Parameter MinimumTotalUnits @Def: Minimum total units of medication the patient must take @Shape: [] 
MinimumTotalUnits = data['MinimumTotalUnits']
# @Parameter MinimumAnxietyUnits @Def: Minimum units of anxiety medication the patient must take @Shape: [] 
MinimumAnxietyUnits = data['MinimumAnxietyUnits']
# @Parameter MaximumAnxietyToAntidepressantRatio @Def: Maximum ratio of anxiety medication units to anti-depressant units @Shape: [] 
MaximumAnxietyToAntidepressantRatio = data['MaximumAnxietyToAntidepressantRatio']

# Variables 
# @Variable AnxietyUnits @Def: Units of anxiety medication the patient takes @Shape: [] 
AnxietyUnits = model.addVar(vtype=GRB.CONTINUOUS, lb=MinimumAnxietyUnits, name=""AnxietyUnits"")
# @Variable AntidepressantUnits @Def: Units of anti-depressant medication the patient takes @Shape: [] 
AntidepressantUnits = model.addVar(vtype=GRB.CONTINUOUS, name=""AntidepressantUnits"")

# Constraints 
# @Constraint Constr_1 @Def: The patient must take at least MinimumTotalUnits of medication.
model.addConstr(AnxietyUnits + AntidepressantUnits >= MinimumTotalUnits)
# @Constraint Constr_2 @Def: At least MinimumAnxietyUnits must be anxiety medication.
model.addConstr(AnxietyUnits >= MinimumAnxietyUnits)
# @Constraint Constr_3 @Def: The amount of anxiety medication cannot exceed MaximumAnxietyToAntidepressantRatio times the amount of anti-depressants.
model.addConstr(AnxietyUnits <= MaximumAnxietyToAntidepressantRatio * AntidepressantUnits)

# Objective 
# @Objective Objective @Def: Minimize the total time until the medications become effective, calculated as (Number of Anxiety Units × TimePerAnxietyUnit) + (Number of Anti-depressant Units × TimePerAntidepressantUnit).
model.setObjective(AnxietyUnits * TimePerAnxietyUnit + AntidepressantUnits * TimePerAntidepressantUnit, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['AnxietyUnits'] = AnxietyUnits.x
variables['AntidepressantUnits'] = AntidepressantUnits.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A pharmacy makes eye cream and foot cream using two different machines, machine 1 and machine 2. Machine 1 can  make 30 ml of eye cream and 60 ml of foot cream per hour. Machine 2 can make 45 ml of eye cream and 30 ml of foot cream per hour. Furthermore, machine 1 requires 20 ml of distilled water per hour while machine 2 requires 15 ml of distilled water per hour. The pharmacy has available 1200 ml of distilled water. If the pharmacy needs to make at least 1300 ml of eye cream and 1500 ml of foot cream, how many hours should each machine be used to minimize the total time needed?","{""variables"": {""OperatingTime"": {""0"": 15.833333333333334, ""1"": 18.333333333333332}}, ""objective"": 34.166666666666664}","{""parametrized_description"": ""A pharmacy produces NumProducts different products using NumMachines different machines. Each machine m can produce ProductionRate[m, p] amount of product p per hour. Additionally, machine m consumes WaterUsage[m] amount of distilled water per hour. The pharmacy has TotalWaterAvailable amount of distilled water available. The pharmacy needs to produce at least RequiredProduct[p] amount of each product p. The objective is to determine the number of hours each machine should be operated to minimize the total time required."", ""keywords"": [""N.A.""], ""parameters"": {""NumMachines"": {""description"": ""Number of machines"", ""shape"": []}, ""NumProducts"": {""description"": ""Number of products"", ""shape"": []}, ""ProductionRate"": {""description"": ""Amount of product p produced per hour by machine m"", ""shape"": [""NumMachines"", ""NumProducts""]}, ""WaterUsage"": {""description"": ""Amount of distilled water consumed per hour by machine m"", ""shape"": [""NumMachines""]}, ""TotalWaterAvailable"": {""description"": ""Total amount of distilled water available"", ""shape"": []}, ""RequiredProduct"": {""description"": ""Minimum required amount of product p"", ""shape"": [""NumProducts""]}}, ""variables"": {""OperatingTime"": {""description"": ""The operating time for machine m"", ""type"": ""continuous"", ""shape"": [""NumMachines""]}}, ""constraints"": [{""description"": ""The total distilled water consumed by all machines cannot exceed TotalWaterAvailable."", ""formulation"": ""\\sum_{m=1}^{\\text{NumMachines}} \\text{WaterUsage}_{m} \\cdot \\text{OperatingTime}_{m} \\leq \\text{TotalWaterAvailable}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(WaterUsage[m] * OperatingTime[m] for m in range(NumMachines)) <= TotalWaterAvailable)""}}, {""description"": ""For each product p, the total production must be at least RequiredProduct[p]."", ""formulation"": ""\\sum_{m=1}^{NumMachines} ProductionRate_{m,p} \\cdot OperatingTime_{m} \\geq RequiredProduct_{p} \\quad \\forall p"", ""code"": {""gurobipy"": ""for p in range(NumProducts):\n    model.addConstr(quicksum(ProductionRate[m][p] * OperatingTime[m] for m in range(NumMachines)) >= RequiredProduct[p], name=f\""ProdRequirement_{p}\"")""}}], ""objective"": {""description"": ""Minimize the total operating hours of all machines while meeting the minimum production requirements for each product and adhering to the total available distilled water."", ""formulation"": ""Min \\sum_{m=1}^{NumMachines} OperatingTime_{m}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(OperatingTime[m] for m in range(NumMachines)), GRB.MINIMIZE)""}}}","{""NumMachines"": 2, ""NumProducts"": 2, ""ProductionRate"": [[30, 60], [45, 30]], ""WaterUsage"": [20, 15], ""TotalWaterAvailable"": 1200, ""RequiredProduct"": [1300, 1500]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A pharmacy produces NumProducts different products using NumMachines different
machines. Each machine m can produce ProductionRate[m, p] amount of product p
per hour. Additionally, machine m consumes WaterUsage[m] amount of distilled
water per hour. The pharmacy has TotalWaterAvailable amount of distilled water
available. The pharmacy needs to produce at least RequiredProduct[p] amount of
each product p. The objective is to determine the number of hours each machine
should be operated to minimize the total time required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/116/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumMachines @Def: Number of machines @Shape: [] 
NumMachines = data['NumMachines']
# @Parameter NumProducts @Def: Number of products @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter ProductionRate @Def: Amount of product p produced per hour by machine m @Shape: ['NumMachines', 'NumProducts'] 
ProductionRate = data['ProductionRate']
# @Parameter WaterUsage @Def: Amount of distilled water consumed per hour by machine m @Shape: ['NumMachines'] 
WaterUsage = data['WaterUsage']
# @Parameter TotalWaterAvailable @Def: Total amount of distilled water available @Shape: [] 
TotalWaterAvailable = data['TotalWaterAvailable']
# @Parameter RequiredProduct @Def: Minimum required amount of product p @Shape: ['NumProducts'] 
RequiredProduct = data['RequiredProduct']

# Variables 
# @Variable OperatingTime @Def: The operating time for machine m @Shape: ['NumMachines'] 
OperatingTime = model.addVars(NumMachines, vtype=GRB.CONTINUOUS, name=""OperatingTime"")

# Constraints 
# @Constraint Constr_1 @Def: The total distilled water consumed by all machines cannot exceed TotalWaterAvailable.
model.addConstr(quicksum(WaterUsage[m] * OperatingTime[m] for m in range(NumMachines)) <= TotalWaterAvailable)
# @Constraint Constr_2 @Def: For each product p, the total production must be at least RequiredProduct[p].
for p in range(NumProducts):
    model.addConstr(quicksum(ProductionRate[m][p] * OperatingTime[m] for m in range(NumMachines)) >= RequiredProduct[p], name=f""ProdRequirement_{p}"")
    
# Objective 
# @Objective Objective @Def: Minimize the total operating hours of all machines while meeting the minimum production requirements for each product and adhering to the total available distilled water.
model.setObjective(quicksum(OperatingTime[m] for m in range(NumMachines)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['OperatingTime'] = {m: OperatingTime[m].x for m in range(NumMachines)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A woman eats cashews and almonds to get her calorie and protein intake. A serving of almonds contains 200 calories and 20 grams of protein. A serving of cashews contains 300 calories and 25 grams of protein. The woman decides to eat at least twice as many servings of almonds as cashews. Furthermore, a serving of almonds contains 15 grams of fat while a serving of cashews contains 12 grams of fat. If the woman needs to consume at least 10000 calories and 800 grams of protein this week, how many servings of each should she eat to minimize her fat intake?","{""variables"": {""NutServings"": {""0"": 28.571428571428573, ""1"": 14.285714285714286}}, ""objective"": 600.0}","{""parametrized_description"": ""A woman consumes servings of NumNutTypes different types of nuts to satisfy at least CalorieRequirement calories and ProteinRequirement grams of protein per week. Each nut type has specific CaloriePerServing, ProteinPerServing, and FatPerServing per serving. She must consume at least ServingRatioMultiplier times as many servings of one nut type as another. The objective is to minimize her total fat intake."", ""keywords"": [""N.A.""], ""parameters"": {""NumNutTypes"": {""description"": ""Number of different nut types"", ""shape"": []}, ""CaloriePerServing"": {""description"": ""Calories in one serving of each nut type"", ""shape"": [""NumNutTypes""]}, ""ProteinPerServing"": {""description"": ""Protein in one serving of each nut type"", ""shape"": [""NumNutTypes""]}, ""FatPerServing"": {""description"": ""Fat in one serving of each nut type"", ""shape"": [""NumNutTypes""]}, ""ServingRatioMultiplier"": {""description"": ""Minimum ratio of servings of almonds to cashews"", ""shape"": []}, ""CalorieRequirement"": {""description"": ""Total calorie intake requirement"", ""shape"": []}, ""ProteinRequirement"": {""description"": ""Total protein intake requirement"", ""shape"": []}}, ""variables"": {""NutServings"": {""description"": ""The number of servings for each nut type"", ""type"": ""continuous"", ""shape"": [""NumNutTypes""]}}, ""constraints"": [{""description"": ""The total calorie intake from all nut servings must be at least CalorieRequirement."", ""formulation"": ""\\sum_{i=1}^{\\text{NumNutTypes}} \\text{CaloriePerServing}_i \\cdot \\text{NutServings}_i \\geq \\text{CalorieRequirement}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(CaloriePerServing[i] * NutServings[i] for i in range(NumNutTypes)) >= CalorieRequirement)""}}, {""description"": ""The total protein intake from all nut servings must be at least ProteinRequirement."", ""formulation"": ""\\sum_{i=1}^{NumNutTypes} ProteinPerServing_i \\cdot NutServings_i \\geq ProteinRequirement"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ProteinPerServing[i] * NutServings[i] for i in range(NumNutTypes)) >= ProteinRequirement)""}}, {""description"": ""She must consume at least ServingRatioMultiplier times as many servings of almonds as cashews."", ""formulation"": ""NutServings_{Almonds} \\geq ServingRatioMultiplier \\times NutServings_{Cashews}"", ""code"": {""gurobipy"": ""model.addConstr(NutServings[0] >= ServingRatioMultiplier * NutServings[1])""}}], ""objective"": {""description"": ""Total fat intake is the sum of the fat from all consumed nut servings. The objective is to minimize the total fat intake."", ""formulation"": ""Min \\sum_{i=1}^{\\text{NumNutTypes}} \\text{NutServings}_i \\cdot \\text{FatPerServing}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(NutServings[i] * FatPerServing[i] for i in range(NumNutTypes)), GRB.MINIMIZE)""}}}","{""NumNutTypes"": 2, ""CaloriePerServing"": [200, 300], ""ProteinPerServing"": [20, 25], ""FatPerServing"": [15, 12], ""ServingRatioMultiplier"": 2, ""CalorieRequirement"": 10000, ""ProteinRequirement"": 800}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A woman consumes servings of NumNutTypes different types of nuts to satisfy at
least CalorieRequirement calories and ProteinRequirement grams of protein per
week. Each nut type has specific CaloriePerServing, ProteinPerServing, and
FatPerServing per serving. She must consume at least ServingRatioMultiplier
times as many servings of one nut type as another. The objective is to minimize
her total fat intake.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/117/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumNutTypes @Def: Number of different nut types @Shape: [] 
NumNutTypes = data['NumNutTypes']
# @Parameter CaloriePerServing @Def: Calories in one serving of each nut type @Shape: ['NumNutTypes'] 
CaloriePerServing = data['CaloriePerServing']
# @Parameter ProteinPerServing @Def: Protein in one serving of each nut type @Shape: ['NumNutTypes'] 
ProteinPerServing = data['ProteinPerServing']
# @Parameter FatPerServing @Def: Fat in one serving of each nut type @Shape: ['NumNutTypes'] 
FatPerServing = data['FatPerServing']
# @Parameter ServingRatioMultiplier @Def: Minimum ratio of servings of almonds to cashews @Shape: [] 
ServingRatioMultiplier = data['ServingRatioMultiplier']
# @Parameter CalorieRequirement @Def: Total calorie intake requirement @Shape: [] 
CalorieRequirement = data['CalorieRequirement']
# @Parameter ProteinRequirement @Def: Total protein intake requirement @Shape: [] 
ProteinRequirement = data['ProteinRequirement']
    
# Variables 
# @Variable NutServings @Def: The number of servings for each nut type @Shape: ['NumNutTypes'] 
NutServings = model.addVars(NumNutTypes, vtype=GRB.CONTINUOUS, name=""NutServings"")
    
# Constraints 
# @Constraint Constr_1 @Def: The total calorie intake from all nut servings must be at least CalorieRequirement.
model.addConstr(quicksum(CaloriePerServing[i] * NutServings[i] for i in range(NumNutTypes)) >= CalorieRequirement)
# @Constraint Constr_2 @Def: The total protein intake from all nut servings must be at least ProteinRequirement.
model.addConstr(quicksum(ProteinPerServing[i] * NutServings[i] for i in range(NumNutTypes)) >= ProteinRequirement)
# @Constraint Constr_3 @Def: She must consume at least ServingRatioMultiplier times as many servings of almonds as cashews.
model.addConstr(NutServings[0] >= ServingRatioMultiplier * NutServings[1])
    
# Objective 
# @Objective Objective @Def: Total fat intake is the sum of the fat from all consumed nut servings. The objective is to minimize the total fat intake.
model.setObjective(quicksum(NutServings[i] * FatPerServing[i] for i in range(NumNutTypes)), GRB.MINIMIZE)
    
# Solve 
model.optimize()
    
# Extract solution 
solution = {}
variables = {}
objective = []
variables['NutServings'] = {i: NutServings[i].x for i in range(NumNutTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A company make both liquid and foam hand sanitizer. Liquid hand sanitizer requires 40 units of water and 50 units of alcohol. Foam hand sanitizer requires 60 units of water and 40 units of alcohol. The company has available 2000 units of water and 2100 units of alcohol. The number of foam hand sanitizers made must exceed the number of liquid hand sanitizers. In addition, at most 30 liquid hand sanitizers can be made. If each liquid hand sanitizer can clean 30 hands and each foam hand sanitizer can clean 20 hands, how many of each should the company make to maximize the number of hands that can be cleaned?","{""variables"": {""Production"": [42.0, 0.0]}, ""objective"": 1260.0}","{""parametrized_description"": ""A company produces NumProducts different products using NumResources different resources. Each product requires specific amounts of resources as defined by ResourceRequired. The TotalAvailableResources limit the total usage of each resource. The production of one product must exceed the production of another product. Additionally, the production of a specific product is limited by MaxLiquidSanitizers. Each product can clean a certain number of hands as specified by CleaningPerUnit. The company aims to determine the number of each product to produce in order to maximize the total number of hands cleaned."", ""keywords"": [""N.A.""], ""parameters"": {""NumProducts"": {""description"": ""Number of different products"", ""shape"": []}, ""NumResources"": {""description"": ""Number of different resources"", ""shape"": []}, ""ResourceRequired"": {""description"": ""Amount of each resource required to produce one unit of each product"", ""shape"": [""NumResources"", ""NumProducts""]}, ""TotalAvailableResources"": {""description"": ""Total available units of each resource"", ""shape"": [""NumResources""]}, ""MaxLiquidSanitizers"": {""description"": ""Maximum number of liquid hand sanitizers that can be produced"", ""shape"": []}, ""CleaningPerUnit"": {""description"": ""Number of hands cleaned by each unit of each product"", ""shape"": [""NumProducts""]}}, ""variables"": {""Production"": {""description"": ""The number of units produced for each product"", ""type"": ""continuous"", ""shape"": [""NumProducts""]}}, ""constraints"": [{""description"": ""Each product requires specific amounts of resources, and the total usage of each resource cannot exceed the TotalAvailableResources."", ""formulation"": ""\\sum_{p=1}^{\\text{NumProducts}} \\text{ResourceRequired}_{r,p} \\cdot \\text{Production}_p \\leq \\text{TotalAvailableResources}_r \\quad \\forall r \\in \\{1, 2, \\dots, \\text{NumResources}\\}"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(ResourceRequired[r][p] * Production[p] for p in range(NumProducts)) <= TotalAvailableResources[r] for r in range(NumResources)), name=\""ResourceUsage\"")""}}, {""description"": ""The production of one product must exceed the production of another product."", ""formulation"": ""Production_{i} \\geq Production_{j}"", ""code"": {""gurobipy"": ""model.addConstr(Production[i] >= Production[j], \""Production_geq_{}_{}\"".format(i, j))""}}, {""description"": ""The production of a specific product cannot exceed MaxLiquidSanitizers."", ""formulation"": ""Production_j \\leq MaxLiquidSanitizers"", ""code"": {""gurobipy"": ""model.addConstr(Production[j] <= MaxLiquidSanitizers)""}}], ""objective"": {""description"": ""Maximize the total number of hands cleaned, calculated as the sum of the number of each product produced multiplied by CleaningPerUnit."", ""formulation"": ""Max \\sum_{p=1}^{NumProducts} Production_p \\times CleaningPerUnit_p"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(Production[p] * CleaningPerUnit[p] for p in range(NumProducts)), GRB.MAXIMIZE)""}}}","{""NumProducts"": 2, ""NumResources"": 2, ""ResourceRequired"": [[40, 60], [50, 40]], ""TotalAvailableResources"": [2000, 2100], ""MaxLiquidSanitizers"": 30, ""CleaningPerUnit"": [30, 20]}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company produces NumProducts different products using NumResources different
resources. Each product requires specific amounts of resources as defined by
ResourceRequired. The TotalAvailableResources limit the total usage of each
resource. The production of one product must exceed the production of another
product. Additionally, the production of a specific product is limited by
MaxLiquidSanitizers. Each product can clean a certain number of hands as
specified by CleaningPerUnit. The company aims to determine the number of each
product to produce in order to maximize the total number of hands cleaned.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/118/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumProducts @Def: Number of different products @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter NumResources @Def: Number of different resources @Shape: [] 
NumResources = data['NumResources']
# @Parameter ResourceRequired @Def: Amount of each resource required to produce one unit of each product @Shape: ['NumResources', 'NumProducts'] 
ResourceRequired = data['ResourceRequired']
# @Parameter TotalAvailableResources @Def: Total available units of each resource @Shape: ['NumResources'] 
TotalAvailableResources = data['TotalAvailableResources']
# @Parameter MaxLiquidSanitizers @Def: Maximum number of liquid hand sanitizers that can be produced @Shape: [] 
MaxLiquidSanitizers = data['MaxLiquidSanitizers']
# @Parameter CleaningPerUnit @Def: Number of hands cleaned by each unit of each product @Shape: ['NumProducts'] 
CleaningPerUnit = data['CleaningPerUnit']

# Variables 
# @Variable Production @Def: The number of units produced for each product @Shape: ['NumProducts'] 
Production = model.addVars(NumProducts, vtype=GRB.CONTINUOUS, name=""Production"")

# Constraints 
# @Constraint Constr_1 @Def: Each product requires specific amounts of resources, and the total usage of each resource cannot exceed the TotalAvailableResources.
model.addConstrs((quicksum(ResourceRequired[r][p] * Production[p] for p in range(NumProducts)) <= TotalAvailableResources[r] for r in range(NumResources)), name=""ResourceUsage"")

# Define indices for Constr_2 and Constr_3
i = 0  # Index of the first product
j = 1  # Index of the second product

# @Constraint Constr_2 @Def: The production of one product must exceed the production of another product.
model.addConstr(Production[i] >= Production[j], ""Production_geq_{}_{}"".format(i, j))
# @Constraint Constr_3 @Def: The production of a specific product cannot exceed MaxLiquidSanitizers.
model.addConstr(Production[j] <= MaxLiquidSanitizers, ""MaxLiquidSanitizers_constr"")

# Objective 
# @Objective Objective @Def: Maximize the total number of hands cleaned, calculated as the sum of the number of each product produced multiplied by CleaningPerUnit.
model.setObjective(quicksum(Production[p] * CleaningPerUnit[p] for p in range(NumProducts)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Production'] = [Production[p].x for p in range(NumProducts)]
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A clinic is conducting a throat or nasal swabs on each patient. A throat swab takes 5 minutes while a nasal swab takes 3 minutes. The clinic must administer at least 30 nasal swabs. Since the nasal swab is more uncomfortable, at least 4 times as many throat swabs must be done as nasal swabs. If the clinic is only operational for 20000 minutes, how many of each swab should be done to maximize the number of patients seen?","{""variables"": {""NumThroatSwab"": 3479.0, ""NumNasalSwab"": 868.0}, ""objective"": 4347.0}","{""parametrized_description"": ""The clinic must perform a number of throat swabs and nasal swabs. Each throat swab requires TimeThroatSwab minutes and each nasal swab requires TimeNasalSwab minutes. At least MinimumNasalSwabs nasal swabs must be administered. The number of throat swabs must be at least ThroatToNasalRatio times the number of nasal swabs. The clinic operates for a total of TotalOperationalTime minutes. The objective is to maximize the total number of patients seen."", ""keywords"": [""N.A.""], ""parameters"": {""TimeThroatSwab"": {""description"": ""Time required to perform one throat swab in minutes"", ""shape"": []}, ""TimeNasalSwab"": {""description"": ""Time required to perform one nasal swab in minutes"", ""shape"": []}, ""MinimumNasalSwabs"": {""description"": ""Minimum number of nasal swabs to be performed"", ""shape"": []}, ""ThroatToNasalRatio"": {""description"": ""Minimum ratio of throat swabs to nasal swabs"", ""shape"": []}, ""TotalOperationalTime"": {""description"": ""Total operational time available in minutes"", ""shape"": []}}, ""variables"": {""NumThroatSwab"": {""description"": ""The number of throat swabs to be performed"", ""type"": ""continuous"", ""shape"": []}, ""NumNasalSwab"": {""description"": ""The number of nasal swabs to be performed"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""Each throat swab requires TimeThroatSwab minutes and each nasal swab requires TimeNasalSwab minutes. The total operational time cannot exceed TotalOperationalTime minutes."", ""formulation"": ""TimeThroatSwab \\cdot NumThroatSwab + TimeNasalSwab \\cdot NumNasalSwab \\leq TotalOperationalTime"", ""code"": {""gurobipy"": ""model.addConstr(TimeThroatSwab * NumThroatSwab + TimeNasalSwab * NumNasalSwab <= TotalOperationalTime, 'OperationalTime')""}}, {""description"": ""At least MinimumNasalSwabs nasal swabs must be administered."", ""formulation"": ""NumNasalSwab \\geq MinimumNasalSwabs"", ""code"": {""gurobipy"": ""model.addConstr(NumNasalSwab >= MinimumNasalSwabs)""}}, {""description"": ""The number of throat swabs must be at least ThroatToNasalRatio times the number of nasal swabs."", ""formulation"": ""NumThroatSwab \\geq ThroatToNasalRatio \\times NumNasalSwab"", ""code"": {""gurobipy"": ""model.addConstr(NumThroatSwab >= ThroatToNasalRatio * NumNasalSwab)""}}], ""objective"": {""description"": ""The objective is to maximize the total number of patients seen."", ""formulation"": ""Max \\ NumThroatSwab + NumNasalSwab"", ""code"": {""gurobipy"": ""model.setObjective(NumThroatSwab + NumNasalSwab, GRB.MAXIMIZE)""}}}","{""TimeThroatSwab"": 5, ""TimeNasalSwab"": 3, ""MinimumNasalSwabs"": 30, ""ThroatToNasalRatio"": 4, ""TotalOperationalTime"": 20000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
The clinic must perform a number of throat swabs and nasal swabs. Each throat
swab requires TimeThroatSwab minutes and each nasal swab requires TimeNasalSwab
minutes. At least MinimumNasalSwabs nasal swabs must be administered. The number
of throat swabs must be at least ThroatToNasalRatio times the number of nasal
swabs. The clinic operates for a total of TotalOperationalTime minutes. The
objective is to maximize the total number of patients seen.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/119/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TimeThroatSwab @Def: Time required to perform one throat swab in minutes @Shape: [] 
TimeThroatSwab = data['TimeThroatSwab']
# @Parameter TimeNasalSwab @Def: Time required to perform one nasal swab in minutes @Shape: [] 
TimeNasalSwab = data['TimeNasalSwab']
# @Parameter MinimumNasalSwabs @Def: Minimum number of nasal swabs to be performed @Shape: [] 
MinimumNasalSwabs = data['MinimumNasalSwabs']
# @Parameter ThroatToNasalRatio @Def: Minimum ratio of throat swabs to nasal swabs @Shape: [] 
ThroatToNasalRatio = data['ThroatToNasalRatio']
# @Parameter TotalOperationalTime @Def: Total operational time available in minutes @Shape: [] 
TotalOperationalTime = data['TotalOperationalTime']

# Variables 
# @Variable NumThroatSwab @Def: The number of throat swabs to be performed @Shape: [] 
NumThroatSwab = model.addVar(vtype=GRB.INTEGER, name=""NumThroatSwab"")
# @Variable NumNasalSwab @Def: The number of nasal swabs to be performed @Shape: [] 
NumNasalSwab = model.addVar(lb=MinimumNasalSwabs, vtype=GRB.INTEGER, name='NumNasalSwab')

# Constraints 
# @Constraint Constr_1 @Def: Each throat swab requires TimeThroatSwab minutes and each nasal swab requires TimeNasalSwab minutes. The total operational time cannot exceed TotalOperationalTime minutes.
model.addConstr(TimeThroatSwab * NumThroatSwab + TimeNasalSwab * NumNasalSwab <= TotalOperationalTime, 'OperationalTime')
# @Constraint Constr_2 @Def: At least MinimumNasalSwabs nasal swabs must be administered.
model.addConstr(NumNasalSwab >= MinimumNasalSwabs)
# @Constraint Constr_3 @Def: The number of throat swabs must be at least ThroatToNasalRatio times the number of nasal swabs.
model.addConstr(NumThroatSwab >= ThroatToNasalRatio * NumNasalSwab)

# Objective 
# @Objective Objective @Def: The objective is to maximize the total number of patients seen.
model.setObjective(NumThroatSwab + NumNasalSwab, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumThroatSwab'] = NumThroatSwab.x
variables['NumNasalSwab'] = NumNasalSwab.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A patient in the hospital can take two different pain killers, pain killer 1 and pain killer 2. Per dose, pain killer 1 delivers 0.5 units of medicine to the legs and 0.8 units of medicine to the back. Per dose, pain killer 2 delivers 0.7 units of medicine to the legs and 0.4 units of medicine to the back. In, addition pain killer 1 deliver 0.3 units of sleeping medicine and pain killer 2 delivers 0.6 units of sleeping medicine. At most 8 units of sleep medicine should be delivered and at least 4 units of medicine should be delivered to the legs. How many doses of each should be taken to maximize the amount of medicine delivered to the back?","{""variables"": {""NumDoses"": {""0"": 0.0, ""1"": 11.428571428571429}}, ""objective"": 6.857142857142857}","{""parametrized_description"": ""A patient can take doses of NumPainKillers different pain killers. Each dose of each pain killer delivers MedicinePerDose units of medicine to each of NumTargets targets. The total amount of sleep medicine delivered must not exceed MaxSleepMedicine units. The total amount of medicine delivered to the legs must be at least MinLegsMedicine units. The objective is to determine the number of doses of each pain killer to maximize the total amount of medicine delivered to the back."", ""keywords"": [""N.A.""], ""parameters"": {""NumPainKillers"": {""description"": ""Number of different pain killers available"", ""shape"": []}, ""NumTargets"": {""description"": ""Number of different medicine targets"", ""shape"": []}, ""MedicinePerDose"": {""description"": ""Amount of medicine delivered to each target per dose for each pain killer"", ""shape"": [""NumPainKillers"", ""NumTargets""]}, ""MaxSleepMedicine"": {""description"": ""Maximum units of sleeping medicine that can be delivered"", ""shape"": []}, ""MinLegsMedicine"": {""description"": ""Minimum units of medicine required for legs"", ""shape"": []}}, ""variables"": {""NumDoses"": {""description"": ""The number of doses for each painkiller"", ""type"": ""continuous"", ""shape"": [""NumPainKillers""]}}, ""constraints"": [{""description"": ""The total amount of sleep medicine delivered must not exceed MaxSleepMedicine units."", ""formulation"": ""\\sum_{p=1}^{\\text{NumPainKillers}} \\text{MedicinePerDose}_{p, \\text{Sleep}} \\times \\text{NumDoses}_p \\leq \\text{MaxSleepMedicine}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(MedicinePerDose[p, 'Sleep'] * NumDoses[p] for p in range(NumPainKillers)) <= MaxSleepMedicine)""}}, {""description"": ""The total amount of medicine delivered to the legs must be at least MinLegsMedicine units."", ""formulation"": ""\\sum_{i=1}^{NumPainKillers} \\text{MedicinePerDose}_{i, \\text{Legs}} \\times \\text{NumDoses}_{i} \\geq \\text{MinLegsMedicine}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(MedicinePerDose[i][0] * NumDoses[i] for i in range(NumPainKillers)) >= MinLegsMedicine)""}}], ""objective"": {""description"": ""The objective is to maximize the total amount of medicine delivered to the back."", ""formulation"": ""Max \\sum_{i=1}^{NumPainKillers} \\text{NumDoses}_i \\cdot \\text{MedicinePerDose}_{i, \\text{back}}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(NumDoses[i] * MedicinePerDose[i, \""back\""] for i in range(NumPainKillers)), GRB.MAXIMIZE)""}}}","{""NumPainKillers"": 2, ""NumTargets"": 3, ""MedicinePerDose"": [[0.5, 0.8, 0.3], [0.7, 0.4, 0.6]], ""MaxSleepMedicine"": 8, ""MinLegsMedicine"": 4}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A patient can take doses of NumPainKillers different pain killers. Each dose of
each pain killer delivers MedicinePerDose units of medicine to each of
NumTargets targets. The total amount of sleep medicine delivered must not exceed
MaxSleepMedicine units. The total amount of medicine delivered to the legs must
be at least MinLegsMedicine units. The objective is to determine the number of
doses of each pain killer to maximize the total amount of medicine delivered to
the back.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/120/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumPainKillers @Def: Number of different pain killers available @Shape: [] 
NumPainKillers = data['NumPainKillers']
# @Parameter NumTargets @Def: Number of different medicine targets @Shape: [] 
NumTargets = data['NumTargets']
# @Parameter MedicinePerDose @Def: Amount of medicine delivered to each target per dose for each pain killer @Shape: ['NumPainKillers', 'NumTargets'] 
MedicinePerDose = data['MedicinePerDose']
# @Parameter MaxSleepMedicine @Def: Maximum units of sleeping medicine that can be delivered @Shape: [] 
MaxSleepMedicine = data['MaxSleepMedicine']
# @Parameter MinLegsMedicine @Def: Minimum units of medicine required for legs @Shape: [] 
MinLegsMedicine = data['MinLegsMedicine']

# Define target indices
# Assuming target order is ['Sleep', 'legs', 'back']
target_indices = {""Sleep"": 0, ""legs"": 1, ""back"": 2}

# Variables 
# @Variable NumDoses @Def: The number of doses for each painkiller @Shape: ['NumPainKillers'] 
NumDoses = model.addVars(NumPainKillers, vtype=GRB.CONTINUOUS, name=""NumDoses"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of sleep medicine delivered must not exceed MaxSleepMedicine units.
model.addConstr(quicksum(MedicinePerDose[p][target_indices['Sleep']] * NumDoses[p] for p in range(NumPainKillers)) <= MaxSleepMedicine)
# @Constraint Constr_2 @Def: The total amount of medicine delivered to the legs must be at least MinLegsMedicine units.
model.addConstr(quicksum(MedicinePerDose[i][target_indices['legs']] * NumDoses[i] for i in range(NumPainKillers)) >= MinLegsMedicine)

# Objective 
# @Objective Objective @Def: The objective is to maximize the total amount of medicine delivered to the back.
model.setObjective(quicksum(NumDoses[i] * MedicinePerDose[i][target_indices['back']] for i in range(NumPainKillers)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumDoses'] = {p: NumDoses[p].X for p in range(NumPainKillers)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A zookeeper feeds a gorilla with bananas and mangoes. Each banana contains 80 calories, 20 grams of potassium, and 10 grams of sugar. Each mango contains 100 calories, 15 grams of potassium, and 8 grams of sugar.  The gorilla must consume at least 4000 calories and 150 grams of potassium. Since the gorilla prefers bananas, at most 33% of the fruits he eats can be mangoes. If excess sugar makes the gorilla aggressive, how many of each fruit should he consume to minimize his sugar intake?","{""variables"": {""XBanana"": 32.0, ""XMango"": 15.0}, ""objective"": 440.0}","{""parametrized_description"": ""A zookeeper feeds a gorilla with bananas and mangoes. Each banana contains CalorieBanana calories, PotassiumBanana grams of potassium, and SugarBanana grams of sugar. Each mango contains CalorieMango calories, PotassiumMango grams of potassium, and SugarMango grams of sugar. The gorilla must consume at least MinCalories calories and MinPotassium grams of potassium. At most MaxMangoFraction of the fruits he eats can be mangoes. To prevent excess sugar intake, determine the number of each fruit he should consume to minimize his sugar intake."", ""keywords"": [""N.A.""], ""parameters"": {""CalorieBanana"": {""description"": ""Amount of calories per banana"", ""shape"": []}, ""CalorieMango"": {""description"": ""Amount of calories per mango"", ""shape"": []}, ""PotassiumBanana"": {""description"": ""Amount of potassium per banana"", ""shape"": []}, ""PotassiumMango"": {""description"": ""Amount of potassium per mango"", ""shape"": []}, ""SugarBanana"": {""description"": ""Amount of sugar per banana"", ""shape"": []}, ""SugarMango"": {""description"": ""Amount of sugar per mango"", ""shape"": []}, ""MinCalories"": {""description"": ""Minimum total calories required"", ""shape"": []}, ""MinPotassium"": {""description"": ""Minimum total potassium required"", ""shape"": []}, ""MaxMangoFraction"": {""description"": ""Maximum fraction of fruits that can be mangoes"", ""shape"": []}}, ""variables"": {""XBanana"": {""description"": ""The number of bananas consumed by the gorilla"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""XMango"": {""description"": ""The number of mangoes consumed by the gorilla"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The gorilla must consume at least MinCalories calories."", ""formulation"": ""CalorieBanana \\cdot XBanana + CalorieMango \\cdot XMango \\geq MinCalories"", ""code"": {""gurobipy"": ""model.addConstr(CalorieBanana * XBanana + CalorieMango * XMango >= MinCalories)""}}, {""description"": ""The gorilla must consume at least MinPotassium grams of potassium."", ""formulation"": ""PotassiumBanana \\cdot XBanana + PotassiumMango \\cdot XMango \\geq MinPotassium"", ""code"": {""gurobipy"": ""model.addConstr(PotassiumBanana * XBanana + PotassiumMango * XMango >= MinPotassium)""}}, {""description"": ""At most MaxMangoFraction of the fruits the gorilla eats can be mangoes."", ""formulation"": ""XMango \\leq MaxMangoFraction \\cdot (XBanana + XMango)"", ""code"": {""gurobipy"": ""model.addConstr(XMango <= MaxMangoFraction * (XBanana + XMango))""}}], ""objective"": {""description"": ""Minimize the total sugar intake."", ""formulation"": ""Min \\ SugarBanana \\times XBanana + SugarMango \\times XMango"", ""code"": {""gurobipy"": ""model.setObjective(SugarBanana * XBanana + SugarMango * XMango, GRB.MINIMIZE)""}}}","{""CalorieBanana"": 80, ""CalorieMango"": 100, ""PotassiumBanana"": 20, ""PotassiumMango"": 15, ""SugarBanana"": 10, ""SugarMango"": 8, ""MinCalories"": 4000, ""MinPotassium"": 150, ""MaxMangoFraction"": 0.33}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A zookeeper feeds a gorilla with bananas and mangoes. Each banana contains
CalorieBanana calories, PotassiumBanana grams of potassium, and SugarBanana
grams of sugar. Each mango contains CalorieMango calories, PotassiumMango grams
of potassium, and SugarMango grams of sugar. The gorilla must consume at least
MinCalories calories and MinPotassium grams of potassium. At most
MaxMangoFraction of the fruits he eats can be mangoes. To prevent excess sugar
intake, determine the number of each fruit he should consume to minimize his
sugar intake.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/121/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CalorieBanana @Def: Amount of calories per banana @Shape: [] 
CalorieBanana = data['CalorieBanana']
# @Parameter CalorieMango @Def: Amount of calories per mango @Shape: [] 
CalorieMango = data['CalorieMango']
# @Parameter PotassiumBanana @Def: Amount of potassium per banana @Shape: [] 
PotassiumBanana = data['PotassiumBanana']
# @Parameter PotassiumMango @Def: Amount of potassium per mango @Shape: [] 
PotassiumMango = data['PotassiumMango']
# @Parameter SugarBanana @Def: Amount of sugar per banana @Shape: [] 
SugarBanana = data['SugarBanana']
# @Parameter SugarMango @Def: Amount of sugar per mango @Shape: [] 
SugarMango = data['SugarMango']
# @Parameter MinCalories @Def: Minimum total calories required @Shape: [] 
MinCalories = data['MinCalories']
# @Parameter MinPotassium @Def: Minimum total potassium required @Shape: [] 
MinPotassium = data['MinPotassium']
# @Parameter MaxMangoFraction @Def: Maximum fraction of fruits that can be mangoes @Shape: [] 
MaxMangoFraction = data['MaxMangoFraction']

# Variables 
# @Variable XBanana @Def: The number of bananas consumed by the gorilla @Shape: ['Integer'] 
XBanana = model.addVar(vtype=GRB.INTEGER, name=""XBanana"")
# @Variable XMango @Def: The number of mangoes consumed by the gorilla @Shape: ['Integer'] 
XMango = model.addVar(vtype=GRB.INTEGER, name=""XMango"")

# Constraints 
# @Constraint Constr_1 @Def: The gorilla must consume at least MinCalories calories.
model.addConstr(CalorieBanana * XBanana + CalorieMango * XMango >= MinCalories)
# @Constraint Constr_2 @Def: The gorilla must consume at least MinPotassium grams of potassium.
model.addConstr(PotassiumBanana * XBanana + PotassiumMango * XMango >= MinPotassium)
# @Constraint Constr_3 @Def: At most MaxMangoFraction of the fruits the gorilla eats can be mangoes.
model.addConstr(XMango <= MaxMangoFraction * (XBanana + XMango))

# Objective 
# @Objective Objective @Def: Minimize the total sugar intake.
model.setObjective(SugarBanana * XBanana + SugarMango * XMango, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['XBanana'] = XBanana.x
variables['XMango'] = XMango.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"In a science club, there are two tables that can be set up to make slime. At table 1, 3 units of powder and 5 units of glue are used to make 4 units of slime. At table 2, 8 units of powder and 6 units of glue are used to make 5 units of slime. However, table 1 produces 2 units of mess while table 2 produces 4 units of mess. The science club has available 100 units of powder and 90 units of glue.  If at most 30 units of mess can be made, how many of each table should be set up to maximize the amount of slime produced?","{""variables"": {""Production"": {""0"": 15.0, ""1"": 0.0}}, ""objective"": 60.0}","{""parametrized_description"": ""In a science club, there are NumTables different tables for making slime. At each table i, PowderUsed[i] units of powder and GlueUsed[i] units of glue are used to produce SlimeProduced[i] units of slime. Each table i also generates MessProduced[i] units of mess. The club has AvailablePowder units of powder and AvailableGlue units of glue available. Additionally, no more than MaxMess units of mess can be created. The objective is to determine the number of each table to set up to maximize the total amount of slime produced."", ""keywords"": [""N.A.""], ""parameters"": {""NumTables"": {""description"": ""Number of different tables for making slime"", ""shape"": []}, ""PowderUsed"": {""description"": ""Amount of powder used by table i"", ""shape"": [""NumTables""]}, ""GlueUsed"": {""description"": ""Amount of glue used by table i"", ""shape"": [""NumTables""]}, ""SlimeProduced"": {""description"": ""Amount of slime produced by table i"", ""shape"": [""NumTables""]}, ""MessProduced"": {""description"": ""Amount of mess produced by table i"", ""shape"": [""NumTables""]}, ""AvailablePowder"": {""description"": ""Total available units of powder"", ""shape"": []}, ""AvailableGlue"": {""description"": ""Total available units of glue"", ""shape"": []}, ""MaxMess"": {""description"": ""Maximum allowable units of mess"", ""shape"": []}}, ""variables"": {""Production"": {""description"": ""The amount produced at table i"", ""type"": ""continuous"", ""shape"": [""NumTables""]}}, ""constraints"": [{""description"": ""The total amount of powder used by all tables cannot exceed AvailablePowder."", ""formulation"": ""\\sum_{i=1}^{\\text{NumTables}} \\text{PowderUsed}_i \\cdot \\text{Production}_i \\leq \\text{AvailablePowder}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(PowderUsed[i] * Production[i] for i in range(NumTables)) <= AvailablePowder)""}}, {""description"": ""The total amount of glue used by all tables cannot exceed AvailableGlue."", ""formulation"": ""\\sum_{i=1}^{NumTables} GlueUsed_i Production_i \\leq AvailableGlue"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(GlueUsed[i] * Production[i] for i in range(NumTables)) <= AvailableGlue)""}}, {""description"": ""The total amount of mess produced by all tables cannot exceed MaxMess."", ""formulation"": ""\\sum_{i=1}^{NumTables} Production_i \\times MessProduced_i \\leq MaxMess"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(Production[i] * MessProduced[i] for i in range(NumTables)) <= MaxMess)""}}], ""objective"": {""description"": ""The total amount of slime produced is the sum of SlimeProduced[i] multiplied by the number of each table set up. The objective is to maximize the total amount of slime produced."", ""formulation"": ""Max \\sum_{i=1}^{NumTables} SlimeProduced_i \\cdot Production_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(SlimeProduced[i] * Production[i] for i in range(NumTables)), GRB.MAXIMIZE)""}}}","{""NumTables"": 2, ""PowderUsed"": [3, 8], ""GlueUsed"": [5, 6], ""SlimeProduced"": [4, 5], ""MessProduced"": [2, 4], ""AvailablePowder"": 100, ""AvailableGlue"": 90, ""MaxMess"": 30}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
In a science club, there are NumTables different tables for making slime. At
each table i, PowderUsed[i] units of powder and GlueUsed[i] units of glue are
used to produce SlimeProduced[i] units of slime. Each table i also generates
MessProduced[i] units of mess. The club has AvailablePowder units of powder and
AvailableGlue units of glue available. Additionally, no more than MaxMess units
of mess can be created. The objective is to determine the number of each table
to set up to maximize the total amount of slime produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/122/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumTables @Def: Number of different tables for making slime @Shape: [] 
NumTables = data['NumTables']
# @Parameter PowderUsed @Def: Amount of powder used by table i @Shape: ['NumTables'] 
PowderUsed = data['PowderUsed']
# @Parameter GlueUsed @Def: Amount of glue used by table i @Shape: ['NumTables'] 
GlueUsed = data['GlueUsed']
# @Parameter SlimeProduced @Def: Amount of slime produced by table i @Shape: ['NumTables'] 
SlimeProduced = data['SlimeProduced']
# @Parameter MessProduced @Def: Amount of mess produced by table i @Shape: ['NumTables'] 
MessProduced = data['MessProduced']
# @Parameter AvailablePowder @Def: Total available units of powder @Shape: [] 
AvailablePowder = data['AvailablePowder']
# @Parameter AvailableGlue @Def: Total available units of glue @Shape: [] 
AvailableGlue = data['AvailableGlue']
# @Parameter MaxMess @Def: Maximum allowable units of mess @Shape: [] 
MaxMess = data['MaxMess']

# Variables 
# @Variable Production @Def: The amount produced at table i @Shape: ['NumTables'] 
Production = model.addVars(NumTables, vtype=GRB.CONTINUOUS, name=""Production"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of powder used by all tables cannot exceed AvailablePowder.
model.addConstr(quicksum(PowderUsed[i] * Production[i] for i in range(NumTables)) <= AvailablePowder)
# @Constraint Constr_2 @Def: The total amount of glue used by all tables cannot exceed AvailableGlue.
model.addConstr(quicksum(GlueUsed[i] * Production[i] for i in range(NumTables)) <= AvailableGlue)
# @Constraint Constr_3 @Def: The total amount of mess produced by all tables cannot exceed MaxMess.
model.addConstr(quicksum(Production[i] * MessProduced[i] for i in range(NumTables)) <= MaxMess)

# Objective 
# @Objective Objective @Def: The total amount of slime produced is the sum of SlimeProduced[i] multiplied by the number of each table set up. The objective is to maximize the total amount of slime produced.
model.setObjective(quicksum(SlimeProduced[i] * Production[i] for i in range(NumTables)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Production'] = {i: Production[i].X for i in range(NumTables)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A pharmaceutical company has 800 units of painkiller medicine and makes daytime and nighttime painkiller. A daytime pill has 6 units of painkiller medicine and 2 units of sleep medicine. A nighttime pill has 5 units of painkiller medicine and 5 units of sleep medicine. Since some people don’t want the sleeping effect, at least 40% of the pills must be daytime pills. However at least 200 nighttime pills must be made. How many of each pill should be made to minimize the total amount of sleep medicine required?",{},{},"{""TotalPainkillerUnits"": 800, ""PainkillerPerDayPill"": 6, ""SleepPerDayPill"": 2, ""PainkillerPerNightPill"": 5, ""SleepPerNightPill"": 5, ""MinDayPillPercentage"": 0.4, ""MinNightPills"": 200}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A pharmaceutical company has TotalPainkillerUnits units of painkiller medicine
and produces daytime and nighttime pills. Each daytime pill contains
PainkillerPerDayPill units of painkiller and SleepPerDayPill units of sleep
medicine. Each nighttime pill contains PainkillerPerNightPill units of
painkiller and SleepPerNightPill units of sleep medicine. At least
MinDayPillPercentage of the total pills must be daytime pills, and at least
MinNightPills nighttime pills must be produced. The objective is to determine
the number of daytime and nighttime pills to minimize the total sleep medicine
required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/123/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalPainkillerUnits @Def: Total number of painkiller medicine units available @Shape: [] 
TotalPainkillerUnits = data['TotalPainkillerUnits']
# @Parameter PainkillerPerDayPill @Def: Units of painkiller medicine per daytime pill @Shape: [] 
PainkillerPerDayPill = data['PainkillerPerDayPill']
# @Parameter SleepPerDayPill @Def: Units of sleep medicine per daytime pill @Shape: [] 
SleepPerDayPill = data['SleepPerDayPill']
# @Parameter PainkillerPerNightPill @Def: Units of painkiller medicine per nighttime pill @Shape: [] 
PainkillerPerNightPill = data['PainkillerPerNightPill']
# @Parameter SleepPerNightPill @Def: Units of sleep medicine per nighttime pill @Shape: [] 
SleepPerNightPill = data['SleepPerNightPill']
# @Parameter MinDayPillPercentage @Def: Minimum percentage of pills that must be daytime pills @Shape: [] 
MinDayPillPercentage = data['MinDayPillPercentage']
# @Parameter MinNightPills @Def: Minimum number of nighttime pills to be made @Shape: [] 
MinNightPills = data['MinNightPills']

# Variables 
# @Variable NumberDaytimePills @Def: The number of daytime pills @Shape: [] 
NumberDaytimePills = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberDaytimePills"")
# @Variable NumberNighttimePills @Def: The number of nighttime pills @Shape: [] 
NumberNighttimePills = model.addVar(vtype=GRB.CONTINUOUS, lb=MinNightPills, name=""NumberNighttimePills"")

# Constraints 
# @Constraint Constr_1 @Def: The total painkiller used in daytime and nighttime pills cannot exceed TotalPainkillerUnits.
model.addConstr(PainkillerPerDayPill * NumberDaytimePills + PainkillerPerNightPill * NumberNighttimePills <= TotalPainkillerUnits)
# @Constraint Constr_2 @Def: At least MinDayPillPercentage percentage of the total pills must be daytime pills.
model.addConstr(NumberDaytimePills >= MinDayPillPercentage * (NumberDaytimePills + NumberNighttimePills))
# @Constraint Constr_3 @Def: At least MinNightPills nighttime pills must be produced.
model.addConstr(NumberNighttimePills >= MinNightPills)

# Objective 
# @Objective Objective @Def: The total sleep medicine used is the sum of SleepPerDayPill units per daytime pill and SleepPerNightPill units per nighttime pill. The objective is to minimize the total sleep medicine required.
model.setObjective(SleepPerDayPill * NumberDaytimePills + SleepPerNightPill * NumberNighttimePills, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberDaytimePills'] = NumberDaytimePills.x
variables['NumberNighttimePills'] = NumberNighttimePills.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A competitive eater challenges himself to eat slices of cheesecake and caramel cake. Each slice of cheesecake contains 200 calories and 40 grams of sugar. Each slice of caramel cake contains 250 calories and 50 grams of sugar. He prefers cheesecake and decides to eat at least 3 times as many slices of cheesecake as caramel cake. However, he must also eat at least 3 slices of caramel cake. If he can consume at most 10000 calories in one day, how many slices of each cake should he eat to maximize the total amount of sugar he consumes?","{""variables"": {""CheesecakeSlices"": 45.0, ""CaramelCakeSlices"": 4.0}, ""objective"": 2000.0}","{""parametrized_description"": ""Determine the number of cheesecake slices and caramel cake slices to maximize the total sugar consumed, where each cheesecake slice provides SugarCheesecake grams of sugar and each caramel cake slice provides SugarCaramelCake grams of sugar. Ensure that the total calories from cheesecake and caramel cake do not exceed MaxTotalCalories, that the number of cheesecake slices is at least MinCheesecakeToCaramelRatio times the number of caramel cake slices, and that the number of caramel cake slices is at least MinCaramelSlices."", ""keywords"": [""N.A.""], ""parameters"": {""CaloriesCheesecake"": {""description"": ""Calories per slice of cheesecake"", ""shape"": []}, ""SugarCheesecake"": {""description"": ""Sugar per slice of cheesecake"", ""shape"": []}, ""CaloriesCaramelCake"": {""description"": ""Calories per slice of caramel cake"", ""shape"": []}, ""SugarCaramelCake"": {""description"": ""Sugar per slice of caramel cake"", ""shape"": []}, ""MinCheesecakeToCaramelRatio"": {""description"": ""Minimum ratio of cheesecake slices to caramel cake slices"", ""shape"": []}, ""MinCaramelSlices"": {""description"": ""Minimum number of caramel cake slices"", ""shape"": []}, ""MaxTotalCalories"": {""description"": ""Maximum total calories that can be consumed in one day"", ""shape"": []}}, ""variables"": {""CheesecakeSlices"": {""description"": ""The number of slices of cheesecake"", ""type"": ""continuous"", ""shape"": []}, ""CaramelCakeSlices"": {""description"": ""The number of slices of caramel cake"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total calories from cheesecake and caramel cake do not exceed MaxTotalCalories"", ""formulation"": ""CheesecakeSlices \\times CaloriesCheesecake + CaramelCakeSlices \\times CaloriesCaramelCake \\leq MaxTotalCalories"", ""code"": {""gurobipy"": ""model.addConstr(CheesecakeSlices * CaloriesCheesecake + CaramelCakeSlices * CaloriesCaramelCake <= MaxTotalCalories)""}}, {""description"": ""The number of cheesecake slices is at least MinCheesecakeToCaramelRatio times the number of caramel cake slices"", ""formulation"": ""CheesecakeSlices \\geq MinCheesecakeToCaramelRatio \\times CaramelCakeSlices"", ""code"": {""gurobipy"": ""model.addConstr(CheesecakeSlices >= MinCheesecakeToCaramelRatio * CaramelCakeSlices)""}}, {""description"": ""The number of caramel cake slices is at least MinCaramelSlices"", ""formulation"": ""CaramelCakeSlices \\geq MinCaramelSlices"", ""code"": {""gurobipy"": ""model.addConstr(CaramelCakeSlices >= MinCaramelSlices)""}}], ""objective"": {""description"": ""Maximize the total sugar consumed, where each cheesecake slice provides SugarCheesecake grams of sugar and each caramel cake slice provides SugarCaramelCake grams of sugar"", ""formulation"": ""Max \\ SugarCheesecake \\cdot CheesecakeSlices + SugarCaramelCake \\cdot CaramelCakeSlices"", ""code"": {""gurobipy"": ""model.setObjective(SugarCheesecake * CheesecakeSlices + SugarCaramelCake * CaramelCakeSlices, GRB.MAXIMIZE)""}}}","{""CaloriesCheesecake"": 200, ""SugarCheesecake"": 40, ""CaloriesCaramelCake"": 250, ""SugarCaramelCake"": 50, ""MinCheesecakeToCaramelRatio"": 3, ""MinCaramelSlices"": 3, ""MaxTotalCalories"": 10000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Determine the number of cheesecake slices and caramel cake slices to maximize
the total sugar consumed, where each cheesecake slice provides SugarCheesecake
grams of sugar and each caramel cake slice provides SugarCaramelCake grams of
sugar. Ensure that the total calories from cheesecake and caramel cake do not
exceed MaxTotalCalories, that the number of cheesecake slices is at least
MinCheesecakeToCaramelRatio times the number of caramel cake slices, and that
the number of caramel cake slices is at least MinCaramelSlices.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/124/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CaloriesCheesecake @Def: Calories per slice of cheesecake @Shape: [] 
CaloriesCheesecake = data['CaloriesCheesecake']
# @Parameter SugarCheesecake @Def: Sugar per slice of cheesecake @Shape: [] 
SugarCheesecake = data['SugarCheesecake']
# @Parameter CaloriesCaramelCake @Def: Calories per slice of caramel cake @Shape: [] 
CaloriesCaramelCake = data['CaloriesCaramelCake']
# @Parameter SugarCaramelCake @Def: Sugar per slice of caramel cake @Shape: [] 
SugarCaramelCake = data['SugarCaramelCake']
# @Parameter MinCheesecakeToCaramelRatio @Def: Minimum ratio of cheesecake slices to caramel cake slices @Shape: [] 
MinCheesecakeToCaramelRatio = data['MinCheesecakeToCaramelRatio']
# @Parameter MinCaramelSlices @Def: Minimum number of caramel cake slices @Shape: [] 
MinCaramelSlices = data['MinCaramelSlices']
# @Parameter MaxTotalCalories @Def: Maximum total calories that can be consumed in one day @Shape: [] 
MaxTotalCalories = data['MaxTotalCalories']

# Variables 
# @Variable CheesecakeSlices @Def: The number of slices of cheesecake @Shape: [] 
CheesecakeSlices = model.addVar(vtype=GRB.INTEGER, name=""CheesecakeSlices"")
# @Variable CaramelCakeSlices @Def: The number of slices of caramel cake @Shape: [] 
CaramelCakeSlices = model.addVar(vtype=GRB.INTEGER, name=""CaramelCakeSlices"")

# Constraints 
# @Constraint Constr_1 @Def: The total calories from cheesecake and caramel cake do not exceed MaxTotalCalories
model.addConstr(CheesecakeSlices * CaloriesCheesecake + CaramelCakeSlices * CaloriesCaramelCake <= MaxTotalCalories)
# @Constraint Constr_2 @Def: The number of cheesecake slices is at least MinCheesecakeToCaramelRatio times the number of caramel cake slices
model.addConstr(CheesecakeSlices >= MinCheesecakeToCaramelRatio * CaramelCakeSlices)
# @Constraint Constr_3 @Def: The number of caramel cake slices is at least MinCaramelSlices
model.addConstr(CaramelCakeSlices >= MinCaramelSlices)

# Objective 
# @Objective Objective @Def: Maximize the total sugar consumed, where each cheesecake slice provides SugarCheesecake grams of sugar and each caramel cake slice provides SugarCaramelCake grams of sugar
model.setObjective(SugarCheesecake * CheesecakeSlices + SugarCaramelCake * CaramelCakeSlices, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['CheesecakeSlices'] = CheesecakeSlices.x
variables['CaramelCakeSlices'] = CaramelCakeSlices.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Both sulfate and ginger need to be added to a shampoo. One unit of sulfate takes 0.5 minutes to be effective while one unit of ginger takes 0.75 minutes to be effective. The shampoo must contain at least 100 units of sulfates and a total of 400 units of both ingredient. Since too much sulfate can damage the hair, there can be at most twice the amount of sulfate as ginger in the shampoo. How many units of each should be added to the shampoo to minimize the total amount of time it takes for the mixture to be effective? (Note: one must be added before the other)","{""variables"": {""SulfateUnits"": 266.0, ""GingerUnits"": 134.0, ""SulfateAddedFirst"": 1.0}, ""objective"": 233.5}","{""parametrized_description"": ""Determine the quantities of sulfate and ginger to add to the shampoo such that the number of sulfate units is at least MinSulfateUnits, the combined number of sulfate and ginger units equals TotalUnits, the number of sulfate units does not exceed MaxSulfateToGingerRatio multiplied by the number of ginger units, one ingredient is added before the other, and the total effective time, based on TimePerUnitSulfate and TimePerUnitGinger, is minimized."", ""keywords"": [""N.A.""], ""parameters"": {""TimePerUnitSulfate"": {""description"": ""Time taken for one unit of sulfate to be effective"", ""shape"": []}, ""TimePerUnitGinger"": {""description"": ""Time taken for one unit of ginger to be effective"", ""shape"": []}, ""MinSulfateUnits"": {""description"": ""Minimum required units of sulfate"", ""shape"": []}, ""TotalUnits"": {""description"": ""Total units of sulfate and ginger"", ""shape"": []}, ""MaxSulfateToGingerRatio"": {""description"": ""Maximum allowed ratio of sulfate to ginger"", ""shape"": []}}, ""variables"": {""SulfateUnits"": {""description"": ""The number of sulfate units"", ""type"": ""continuous"", ""shape"": []}, ""GingerUnits"": {""description"": ""The number of ginger units"", ""type"": ""continuous"", ""shape"": []}, ""SulfateAddedFirst"": {""description"": ""Binary variable indicating whether Sulfate is added before Ginger"", ""type"": ""continuous"", ""shape"": [""binary""]}}, ""constraints"": [{""description"": ""The number of sulfate units is at least MinSulfateUnits."", ""formulation"": ""SulfateUnits \\geq MinSulfateUnits"", ""code"": {""gurobipy"": ""model.addConstr(SulfateUnits >= MinSulfateUnits)""}}, {""description"": ""The combined number of sulfate and ginger units equals TotalUnits."", ""formulation"": ""SulfateUnits + GingerUnits = TotalUnits"", ""code"": {""gurobipy"": ""model.addConstr(SulfateUnits + GingerUnits == TotalUnits)""}}, {""description"": ""The number of sulfate units does not exceed MaxSulfateToGingerRatio multiplied by the number of ginger units."", ""formulation"": ""SulfateUnits \\leq MaxSulfateToGingerRatio \\times GingerUnits"", ""code"": {""gurobipy"": ""model.addConstr(SulfateUnits <= MaxSulfateToGingerRatio * GingerUnits)""}}, {""description"": ""One ingredient is added before the other."", ""formulation"": ""SulfateAddedFirst = 1 \\\\ SulfateAddedFirst \\in \\{0,1\\}"", ""code"": {""gurobipy"": ""model.addConstr(SulfateAddedFirst == 1)""}}], ""objective"": {""description"": ""Minimize the total effective time, calculated as (TimePerUnitSulfate * number of sulfate units) + (TimePerUnitGinger * number of ginger units)."", ""formulation"": ""Min \\left( TimePerUnitSulfate \\cdot SulfateUnits + TimePerUnitGinger \\cdot GingerUnits \\right)"", ""code"": {""gurobipy"": ""model.setObjective(TimePerUnitSulfate * SulfateUnits + TimePerUnitGinger * GingerUnits, GRB.MINIMIZE)""}}}","{""TimePerUnitSulfate"": 0.5, ""TimePerUnitGinger"": 0.75, ""MinSulfateUnits"": 100, ""TotalUnits"": 400, ""MaxSulfateToGingerRatio"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Determine the quantities of sulfate and ginger to add to the shampoo such that
the number of sulfate units is at least MinSulfateUnits, the combined number of
sulfate and ginger units equals TotalUnits, the number of sulfate units does not
exceed MaxSulfateToGingerRatio multiplied by the number of ginger units, one
ingredient is added before the other, and the total effective time, based on
TimePerUnitSulfate and TimePerUnitGinger, is minimized.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/125/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TimePerUnitSulfate @Def: Time taken for one unit of sulfate to be effective @Shape: [] 
TimePerUnitSulfate = data['TimePerUnitSulfate']
# @Parameter TimePerUnitGinger @Def: Time taken for one unit of ginger to be effective @Shape: [] 
TimePerUnitGinger = data['TimePerUnitGinger']
# @Parameter MinSulfateUnits @Def: Minimum required units of sulfate @Shape: [] 
MinSulfateUnits = data['MinSulfateUnits']
# @Parameter TotalUnits @Def: Total units of sulfate and ginger @Shape: [] 
TotalUnits = data['TotalUnits']
# @Parameter MaxSulfateToGingerRatio @Def: Maximum allowed ratio of sulfate to ginger @Shape: [] 
MaxSulfateToGingerRatio = data['MaxSulfateToGingerRatio']

# Variables 
# @Variable SulfateUnits @Def: The number of sulfate units @Shape: [] 
SulfateUnits = model.addVar(vtype=GRB.INTEGER, lb=MinSulfateUnits, name=""SulfateUnits"")
# @Variable GingerUnits @Def: The number of ginger units @Shape: [] 
GingerUnits = model.addVar(vtype=GRB.INTEGER, name=""GingerUnits"")
# @Variable SulfateAddedFirst @Def: Binary variable indicating whether Sulfate is added before Ginger @Shape: ['binary'] 
SulfateAddedFirst = model.addVar(vtype=GRB.BINARY, name=""SulfateAddedFirst"")

# Constraints 
# @Constraint Constr_1 @Def: The number of sulfate units is at least MinSulfateUnits.
model.addConstr(SulfateUnits >= MinSulfateUnits)
# @Constraint Constr_2 @Def: The combined number of sulfate and ginger units equals TotalUnits.
model.addConstr(SulfateUnits + GingerUnits == TotalUnits)
# @Constraint Constr_3 @Def: The number of sulfate units does not exceed MaxSulfateToGingerRatio multiplied by the number of ginger units.
model.addConstr(SulfateUnits <= MaxSulfateToGingerRatio * GingerUnits)
# @Constraint Constr_4 @Def: One ingredient is added before the other.
model.addConstr(SulfateAddedFirst == 1)

# Objective 
# @Objective Objective @Def: Minimize the total effective time, calculated as (TimePerUnitSulfate * number of sulfate units) + (TimePerUnitGinger * number of ginger units).
model.setObjective(TimePerUnitSulfate * SulfateUnits + TimePerUnitGinger * GingerUnits, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SulfateUnits'] = SulfateUnits.x
variables['GingerUnits'] = GingerUnits.x
variables['SulfateAddedFirst'] = SulfateAddedFirst.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A pharmaceutical company has two labs, lab 1 and lab 2, where they make heart and lung medication in pill form. At lab 1, they can produce 20 heart medication pills and 30 lung medication pills per hour. At lab 2, they can produce 30 heart medication pills and 40 lung medication pills per hour. Each session at lab 1 requires 3 hours of worker labor while each session at lab 2 requires 5 hours of worker labor. The company has 1500 worker hours available and must make at least 20000 heart medication pills and at least 30000 lung medication pills. How many hours at each lab should be run to minimize the total time needed?",{},{},"{""NumLabs"": 2, ""NumPillTypes"": 2, ""ProductionRate"": [[20, 30], [30, 40]], ""WorkerLaborPerLab"": [3, 5], ""TotalWorkerHours"": 1500, ""MinRequiredPills"": [20000, 30000]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A pharmaceutical company operates NumLabs laboratories to produce NumPillTypes
types of medication pills. Each laboratory has a ProductionRate of pills per
hour for each pill type. Each session at a laboratory requires WorkerLaborPerLab
worker hours. The company has TotalWorkerHours worker hours available and must
produce at least MinRequiredPills pills for each pill type. The objective is to
determine the number of hours each laboratory should operate to minimize the
total time needed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/126/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumLabs @Def: Number of labs @Shape: [] 
NumLabs = data['NumLabs']
# @Parameter NumPillTypes @Def: Number of pill types @Shape: [] 
NumPillTypes = data['NumPillTypes']
# @Parameter ProductionRate @Def: Production rate (pills per hour) for each lab and pill type @Shape: ['NumLabs', 'NumPillTypes'] 
ProductionRate = data['ProductionRate']
# @Parameter WorkerLaborPerLab @Def: Worker labor hours required per session for each lab @Shape: ['NumLabs'] 
WorkerLaborPerLab = data['WorkerLaborPerLab']
# @Parameter TotalWorkerHours @Def: Total worker hours available @Shape: [] 
TotalWorkerHours = data['TotalWorkerHours']
# @Parameter MinRequiredPills @Def: Minimum required pills for each pill type @Shape: ['NumPillTypes'] 
MinRequiredPills = data['MinRequiredPills']

# Variables 
# @Variable Sessions @Def: The number of sessions for each lab @Shape: ['NumLabs'] 
Sessions = model.addVars(NumLabs, vtype=GRB.CONTINUOUS, name=""Sessions"")

# Constraints 
# @Constraint Constr_1 @Def: The total worker labor hours used across all laboratories must not exceed TotalWorkerHours.
model.addConstr(quicksum(WorkerLaborPerLab[l] * Sessions[l] for l in range(NumLabs)) <= TotalWorkerHours)
# @Constraint Constr_2 @Def: For each pill type, the total number of pills produced across all laboratories must be at least MinRequiredPills.
model.addConstrs((quicksum(Sessions[l] * ProductionRate[l, p] for l in range(NumLabs)) >= MinRequiredPills[p] for p in range(NumPillTypes)), name=""MinRequiredPills"")

# Objective 
# @Objective Objective @Def: Minimize the total operating hours across all laboratories to determine the number of hours each laboratory should operate.
model.setObjective(quicksum(Sessions[i] * WorkerLaborPerLab[i] for i in range(NumLabs)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Sessions'] = Sessions.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A doctor suggests that his patient eat oranges and grapefruit to meet his vitamin C and vitamin A requirements. One orange contains 5 units of vitamin C, 3 units of vitamin A, and 5 grams of sugar. One grapefruit contains 7 units of vitamin C, 5 units of vitamin A, and 6 grams of sugar. The patient must get at least 80 units of vitamin C and 70 units of vitamin A. Since the patent prefers oranges, he must eat at least 2 times as many oranges as grapefruit. How many of each should he eat to minimize his sugar intake?","{""variables"": {""NumberOfOranges"": 15.0, ""NumberOfGrapefruits"": 5.0}, ""objective"": 105.0}","{""parametrized_description"": ""A patient must consume oranges and grapefruits to satisfy minimum vitamin requirements. Each orange provides VitaminCPerOrange units of vitamin C and VitaminAPerOrange units of vitamin A, contributing SugarPerOrange grams of sugar. Each grapefruit provides VitaminCPerGrapefruit units of vitamin C and VitaminAPerGrapefruit units of vitamin A, contributing SugarPerGrapefruit grams of sugar. The patient must obtain at least MinVitaminC units of vitamin C and at least MinVitaminA units of vitamin A. Additionally, the number of oranges consumed must be at least MinOrangeToGrapefruitRatio times the number of grapefruits. The objective is to minimize the total sugar intake."", ""keywords"": [""N.A.""], ""parameters"": {""VitaminCPerOrange"": {""description"": ""Units of vitamin C per orange"", ""shape"": []}, ""VitaminAPerOrange"": {""description"": ""Units of vitamin A per orange"", ""shape"": []}, ""SugarPerOrange"": {""description"": ""Grams of sugar per orange"", ""shape"": []}, ""VitaminCPerGrapefruit"": {""description"": ""Units of vitamin C per grapefruit"", ""shape"": []}, ""VitaminAPerGrapefruit"": {""description"": ""Units of vitamin A per grapefruit"", ""shape"": []}, ""SugarPerGrapefruit"": {""description"": ""Grams of sugar per grapefruit"", ""shape"": []}, ""MinVitaminC"": {""description"": ""Minimum required units of vitamin C"", ""shape"": []}, ""MinVitaminA"": {""description"": ""Minimum required units of vitamin A"", ""shape"": []}, ""MinOrangeToGrapefruitRatio"": {""description"": ""Minimum ratio of oranges to grapefruits indicating preference"", ""shape"": []}}, ""variables"": {""NumberOfOranges"": {""description"": ""The number of oranges the patient consumes"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberOfGrapefruits"": {""description"": ""The number of grapefruits the patient consumes"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The patient must obtain at least MinVitaminC units of vitamin C."", ""formulation"": ""VitaminCPerOrange \\times NumberOfOranges + VitaminCPerGrapefruit \\times NumberOfGrapefruits \\geq MinVitaminC"", ""code"": {""gurobipy"": ""model.addConstr(VitaminCPerOrange * NumberOfOranges + VitaminCPerGrapefruit * NumberOfGrapefruits >= MinVitaminC)""}}, {""description"": ""The patient must obtain at least MinVitaminA units of vitamin A."", ""formulation"": ""VitaminAPerOrange \\cdot NumberOfOranges + VitaminAPerGrapefruit \\cdot NumberOfGrapefruits \\geq MinVitaminA"", ""code"": {""gurobipy"": ""model.addConstr(VitaminAPerOrange * NumberOfOranges + VitaminAPerGrapefruit * NumberOfGrapefruits >= MinVitaminA)""}}, {""description"": ""The number of oranges consumed must be at least MinOrangeToGrapefruitRatio times the number of grapefruits."", ""formulation"": ""NumberOfOranges \\geq MinOrangeToGrapefruitRatio \\times NumberOfGrapefruits"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfOranges >= MinOrangeToGrapefruitRatio * NumberOfGrapefruits)""}}], ""objective"": {""description"": ""Total sugar intake is calculated as SugarPerOrange times the number of oranges plus SugarPerGrapefruit times the number of grapefruits. The objective is to minimize the total sugar intake."", ""formulation"": ""Min \\, SugarPerOrange \\times NumberOfOranges + SugarPerGrapefruit \\times NumberOfGrapefruits"", ""code"": {""gurobipy"": ""model.setObjective(SugarPerOrange * NumberOfOranges + SugarPerGrapefruit * NumberOfGrapefruits, GRB.MINIMIZE)""}}}","{""VitaminCPerOrange"": 5, ""VitaminAPerOrange"": 3, ""SugarPerOrange"": 5, ""VitaminCPerGrapefruit"": 7, ""VitaminAPerGrapefruit"": 5, ""SugarPerGrapefruit"": 6, ""MinVitaminC"": 80, ""MinVitaminA"": 70, ""MinOrangeToGrapefruitRatio"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A patient must consume oranges and grapefruits to satisfy minimum vitamin
requirements. Each orange provides VitaminCPerOrange units of vitamin C and
VitaminAPerOrange units of vitamin A, contributing SugarPerOrange grams of
sugar. Each grapefruit provides VitaminCPerGrapefruit units of vitamin C and
VitaminAPerGrapefruit units of vitamin A, contributing SugarPerGrapefruit grams
of sugar. The patient must obtain at least MinVitaminC units of vitamin C and at
least MinVitaminA units of vitamin A. Additionally, the number of oranges
consumed must be at least MinOrangeToGrapefruitRatio times the number of
grapefruits. The objective is to minimize the total sugar intake.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/127/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter VitaminCPerOrange @Def: Units of vitamin C per orange @Shape: [] 
VitaminCPerOrange = data['VitaminCPerOrange']
# @Parameter VitaminAPerOrange @Def: Units of vitamin A per orange @Shape: [] 
VitaminAPerOrange = data['VitaminAPerOrange']
# @Parameter SugarPerOrange @Def: Grams of sugar per orange @Shape: [] 
SugarPerOrange = data['SugarPerOrange']
# @Parameter VitaminCPerGrapefruit @Def: Units of vitamin C per grapefruit @Shape: [] 
VitaminCPerGrapefruit = data['VitaminCPerGrapefruit']
# @Parameter VitaminAPerGrapefruit @Def: Units of vitamin A per grapefruit @Shape: [] 
VitaminAPerGrapefruit = data['VitaminAPerGrapefruit']
# @Parameter SugarPerGrapefruit @Def: Grams of sugar per grapefruit @Shape: [] 
SugarPerGrapefruit = data['SugarPerGrapefruit']
# @Parameter MinVitaminC @Def: Minimum required units of vitamin C @Shape: [] 
MinVitaminC = data['MinVitaminC']
# @Parameter MinVitaminA @Def: Minimum required units of vitamin A @Shape: [] 
MinVitaminA = data['MinVitaminA']
# @Parameter MinOrangeToGrapefruitRatio @Def: Minimum ratio of oranges to grapefruits indicating preference @Shape: [] 
MinOrangeToGrapefruitRatio = data['MinOrangeToGrapefruitRatio']

# Variables 
# @Variable NumberOfOranges @Def: The number of oranges the patient consumes @Shape: ['Integer'] 
NumberOfOranges = model.addVar(vtype=GRB.INTEGER, name=""NumberOfOranges"")
# @Variable NumberOfGrapefruits @Def: The number of grapefruits the patient consumes @Shape: ['Integer'] 
NumberOfGrapefruits = model.addVar(vtype=GRB.INTEGER, name=""NumberOfGrapefruits"")

# Constraints 
# @Constraint Constr_1 @Def: The patient must obtain at least MinVitaminC units of vitamin C.
model.addConstr(VitaminCPerOrange * NumberOfOranges + VitaminCPerGrapefruit * NumberOfGrapefruits >= MinVitaminC)
# @Constraint Constr_2 @Def: The patient must obtain at least MinVitaminA units of vitamin A.
model.addConstr(VitaminAPerOrange * NumberOfOranges + VitaminAPerGrapefruit * NumberOfGrapefruits >= MinVitaminA)
# @Constraint Constr_3 @Def: The number of oranges consumed must be at least MinOrangeToGrapefruitRatio times the number of grapefruits.
model.addConstr(NumberOfOranges >= MinOrangeToGrapefruitRatio * NumberOfGrapefruits)

# Objective 
# @Objective Objective @Def: Total sugar intake is calculated as SugarPerOrange times the number of oranges plus SugarPerGrapefruit times the number of grapefruits. The objective is to minimize the total sugar intake.
model.setObjective(SugarPerOrange * NumberOfOranges + SugarPerGrapefruit * NumberOfGrapefruits, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfOranges'] = NumberOfOranges.x
variables['NumberOfGrapefruits'] = NumberOfGrapefruits.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A university research lab can make two types of diabetes medicine, medicine A and medicine B. Per dose, medicine A takes 30 units of imported material and 50 units of mRNA to make. Per dose, medicine B takes 40 units of imported material and 30 units of mRNA to take. The lab has available at most 300 units of imported material and 400 units of mRNA. The lab can make at most 5 doses of medicine A and the number of doses of medicine B must be larger than the number of dosed of medicine A. If one dose of medicine A can treat 12 people and one dose of medicine B can treat 8 people, how many doses of each should be made to maximize the number of people that can be treated?","{""variables"": {""DosesA"": 3.7142857142857144, ""DosesB"": 4.714285714285714}, ""objective"": 82.28571428571428}","{""parametrized_description"": ""A university research lab produces two types of diabetes medicine, medicine A and medicine B. Each dose of medicine A requires ImportedMaterialPerDoseA units of imported material and MRNAPerDoseA units of mRNA. Each dose of medicine B requires ImportedMaterialPerDoseB units of imported material and MRNAPerDoseB units of mRNA. The lab has a maximum of MaxImportedMaterial units of imported material and MaxMRNA units of mRNA available. The production of medicine A is limited to MaxDosesA doses, and the number of doses of medicine B must exceed the number of doses of medicine A. The objective is to maximize the total number of people treated, where each dose of medicine A treats TreatmentPerDoseA individuals and each dose of medicine B treats TreatmentPerDoseB individuals."", ""keywords"": [""N.A.""], ""parameters"": {""ImportedMaterialPerDoseA"": {""description"": ""Amount of imported material required to produce one dose of medicine A"", ""shape"": []}, ""MRNAPerDoseA"": {""description"": ""Amount of mRNA required to produce one dose of medicine A"", ""shape"": []}, ""ImportedMaterialPerDoseB"": {""description"": ""Amount of imported material required to produce one dose of medicine B"", ""shape"": []}, ""MRNAPerDoseB"": {""description"": ""Amount of mRNA required to produce one dose of medicine B"", ""shape"": []}, ""MaxImportedMaterial"": {""description"": ""Maximum available units of imported material"", ""shape"": []}, ""MaxMRNA"": {""description"": ""Maximum available units of mRNA"", ""shape"": []}, ""MaxDosesA"": {""description"": ""Maximum number of doses of medicine A that can be produced"", ""shape"": []}, ""TreatmentPerDoseA"": {""description"": ""Number of people treated by one dose of medicine A"", ""shape"": []}, ""TreatmentPerDoseB"": {""description"": ""Number of people treated by one dose of medicine B"", ""shape"": []}}, ""variables"": {""DosesA"": {""description"": ""The number of doses of medicine A produced"", ""type"": ""continuous"", ""shape"": []}, ""DosesB"": {""description"": ""The number of doses of medicine B produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total imported material used by medicines A and B cannot exceed MaxImportedMaterial units."", ""formulation"": ""ImportedMaterialPerDoseA \\times DosesA + ImportedMaterialPerDoseB \\times DosesB \\leq MaxImportedMaterial"", ""code"": {""gurobipy"": ""model.addConstr(ImportedMaterialPerDoseA * DosesA + ImportedMaterialPerDoseB * DosesB <= MaxImportedMaterial)""}}, {""description"": ""The total mRNA used by medicines A and B cannot exceed MaxMRNA units."", ""formulation"": ""MRNAPerDoseA \\times DosesA + MRNAPerDoseB \\times DosesB \\leq MaxMRNA"", ""code"": {""gurobipy"": ""model.addConstr(MRNAPerDoseA * DosesA + MRNAPerDoseB * DosesB <= MaxMRNA)""}}, {""description"": ""The number of doses of medicine A produced cannot exceed MaxDosesA."", ""formulation"": ""DosesA \\leq MaxDosesA"", ""code"": {""gurobipy"": ""model.addConstr(DosesA <= MaxDosesA)""}}, {""description"": ""The number of doses of medicine B produced must exceed the number of doses of medicine A."", ""formulation"": ""DosesB \\geq DosesA + 1"", ""code"": {""gurobipy"": ""model.addConstr(DosesB >= DosesA + 1)""}}], ""objective"": {""description"": ""Maximize the total number of people treated, which is the sum of TreatmentPerDoseA times the number of doses of medicine A and TreatmentPerDoseB times the number of doses of medicine B."", ""formulation"": ""Max TreatmentPerDoseA \\times DosesA + TreatmentPerDoseB \\times DosesB"", ""code"": {""gurobipy"": ""model.setObjective(TreatmentPerDoseA * DosesA + TreatmentPerDoseB * DosesB, GRB.MAXIMIZE)""}}}","{""ImportedMaterialPerDoseA"": 30, ""MRNAPerDoseA"": 50, ""ImportedMaterialPerDoseB"": 40, ""MRNAPerDoseB"": 30, ""MaxImportedMaterial"": 300, ""MaxMRNA"": 400, ""MaxDosesA"": 5, ""TreatmentPerDoseA"": 12, ""TreatmentPerDoseB"": 8}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A university research lab produces two types of diabetes medicine, medicine A
and medicine B. Each dose of medicine A requires ImportedMaterialPerDoseA units
of imported material and MRNAPerDoseA units of mRNA. Each dose of medicine B
requires ImportedMaterialPerDoseB units of imported material and MRNAPerDoseB
units of mRNA. The lab has a maximum of MaxImportedMaterial units of imported
material and MaxMRNA units of mRNA available. The production of medicine A is
limited to MaxDosesA doses, and the number of doses of medicine B must exceed
the number of doses of medicine A. The objective is to maximize the total number
of people treated, where each dose of medicine A treats TreatmentPerDoseA
individuals and each dose of medicine B treats TreatmentPerDoseB individuals.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/128/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ImportedMaterialPerDoseA @Def: Amount of imported material required to produce one dose of medicine A @Shape: [] 
ImportedMaterialPerDoseA = data['ImportedMaterialPerDoseA']
# @Parameter MRNAPerDoseA @Def: Amount of mRNA required to produce one dose of medicine A @Shape: [] 
MRNAPerDoseA = data['MRNAPerDoseA']
# @Parameter ImportedMaterialPerDoseB @Def: Amount of imported material required to produce one dose of medicine B @Shape: [] 
ImportedMaterialPerDoseB = data['ImportedMaterialPerDoseB']
# @Parameter MRNAPerDoseB @Def: Amount of mRNA required to produce one dose of medicine B @Shape: [] 
MRNAPerDoseB = data['MRNAPerDoseB']
# @Parameter MaxImportedMaterial @Def: Maximum available units of imported material @Shape: [] 
MaxImportedMaterial = data['MaxImportedMaterial']
# @Parameter MaxMRNA @Def: Maximum available units of mRNA @Shape: [] 
MaxMRNA = data['MaxMRNA']
# @Parameter MaxDosesA @Def: Maximum number of doses of medicine A that can be produced @Shape: [] 
MaxDosesA = data['MaxDosesA']
# @Parameter TreatmentPerDoseA @Def: Number of people treated by one dose of medicine A @Shape: [] 
TreatmentPerDoseA = data['TreatmentPerDoseA']
# @Parameter TreatmentPerDoseB @Def: Number of people treated by one dose of medicine B @Shape: [] 
TreatmentPerDoseB = data['TreatmentPerDoseB']

# Variables 
# @Variable DosesA @Def: The number of doses of medicine A produced @Shape: [] 
DosesA = model.addVar(vtype=GRB.CONTINUOUS, name=""DosesA"")
# @Variable DosesB @Def: The number of doses of medicine B produced @Shape: [] 
DosesB = model.addVar(vtype=GRB.CONTINUOUS, name=""DosesB"")

# Constraints 
# @Constraint Constr_1 @Def: The total imported material used by medicines A and B cannot exceed MaxImportedMaterial units.
model.addConstr(ImportedMaterialPerDoseA * DosesA + ImportedMaterialPerDoseB * DosesB <= MaxImportedMaterial)
# @Constraint Constr_2 @Def: The total mRNA used by medicines A and B cannot exceed MaxMRNA units.
model.addConstr(MRNAPerDoseA * DosesA + MRNAPerDoseB * DosesB <= MaxMRNA)
# @Constraint Constr_3 @Def: The number of doses of medicine A produced cannot exceed MaxDosesA.
model.addConstr(DosesA <= MaxDosesA)
# @Constraint Constr_4 @Def: The number of doses of medicine B produced must exceed the number of doses of medicine A.
model.addConstr(DosesB >= DosesA + 1)

# Objective 
# @Objective Objective @Def: Maximize the total number of people treated, which is the sum of TreatmentPerDoseA times the number of doses of medicine A and TreatmentPerDoseB times the number of doses of medicine B.
model.setObjective(TreatmentPerDoseA * DosesA + TreatmentPerDoseB * DosesB, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['DosesA'] = DosesA.x
variables['DosesB'] = DosesB.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A popup clinic is doing virus testing with either spit tests or swabs. A spit test takes 10 minutes to administer while a  swab takes 15 minutes to administer. Since the spit test is more accurate, at least twice as many spit tests should be given as  swabs. However, at least 20  swabs must be administers. If the popup clinic operates for 8000 minutes, maximize the number of tests that can be administered.","{""variables"": {""NumberOfSpitTests"": 770.0, ""NumberOfSwabTests"": 20.0}, ""objective"": 790.0}","{""parametrized_description"": ""A popup clinic administers two types of virus tests: spit tests and swab tests. Administering a spit test takes TimeSpitTest minutes and administering a swab test takes TimeSwabTest minutes. At least MinRatioSpitToSwab times as many spit tests as swab tests must be administered, and at least MinSwabTests swab tests must be administered. The clinic operates for TotalOperatingTime minutes. The objective is to maximize the total number of tests administered."", ""keywords"": [""N.A.""], ""parameters"": {""TimeSpitTest"": {""description"": ""Time to administer a spit test"", ""shape"": []}, ""TimeSwabTest"": {""description"": ""Time to administer a swab test"", ""shape"": []}, ""MinRatioSpitToSwab"": {""description"": ""Minimum ratio of spit tests to swab tests"", ""shape"": []}, ""MinSwabTests"": {""description"": ""Minimum number of swab tests to administer"", ""shape"": []}, ""TotalOperatingTime"": {""description"": ""Total operating time in minutes"", ""shape"": []}}, ""variables"": {""NumberOfSpitTests"": {""description"": ""The number of spit tests to administer"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfSwabTests"": {""description"": ""The number of swab tests to administer"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""Administering a spit test takes TimeSpitTest minutes and administering a swab test takes TimeSwabTest minutes. The total operating time cannot exceed TotalOperatingTime minutes."", ""formulation"": ""TimeSpitTest \\times NumberOfSpitTests + TimeSwabTest \\times NumberOfSwabTests \\leq TotalOperatingTime"", ""code"": {""gurobipy"": ""model.addConstr(TimeSpitTest * NumberOfSpitTests + TimeSwabTest * NumberOfSwabTests <= TotalOperatingTime)""}}, {""description"": ""At least MinRatioSpitToSwab times as many spit tests as swab tests must be administered."", ""formulation"": ""NumberOfSpitTests \\geq MinRatioSpitToSwab \\times NumberOfSwabTests"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfSpitTests >= MinRatioSpitToSwab * NumberOfSwabTests)""}}, {""description"": ""At least MinSwabTests swab tests must be administered."", ""formulation"": ""NumberOfSwabTests \\geq MinSwabTests"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfSwabTests >= MinSwabTests)""}}], ""objective"": {""description"": ""The total number of tests administered is the sum of spit tests and swab tests. The objective is to maximize the total number of tests administered."", ""formulation"": ""Max NumberOfSpitTests + NumberOfSwabTests"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfSpitTests + NumberOfSwabTests, GRB.MAXIMIZE)""}}}","{""TimeSpitTest"": 10, ""TimeSwabTest"": 15, ""MinRatioSpitToSwab"": 2, ""MinSwabTests"": 20, ""TotalOperatingTime"": 8000}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A popup clinic administers two types of virus tests: spit tests and swab tests.
Administering a spit test takes TimeSpitTest minutes and administering a swab
test takes TimeSwabTest minutes. At least MinRatioSpitToSwab times as many spit
tests as swab tests must be administered, and at least MinSwabTests swab tests
must be administered. The clinic operates for TotalOperatingTime minutes. The
objective is to maximize the total number of tests administered.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/129/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TimeSpitTest @Def: Time to administer a spit test @Shape: [] 
TimeSpitTest = data['TimeSpitTest']
# @Parameter TimeSwabTest @Def: Time to administer a swab test @Shape: [] 
TimeSwabTest = data['TimeSwabTest']
# @Parameter MinRatioSpitToSwab @Def: Minimum ratio of spit tests to swab tests @Shape: [] 
MinRatioSpitToSwab = data['MinRatioSpitToSwab']
# @Parameter MinSwabTests @Def: Minimum number of swab tests to administer @Shape: [] 
MinSwabTests = data['MinSwabTests']
# @Parameter TotalOperatingTime @Def: Total operating time in minutes @Shape: [] 
TotalOperatingTime = data['TotalOperatingTime']

# Variables 
# @Variable NumberOfSpitTests @Def: The number of spit tests to administer @Shape: [] 
NumberOfSpitTests = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfSpitTests"")
# @Variable NumberOfSwabTests @Def: The number of swab tests to administer @Shape: [] 
NumberOfSwabTests = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfSwabTests"")

# Constraints 
# @Constraint Constr_1 @Def: Administering a spit test takes TimeSpitTest minutes and administering a swab test takes TimeSwabTest minutes. The total operating time cannot exceed TotalOperatingTime minutes.
model.addConstr(TimeSpitTest * NumberOfSpitTests + TimeSwabTest * NumberOfSwabTests <= TotalOperatingTime)
# @Constraint Constr_2 @Def: At least MinRatioSpitToSwab times as many spit tests as swab tests must be administered.
model.addConstr(NumberOfSpitTests >= MinRatioSpitToSwab * NumberOfSwabTests)
# @Constraint Constr_3 @Def: At least MinSwabTests swab tests must be administered.
model.addConstr(NumberOfSwabTests >= MinSwabTests)

# Objective 
# @Objective Objective @Def: The total number of tests administered is the sum of spit tests and swab tests. The objective is to maximize the total number of tests administered.
model.setObjective(NumberOfSpitTests + NumberOfSwabTests, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfSpitTests'] = NumberOfSpitTests.x
variables['NumberOfSwabTests'] = NumberOfSwabTests.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A patient is undergoing radiation treatment involving two beams, Beam 1 and Beam 2. Beam 1 delivers a dose of 0.3 units of medicine per minute to the benign area of the pancreas and 0.2 units of medicine per minute to the benign area of the skin. Beam 2 delivers 0.2 units of medicine per minute to the benign area of the pancreas and 0.1 units of medicine per minute to the benign area of the skin.  In addition, beam 1 delivers 0.6 units of medicine per minute to the tumor and beam 2 delivers 0.4 units of medicine per minute to the tumor. At most 4 units of medicine should be received by the skin and at least 3 units of medicine should be delivered to the tumor.  How many minutes of each beam should be used to minimize the total radiation received by the pancreas?","{""variables"": {""MinutesBeam1"": 0.0, ""MinutesBeam2"": 7.5}, ""objective"": 1.5}","{""parametrized_description"": ""A patient receives radiation treatment using Beam1 and Beam2. Beam1 delivers DoseRateBeam1BenignPancreas units per minute to the benign area of the pancreas, DoseRateBeam1BenignSkin units per minute to the benign area of the skin, and DoseRateBeam1Tumor units per minute to the tumor. Similarly, Beam2 delivers DoseRateBeam2BenignPancreas units per minute to the benign area of the pancreas, DoseRateBeam2BenignSkin units per minute to the benign area of the skin, and DoseRateBeam2Tumor units per minute to the tumor. The total dose to the skin must not exceed MaxDoseSkin, and the total dose to the tumor must be at least MinDoseTumor. The objective is to determine the number of minutes to use Beam1 and Beam2 to minimize the total radiation received by the pancreas."", ""keywords"": [""N.A.""], ""parameters"": {""DoseRateBeam1BenignPancreas"": {""description"": ""Dose delivered per minute by Beam 1 to the benign area of the pancreas"", ""shape"": []}, ""DoseRateBeam1BenignSkin"": {""description"": ""Dose delivered per minute by Beam 1 to the benign area of the skin"", ""shape"": []}, ""DoseRateBeam1Tumor"": {""description"": ""Dose delivered per minute by Beam 1 to the tumor"", ""shape"": []}, ""DoseRateBeam2BenignPancreas"": {""description"": ""Dose delivered per minute by Beam 2 to the benign area of the pancreas"", ""shape"": []}, ""DoseRateBeam2BenignSkin"": {""description"": ""Dose delivered per minute by Beam 2 to the benign area of the skin"", ""shape"": []}, ""DoseRateBeam2Tumor"": {""description"": ""Dose delivered per minute by Beam 2 to the tumor"", ""shape"": []}, ""MaxDoseSkin"": {""description"": ""Maximum allowable dose to the skin"", ""shape"": []}, ""MinDoseTumor"": {""description"": ""Minimum required dose to the tumor"", ""shape"": []}}, ""variables"": {""MinutesBeam1"": {""description"": ""The number of minutes Beam 1 is used"", ""type"": ""continuous"", ""shape"": []}, ""MinutesBeam2"": {""description"": ""The number of minutes Beam 2 is used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total dose to the skin is DoseRateBeam1BenignSkin multiplied by the number of minutes Beam1 is used plus DoseRateBeam2BenignSkin multiplied by the number of minutes Beam2 is used. The total dose to the skin must not exceed MaxDoseSkin."", ""formulation"": ""DoseRateBeam1BenignSkin \\cdot MinutesBeam1 + DoseRateBeam2BenignSkin \\cdot MinutesBeam2 \\leq MaxDoseSkin"", ""code"": {""gurobipy"": ""model.addConstr(DoseRateBeam1BenignSkin * MinutesBeam1 + DoseRateBeam2BenignSkin * MinutesBeam2 <= MaxDoseSkin)""}}, {""description"": ""The total dose to the tumor is DoseRateBeam1Tumor multiplied by the number of minutes Beam1 is used plus DoseRateBeam2Tumor multiplied by the number of minutes Beam2 is used. The total dose to the tumor must be at least MinDoseTumor."", ""formulation"": ""DoseRateBeam1Tumor \\times MinutesBeam1 + DoseRateBeam2Tumor \\times MinutesBeam2 \\geq MinDoseTumor"", ""code"": {""gurobipy"": ""model.addConstr(DoseRateBeam1Tumor * MinutesBeam1 + DoseRateBeam2Tumor * MinutesBeam2 >= MinDoseTumor)""}}], ""objective"": {""description"": ""Minimize the total radiation received by the pancreas, which is calculated as DoseRateBeam1BenignPancreas multiplied by the number of minutes Beam1 is used plus DoseRateBeam2BenignPancreas multiplied by the number of minutes Beam2 is used."", ""formulation"": ""Min \\ DoseRateBeam1BenignPancreas \\times MinutesBeam1 + DoseRateBeam2BenignPancreas \\times MinutesBeam2"", ""code"": {""gurobipy"": ""model.setObjective(DoseRateBeam1BenignPancreas * MinutesBeam1 + DoseRateBeam2BenignPancreas * MinutesBeam2, GRB.MINIMIZE)""}}}","{""DoseRateBeam1BenignPancreas"": 0.3, ""DoseRateBeam1BenignSkin"": 0.2, ""DoseRateBeam1Tumor"": 0.6, ""DoseRateBeam2BenignPancreas"": 0.2, ""DoseRateBeam2BenignSkin"": 0.1, ""DoseRateBeam2Tumor"": 0.4, ""MaxDoseSkin"": 4, ""MinDoseTumor"": 3}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A patient receives radiation treatment using Beam1 and Beam2. Beam1 delivers
DoseRateBeam1BenignPancreas units per minute to the benign area of the pancreas,
DoseRateBeam1BenignSkin units per minute to the benign area of the skin, and
DoseRateBeam1Tumor units per minute to the tumor. Similarly, Beam2 delivers
DoseRateBeam2BenignPancreas units per minute to the benign area of the pancreas,
DoseRateBeam2BenignSkin units per minute to the benign area of the skin, and
DoseRateBeam2Tumor units per minute to the tumor. The total dose to the skin
must not exceed MaxDoseSkin, and the total dose to the tumor must be at least
MinDoseTumor. The objective is to determine the number of minutes to use Beam1
and Beam2 to minimize the total radiation received by the pancreas.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/130/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter DoseRateBeam1BenignPancreas @Def: Dose delivered per minute by Beam 1 to the benign area of the pancreas @Shape: [] 
DoseRateBeam1BenignPancreas = data['DoseRateBeam1BenignPancreas']
# @Parameter DoseRateBeam1BenignSkin @Def: Dose delivered per minute by Beam 1 to the benign area of the skin @Shape: [] 
DoseRateBeam1BenignSkin = data['DoseRateBeam1BenignSkin']
# @Parameter DoseRateBeam1Tumor @Def: Dose delivered per minute by Beam 1 to the tumor @Shape: [] 
DoseRateBeam1Tumor = data['DoseRateBeam1Tumor']
# @Parameter DoseRateBeam2BenignPancreas @Def: Dose delivered per minute by Beam 2 to the benign area of the pancreas @Shape: [] 
DoseRateBeam2BenignPancreas = data['DoseRateBeam2BenignPancreas']
# @Parameter DoseRateBeam2BenignSkin @Def: Dose delivered per minute by Beam 2 to the benign area of the skin @Shape: [] 
DoseRateBeam2BenignSkin = data['DoseRateBeam2BenignSkin']
# @Parameter DoseRateBeam2Tumor @Def: Dose delivered per minute by Beam 2 to the tumor @Shape: [] 
DoseRateBeam2Tumor = data['DoseRateBeam2Tumor']
# @Parameter MaxDoseSkin @Def: Maximum allowable dose to the skin @Shape: [] 
MaxDoseSkin = data['MaxDoseSkin']
# @Parameter MinDoseTumor @Def: Minimum required dose to the tumor @Shape: [] 
MinDoseTumor = data['MinDoseTumor']

# Variables 
# @Variable MinutesBeam1 @Def: The number of minutes Beam 1 is used @Shape: [] 
MinutesBeam1 = model.addVar(vtype=GRB.CONTINUOUS, name=""MinutesBeam1"")
# @Variable MinutesBeam2 @Def: The number of minutes Beam 2 is used @Shape: [] 
MinutesBeam2 = model.addVar(vtype=GRB.CONTINUOUS, name=""MinutesBeam2"")

# Constraints 
# @Constraint Constr_1 @Def: The total dose to the skin is DoseRateBeam1BenignSkin multiplied by the number of minutes Beam1 is used plus DoseRateBeam2BenignSkin multiplied by the number of minutes Beam2 is used. The total dose to the skin must not exceed MaxDoseSkin.
model.addConstr(DoseRateBeam1BenignSkin * MinutesBeam1 + DoseRateBeam2BenignSkin * MinutesBeam2 <= MaxDoseSkin)
# @Constraint Constr_2 @Def: The total dose to the tumor is DoseRateBeam1Tumor multiplied by the number of minutes Beam1 is used plus DoseRateBeam2Tumor multiplied by the number of minutes Beam2 is used. The total dose to the tumor must be at least MinDoseTumor.
model.addConstr(DoseRateBeam1Tumor * MinutesBeam1 + DoseRateBeam2Tumor * MinutesBeam2 >= MinDoseTumor)

# Objective 
# @Objective Objective @Def: Minimize the total radiation received by the pancreas, which is calculated as DoseRateBeam1BenignPancreas multiplied by the number of minutes Beam1 is used plus DoseRateBeam2BenignPancreas multiplied by the number of minutes Beam2 is used.
model.setObjective(DoseRateBeam1BenignPancreas * MinutesBeam1 + DoseRateBeam2BenignPancreas * MinutesBeam2, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['MinutesBeam1'] = MinutesBeam1.x
variables['MinutesBeam2'] = MinutesBeam2.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A body builder buys pre prepared meals, a turkey dinner and a tuna salad sandwich. The turkey dinner contains 20 grams of protein, 30 grams of carbs, and 12 grams of fat. The tuna salad sandwich contains 18 grams of protein, 25 grams of carbs, and 8 grams of fat. The bodybuilder wants to get at least 150 grams of protein and 200 grams of carbs. In addition because the turkey dinner is expensive, at most 40% of the meals should be turkey dinner. How many of each meal should he eat if he wants to minimize his fat intake?","{""variables"": {""QuantityTurkey"": 0.0, ""QuantityTuna"": 8.333333333333334}, ""objective"": 66.66666666666667}","{""parametrized_description"": ""A bodybuilder purchases two types of meals: MealA and MealB. Each MealA contains ProteinTurkey amount of protein, CarbsTurkey amount of carbohydrates, and FatTurkey amount of fat. Each MealB contains ProteinTuna amount of protein, CarbsTuna amount of carbohydrates, and FatTuna amount of fat. The bodybuilder aims to obtain at least MinProtein total protein and at least MinCarbs total carbohydrates. Additionally, no more than MaxTurkeyFraction fraction of the total meals can be MealA. The objective is to minimize the total fat intake."", ""keywords"": [""N.A.""], ""parameters"": {""ProteinTurkey"": {""description"": ""Amount of protein in one turkey dinner"", ""shape"": []}, ""CarbsTurkey"": {""description"": ""Amount of carbohydrates in one turkey dinner"", ""shape"": []}, ""FatTurkey"": {""description"": ""Amount of fat in one turkey dinner"", ""shape"": []}, ""ProteinTuna"": {""description"": ""Amount of protein in one tuna salad sandwich"", ""shape"": []}, ""CarbsTuna"": {""description"": ""Amount of carbohydrates in one tuna salad sandwich"", ""shape"": []}, ""FatTuna"": {""description"": ""Amount of fat in one tuna salad sandwich"", ""shape"": []}, ""MinProtein"": {""description"": ""Minimum required total protein"", ""shape"": []}, ""MinCarbs"": {""description"": ""Minimum required total carbohydrates"", ""shape"": []}, ""MaxTurkeyFraction"": {""description"": ""Maximum fraction of meals that can be turkey dinners"", ""shape"": []}}, ""variables"": {""QuantityTurkey"": {""description"": ""The number of turkey dinners"", ""type"": ""continuous"", ""shape"": []}, ""QuantityTuna"": {""description"": ""The number of tuna salad sandwiches"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total protein from MealA and MealB must be at least MinProtein."", ""formulation"": ""ProteinTurkey \\cdot QuantityTurkey + ProteinTuna \\cdot QuantityTuna \\geq MinProtein"", ""code"": {""gurobipy"": ""model.addConstr(ProteinTurkey * QuantityTurkey + ProteinTuna * QuantityTuna >= MinProtein)""}}, {""description"": ""The total carbohydrates from MealA and MealB must be at least MinCarbs."", ""formulation"": ""CarbsTurkey \\cdot QuantityTurkey + CarbsTuna \\cdot QuantityTuna \\geq MinCarbs"", ""code"": {""gurobipy"": ""model.addConstr(CarbsTurkey * QuantityTurkey + CarbsTuna * QuantityTuna >= MinCarbs)""}}, {""description"": ""No more than MaxTurkeyFraction fraction of the total meals can be MealA."", ""formulation"": ""QuantityTurkey \\leq MaxTurkeyFraction \\times \\left( QuantityTurkey + QuantityTuna \\right )"", ""code"": {""gurobipy"": ""model.addConstr(QuantityTurkey <= MaxTurkeyFraction * (QuantityTurkey + QuantityTuna))""}}], ""objective"": {""description"": ""Minimize the total fat intake."", ""formulation"": ""Min \\ FatTurkey \\cdot QuantityTurkey + FatTuna \\cdot QuantityTuna"", ""code"": {""gurobipy"": ""model.setObjective(FatTurkey * QuantityTurkey + FatTuna * QuantityTuna, GRB.MINIMIZE)""}}}","{""ProteinTurkey"": 20, ""CarbsTurkey"": 30, ""FatTurkey"": 12, ""ProteinTuna"": 18, ""CarbsTuna"": 25, ""FatTuna"": 8, ""MinProtein"": 150, ""MinCarbs"": 200, ""MaxTurkeyFraction"": 0.4}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A bodybuilder purchases two types of meals: MealA and MealB. Each MealA contains
ProteinTurkey amount of protein, CarbsTurkey amount of carbohydrates, and
FatTurkey amount of fat. Each MealB contains ProteinTuna amount of protein,
CarbsTuna amount of carbohydrates, and FatTuna amount of fat. The bodybuilder
aims to obtain at least MinProtein total protein and at least MinCarbs total
carbohydrates. Additionally, no more than MaxTurkeyFraction fraction of the
total meals can be MealA. The objective is to minimize the total fat intake.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/131/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProteinTurkey @Def: Amount of protein in one turkey dinner @Shape: [] 
ProteinTurkey = data['ProteinTurkey']
# @Parameter CarbsTurkey @Def: Amount of carbohydrates in one turkey dinner @Shape: [] 
CarbsTurkey = data['CarbsTurkey']
# @Parameter FatTurkey @Def: Amount of fat in one turkey dinner @Shape: [] 
FatTurkey = data['FatTurkey']
# @Parameter ProteinTuna @Def: Amount of protein in one tuna salad sandwich @Shape: [] 
ProteinTuna = data['ProteinTuna']
# @Parameter CarbsTuna @Def: Amount of carbohydrates in one tuna salad sandwich @Shape: [] 
CarbsTuna = data['CarbsTuna']
# @Parameter FatTuna @Def: Amount of fat in one tuna salad sandwich @Shape: [] 
FatTuna = data['FatTuna']
# @Parameter MinProtein @Def: Minimum required total protein @Shape: [] 
MinProtein = data['MinProtein']
# @Parameter MinCarbs @Def: Minimum required total carbohydrates @Shape: [] 
MinCarbs = data['MinCarbs']
# @Parameter MaxTurkeyFraction @Def: Maximum fraction of meals that can be turkey dinners @Shape: [] 
MaxTurkeyFraction = data['MaxTurkeyFraction']

# Variables 
# @Variable QuantityTurkey @Def: The number of turkey dinners @Shape: [] 
QuantityTurkey = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityTurkey"")
# @Variable QuantityTuna @Def: The number of tuna salad sandwiches @Shape: [] 
QuantityTuna = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityTuna"")

# Constraints 
# @Constraint Constr_1 @Def: The total protein from MealA and MealB must be at least MinProtein.
model.addConstr(ProteinTurkey * QuantityTurkey + ProteinTuna * QuantityTuna >= MinProtein)
# @Constraint Constr_2 @Def: The total carbohydrates from MealA and MealB must be at least MinCarbs.
model.addConstr(CarbsTurkey * QuantityTurkey + CarbsTuna * QuantityTuna >= MinCarbs)
# @Constraint Constr_3 @Def: No more than MaxTurkeyFraction fraction of the total meals can be MealA.
model.addConstr(QuantityTurkey <= MaxTurkeyFraction * (QuantityTurkey + QuantityTuna))

# Objective 
# @Objective Objective @Def: Minimize the total fat intake.
model.setObjective(FatTurkey * QuantityTurkey + FatTuna * QuantityTuna, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityTurkey'] = QuantityTurkey.x
variables['QuantityTuna'] = QuantityTuna.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A chemistry teacher teaches her students two experiments, experiment 1 and experiment 2. In experiment 1, 3 units of the red liquid and 4 units of the blue liquid mix to create 5 units of green gas. In experiment 2, 5 units of the red liquid and 3 units of the blue liquid mix to create 6 units of the green gas. In addition, experiment 1 produces 1 units of smelly gas while experiment 2 produces 2 units of smelly gas.  The lab has available 80 units of red liquid and 70 units of blue liquid. If at most 10 units of smelly gas can be produced, how many experiments of each should be done to maximize the total amount of green gas produced?","{""variables"": {""ExperimentPerformed"": [1.0, 1.0]}, ""objective"": 11.0}","{""parametrized_description"": ""A chemistry teacher conducts a set of NumExperiments different experiments. Each experiment i requires RedUsage[i] units of red liquid and BlueUsage[i] units of blue liquid, and produces GreenGasProduction[i] units of green gas and SmellyGasProduction[i] units of smelly gas. The total available red liquid is TotalRed units and the total available blue liquid is TotalBlue units. Additionally, the total smelly gas produced must not exceed MaxSmelly units. The objective is to determine the number of each experiment to perform in order to maximize the total GreenGasProduction."", ""keywords"": [""N.A.""], ""parameters"": {""NumExperiments"": {""description"": ""Number of different experiments"", ""shape"": []}, ""RedUsage"": {""description"": ""Amount of red liquid required for each experiment"", ""shape"": [""NumExperiments""]}, ""BlueUsage"": {""description"": ""Amount of blue liquid required for each experiment"", ""shape"": [""NumExperiments""]}, ""GreenGasProduction"": {""description"": ""Amount of green gas produced by each experiment"", ""shape"": [""NumExperiments""]}, ""SmellyGasProduction"": {""description"": ""Amount of smelly gas produced by each experiment"", ""shape"": [""NumExperiments""]}, ""TotalRed"": {""description"": ""Total units of red liquid available"", ""shape"": []}, ""TotalBlue"": {""description"": ""Total units of blue liquid available"", ""shape"": []}, ""MaxSmelly"": {""description"": ""Maximum units of smelly gas allowed"", ""shape"": []}}, ""variables"": {""ExperimentPerformed"": {""description"": ""Binary variable indicating whether each experiment is performed"", ""type"": ""continuous"", ""shape"": [""NumExperiments""]}}, ""constraints"": [{""description"": ""The total red liquid used by all experiments does not exceed TotalRed units."", ""formulation"": ""\\sum_{i=1}^{\\text{NumExperiments}} \\text{RedUsage}_i \\cdot \\text{ExperimentPerformed}_i \\leq \\text{TotalRed}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(RedUsage[i] * ExperimentPerformed[i] for i in range(NumExperiments)) <= TotalRed)""}}, {""description"": ""The total blue liquid used by all experiments does not exceed TotalBlue units."", ""formulation"": ""\\sum_{i=1}^{\\text{NumExperiments}} \\text{BlueUsage}_i \\cdot \\text{ExperimentPerformed}_i \\leq \\text{TotalBlue}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(BlueUsage[i] * ExperimentPerformed[i] for i in range(NumExperiments)) <= TotalBlue)""}}, {""description"": ""The total smelly gas produced by all experiments does not exceed MaxSmelly units."", ""formulation"": ""\\sum_{i=1}^{NumExperiments} \\text{SmellyGasProduction}_i \\cdot \\text{ExperimentPerformed}_i \\leq \\text{MaxSmelly}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(SmellyGasProduction[i] * ExperimentPerformed[i] for i in range(NumExperiments)) <= MaxSmelly)""}}], ""objective"": {""description"": ""Maximize the total GreenGasProduction by determining the number of each experiment to perform."", ""formulation"": ""Max \\sum_{i=1}^{\\text{NumExperiments}} \\text{GreenGasProduction}_i \\cdot \\text{ExperimentPerformed}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(GreenGasProduction[i] * ExperimentPerformed[i] for i in range(NumExperiments)), GRB.MAXIMIZE)""}}}","{""NumExperiments"": 2, ""RedUsage"": [3, 5], ""BlueUsage"": [4, 3], ""GreenGasProduction"": [5, 6], ""SmellyGasProduction"": [1, 2], ""TotalRed"": 80, ""TotalBlue"": 70, ""MaxSmelly"": 10}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A chemistry teacher conducts a set of NumExperiments different experiments. Each
experiment i requires RedUsage[i] units of red liquid and BlueUsage[i] units of
blue liquid, and produces GreenGasProduction[i] units of green gas and
SmellyGasProduction[i] units of smelly gas. The total available red liquid is
TotalRed units and the total available blue liquid is TotalBlue units.
Additionally, the total smelly gas produced must not exceed MaxSmelly units. The
objective is to determine the number of each experiment to perform in order to
maximize the total GreenGasProduction.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/132/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumExperiments @Def: Number of different experiments @Shape: [] 
NumExperiments = data['NumExperiments']
# @Parameter RedUsage @Def: Amount of red liquid required for each experiment @Shape: ['NumExperiments'] 
RedUsage = data['RedUsage']
# @Parameter BlueUsage @Def: Amount of blue liquid required for each experiment @Shape: ['NumExperiments'] 
BlueUsage = data['BlueUsage']
# @Parameter GreenGasProduction @Def: Amount of green gas produced by each experiment @Shape: ['NumExperiments'] 
GreenGasProduction = data['GreenGasProduction']
# @Parameter SmellyGasProduction @Def: Amount of smelly gas produced by each experiment @Shape: ['NumExperiments'] 
SmellyGasProduction = data['SmellyGasProduction']
# @Parameter TotalRed @Def: Total units of red liquid available @Shape: [] 
TotalRed = data['TotalRed']
# @Parameter TotalBlue @Def: Total units of blue liquid available @Shape: [] 
TotalBlue = data['TotalBlue']
# @Parameter MaxSmelly @Def: Maximum units of smelly gas allowed @Shape: [] 
MaxSmelly = data['MaxSmelly']

# Variables 
# @Variable ExperimentPerformed @Def: Binary variable indicating whether each experiment is performed @Shape: ['NumExperiments'] 
ExperimentPerformed = model.addVars(NumExperiments, vtype=GRB.BINARY, name='ExperimentPerformed')

# Constraints 
# @Constraint Constr_1 @Def: The total red liquid used by all experiments does not exceed TotalRed units.
model.addConstr(quicksum(RedUsage[i] * ExperimentPerformed[i] for i in range(NumExperiments)) <= TotalRed)
# @Constraint Constr_2 @Def: The total blue liquid used by all experiments does not exceed TotalBlue units.
model.addConstr(quicksum(BlueUsage[i] * ExperimentPerformed[i] for i in range(NumExperiments)) <= TotalBlue)
# @Constraint Constr_3 @Def: The total smelly gas produced by all experiments does not exceed MaxSmelly units.
model.addConstr(quicksum(SmellyGasProduction[i] * ExperimentPerformed[i] for i in range(NumExperiments)) <= MaxSmelly)

# Objective 
# @Objective Objective @Def: Maximize the total GreenGasProduction by determining the number of each experiment to perform.
model.setObjective(quicksum(GreenGasProduction[i] * ExperimentPerformed[i] for i in range(NumExperiments)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ExperimentPerformed'] = [v.X for v in ExperimentPerformed.values()]
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A lab has 1000 units of medicinal ingredients to make two pills, a large pill and a small pill. A large pill requires 3 units of medicinal ingredients and 2 units of filler. A small pill requires 2 units of medicinal ingredients and 1 unit of filler. The lab has to make at least 100 large pills. However, since small pills are more popular at least 60% of the total number of pills must be small. How many of each should be made to minimize the total number of filler material needed?","{""variables"": {""PillsProduced"": {""0"": 100.0, ""1"": 150.0}}, ""objective"": 350.0}","{""parametrized_description"": ""A lab has TotalMedicinalIngredients units of medicinal ingredients available to produce NumPillTypes different types of pills. Each pill type i requires RequiredMedicinal[i] units of medicinal ingredients and RequiredFiller[i] units of filler. The lab must produce at least MinimumPills[i] units of pill type i. Additionally, at least MinimumProportion[i] of the total number of pills produced must be of pill type i. The objective is to determine the number of each pill type to minimize the total filler material used."", ""keywords"": [""N.A.""], ""parameters"": {""TotalMedicinalIngredients"": {""description"": ""Total units of medicinal ingredients available to produce pills"", ""shape"": []}, ""NumPillTypes"": {""description"": ""Number of different pill types"", ""shape"": []}, ""RequiredMedicinal"": {""description"": ""Units of medicinal ingredients required to produce one unit of pill type i"", ""shape"": [""NumPillTypes""]}, ""RequiredFiller"": {""description"": ""Units of filler required to produce one unit of pill type i"", ""shape"": [""NumPillTypes""]}, ""MinimumPills"": {""description"": ""Minimum number of pills that must be produced for pill type i"", ""shape"": [""NumPillTypes""]}, ""MinimumProportion"": {""description"": ""Minimum proportion of total pills that must be of pill type i"", ""shape"": [""NumPillTypes""]}}, ""variables"": {""PillsProduced"": {""description"": ""The number of pills produced for each pill type"", ""type"": ""continuous"", ""shape"": [""NumPillTypes""]}}, ""constraints"": [{""description"": ""The total medicinal ingredients used cannot exceed TotalMedicinalIngredients."", ""formulation"": ""\\sum_{i=1}^{NumPillTypes} RequiredMedicinal_i \\times PillsProduced_i \\leq TotalMedicinalIngredients"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(RequiredMedicinal[i] * PillsProduced[i] for i in range(NumPillTypes)) <= TotalMedicinalIngredients)""}}, {""description"": ""For each pill type i, at least MinimumPills[i] units must be produced."", ""formulation"": ""PillsProduced_i \\geq MinimumPills_i \\quad \\forall i = 1, \\dots, NumPillTypes"", ""code"": {""gurobipy"": ""model.addConstrs((PillsProduced[i] >= MinimumPills[i] for i in range(NumPillTypes)), \""MinPills\"")""}}, {""description"": ""For each pill type i, at least MinimumProportion[i] of the total pills produced must be of pill type i."", ""formulation"": ""\\text{PillsProduced}_i \\geq \\text{MinimumProportion}_i \\cdot \\sum_{j=1}^{\\text{NumPillTypes}} \\text{PillsProduced}_j, \\quad \\forall i \\in \\{1, \\dots, \\text{NumPillTypes}\\}"", ""code"": {""gurobipy"": ""model.addConstrs((PillsProduced[i] >= MinimumProportion[i] * quicksum(PillsProduced[j] for j in range(NumPillTypes)) for i in range(NumPillTypes)), 'MinimumProportion')""}}], ""objective"": {""description"": ""Minimize the total filler material used, which is the sum of RequiredFiller[i] multiplied by the number of pills produced for each pill type i."", ""formulation"": ""Min \\sum_{i=1}^{\\text{NumPillTypes}} \\text{RequiredFiller}[i] \\times \\text{PillsProduced}[i]"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(RequiredFiller[i] * PillsProduced[i] for i in range(NumPillTypes)), GRB.MINIMIZE)""}}}","{""TotalMedicinalIngredients"": 1000, ""NumPillTypes"": 2, ""RequiredMedicinal"": [3, 2], ""RequiredFiller"": [2, 1], ""MinimumPills"": [100, 0], ""MinimumProportion"": [0, 0.6]}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A lab has TotalMedicinalIngredients units of medicinal ingredients available to
produce NumPillTypes different types of pills. Each pill type i requires
RequiredMedicinal[i] units of medicinal ingredients and RequiredFiller[i] units
of filler. The lab must produce at least MinimumPills[i] units of pill type i.
Additionally, at least MinimumProportion[i] of the total number of pills
produced must be of pill type i. The objective is to determine the number of
each pill type to minimize the total filler material used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/133/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
            
# Parameters 
# @Parameter TotalMedicinalIngredients @Def: Total units of medicinal ingredients available to produce pills @Shape: [] 
TotalMedicinalIngredients = data['TotalMedicinalIngredients']
# @Parameter NumPillTypes @Def: Number of different pill types @Shape: [] 
NumPillTypes = data['NumPillTypes']
# @Parameter RequiredMedicinal @Def: Units of medicinal ingredients required to produce one unit of pill type i @Shape: ['NumPillTypes'] 
RequiredMedicinal = data['RequiredMedicinal']
# @Parameter RequiredFiller @Def: Units of filler required to produce one unit of pill type i @Shape: ['NumPillTypes'] 
RequiredFiller = data['RequiredFiller']
# @Parameter MinimumPills @Def: Minimum number of pills that must be produced for pill type i @Shape: ['NumPillTypes'] 
MinimumPills = data['MinimumPills']
# @Parameter MinimumProportion @Def: Minimum proportion of total pills that must be of pill type i @Shape: ['NumPillTypes'] 
MinimumProportion = data['MinimumProportion']

# Variables 
# @Variable PillsProduced @Def: The number of pills produced for each pill type @Shape: ['NumPillTypes'] 
PillsProduced = model.addVars(NumPillTypes, vtype=GRB.INTEGER, name=""PillsProduced"")

# Constraints 
# @Constraint Constr_1 @Def: The total medicinal ingredients used cannot exceed TotalMedicinalIngredients.
model.addConstr(quicksum(RequiredMedicinal[i] * PillsProduced[i] for i in range(NumPillTypes)) <= TotalMedicinalIngredients)
# @Constraint Constr_2 @Def: For each pill type i, at least MinimumPills[i] units must be produced.
model.addConstrs((PillsProduced[i] >= MinimumPills[i] for i in range(NumPillTypes)), ""MinPills"")
# @Constraint Constr_3 @Def: For each pill type i, at least MinimumProportion[i] of the total pills produced must be of pill type i.
model.addConstrs((PillsProduced[i] >= MinimumProportion[i] * quicksum(PillsProduced[j] for j in range(NumPillTypes)) for i in range(NumPillTypes)), 'MinimumProportion')

# Objective 
# @Objective Objective @Def: Minimize the total filler material used, which is the sum of RequiredFiller[i] multiplied by the number of pills produced for each pill type i.
model.setObjective(quicksum(RequiredFiller[i] * PillsProduced[i] for i in range(NumPillTypes)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['PillsProduced'] = {i: PillsProduced[i].x for i in range(NumPillTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"Both chorine and water softener need to be added to a pool. One unit of chlorine takes 1 minute to be effective while one unit of water softener takes 2 minutes to be effective. Because too much chlorine can burn your eyes, there has to at most half as much chlorine as water softener in the pool. If there has to be at least 200 units of chlorine in the water and a total of 500 units of chemicals in the water, how many units of each should be added to minimize the total time it takes for the pool to be ready? (Note: chlorine must be added before water softener or vice versa).","{""variables"": {""ChlorineAmount"": 200.0, ""WaterSoftenerAmount"": 400.0, ""ChlorineUnits"": 500.0, ""WaterSoftenerUnits"": -0.0, ""TotalTime"": 0.0}, ""objective"": 0.0}","{""parametrized_description"": ""Two chemicals, Chlorine and WaterSoftener, need to be added to a pool. Each unit of Chlorine becomes effective after ChlorineEffectivenessTime minutes, and each unit of WaterSoftener becomes effective after WaterSoftenerEffectivenessTime minutes. The amount of Chlorine must not exceed MaxChlorineToWaterSoftenerRatio times the amount of WaterSoftener. At least MinChlorineUnits of Chlorine must be added, and the total number of chemical units added must equal TotalChemicalUnits. The objective is to determine the number of units of Chlorine and WaterSoftener to add in order to minimize the total time for the pool to be ready."", ""keywords"": [""N.A.""], ""parameters"": {""ChlorineEffectivenessTime"": {""description"": ""The time in minutes for one unit of chlorine to become effective"", ""shape"": []}, ""WaterSoftenerEffectivenessTime"": {""description"": ""The time in minutes for one unit of water softener to become effective"", ""shape"": []}, ""MaxChlorineToWaterSoftenerRatio"": {""description"": ""The maximum allowed ratio of chlorine to water softener in the pool"", ""shape"": []}, ""MinChlorineUnits"": {""description"": ""The minimum required units of chlorine to be added to the pool"", ""shape"": []}, ""TotalChemicalUnits"": {""description"": ""The total number of chemical units to be added to the pool"", ""shape"": []}}, ""variables"": {""ChlorineAmount"": {""description"": ""The amount of Chlorine added to the pool"", ""type"": ""continuous"", ""shape"": []}, ""WaterSoftenerAmount"": {""description"": ""The amount of Water Softener added to the pool"", ""type"": ""continuous"", ""shape"": []}, ""ChlorineUnits"": {""description"": ""The number of Chlorine units added to the pool"", ""type"": ""continuous"", ""shape"": []}, ""WaterSoftenerUnits"": {""description"": ""The number of Water Softener units added to the pool"", ""type"": ""continuous"", ""shape"": []}, ""TotalTime"": {""description"": ""The total time for the pool to be ready"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The amount of Chlorine must not exceed MaxChlorineToWaterSoftenerRatio times the amount of WaterSoftener."", ""formulation"": ""ChlorineAmount \\leq MaxChlorineToWaterSoftenerRatio \\times WaterSoftenerAmount"", ""code"": {""gurobipy"": ""model.addConstr(ChlorineAmount <= MaxChlorineToWaterSoftenerRatio * WaterSoftenerAmount)""}}, {""description"": ""At least MinChlorineUnits of Chlorine must be added."", ""formulation"": ""ChlorineAmount \\geq MinChlorineUnits"", ""code"": {""gurobipy"": ""model.addConstr(ChlorineAmount >= MinChlorineUnits)""}}, {""description"": ""The total number of chemical units added must equal TotalChemicalUnits."", ""formulation"": ""ChlorineUnits + WaterSoftenerUnits = TotalChemicalUnits"", ""code"": {""gurobipy"": ""model.addConstr(ChlorineUnits + WaterSoftenerUnits == TotalChemicalUnits)""}}], ""objective"": {""description"": ""Determine the number of units of Chlorine and WaterSoftener to add in order to minimize the total time for the pool to be ready."", ""formulation"": ""Minimize \\ TotalTime \\n TotalTime \\geq ChlorineUnits \\cdot ChlorineEffectivenessTime \\n TotalTime \\geq WaterSoftenerUnits \\cdot WaterSoftenerEffectivenessTime"", ""code"": {""gurobipy"": ""model.setObjective(TotalTime, GRB.MINIMIZE)""}}}","{""ChlorineEffectivenessTime"": 1, ""WaterSoftenerEffectivenessTime"": 2, ""MaxChlorineToWaterSoftenerRatio"": 0.5, ""MinChlorineUnits"": 200, ""TotalChemicalUnits"": 500}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Two chemicals, Chlorine and WaterSoftener, need to be added to a pool. Each unit
of Chlorine becomes effective after ChlorineEffectivenessTime minutes, and each
unit of WaterSoftener becomes effective after WaterSoftenerEffectivenessTime
minutes. The amount of Chlorine must not exceed MaxChlorineToWaterSoftenerRatio
times the amount of WaterSoftener. At least MinChlorineUnits of Chlorine must be
added, and the total number of chemical units added must equal
TotalChemicalUnits. The objective is to determine the number of units of
Chlorine and WaterSoftener to add in order to minimize the total time for the
pool to be ready.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/134/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ChlorineEffectivenessTime @Def: The time in minutes for one unit of chlorine to become effective @Shape: [] 
ChlorineEffectivenessTime = data['ChlorineEffectivenessTime']
# @Parameter WaterSoftenerEffectivenessTime @Def: The time in minutes for one unit of water softener to become effective @Shape: [] 
WaterSoftenerEffectivenessTime = data['WaterSoftenerEffectivenessTime']
# @Parameter MaxChlorineToWaterSoftenerRatio @Def: The maximum allowed ratio of chlorine to water softener in the pool @Shape: [] 
MaxChlorineToWaterSoftenerRatio = data['MaxChlorineToWaterSoftenerRatio']
# @Parameter MinChlorineUnits @Def: The minimum required units of chlorine to be added to the pool @Shape: [] 
MinChlorineUnits = data['MinChlorineUnits']
# @Parameter TotalChemicalUnits @Def: The total number of chemical units to be added to the pool @Shape: [] 
TotalChemicalUnits = data['TotalChemicalUnits']

# Variables 
# @Variable ChlorineAmount @Def: The amount of Chlorine added to the pool @Shape: [] 
ChlorineAmount = model.addVar(vtype=GRB.CONTINUOUS, name=""ChlorineAmount"")
# @Variable WaterSoftenerAmount @Def: The amount of Water Softener added to the pool @Shape: [] 
WaterSoftenerAmount = model.addVar(vtype=GRB.CONTINUOUS, name=""WaterSoftenerAmount"")
# @Variable ChlorineUnits @Def: The number of Chlorine units added to the pool @Shape: [] 
ChlorineUnits = model.addVar(vtype=GRB.INTEGER, name=""ChlorineUnits"")
# @Variable WaterSoftenerUnits @Def: The number of Water Softener units added to the pool @Shape: [] 
WaterSoftenerUnits = model.addVar(vtype=GRB.INTEGER, name=""WaterSoftenerUnits"")
# @Variable TotalTime @Def: The total time for the pool to be ready @Shape: [] 
TotalTime = model.addVar(vtype=GRB.CONTINUOUS, name=""TotalTime"")

# Constraints 
# @Constraint Constr_1 @Def: The amount of Chlorine must not exceed MaxChlorineToWaterSoftenerRatio times the amount of WaterSoftener.
model.addConstr(ChlorineAmount <= MaxChlorineToWaterSoftenerRatio * WaterSoftenerAmount)
# @Constraint Constr_2 @Def: At least MinChlorineUnits of Chlorine must be added.
model.addConstr(ChlorineAmount >= MinChlorineUnits)
# @Constraint Constr_3 @Def: The total number of chemical units added must equal TotalChemicalUnits.
model.addConstr(ChlorineUnits + WaterSoftenerUnits == TotalChemicalUnits)

# Objective 
# @Objective Objective @Def: Determine the number of units of Chlorine and WaterSoftener to add in order to minimize the total time for the pool to be ready.
model.setObjective(TotalTime, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ChlorineAmount'] = ChlorineAmount.x
variables['WaterSoftenerAmount'] = WaterSoftenerAmount.x
variables['ChlorineUnits'] = ChlorineUnits.x
variables['WaterSoftenerUnits'] = WaterSoftenerUnits.x
variables['TotalTime'] = TotalTime.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A drug company is making pain killers and sleeping pills using two processes, process 1 and process 2. Process 1 produces 35 units of pain killers and 12 units of sleeping pills per hour. Process 2 produces 50 units of pain killers and 30 units of sleeping pills per hour. Process 1 requires 50 units of preliminary material while process 2 requires 60 units of preliminary material. The drug company has available 2000 units of preliminary material and must make at least 1200 units of pain killers and 1200 units of sleeping pills. How many of each process should be run to minimize the total time needed?",{},{},"{""NumProcesses"": 2, ""NumProducts"": 2, ""ProductionRate"": [[35, 12], [50, 30]], ""PreliminaryMaterialRequired"": [50, 60], ""TotalPreliminaryMaterialAvailable"": 2000, ""MinProductRequired"": [1200, 1200]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A company utilizes NumProcesses different production processes to manufacture
NumProducts types of products. Each process has a ProductionRate for each
product, requires a certain amount of PreliminaryMaterialRequired per hour, and
the company has a total of TotalPreliminaryMaterialAvailable units of
preliminary material available. The company must produce at least
MinProductRequired units of each product. The objective is to determine the
number of each process to run in order to minimize the total time needed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/135/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumProcesses @Def: Number of production processes @Shape: [] 
NumProcesses = data['NumProcesses']
# @Parameter NumProducts @Def: Number of product types @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter ProductionRate @Def: Production rate of each product per process (units per hour) @Shape: ['NumProcesses', 'NumProducts'] 
ProductionRate = data['ProductionRate']
# @Parameter PreliminaryMaterialRequired @Def: Preliminary material required per process (units per hour) @Shape: ['NumProcesses'] 
PreliminaryMaterialRequired = data['PreliminaryMaterialRequired']
# @Parameter TotalPreliminaryMaterialAvailable @Def: Total units of preliminary material available @Shape: [] 
TotalPreliminaryMaterialAvailable = data['TotalPreliminaryMaterialAvailable']
# @Parameter MinProductRequired @Def: Minimum units of each product to be produced @Shape: ['NumProducts'] 
MinProductRequired = data['MinProductRequired']

# Variables 
# @Variable NumberOfProcesses @Def: The number of each production process @Shape: ['NumProcesses'] 
NumberOfProcesses = model.addVars(NumProcesses, vtype=GRB.CONTINUOUS, name=""NumberOfProcesses"")
# @Variable Time @Def: The total production time @Shape: [] 
Time = model.addVar(vtype=GRB.CONTINUOUS, name=""Time"")

# Constraints 
# @Constraint Constr_1 @Def: The total preliminary material used by all processes cannot exceed TotalPreliminaryMaterialAvailable units. This is calculated as the sum of (PreliminaryMaterialRequired[i] * NumberOfProcesses[i] * Time) for all processes i.
model.addConstr(quicksum(PreliminaryMaterialRequired[i] * NumberOfProcesses[i] * Time for i in range(NumProcesses)) <= TotalPreliminaryMaterialAvailable)
# @Constraint Constr_2 @Def: For each product, the total production across all processes must be at least MinProductRequired units. This is calculated as the sum of (ProductionRate[i][j] * NumberOfProcesses[i] * Time) for all processes i and each product j.
model.addConstrs((quicksum(ProductionRate[i][j] * NumberOfProcesses[i] * Time for i in range(NumProcesses)) >= MinProductRequired[j] for j in range(NumProducts)), name=""MinProductRequired"")
# @Constraint Constr_3 @Def: Number of each process to run must be a non-negative value.
model.addConstrs((NumberOfProcesses[p] >= 0 for p in range(NumProcesses)), name=""NumberOfProcesses_nonnegative"")
# @Constraint Constr_4 @Def: Time must be a non-negative value.
model.addConstr(Time >= 0)

# Objective 
# @Objective Objective @Def: Minimize the total time needed by determining the number of each process to run.
model.setObjective(Time, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfProcesses'] = NumberOfProcesses.x
variables['Time'] = Time.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A dietician recommends her client eat blueberries and strawberries to meet her anti-oxidant and mineral requirement. A pack of blueberries contains 3 units of anti-oxidants and 5 units of minerals. A pack of strawberries contains 1 unit of anti-oxidants and 7 units of minerals. The client must get at least 90 units of anti-oxidants and 100 units of minerals. In addition, because blueberries are not in season, the dietician recommend she eats at least 3 times as many packs of strawberries as blueberries. If a pack of blueberries contains 5 grams of sugar and a pack of strawberries contains 7 grams of sugar, how many of packs of each should she consume to minimize her sugar intake?","{""variables"": {""NumberOfBlueberryPacks"": 15.0, ""NumberOfStrawberryPacks"": 45.0}, ""objective"": 390.0}","{""parametrized_description"": ""Determine the number of blueberry packs and strawberry packs to minimize the total sugar intake, where total sugar is the product of SugarPerBlueberryPack and the number of blueberry packs plus the product of SugarPerStrawberryPack and the number of strawberry packs. Ensure that the total anti-oxidants, calculated as AntiOxidantsPerBlueberryPack multiplied by the number of blueberry packs plus AntiOxidantsPerStrawberryPack multiplied by the number of strawberry packs, is at least MinimumAntiOxidants. Similarly, the total minerals, calculated as MineralsPerBlueberryPack multiplied by the number of blueberry packs plus MineralsPerStrawberryPack multiplied by the number of strawberry packs, meets or exceeds MinimumMinerals. Additionally, the number of strawberry packs must be at least MinimumStrawberriesToBlueberriesRatio times the number of blueberry packs."", ""keywords"": [""N.A.""], ""parameters"": {""AntiOxidantsPerBlueberryPack"": {""description"": ""Units of anti-oxidants per pack of blueberries"", ""shape"": []}, ""AntiOxidantsPerStrawberryPack"": {""description"": ""Units of anti-oxidants per pack of strawberries"", ""shape"": []}, ""MineralsPerBlueberryPack"": {""description"": ""Units of minerals per pack of blueberries"", ""shape"": []}, ""MineralsPerStrawberryPack"": {""description"": ""Units of minerals per pack of strawberries"", ""shape"": []}, ""SugarPerBlueberryPack"": {""description"": ""Grams of sugar per pack of blueberries"", ""shape"": []}, ""SugarPerStrawberryPack"": {""description"": ""Grams of sugar per pack of strawberries"", ""shape"": []}, ""MinimumAntiOxidants"": {""description"": ""Minimum required units of anti-oxidants"", ""shape"": []}, ""MinimumMinerals"": {""description"": ""Minimum required units of minerals"", ""shape"": []}, ""MinimumStrawberriesToBlueberriesRatio"": {""description"": ""Minimum ratio of strawberries packs to blueberry packs"", ""shape"": []}}, ""variables"": {""NumberOfBlueberryPacks"": {""description"": ""The number of blueberry packs"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfStrawberryPacks"": {""description"": ""The number of strawberry packs"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total anti-oxidants, calculated as AntiOxidantsPerBlueberryPack multiplied by the number of blueberry packs plus AntiOxidantsPerStrawberryPack multiplied by the number of strawberry packs, is at least MinimumAntiOxidants."", ""formulation"": ""AntiOxidantsPerBlueberryPack \\times NumberOfBlueberryPacks + AntiOxidantsPerStrawberryPack \\times NumberOfStrawberryPacks \\geq MinimumAntiOxidants"", ""code"": {""gurobipy"": ""model.addConstr(AntiOxidantsPerBlueberryPack * NumberOfBlueberryPacks + AntiOxidantsPerStrawberryPack * NumberOfStrawberryPacks >= MinimumAntiOxidants)""}}, {""description"": ""The total minerals, calculated as MineralsPerBlueberryPack multiplied by the number of blueberry packs plus MineralsPerStrawberryPack multiplied by the number of strawberry packs, meets or exceeds MinimumMinerals."", ""formulation"": ""MineralsPerBlueberryPack \\times NumberOfBlueberryPacks + MineralsPerStrawberryPack \\times NumberOfStrawberryPacks \\geq MinimumMinerals"", ""code"": {""gurobipy"": ""model.addConstr(MineralsPerBlueberryPack * NumberOfBlueberryPacks + MineralsPerStrawberryPack * NumberOfStrawberryPacks >= MinimumMinerals)""}}, {""description"": ""The number of strawberry packs must be at least MinimumStrawberriesToBlueberriesRatio times the number of blueberry packs."", ""formulation"": ""NumberOfStrawberryPacks \\geq MinimumStrawberriesToBlueberriesRatio \\times NumberOfBlueberryPacks"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfStrawberryPacks >= MinimumStrawberriesToBlueberriesRatio * NumberOfBlueberryPacks)""}}], ""objective"": {""description"": ""Total sugar intake is the product of SugarPerBlueberryPack and the number of blueberry packs plus the product of SugarPerStrawberryPack and the number of strawberry packs. The objective is to minimize the total sugar intake."", ""formulation"": ""Min \\ SugarPerBlueberryPack \\times NumberOfBlueberryPacks + SugarPerStrawberryPack \\times NumberOfStrawberryPacks"", ""code"": {""gurobipy"": ""model.setObjective(SugarPerBlueberryPack * NumberOfBlueberryPacks + SugarPerStrawberryPack * NumberOfStrawberryPacks, GRB.MINIMIZE)""}}}","{""AntiOxidantsPerBlueberryPack"": 3, ""AntiOxidantsPerStrawberryPack"": 1, ""MineralsPerBlueberryPack"": 5, ""MineralsPerStrawberryPack"": 7, ""SugarPerBlueberryPack"": 5, ""SugarPerStrawberryPack"": 7, ""MinimumAntiOxidants"": 90, ""MinimumMinerals"": 100, ""MinimumStrawberriesToBlueberriesRatio"": 3}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Determine the number of blueberry packs and strawberry packs to minimize the
total sugar intake, where total sugar is the product of SugarPerBlueberryPack
and the number of blueberry packs plus the product of SugarPerStrawberryPack and
the number of strawberry packs. Ensure that the total anti-oxidants, calculated
as AntiOxidantsPerBlueberryPack multiplied by the number of blueberry packs plus
AntiOxidantsPerStrawberryPack multiplied by the number of strawberry packs, is
at least MinimumAntiOxidants. Similarly, the total minerals, calculated as
MineralsPerBlueberryPack multiplied by the number of blueberry packs plus
MineralsPerStrawberryPack multiplied by the number of strawberry packs, meets or
exceeds MinimumMinerals. Additionally, the number of strawberry packs must be at
least MinimumStrawberriesToBlueberriesRatio times the number of blueberry packs.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/136/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter AntiOxidantsPerBlueberryPack @Def: Units of anti-oxidants per pack of blueberries @Shape: [] 
AntiOxidantsPerBlueberryPack = data['AntiOxidantsPerBlueberryPack']
# @Parameter AntiOxidantsPerStrawberryPack @Def: Units of anti-oxidants per pack of strawberries @Shape: [] 
AntiOxidantsPerStrawberryPack = data['AntiOxidantsPerStrawberryPack']
# @Parameter MineralsPerBlueberryPack @Def: Units of minerals per pack of blueberries @Shape: [] 
MineralsPerBlueberryPack = data['MineralsPerBlueberryPack']
# @Parameter MineralsPerStrawberryPack @Def: Units of minerals per pack of strawberries @Shape: [] 
MineralsPerStrawberryPack = data['MineralsPerStrawberryPack']
# @Parameter SugarPerBlueberryPack @Def: Grams of sugar per pack of blueberries @Shape: [] 
SugarPerBlueberryPack = data['SugarPerBlueberryPack']
# @Parameter SugarPerStrawberryPack @Def: Grams of sugar per pack of strawberries @Shape: [] 
SugarPerStrawberryPack = data['SugarPerStrawberryPack']
# @Parameter MinimumAntiOxidants @Def: Minimum required units of anti-oxidants @Shape: [] 
MinimumAntiOxidants = data['MinimumAntiOxidants']
# @Parameter MinimumMinerals @Def: Minimum required units of minerals @Shape: [] 
MinimumMinerals = data['MinimumMinerals']
# @Parameter MinimumStrawberriesToBlueberriesRatio @Def: Minimum ratio of strawberries packs to blueberry packs @Shape: [] 
MinimumStrawberriesToBlueberriesRatio = data['MinimumStrawberriesToBlueberriesRatio']

# Variables 
# @Variable NumberOfBlueberryPacks @Def: The number of blueberry packs @Shape: [] 
NumberOfBlueberryPacks = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfBlueberryPacks"")
# @Variable NumberOfStrawberryPacks @Def: The number of strawberry packs @Shape: [] 
NumberOfStrawberryPacks = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfStrawberryPacks"")

# Constraints 
# @Constraint Constr_1 @Def: The total anti-oxidants, calculated as AntiOxidantsPerBlueberryPack multiplied by the number of blueberry packs plus AntiOxidantsPerStrawberryPack multiplied by the number of strawberry packs, is at least MinimumAntiOxidants.
model.addConstr(AntiOxidantsPerBlueberryPack * NumberOfBlueberryPacks + AntiOxidantsPerStrawberryPack * NumberOfStrawberryPacks >= MinimumAntiOxidants)
# @Constraint Constr_2 @Def: The total minerals, calculated as MineralsPerBlueberryPack multiplied by the number of blueberry packs plus MineralsPerStrawberryPack multiplied by the number of strawberry packs, meets or exceeds MinimumMinerals.
model.addConstr(MineralsPerBlueberryPack * NumberOfBlueberryPacks + MineralsPerStrawberryPack * NumberOfStrawberryPacks >= MinimumMinerals)
# @Constraint Constr_3 @Def: The number of strawberry packs must be at least MinimumStrawberriesToBlueberriesRatio times the number of blueberry packs.
model.addConstr(NumberOfStrawberryPacks >= MinimumStrawberriesToBlueberriesRatio * NumberOfBlueberryPacks)

# Objective 
# @Objective Objective @Def: Total sugar intake is the product of SugarPerBlueberryPack and the number of blueberry packs plus the product of SugarPerStrawberryPack and the number of strawberry packs. The objective is to minimize the total sugar intake.
model.setObjective(SugarPerBlueberryPack * NumberOfBlueberryPacks + SugarPerStrawberryPack * NumberOfStrawberryPacks, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfBlueberryPacks'] = NumberOfBlueberryPacks.x
variables['NumberOfStrawberryPacks'] = NumberOfStrawberryPacks.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An engineering school has a bridge building competition where students must build as many beam bridges and truss bridges as they can using Popsicle sticks and glue. A beam bridge requires 30 Popsicle sticks and 5 units of glue while a truss bridge requires 50 Popsicle sticks and 8 units of glue. Each team has at most 600 Popsicle sticks and 100 units of glue. In addition, each team can build at most 5 truss bridges and the number of beam bridges must be larger than the number of truss bridges. If a beam bridge can hold 40 grams and a truss bridge can hold 60 grams, how many of each bridge should a team build to maximize the total mass that can be supported?","{""variables"": {""BeamBridges"": 20.0, ""TrussBridges"": 0.0}, ""objective"": 800.0}","{""parametrized_description"": ""Determine the number of beam bridges and truss bridges to maximize the total mass supported, given that the total number of Popsicle sticks used for beam bridges and truss bridges does not exceed TotalPopsicleSticks, the total units of glue used for beam bridges and truss bridges does not exceed TotalGlue, the number of truss bridges does not exceed MaxTrussBridges, and the number of beam bridges is greater than the number of truss bridges."", ""keywords"": [""N.A.""], ""parameters"": {""TotalPopsicleSticks"": {""description"": ""Total number of Popsicle sticks available"", ""shape"": []}, ""PopsicleSticksPerBeamBridge"": {""description"": ""Number of Popsicle sticks required to build one beam bridge"", ""shape"": []}, ""PopsicleSticksPerTrussBridge"": {""description"": ""Number of Popsicle sticks required to build one truss bridge"", ""shape"": []}, ""TotalGlue"": {""description"": ""Total units of glue available"", ""shape"": []}, ""GluePerBeamBridge"": {""description"": ""Units of glue required to build one beam bridge"", ""shape"": []}, ""GluePerTrussBridge"": {""description"": ""Units of glue required to build one truss bridge"", ""shape"": []}, ""MaxTrussBridges"": {""description"": ""Maximum number of truss bridges that can be built"", ""shape"": []}, ""MassPerBeamBridge"": {""description"": ""Mass that one beam bridge can hold"", ""shape"": []}, ""MassPerTrussBridge"": {""description"": ""Mass that one truss bridge can hold"", ""shape"": []}}, ""variables"": {""BeamBridges"": {""description"": ""The number of beam bridges to build"", ""type"": ""continuous"", ""shape"": []}, ""TrussBridges"": {""description"": ""The number of truss bridges to build"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of Popsicle sticks used for beam bridges and truss bridges does not exceed TotalPopsicleSticks."", ""formulation"": ""PopsicleSticksPerBeamBridge \\cdot BeamBridges + PopsicleSticksPerTrussBridge \\cdot TrussBridges \\leq TotalPopsicleSticks"", ""code"": {""gurobipy"": ""model.addConstr(PopsicleSticksPerBeamBridge * BeamBridges + PopsicleSticksPerTrussBridge * TrussBridges <= TotalPopsicleSticks)""}}, {""description"": ""The total units of glue used for beam bridges and truss bridges does not exceed TotalGlue."", ""formulation"": ""GluePerBeamBridge \\times BeamBridges + GluePerTrussBridge \\times TrussBridges \\leq TotalGlue"", ""code"": {""gurobipy"": ""model.addConstr(GluePerBeamBridge * BeamBridges + GluePerTrussBridge * TrussBridges <= TotalGlue)""}}, {""description"": ""The number of truss bridges does not exceed MaxTrussBridges."", ""formulation"": ""TrussBridges \\leq MaxTrussBridges"", ""code"": {""gurobipy"": ""model.addConstr(TrussBridges <= MaxTrussBridges)""}}, {""description"": ""The number of beam bridges is greater than the number of truss bridges."", ""formulation"": ""BeamBridges \\geq TrussBridges + 1"", ""code"": {""gurobipy"": ""model.addConstr(BeamBridges >= TrussBridges + 1)""}}], ""objective"": {""description"": ""Maximize the total mass supported, which is the sum of the mass supported by beam bridges and truss bridges."", ""formulation"": ""Max \\ MassPerBeamBridge \\cdot BeamBridges + MassPerTrussBridge \\cdot TrussBridges"", ""code"": {""gurobipy"": ""model.setObjective(MassPerBeamBridge * BeamBridges + MassPerTrussBridge * TrussBridges, GRB.MAXIMIZE)""}}}","{""TotalPopsicleSticks"": 600, ""PopsicleSticksPerBeamBridge"": 30, ""PopsicleSticksPerTrussBridge"": 50, ""TotalGlue"": 100, ""GluePerBeamBridge"": 5, ""GluePerTrussBridge"": 8, ""MaxTrussBridges"": 5, ""MassPerBeamBridge"": 40, ""MassPerTrussBridge"": 60}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Determine the number of beam bridges and truss bridges to maximize the total
mass supported, given that the total number of Popsicle sticks used for beam
bridges and truss bridges does not exceed TotalPopsicleSticks, the total units
of glue used for beam bridges and truss bridges does not exceed TotalGlue, the
number of truss bridges does not exceed MaxTrussBridges, and the number of beam
bridges is greater than the number of truss bridges.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/137/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalPopsicleSticks @Def: Total number of Popsicle sticks available @Shape: [] 
TotalPopsicleSticks = data['TotalPopsicleSticks']
# @Parameter PopsicleSticksPerBeamBridge @Def: Number of Popsicle sticks required to build one beam bridge @Shape: [] 
PopsicleSticksPerBeamBridge = data['PopsicleSticksPerBeamBridge']
# @Parameter PopsicleSticksPerTrussBridge @Def: Number of Popsicle sticks required to build one truss bridge @Shape: [] 
PopsicleSticksPerTrussBridge = data['PopsicleSticksPerTrussBridge']
# @Parameter TotalGlue @Def: Total units of glue available @Shape: [] 
TotalGlue = data['TotalGlue']
# @Parameter GluePerBeamBridge @Def: Units of glue required to build one beam bridge @Shape: [] 
GluePerBeamBridge = data['GluePerBeamBridge']
# @Parameter GluePerTrussBridge @Def: Units of glue required to build one truss bridge @Shape: [] 
GluePerTrussBridge = data['GluePerTrussBridge']
# @Parameter MaxTrussBridges @Def: Maximum number of truss bridges that can be built @Shape: [] 
MaxTrussBridges = data['MaxTrussBridges']
# @Parameter MassPerBeamBridge @Def: Mass that one beam bridge can hold @Shape: [] 
MassPerBeamBridge = data['MassPerBeamBridge']
# @Parameter MassPerTrussBridge @Def: Mass that one truss bridge can hold @Shape: [] 
MassPerTrussBridge = data['MassPerTrussBridge']

# Variables 
# @Variable BeamBridges @Def: The number of beam bridges to build @Shape: [] 
BeamBridges = model.addVar(vtype=GRB.INTEGER, name=""BeamBridges"")
# @Variable TrussBridges @Def: The number of truss bridges to build @Shape: [] 
TrussBridges = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxTrussBridges, name=""TrussBridges"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of Popsicle sticks used for beam bridges and truss bridges does not exceed TotalPopsicleSticks.
model.addConstr(PopsicleSticksPerBeamBridge * BeamBridges + PopsicleSticksPerTrussBridge * TrussBridges <= TotalPopsicleSticks)
# @Constraint Constr_2 @Def: The total units of glue used for beam bridges and truss bridges does not exceed TotalGlue.
model.addConstr(GluePerBeamBridge * BeamBridges + GluePerTrussBridge * TrussBridges <= TotalGlue)
# @Constraint Constr_3 @Def: The number of truss bridges does not exceed MaxTrussBridges.
model.addConstr(TrussBridges <= MaxTrussBridges)
# @Constraint Constr_4 @Def: The number of beam bridges is greater than the number of truss bridges.
model.addConstr(BeamBridges >= TrussBridges + 1)

# Objective 
# @Objective Objective @Def: Maximize the total mass supported, which is the sum of the mass supported by beam bridges and truss bridges.
model.setObjective(MassPerBeamBridge * BeamBridges + MassPerTrussBridge * TrussBridges, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['BeamBridges'] = BeamBridges.x
variables['TrussBridges'] = TrussBridges.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A clinic administers two vaccines available for the public to take one at a time. One vaccine is taken as a pill and another is taken as a shot. The pill vaccine takes 10 minutes to administer while the shot takes 20 minutes to administer. Since the shot has been more thoroughly studied, the clinic must deliver at least 3 times as many shots as pill. In addition, the clinic must administer at least 30 pill vaccines. If the clinic only operates for 10000 minutes, maximize the number of patients that can be vaccinated.","{""variables"": {""NumberOfPills"": 142.0, ""NumberOfShots"": 429.0}, ""objective"": 571.0}","{""parametrized_description"": ""A clinic administers two types of vaccines, Pill and Shot. Administering a Pill vaccine takes TimePerPill minutes, while administering a Shot vaccine takes TimePerShot minutes. The clinic must administer at least ShotToPillRatio times as many Shots as Pills, and at least MinPills Pills. Given that the clinic operates for TotalOperatingTime minutes, the goal is to maximize the number of patients vaccinated."", ""keywords"": [""N.A.""], ""parameters"": {""TimePerPill"": {""description"": ""Time required to administer a pill vaccine"", ""shape"": []}, ""TimePerShot"": {""description"": ""Time required to administer a shot vaccine"", ""shape"": []}, ""ShotToPillRatio"": {""description"": ""Minimum ratio of shots to pills"", ""shape"": []}, ""MinPills"": {""description"": ""Minimum number of pill vaccines to administer"", ""shape"": []}, ""TotalOperatingTime"": {""description"": ""Total operating time of the clinic in minutes"", ""shape"": []}}, ""variables"": {""NumberOfPills"": {""description"": ""The number of pill vaccines to administer"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfShots"": {""description"": ""The number of shot vaccines to administer"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total time required to administer Pill vaccines and Shot vaccines must not exceed TotalOperatingTime minutes."", ""formulation"": ""TimePerPill \\times NumberOfPills + TimePerShot \\times NumberOfShots \\leq TotalOperatingTime"", ""code"": {""gurobipy"": ""model.addConstr(TimePerPill * NumberOfPills + TimePerShot * NumberOfShots <= TotalOperatingTime)""}}, {""description"": ""The number of Shot vaccines administered must be at least ShotToPillRatio times the number of Pill vaccines administered."", ""formulation"": ""NumberOfShots \\geq ShotToPillRatio \\times NumberOfPills"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfShots >= ShotToPillRatio * NumberOfPills)""}}, {""description"": ""At least MinPills Pill vaccines must be administered."", ""formulation"": ""NumberOfPills \\geq MinPills"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfPills >= MinPills, 'AtLeastMinPills')""}}], ""objective"": {""description"": ""Maximize the total number of patients vaccinated, which is the sum of Pill and Shot vaccines administered."", ""formulation"": ""Max \\ NumberOfPills + NumberOfShots"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfPills + NumberOfShots, GRB.MAXIMIZE)""}}}","{""TimePerPill"": 10, ""TimePerShot"": 20, ""ShotToPillRatio"": 3, ""MinPills"": 30, ""TotalOperatingTime"": 10000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A clinic administers two types of vaccines, Pill and Shot. Administering a Pill
vaccine takes TimePerPill minutes, while administering a Shot vaccine takes
TimePerShot minutes. The clinic must administer at least ShotToPillRatio times
as many Shots as Pills, and at least MinPills Pills. Given that the clinic
operates for TotalOperatingTime minutes, the goal is to maximize the number of
patients vaccinated.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/138/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TimePerPill @Def: Time required to administer a pill vaccine @Shape: [] 
TimePerPill = data['TimePerPill']
# @Parameter TimePerShot @Def: Time required to administer a shot vaccine @Shape: [] 
TimePerShot = data['TimePerShot']
# @Parameter ShotToPillRatio @Def: Minimum ratio of shots to pills @Shape: [] 
ShotToPillRatio = data['ShotToPillRatio']
# @Parameter MinPills @Def: Minimum number of pill vaccines to administer @Shape: [] 
MinPills = data['MinPills']
# @Parameter TotalOperatingTime @Def: Total operating time of the clinic in minutes @Shape: [] 
TotalOperatingTime = data['TotalOperatingTime']

# Variables 
# @Variable NumberOfPills @Def: The number of pill vaccines to administer @Shape: [] 
NumberOfPills = model.addVar(vtype=GRB.INTEGER, lb=MinPills, name=""NumberOfPills"")
# @Variable NumberOfShots @Def: The number of shot vaccines to administer @Shape: [] 
NumberOfShots = model.addVar(vtype=GRB.INTEGER, name=""NumberOfShots"")

# Constraints 
# @Constraint Constr_1 @Def: The total time required to administer Pill vaccines and Shot vaccines must not exceed TotalOperatingTime minutes.
model.addConstr(TimePerPill * NumberOfPills + TimePerShot * NumberOfShots <= TotalOperatingTime)
# @Constraint Constr_2 @Def: The number of Shot vaccines administered must be at least ShotToPillRatio times the number of Pill vaccines administered.
model.addConstr(NumberOfShots >= ShotToPillRatio * NumberOfPills)
# @Constraint Constr_3 @Def: At least MinPills Pill vaccines must be administered.
model.addConstr(NumberOfPills >= MinPills, 'AtLeastMinPills')

# Objective 
# @Objective Objective @Def: Maximize the total number of patients vaccinated, which is the sum of Pill and Shot vaccines administered.
model.setObjective(NumberOfPills + NumberOfShots, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfPills'] = NumberOfPills.x
variables['NumberOfShots'] = NumberOfShots.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A chocolate company can transport their boxes of chocolate either using their own vans or by renting trucks. Their vans can transport 50 boxes per trip while a truck can transport 80 boxes per trip. Since they own their vans, the cost per van trip is $30 while the cost per truck trip is $50. The company needs to transport at least 1500 boxes of chocolate and they have a budget of $1000. Since the vans also provide advertising, the number of trips by van must be larger than the number of trips by trucks. How many of trip by each should be done to minimize the total number of trips?","{""variables"": {""VanTrips"": 13.0, ""TruckTrips"": 11.0}, ""objective"": 24.0}","{""parametrized_description"": ""A company can transport boxes using vans or trucks. Each van trip has a capacity of VanCapacity boxes and costs VanCost dollars, while each truck trip has a capacity of TruckCapacity boxes and costs TruckCost dollars. The company needs to transport at least MinBoxes boxes with a total cost not exceeding Budget dollars. Additionally, the number of van trips must be greater than the number of truck trips. The objective is to minimize the total number of trips."", ""keywords"": [""N.A.""], ""parameters"": {""VanCapacity"": {""description"": ""Capacity of a van in boxes per trip"", ""shape"": []}, ""TruckCapacity"": {""description"": ""Capacity of a truck in boxes per trip"", ""shape"": []}, ""VanCost"": {""description"": ""Cost per van trip in dollars"", ""shape"": []}, ""TruckCost"": {""description"": ""Cost per truck trip in dollars"", ""shape"": []}, ""MinBoxes"": {""description"": ""Minimum number of boxes to transport"", ""shape"": []}, ""Budget"": {""description"": ""Budget available in dollars"", ""shape"": []}}, ""variables"": {""VanTrips"": {""description"": ""The number of van trips"", ""type"": ""continuous"", ""shape"": []}, ""TruckTrips"": {""description"": ""The number of truck trips"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of boxes transported using vans and trucks must be at least MinBoxes, where each van trip transports VanCapacity boxes and each truck trip transports TruckCapacity boxes."", ""formulation"": ""VanTrips \\\\cdot VanCapacity + TruckTrips \\\\cdot TruckCapacity \\geq MinBoxes"", ""code"": {""gurobipy"": ""model.addConstr(VanTrips * VanCapacity + TruckTrips * TruckCapacity >= MinBoxes)""}}, {""description"": ""The total transportation cost must not exceed Budget dollars, where each van trip costs VanCost dollars and each truck trip costs TruckCost dollars."", ""formulation"": ""VanCost \\times VanTrips + TruckCost \\times TruckTrips \\leq Budget"", ""code"": {""gurobipy"": ""model.addConstr(VanCost * VanTrips + TruckCost * TruckTrips <= Budget)""}}, {""description"": ""The number of van trips must be greater than the number of truck trips."", ""formulation"": ""VanTrips \\geq TruckTrips + 1"", ""code"": {""gurobipy"": ""model.addConstr(VanTrips >= TruckTrips + 1)""}}], ""objective"": {""description"": ""Minimize the total number of trips."", ""formulation"": ""Min \\ VanTrips + TruckTrips"", ""code"": {""gurobipy"": ""model.setObjective(VanTrips + TruckTrips, GRB.MINIMIZE)""}}}","{""VanCapacity"": 50, ""TruckCapacity"": 80, ""VanCost"": 30, ""TruckCost"": 50, ""MinBoxes"": 1500, ""Budget"": 1000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company can transport boxes using vans or trucks. Each van trip has a capacity
of VanCapacity boxes and costs VanCost dollars, while each truck trip has a
capacity of TruckCapacity boxes and costs TruckCost dollars. The company needs
to transport at least MinBoxes boxes with a total cost not exceeding Budget
dollars. Additionally, the number of van trips must be greater than the number
of truck trips. The objective is to minimize the total number of trips.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/139/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter VanCapacity @Def: Capacity of a van in boxes per trip @Shape: [] 
VanCapacity = data['VanCapacity']
# @Parameter TruckCapacity @Def: Capacity of a truck in boxes per trip @Shape: [] 
TruckCapacity = data['TruckCapacity']
# @Parameter VanCost @Def: Cost per van trip in dollars @Shape: [] 
VanCost = data['VanCost']
# @Parameter TruckCost @Def: Cost per truck trip in dollars @Shape: [] 
TruckCost = data['TruckCost']
# @Parameter MinBoxes @Def: Minimum number of boxes to transport @Shape: [] 
MinBoxes = data['MinBoxes']
# @Parameter Budget @Def: Budget available in dollars @Shape: [] 
Budget = data['Budget']

# Variables 
# @Variable VanTrips @Def: The number of van trips @Shape: [] 
VanTrips = model.addVar(vtype=GRB.INTEGER, name=""VanTrips"")
# @Variable TruckTrips @Def: The number of truck trips @Shape: [] 
TruckTrips = model.addVar(vtype=GRB.INTEGER, name=""TruckTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of boxes transported using vans and trucks must be at least MinBoxes, where each van trip transports VanCapacity boxes and each truck trip transports TruckCapacity boxes.
model.addConstr(VanTrips * VanCapacity + TruckTrips * TruckCapacity >= MinBoxes)
# @Constraint Constr_2 @Def: The total transportation cost must not exceed Budget dollars, where each van trip costs VanCost dollars and each truck trip costs TruckCost dollars.
model.addConstr(VanCost * VanTrips + TruckCost * TruckTrips <= Budget)
# @Constraint Constr_3 @Def: The number of van trips must be greater than the number of truck trips.
model.addConstr(VanTrips >= TruckTrips + 1)

# Objective 
# @Objective Objective @Def: Minimize the total number of trips.
model.setObjective(VanTrips + TruckTrips, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['VanTrips'] = VanTrips.x
variables['TruckTrips'] = TruckTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A bee farmer transports his honey in small and large bottles. A small bottle can take 5 units of honey while a large bottle can take 20 units of honey. The farmer has available at most 300 small bottles and at most 100 large bottles. In addition, since small bottles are easier to sell, at least twice as many small bottles must be used than large bottles. Finally, he can transport at most 200 bottles total and at least 50 must be large bottles. How many of each bottle should be use to maximize the total amount of honey he can transport?","{""variables"": {""SmallBottlesUsed"": 134.0, ""LargeBottlesUsed"": 66.0}, ""objective"": 1990.0}","{""parametrized_description"": ""A bee farmer transports his honey in small and large bottles, where a small bottle has a capacity of SmallBottleCapacity units of honey and a large bottle has a capacity of LargeBottleCapacity units of honey. The farmer has available at most MaxSmallBottles small bottles and at most MaxLargeBottles large bottles. Additionally, the number of small bottles used must be at least MinRatioSmallToLarge times the number of large bottles used. The total number of bottles transported must not exceed MaxTotalBottles, and at least MinLargeBottles large bottles must be used. The farmer aims to maximize the total amount of honey transported."", ""keywords"": [""N.A.""], ""parameters"": {""SmallBottleCapacity"": {""description"": ""Capacity of a small bottle in units of honey"", ""shape"": []}, ""LargeBottleCapacity"": {""description"": ""Capacity of a large bottle in units of honey"", ""shape"": []}, ""MaxSmallBottles"": {""description"": ""Maximum number of small bottles available"", ""shape"": []}, ""MaxLargeBottles"": {""description"": ""Maximum number of large bottles available"", ""shape"": []}, ""MinRatioSmallToLarge"": {""description"": ""Minimum ratio of small bottles to large bottles"", ""shape"": []}, ""MaxTotalBottles"": {""description"": ""Maximum total number of bottles that can be transported"", ""shape"": []}, ""MinLargeBottles"": {""description"": ""Minimum number of large bottles that must be used"", ""shape"": []}}, ""variables"": {""SmallBottlesUsed"": {""description"": ""The number of small bottles used"", ""type"": ""continuous"", ""shape"": []}, ""LargeBottlesUsed"": {""description"": ""The number of large bottles used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of small bottles used must be at least MinRatioSmallToLarge times the number of large bottles used."", ""formulation"": ""SmallBottlesUsed \\geq MinRatioSmallToLarge \\cdot LargeBottlesUsed"", ""code"": {""gurobipy"": ""model.addConstr(SmallBottlesUsed >= MinRatioSmallToLarge * LargeBottlesUsed)""}}, {""description"": ""The total number of bottles transported must not exceed MaxTotalBottles."", ""formulation"": ""SmallBottlesUsed + LargeBottlesUsed \\leq MaxTotalBottles"", ""code"": {""gurobipy"": ""model.addConstr(SmallBottlesUsed + LargeBottlesUsed <= MaxTotalBottles)""}}, {""description"": ""At least MinLargeBottles large bottles must be used."", ""formulation"": ""LargeBottlesUsed \\geq MinLargeBottles"", ""code"": {""gurobipy"": ""model.addConstr(LargeBottlesUsed >= MinLargeBottles)""}}, {""description"": ""The number of small bottles used must not exceed MaxSmallBottles."", ""formulation"": ""SmallBottlesUsed \\leq MaxSmallBottles"", ""code"": {""gurobipy"": ""model.addConstr(SmallBottlesUsed <= MaxSmallBottles)""}}, {""description"": ""The number of large bottles used must not exceed MaxLargeBottles."", ""formulation"": ""LargeBottlesUsed \\leq MaxLargeBottles"", ""code"": {""gurobipy"": ""model.addConstr(LargeBottlesUsed <= MaxLargeBottles)""}}], ""objective"": {""description"": ""Maximize the total amount of honey transported, which is the sum of (SmallBottleCapacity \u00d7 number of small bottles) and (LargeBottleCapacity \u00d7 number of large bottles)."", ""formulation"": ""Max \\ SmallBottleCapacity \\times SmallBottlesUsed + LargeBottleCapacity \\times LargeBottlesUsed"", ""code"": {""gurobipy"": ""model.setObjective(SmallBottleCapacity * SmallBottlesUsed + LargeBottleCapacity * LargeBottlesUsed, GRB.MAXIMIZE)""}}}","{""SmallBottleCapacity"": 5, ""LargeBottleCapacity"": 20, ""MaxSmallBottles"": 300, ""MaxLargeBottles"": 100, ""MinRatioSmallToLarge"": 2, ""MaxTotalBottles"": 200, ""MinLargeBottles"": 50}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A bee farmer transports his honey in small and large bottles, where a small
bottle has a capacity of SmallBottleCapacity units of honey and a large bottle
has a capacity of LargeBottleCapacity units of honey. The farmer has available
at most MaxSmallBottles small bottles and at most MaxLargeBottles large bottles.
Additionally, the number of small bottles used must be at least
MinRatioSmallToLarge times the number of large bottles used. The total number of
bottles transported must not exceed MaxTotalBottles, and at least
MinLargeBottles large bottles must be used. The farmer aims to maximize the
total amount of honey transported.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/140/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SmallBottleCapacity @Def: Capacity of a small bottle in units of honey @Shape: [] 
SmallBottleCapacity = data['SmallBottleCapacity']
# @Parameter LargeBottleCapacity @Def: Capacity of a large bottle in units of honey @Shape: [] 
LargeBottleCapacity = data['LargeBottleCapacity']
# @Parameter MaxSmallBottles @Def: Maximum number of small bottles available @Shape: [] 
MaxSmallBottles = data['MaxSmallBottles']
# @Parameter MaxLargeBottles @Def: Maximum number of large bottles available @Shape: [] 
MaxLargeBottles = data['MaxLargeBottles']
# @Parameter MinRatioSmallToLarge @Def: Minimum ratio of small bottles to large bottles @Shape: [] 
MinRatioSmallToLarge = data['MinRatioSmallToLarge']
# @Parameter MaxTotalBottles @Def: Maximum total number of bottles that can be transported @Shape: [] 
MaxTotalBottles = data['MaxTotalBottles']
# @Parameter MinLargeBottles @Def: Minimum number of large bottles that must be used @Shape: [] 
MinLargeBottles = data['MinLargeBottles']

# Variables 
# @Variable SmallBottlesUsed @Def: The number of small bottles used @Shape: [] 
SmallBottlesUsed = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxSmallBottles, name=""SmallBottlesUsed"")
# @Variable LargeBottlesUsed @Def: The number of large bottles used @Shape: [] 
LargeBottlesUsed = model.addVar(vtype=GRB.INTEGER, lb=MinLargeBottles, ub=MaxLargeBottles, name=""LargeBottlesUsed"")

# Constraints 
# @Constraint Constr_1 @Def: The number of small bottles used must be at least MinRatioSmallToLarge times the number of large bottles used.
model.addConstr(SmallBottlesUsed >= MinRatioSmallToLarge * LargeBottlesUsed)
# @Constraint Constr_2 @Def: The total number of bottles transported must not exceed MaxTotalBottles.
model.addConstr(SmallBottlesUsed + LargeBottlesUsed <= MaxTotalBottles)
# @Constraint Constr_3 @Def: At least MinLargeBottles large bottles must be used.
model.addConstr(LargeBottlesUsed >= MinLargeBottles)
# @Constraint Constr_4 @Def: The number of small bottles used must not exceed MaxSmallBottles.
model.addConstr(SmallBottlesUsed <= MaxSmallBottles)
# @Constraint Constr_5 @Def: The number of large bottles used must not exceed MaxLargeBottles.
model.addConstr(LargeBottlesUsed <= MaxLargeBottles)

# Objective 
# @Objective Objective @Def: Maximize the total amount of honey transported, which is the sum of (SmallBottleCapacity × number of small bottles) and (LargeBottleCapacity × number of large bottles).
model.setObjective(SmallBottleCapacity * SmallBottlesUsed + LargeBottleCapacity * LargeBottlesUsed, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SmallBottlesUsed'] = SmallBottlesUsed.x
variables['LargeBottlesUsed'] = LargeBottlesUsed.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An international goods exporter uses ships and planes to transport goods. A ship can take 40 containers worth of goods and uses 500 liters of fuel per trip. A plane can take 20 containers worth of goods and uses 300 liters of fuel per trip. The company needs to transport at least 500 containers worth of goods. In addition, there can be at most 10 plane trips made and a minimum of 50% of the trips made must be by ship. How many of each trip should be made to minimize the total amount of fuel consumed?","{""variables"": {""ShipTrips"": 12.0, ""PlaneTrips"": 1.0}, ""objective"": 6300.0}","{""parametrized_description"": ""An international goods exporter uses ships and planes to transport goods. Each ship can carry ShipCapacity containers and consumes ShipFuel liters of fuel per trip. Each plane can carry PlaneCapacity containers and consumes PlaneFuel liters of fuel per trip. The company needs to transport at least MinContainers containers. Additionally, no more than MaxPlaneTrips plane trips can be made, and at least MinShipTripFraction of the total trips must be by ship. The objective is to minimize the total fuel consumption."", ""keywords"": [""N.A.""], ""parameters"": {""ShipCapacity"": {""description"": ""Capacity of a ship in containers"", ""shape"": []}, ""ShipFuel"": {""description"": ""Fuel usage of a ship per trip in liters"", ""shape"": []}, ""PlaneCapacity"": {""description"": ""Capacity of a plane in containers"", ""shape"": []}, ""PlaneFuel"": {""description"": ""Fuel usage of a plane per trip in liters"", ""shape"": []}, ""MinContainers"": {""description"": ""Minimum number of containers to transport"", ""shape"": []}, ""MaxPlaneTrips"": {""description"": ""Maximum number of plane trips"", ""shape"": []}, ""MinShipTripFraction"": {""description"": ""Minimum fraction of trips that must be by ship"", ""shape"": []}}, ""variables"": {""ShipTrips"": {""description"": ""The number of ship trips"", ""type"": ""continuous"", ""shape"": []}, ""PlaneTrips"": {""description"": ""The number of plane trips"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of containers transported by ships and planes must be at least MinContainers."", ""formulation"": ""ShipTrips \\times ShipCapacity + PlaneTrips \\times PlaneCapacity \\geq MinContainers"", ""code"": {""gurobipy"": ""model.addConstr(ShipTrips * ShipCapacity + PlaneTrips * PlaneCapacity >= MinContainers)""}}, {""description"": ""No more than MaxPlaneTrips plane trips can be made."", ""formulation"": ""PlaneTrips \\leq MaxPlaneTrips"", ""code"": {""gurobipy"": ""model.addConstr(PlaneTrips <= MaxPlaneTrips)""}}, {""description"": ""At least MinShipTripFraction of the total trips must be by ship."", ""formulation"": ""ShipTrips \\geq MinShipTripFraction \\times (ShipTrips + PlaneTrips)"", ""code"": {""gurobipy"": ""model.addConstr(ShipTrips >= MinShipTripFraction * (ShipTrips + PlaneTrips))""}}], ""objective"": {""description"": ""Minimize the total fuel consumption, which is the sum of fuel used by ships and planes based on the number of trips made."", ""formulation"": ""Min \\ ShipFuel \\cdot ShipTrips + PlaneFuel \\cdot PlaneTrips"", ""code"": {""gurobipy"": ""model.setObjective(ShipFuel * ShipTrips + PlaneFuel * PlaneTrips, GRB.MINIMIZE)""}}}","{""ShipCapacity"": 40, ""ShipFuel"": 500, ""PlaneCapacity"": 20, ""PlaneFuel"": 300, ""MinContainers"": 500, ""MaxPlaneTrips"": 10, ""MinShipTripFraction"": 0.5}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
An international goods exporter uses ships and planes to transport goods. Each
ship can carry ShipCapacity containers and consumes ShipFuel liters of fuel per
trip. Each plane can carry PlaneCapacity containers and consumes PlaneFuel
liters of fuel per trip. The company needs to transport at least MinContainers
containers. Additionally, no more than MaxPlaneTrips plane trips can be made,
and at least MinShipTripFraction of the total trips must be by ship. The
objective is to minimize the total fuel consumption.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/141/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ShipCapacity @Def: Capacity of a ship in containers @Shape: [] 
ShipCapacity = data['ShipCapacity']
# @Parameter ShipFuel @Def: Fuel usage of a ship per trip in liters @Shape: [] 
ShipFuel = data['ShipFuel']
# @Parameter PlaneCapacity @Def: Capacity of a plane in containers @Shape: [] 
PlaneCapacity = data['PlaneCapacity']
# @Parameter PlaneFuel @Def: Fuel usage of a plane per trip in liters @Shape: [] 
PlaneFuel = data['PlaneFuel']
# @Parameter MinContainers @Def: Minimum number of containers to transport @Shape: [] 
MinContainers = data['MinContainers']
# @Parameter MaxPlaneTrips @Def: Maximum number of plane trips @Shape: [] 
MaxPlaneTrips = data['MaxPlaneTrips']
# @Parameter MinShipTripFraction @Def: Minimum fraction of trips that must be by ship @Shape: [] 
MinShipTripFraction = data['MinShipTripFraction']

# Variables 
# @Variable ShipTrips @Def: The number of ship trips @Shape: [] 
ShipTrips = model.addVar(vtype=GRB.INTEGER, name=""ShipTrips"")
# @Variable PlaneTrips @Def: The number of plane trips @Shape: [] 
PlaneTrips = model.addVar(vtype=GRB.INTEGER, name=""PlaneTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of containers transported by ships and planes must be at least MinContainers.
model.addConstr(ShipTrips * ShipCapacity + PlaneTrips * PlaneCapacity >= MinContainers)
# @Constraint Constr_2 @Def: No more than MaxPlaneTrips plane trips can be made.
model.addConstr(PlaneTrips <= MaxPlaneTrips)
# @Constraint Constr_3 @Def: At least MinShipTripFraction of the total trips must be by ship.
model.addConstr(ShipTrips >= MinShipTripFraction * (ShipTrips + PlaneTrips))

# Objective 
# @Objective Objective @Def: Minimize the total fuel consumption, which is the sum of fuel used by ships and planes based on the number of trips made.
model.setObjective(ShipFuel * ShipTrips + PlaneFuel * PlaneTrips, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ShipTrips'] = ShipTrips.x
variables['PlaneTrips'] = PlaneTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"There has been an oil spill in the ocean and ducks need to be taken to shore to be cleaned either by boat or by canoe. A boat can take 10 ducks per trip while a canoe can take 8 ducks per trip. Since the boats are motor powered, they take 20 minutes per trip while the canoes take 40 minutes per trip. In order to avoid further environmental damage, there can be at most 12 boat trips and at least 60% of the trips should be by canoe. If at least 300 ducks need to be taken to shore, how many of each transportation method should be used to minimize the total amount of time needed to transport the ducks?","{""variables"": {""BoatTrips"": 12.0, ""CanoeTrips"": 23.0}, ""objective"": 1160.0}","{""parametrized_description"": ""Determine the number of boat trips and canoe trips to minimize the total transportation time, where each boat trip carries BoatCapacity ducks and takes BoatTripTime minutes, and each canoe trip carries CanoeCapacity ducks and takes CanoeTripTime minutes. The number of boat trips must not exceed MaxBoatTrips, at least MinCanoeTripFraction of all trips must be canoe trips, and the total number of ducks transported must be at least MinDucks."", ""keywords"": [""N.A.""], ""parameters"": {""BoatCapacity"": {""description"": ""Number of ducks a boat can carry per trip"", ""shape"": []}, ""CanoeCapacity"": {""description"": ""Number of ducks a canoe can carry per trip"", ""shape"": []}, ""BoatTripTime"": {""description"": ""Time in minutes per boat trip"", ""shape"": []}, ""CanoeTripTime"": {""description"": ""Time in minutes per canoe trip"", ""shape"": []}, ""MaxBoatTrips"": {""description"": ""Maximum number of boat trips allowed"", ""shape"": []}, ""MinCanoeTripFraction"": {""description"": ""Minimum fraction of trips that must be by canoe"", ""shape"": []}, ""MinDucks"": {""description"": ""Minimum number of ducks to be transported to shore"", ""shape"": []}}, ""variables"": {""BoatTrips"": {""description"": ""The number of boat trips"", ""type"": ""continuous"", ""shape"": [""NonNegative"", ""Integer""]}, ""CanoeTrips"": {""description"": ""The number of canoe trips"", ""type"": ""continuous"", ""shape"": [""NonNegative"", ""Integer""]}}, ""constraints"": [{""description"": ""The number of boat trips must not exceed MaxBoatTrips."", ""formulation"": ""BoatTrips \\leq MaxBoatTrips"", ""code"": {""gurobipy"": ""model.addConstr(BoatTrips <= MaxBoatTrips)""}}, {""description"": ""At least MinCanoeTripFraction of all trips must be canoe trips."", ""formulation"": ""CanoeTrips \\geq MinCanoeTripFraction \\times (BoatTrips + CanoeTrips)"", ""code"": {""gurobipy"": ""model.addConstr(CanoeTrips >= MinCanoeTripFraction * (BoatTrips + CanoeTrips))""}}, {""description"": ""The total number of ducks transported must be at least MinDucks."", ""formulation"": ""BoatTrips \\cdot BoatCapacity + CanoeTrips \\cdot CanoeCapacity \\geq MinDucks"", ""code"": {""gurobipy"": ""model.addConstr(BoatTrips * BoatCapacity + CanoeTrips * CanoeCapacity >= MinDucks)""}}], ""objective"": {""description"": ""Minimize the total transportation time, which is calculated as (Number of boat trips \u00d7 BoatTripTime) + (Number of canoe trips \u00d7 CanoeTripTime)."", ""formulation"": ""Minimize \\; BoatTrips \\cdot BoatTripTime + CanoeTrips \\cdot CanoeTripTime"", ""code"": {""gurobipy"": ""model.setObjective(BoatTrips * BoatTripTime + CanoeTrips * CanoeTripTime, GRB.MINIMIZE)""}}}","{""BoatCapacity"": 10, ""CanoeCapacity"": 8, ""BoatTripTime"": 20, ""CanoeTripTime"": 40, ""MaxBoatTrips"": 12, ""MinCanoeTripFraction"": 0.6, ""MinDucks"": 300}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Determine the number of boat trips and canoe trips to minimize the total
transportation time, where each boat trip carries BoatCapacity ducks and takes
BoatTripTime minutes, and each canoe trip carries CanoeCapacity ducks and takes
CanoeTripTime minutes. The number of boat trips must not exceed MaxBoatTrips, at
least MinCanoeTripFraction of all trips must be canoe trips, and the total
number of ducks transported must be at least MinDucks.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/142/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter BoatCapacity @Def: Number of ducks a boat can carry per trip @Shape: [] 
BoatCapacity = data['BoatCapacity']
# @Parameter CanoeCapacity @Def: Number of ducks a canoe can carry per trip @Shape: [] 
CanoeCapacity = data['CanoeCapacity']
# @Parameter BoatTripTime @Def: Time in minutes per boat trip @Shape: [] 
BoatTripTime = data['BoatTripTime']
# @Parameter CanoeTripTime @Def: Time in minutes per canoe trip @Shape: [] 
CanoeTripTime = data['CanoeTripTime']
# @Parameter MaxBoatTrips @Def: Maximum number of boat trips allowed @Shape: [] 
MaxBoatTrips = data['MaxBoatTrips']
# @Parameter MinCanoeTripFraction @Def: Minimum fraction of trips that must be by canoe @Shape: [] 
MinCanoeTripFraction = data['MinCanoeTripFraction']
# @Parameter MinDucks @Def: Minimum number of ducks to be transported to shore @Shape: [] 
MinDucks = data['MinDucks']

# Variables 
# @Variable BoatTrips @Def: The number of boat trips @Shape: ['NonNegative', 'Integer'] 
BoatTrips = model.addVar(vtype=GRB.INTEGER, name=""BoatTrips"", lb=0)
# @Variable CanoeTrips @Def: The number of canoe trips @Shape: ['NonNegative', 'Integer'] 
CanoeTrips = model.addVar(vtype=GRB.INTEGER, name=""CanoeTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The number of boat trips must not exceed MaxBoatTrips.
model.addConstr(BoatTrips <= MaxBoatTrips)
# @Constraint Constr_2 @Def: At least MinCanoeTripFraction of all trips must be canoe trips.
model.addConstr(CanoeTrips >= MinCanoeTripFraction * (BoatTrips + CanoeTrips))
# @Constraint Constr_3 @Def: The total number of ducks transported must be at least MinDucks.
model.addConstr(BoatTrips * BoatCapacity + CanoeTrips * CanoeCapacity >= MinDucks)

# Objective 
# @Objective Objective @Def: Minimize the total transportation time, which is calculated as (Number of boat trips × BoatTripTime) + (Number of canoe trips × CanoeTripTime).
model.setObjective(BoatTrips * BoatTripTime + CanoeTrips * CanoeTripTime, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['BoatTrips'] = BoatTrips.x
variables['CanoeTrips'] = CanoeTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A soda company sends bottles of their soda to stores around the city in old and new vans. An old van can take 100 soda bottles while a new van can take 80 soda bottles. An old van produces 50 units of pollution while a new van only produces 30 units of pollution. The company needs to send at least 5000 bottles. In addition, at most 30 new vans can be used. How many of each van should be used to minimize the total amount of pollution produced?","{""variables"": {""NumberOfOldVans"": 26.0, ""NumberOfNewVans"": 30.0}, ""objective"": 2200.0}","{""parametrized_description"": ""A soda company uses old and new vans to transport soda bottles to stores. Each old van has a capacity of OldVanCapacity bottles and produces OldVanPollution units of pollution. Each new van has a capacity of NewVanCapacity bottles and produces NewVanPollution units of pollution. The company needs to transport at least MinimumBottles soda bottles and can use at most MaximumNewVans new vans. The goal is to determine the number of old and new vans to minimize the total amount of pollution produced."", ""keywords"": [""N.A.""], ""parameters"": {""OldVanCapacity"": {""description"": ""Capacity of an old van in soda bottles"", ""shape"": []}, ""NewVanCapacity"": {""description"": ""Capacity of a new van in soda bottles"", ""shape"": []}, ""OldVanPollution"": {""description"": ""Pollution produced by an old van in units"", ""shape"": []}, ""NewVanPollution"": {""description"": ""Pollution produced by a new van in units"", ""shape"": []}, ""MinimumBottles"": {""description"": ""Minimum number of soda bottles that need to be sent"", ""shape"": []}, ""MaximumNewVans"": {""description"": ""Maximum number of new vans that can be used"", ""shape"": []}}, ""variables"": {""NumberOfOldVans"": {""description"": ""The number of old vans used"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfNewVans"": {""description"": ""The number of new vans used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""Each old van has a capacity of OldVanCapacity bottles and each new van has a capacity of NewVanCapacity bottles. The total number of bottles transported must be at least MinimumBottles."", ""formulation"": ""OldVanCapacity \\times NumberOfOldVans + NewVanCapacity \\times NumberOfNewVans \\geq MinimumBottles"", ""code"": {""gurobipy"": ""model.addConstr(OldVanCapacity * NumberOfOldVans + NewVanCapacity * NumberOfNewVans >= MinimumBottles)""}}, {""description"": ""The number of new vans used must not exceed MaximumNewVans."", ""formulation"": ""NumberOfNewVans \\leq MaximumNewVans"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfNewVans <= MaximumNewVans)""}}], ""objective"": {""description"": ""Total pollution is the sum of the pollution produced by all old vans and new vans. The objective is to minimize the total pollution."", ""formulation"": ""Min \\ NumberOfOldVans \\times OldVanPollution + NumberOfNewVans \\times NewVanPollution"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfOldVans * OldVanPollution + NumberOfNewVans * NewVanPollution, GRB.MINIMIZE)""}}}","{""OldVanCapacity"": 100, ""NewVanCapacity"": 80, ""OldVanPollution"": 50, ""NewVanPollution"": 30, ""MinimumBottles"": 5000, ""MaximumNewVans"": 30}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A soda company uses old and new vans to transport soda bottles to stores. Each
old van has a capacity of OldVanCapacity bottles and produces OldVanPollution
units of pollution. Each new van has a capacity of NewVanCapacity bottles and
produces NewVanPollution units of pollution. The company needs to transport at
least MinimumBottles soda bottles and can use at most MaximumNewVans new vans.
The goal is to determine the number of old and new vans to minimize the total
amount of pollution produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/143/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter OldVanCapacity @Def: Capacity of an old van in soda bottles @Shape: [] 
OldVanCapacity = data['OldVanCapacity']
# @Parameter NewVanCapacity @Def: Capacity of a new van in soda bottles @Shape: [] 
NewVanCapacity = data['NewVanCapacity']
# @Parameter OldVanPollution @Def: Pollution produced by an old van in units @Shape: [] 
OldVanPollution = data['OldVanPollution']
# @Parameter NewVanPollution @Def: Pollution produced by a new van in units @Shape: [] 
NewVanPollution = data['NewVanPollution']
# @Parameter MinimumBottles @Def: Minimum number of soda bottles that need to be sent @Shape: [] 
MinimumBottles = data['MinimumBottles']
# @Parameter MaximumNewVans @Def: Maximum number of new vans that can be used @Shape: [] 
MaximumNewVans = data['MaximumNewVans']

# Variables 
# @Variable NumberOfOldVans @Def: The number of old vans used @Shape: [] 
NumberOfOldVans = model.addVar(vtype=GRB.INTEGER, name=""NumberOfOldVans"")
# @Variable NumberOfNewVans @Def: The number of new vans used @Shape: [] 
NumberOfNewVans = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaximumNewVans, name=""NumberOfNewVans"")

# Constraints 
# @Constraint Constr_1 @Def: Each old van has a capacity of OldVanCapacity bottles and each new van has a capacity of NewVanCapacity bottles. The total number of bottles transported must be at least MinimumBottles.
model.addConstr(OldVanCapacity * NumberOfOldVans + NewVanCapacity * NumberOfNewVans >= MinimumBottles)
# @Constraint Constr_2 @Def: The number of new vans used must not exceed MaximumNewVans.
model.addConstr(NumberOfNewVans <= MaximumNewVans)

# Objective 
# @Objective Objective @Def: Total pollution is the sum of the pollution produced by all old vans and new vans. The objective is to minimize the total pollution.
model.setObjective(NumberOfOldVans * OldVanPollution + NumberOfNewVans * NewVanPollution, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfOldVans'] = NumberOfOldVans.x
variables['NumberOfNewVans'] = NumberOfNewVans.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A lawn mowing service provides neighborhood services using small teams and large teams. A small team requires 3 employees and can mow 50 sq ft of lawn. A large team requires 5 employees and can mow 80 sq ft of lawn. The company has 150 employees available. Because most people have smaller lawns in the city, the number of small teams must be at least 3 times as much as the number of large teams. In addition, to make sure the company can meet all demands, there has to be at least 6 large teams and at least 10 small teams. How many of each team type should be used to maximize the amount of lawn that can be mowed?","{""variables"": {""SmallTeams"": 40.0, ""LargeTeams"": 6.0}, ""objective"": 2480.0}","{""parametrized_description"": ""A lawn mowing service utilizes SmallTeams and LargeTeams. Each SmallTeam requires EmployeesPerSmallTeam employees and can mow AreaMowedSmallTeam of lawn. Each LargeTeam requires EmployeesPerLargeTeam employees and can mow AreaMowedLargeTeam of lawn. The service has TotalEmployees available employees. The number of SmallTeams must be at least RatioSmallToLargeTeams times the number of LargeTeams. Additionally, there must be a minimum of MinLargeTeams LargeTeams and at least MinSmallTeams SmallTeams. The objective is to determine the optimal number of SmallTeams and LargeTeams to maximize the total area mowed."", ""keywords"": [""N.A.""], ""parameters"": {""EmployeesPerSmallTeam"": {""description"": ""Number of employees required per small team"", ""shape"": []}, ""AreaMowedSmallTeam"": {""description"": ""Area mowed by a small team"", ""shape"": []}, ""EmployeesPerLargeTeam"": {""description"": ""Number of employees required per large team"", ""shape"": []}, ""AreaMowedLargeTeam"": {""description"": ""Area mowed by a large team"", ""shape"": []}, ""TotalEmployees"": {""description"": ""Total number of employees available"", ""shape"": []}, ""RatioSmallToLargeTeams"": {""description"": ""Minimum ratio of small teams to large teams"", ""shape"": []}, ""MinLargeTeams"": {""description"": ""Minimum number of large teams"", ""shape"": []}, ""MinSmallTeams"": {""description"": ""Minimum number of small teams"", ""shape"": []}}, ""variables"": {""SmallTeams"": {""description"": ""The number of small teams"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""LargeTeams"": {""description"": ""The number of large teams"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total number of employees required by SmallTeams and LargeTeams cannot exceed TotalEmployees."", ""formulation"": ""EmployeesPerSmallTeam \\times SmallTeams + EmployeesPerLargeTeam \\times LargeTeams \\leq TotalEmployees"", ""code"": {""gurobipy"": ""model.addConstr(EmployeesPerSmallTeam * SmallTeams + EmployeesPerLargeTeam * LargeTeams <= TotalEmployees)""}}, {""description"": ""The number of SmallTeams must be at least RatioSmallToLargeTeams times the number of LargeTeams."", ""formulation"": ""SmallTeams \\geq RatioSmallToLargeTeams \\times LargeTeams"", ""code"": {""gurobipy"": ""model.addConstr(SmallTeams >= RatioSmallToLargeTeams * LargeTeams)""}}, {""description"": ""There must be at least MinLargeTeams LargeTeams."", ""formulation"": ""LargeTeams \\geq MinLargeTeams"", ""code"": {""gurobipy"": ""model.addConstr(LargeTeams >= MinLargeTeams)""}}, {""description"": ""There must be at least MinSmallTeams SmallTeams."", ""formulation"": ""SmallTeams \\geq MinSmallTeams"", ""code"": {""gurobipy"": ""model.addConstr(SmallTeams >= MinSmallTeams)""}}], ""objective"": {""description"": ""Total area mowed is the sum of the areas mowed by SmallTeams and LargeTeams. The objective is to maximize the total area mowed."", ""formulation"": ""Max \\left( AreaMowedSmallTeam \\times SmallTeams + AreaMowedLargeTeam \\times LargeTeams \\right )"", ""code"": {""gurobipy"": ""model.setObjective(AreaMowedSmallTeam * SmallTeams + AreaMowedLargeTeam * LargeTeams, GRB.MAXIMIZE)""}}}","{""EmployeesPerSmallTeam"": 3, ""AreaMowedSmallTeam"": 50, ""EmployeesPerLargeTeam"": 5, ""AreaMowedLargeTeam"": 80, ""TotalEmployees"": 150, ""RatioSmallToLargeTeams"": 3, ""MinLargeTeams"": 6, ""MinSmallTeams"": 10}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A lawn mowing service utilizes SmallTeams and LargeTeams. Each SmallTeam
requires EmployeesPerSmallTeam employees and can mow AreaMowedSmallTeam of lawn.
Each LargeTeam requires EmployeesPerLargeTeam employees and can mow
AreaMowedLargeTeam of lawn. The service has TotalEmployees available employees.
The number of SmallTeams must be at least RatioSmallToLargeTeams times the
number of LargeTeams. Additionally, there must be a minimum of MinLargeTeams
LargeTeams and at least MinSmallTeams SmallTeams. The objective is to determine
the optimal number of SmallTeams and LargeTeams to maximize the total area
mowed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/144/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter EmployeesPerSmallTeam @Def: Number of employees required per small team @Shape: [] 
EmployeesPerSmallTeam = data['EmployeesPerSmallTeam']
# @Parameter AreaMowedSmallTeam @Def: Area mowed by a small team @Shape: [] 
AreaMowedSmallTeam = data['AreaMowedSmallTeam']
# @Parameter EmployeesPerLargeTeam @Def: Number of employees required per large team @Shape: [] 
EmployeesPerLargeTeam = data['EmployeesPerLargeTeam']
# @Parameter AreaMowedLargeTeam @Def: Area mowed by a large team @Shape: [] 
AreaMowedLargeTeam = data['AreaMowedLargeTeam']
# @Parameter TotalEmployees @Def: Total number of employees available @Shape: [] 
TotalEmployees = data['TotalEmployees']
# @Parameter RatioSmallToLargeTeams @Def: Minimum ratio of small teams to large teams @Shape: [] 
RatioSmallToLargeTeams = data['RatioSmallToLargeTeams']
# @Parameter MinLargeTeams @Def: Minimum number of large teams @Shape: [] 
MinLargeTeams = data['MinLargeTeams']
# @Parameter MinSmallTeams @Def: Minimum number of small teams @Shape: [] 
MinSmallTeams = data['MinSmallTeams']

# Variables 
# @Variable SmallTeams @Def: The number of small teams @Shape: ['Integer'] 
SmallTeams = model.addVar(vtype=GRB.INTEGER, name=""SmallTeams"")
# @Variable LargeTeams @Def: The number of large teams @Shape: ['Integer'] 
LargeTeams = model.addVar(vtype=GRB.INTEGER, name=""LargeTeams"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of employees required by SmallTeams and LargeTeams cannot exceed TotalEmployees.
model.addConstr(EmployeesPerSmallTeam * SmallTeams + EmployeesPerLargeTeam * LargeTeams <= TotalEmployees)
# @Constraint Constr_2 @Def: The number of SmallTeams must be at least RatioSmallToLargeTeams times the number of LargeTeams.
model.addConstr(SmallTeams >= RatioSmallToLargeTeams * LargeTeams)
# @Constraint Constr_3 @Def: There must be at least MinLargeTeams LargeTeams.
model.addConstr(LargeTeams >= MinLargeTeams)
# @Constraint Constr_4 @Def: There must be at least MinSmallTeams SmallTeams.
model.addConstr(SmallTeams >= MinSmallTeams)

# Objective 
# @Objective Objective @Def: Total area mowed is the sum of the areas mowed by SmallTeams and LargeTeams. The objective is to maximize the total area mowed.
model.setObjective(AreaMowedSmallTeam * SmallTeams + AreaMowedLargeTeam * LargeTeams, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SmallTeams'] = SmallTeams.x
variables['LargeTeams'] = LargeTeams.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An aquarium does shows using otters and dolphins. An otter will do 3 tricks at a time and requires 3 treats to do so. A dolphin will do 1 trick at a time and requires 5 treats to do so. Since dolphins are more popular, at least 10 dolphins must be used and at most 30% of the performers can be otters. If the aquarium only has 200 treats available, maximize the total number of tricks that can be preformed.","{""variables"": {""NumberOfDolphins"": 32.0, ""NumberOfOtters"": 13.0}, ""objective"": 71.0}","{""parametrized_description"": ""An aquarium uses Otters and Dolphins to perform tricks. Each Otter performs OtterTricks at a time and requires OtterTreats treats per performance. Each Dolphin performs DolphinTricks at a time and requires DolphinTreats treats per performance. The aquarium must use at least MinDolphins Dolphins and ensure that no more than MaxOtterPercentage of the total performers are Otters. With a total of TotalTreats treats available, the objective is to maximize the total number of tricks performed."", ""keywords"": [""N.A.""], ""parameters"": {""OtterTricks"": {""description"": ""Number of tricks an otter can perform at a time"", ""shape"": []}, ""OtterTreats"": {""description"": ""Number of treats an otter requires to perform at a time"", ""shape"": []}, ""DolphinTricks"": {""description"": ""Number of tricks a dolphin can perform at a time"", ""shape"": []}, ""DolphinTreats"": {""description"": ""Number of treats a dolphin requires to perform at a time"", ""shape"": []}, ""MinDolphins"": {""description"": ""Minimum number of dolphins required"", ""shape"": []}, ""MaxOtterPercentage"": {""description"": ""Maximum percentage of performers that can be otters"", ""shape"": []}, ""TotalTreats"": {""description"": ""Total number of treats available"", ""shape"": []}}, ""variables"": {""NumberOfDolphins"": {""description"": ""The number of dolphins"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfOtters"": {""description"": ""The number of otters"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of Dolphins must be at least MinDolphins."", ""formulation"": ""NumberOfDolphins \\geq MinDolphins"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfDolphins >= MinDolphins)""}}, {""description"": ""The number of Otters must not exceed MaxOtterPercentage of the total number of performers."", ""formulation"": ""NumberOfOtters \\leq MaxOtterPercentage \\times (NumberOfOtters + NumberOfDolphins)"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfOtters <= MaxOtterPercentage * (NumberOfOtters + NumberOfDolphins))""}}, {""description"": ""The total number of treats used by Otters and Dolphins must not exceed TotalTreats."", ""formulation"": ""NumberOfOtters \\times OtterTreats + NumberOfDolphins \\times DolphinTreats \\leq TotalTreats"", ""code"": {""gurobipy"": ""model.addConstr(OtterTreats * NumberOfOtters + DolphinTreats * NumberOfDolphins <= TotalTreats)""}}], ""objective"": {""description"": ""Maximize the total number of tricks performed, which is the sum of OtterTricks multiplied by the number of Otters and DolphinTricks multiplied by the number of Dolphins."", ""formulation"": ""Max \\ OtterTricks \\cdot NumberOfOtters + DolphinTricks \\cdot NumberOfDolphins"", ""code"": {""gurobipy"": ""model.setObjective(OtterTricks * NumberOfOtters + DolphinTricks * NumberOfDolphins, GRB.MAXIMIZE)""}}}","{""OtterTricks"": 3, ""OtterTreats"": 3, ""DolphinTricks"": 1, ""DolphinTreats"": 5, ""MinDolphins"": 10, ""MaxOtterPercentage"": 0.3, ""TotalTreats"": 200}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
An aquarium uses Otters and Dolphins to perform tricks. Each Otter performs
OtterTricks at a time and requires OtterTreats treats per performance. Each
Dolphin performs DolphinTricks at a time and requires DolphinTreats treats per
performance. The aquarium must use at least MinDolphins Dolphins and ensure that
no more than MaxOtterPercentage of the total performers are Otters. With a total
of TotalTreats treats available, the objective is to maximize the total number
of tricks performed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/145/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter OtterTricks @Def: Number of tricks an otter can perform at a time @Shape: [] 
OtterTricks = data['OtterTricks']
# @Parameter OtterTreats @Def: Number of treats an otter requires to perform at a time @Shape: [] 
OtterTreats = data['OtterTreats']
# @Parameter DolphinTricks @Def: Number of tricks a dolphin can perform at a time @Shape: [] 
DolphinTricks = data['DolphinTricks']
# @Parameter DolphinTreats @Def: Number of treats a dolphin requires to perform at a time @Shape: [] 
DolphinTreats = data['DolphinTreats']
# @Parameter MinDolphins @Def: Minimum number of dolphins required @Shape: [] 
MinDolphins = data['MinDolphins']
# @Parameter MaxOtterPercentage @Def: Maximum percentage of performers that can be otters @Shape: [] 
MaxOtterPercentage = data['MaxOtterPercentage']
# @Parameter TotalTreats @Def: Total number of treats available @Shape: [] 
TotalTreats = data['TotalTreats']

# Variables 
# @Variable NumberOfDolphins @Def: The number of dolphins @Shape: [] 
NumberOfDolphins = model.addVar(vtype=GRB.INTEGER, name=""NumberOfDolphins"")
# @Variable NumberOfOtters @Def: The number of otters @Shape: [] 
NumberOfOtters = model.addVar(vtype=GRB.INTEGER, lb=0, name=""NumberOfOtters"")

# Constraints 
# @Constraint Constr_1 @Def: The number of Dolphins must be at least MinDolphins.
model.addConstr(NumberOfDolphins >= MinDolphins)
# @Constraint Constr_2 @Def: The number of Otters must not exceed MaxOtterPercentage of the total number of performers.
model.addConstr(NumberOfOtters <= MaxOtterPercentage * (NumberOfOtters + NumberOfDolphins))
# @Constraint Constr_3 @Def: The total number of treats used by Otters and Dolphins must not exceed TotalTreats.
model.addConstr(OtterTreats * NumberOfOtters + DolphinTreats * NumberOfDolphins <= TotalTreats)

# Objective 
# @Objective Objective @Def: Maximize the total number of tricks performed, which is the sum of OtterTricks multiplied by the number of Otters and DolphinTricks multiplied by the number of Dolphins.
model.setObjective(OtterTricks * NumberOfOtters + DolphinTricks * NumberOfDolphins, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfDolphins'] = NumberOfDolphins.x
variables['NumberOfOtters'] = NumberOfOtters.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A shoe company supplies shoes to stores via vans and trucks. A van can transport 50 pairs of shoes while a truck can transport 100 pairs of shoes. The company must supply a minimum of 2000 pairs of shoes around the city. Since most stores are small, the number of trucks used cannot exceed the number of vans used.  Find the minimum number of vans that can be used?","{""variables"": {""NumberOfVans"": 14.0, ""NumberOfTrucks"": 14.0}, ""objective"": 14.0}","{""parametrized_description"": ""A company supplies at least MinPairsToSupply items using vehicles of two types: vans and trucks. Each van can transport VanCapacity items and each truck can transport TruckCapacity items. The number of trucks used cannot exceed the number of vans used. Determine the minimum number of vans required."", ""keywords"": [""N.A.""], ""parameters"": {""VanCapacity"": {""description"": ""Number of pairs of shoes a van can transport"", ""shape"": []}, ""TruckCapacity"": {""description"": ""Number of pairs of shoes a truck can transport"", ""shape"": []}, ""MinPairsToSupply"": {""description"": ""Minimum number of pairs of shoes to supply"", ""shape"": []}}, ""variables"": {""NumberOfVans"": {""description"": ""The number of vans used to transport the shoes"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberOfTrucks"": {""description"": ""The number of trucks used to transport the shoes"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total number of items transported by vans and trucks must be at least MinPairsToSupply."", ""formulation"": ""VanCapacity \\times NumberOfVans + TruckCapacity \\times NumberOfTrucks \\geq MinPairsToSupply"", ""code"": {""gurobipy"": ""model.addConstr(VanCapacity * NumberOfVans + TruckCapacity * NumberOfTrucks >= MinPairsToSupply)""}}, {""description"": ""The number of trucks used cannot exceed the number of vans used."", ""formulation"": ""NumberOfTrucks \\leq NumberOfVans"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfTrucks <= NumberOfVans)""}}], ""objective"": {""description"": ""Minimize the number of vans required to supply at least MinPairsToSupply items while ensuring that the number of trucks used does not exceed the number of vans used."", ""formulation"": ""Min NumberOfVans \\\\ NumberOfVans \\times VanCapacity + NumberOfTrucks \\times TruckCapacity \\geq MinPairsToSupply \\\\ NumberOfTrucks \\leq NumberOfVans"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfVans, GRB.MINIMIZE)""}}}","{""VanCapacity"": 50, ""TruckCapacity"": 100, ""MinPairsToSupply"": 2000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company supplies at least MinPairsToSupply items using vehicles of two types:
vans and trucks. Each van can transport VanCapacity items and each truck can
transport TruckCapacity items. The number of trucks used cannot exceed the
number of vans used. Determine the minimum number of vans required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/146/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter VanCapacity @Def: Number of pairs of shoes a van can transport @Shape: [] 
VanCapacity = data['VanCapacity']
# @Parameter TruckCapacity @Def: Number of pairs of shoes a truck can transport @Shape: [] 
TruckCapacity = data['TruckCapacity']
# @Parameter MinPairsToSupply @Def: Minimum number of pairs of shoes to supply @Shape: [] 
MinPairsToSupply = data['MinPairsToSupply']

# Variables 
# @Variable NumberOfVans @Def: The number of vans used to transport the shoes @Shape: ['Integer'] 
NumberOfVans = model.addVar(vtype=GRB.INTEGER, name=""NumberOfVans"")
# @Variable NumberOfTrucks @Def: The number of trucks used to transport the shoes @Shape: ['Integer'] 
NumberOfTrucks = model.addVar(vtype=GRB.INTEGER, name=""NumberOfTrucks"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of items transported by vans and trucks must be at least MinPairsToSupply.
model.addConstr(VanCapacity * NumberOfVans + TruckCapacity * NumberOfTrucks >= MinPairsToSupply)
# @Constraint Constr_2 @Def: The number of trucks used cannot exceed the number of vans used.
model.addConstr(NumberOfTrucks <= NumberOfVans)

# Objective 
# @Objective Objective @Def: Minimize the number of vans required to supply at least MinPairsToSupply items while ensuring that the number of trucks used does not exceed the number of vans used.
model.setObjective(NumberOfVans, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfVans'] = NumberOfVans.x
variables['NumberOfTrucks'] = NumberOfTrucks.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An oil and gas company is sending their oil to the port using containers and trucks. A container can hold 30 units of oil while a truck can hold 40 units of oil. Due to government restrictions, the number of trucks used has to at most half the number of containers used. If at least 2000 units of oil need to be sent to the port and at least 15 containers need to be used, minimize the total number of containers and trucks needed.","{""variables"": {""NumContainers"": 40.0, ""NumTrucks"": 20.0}, ""objective"": 60.0}","{""parametrized_description"": ""An oil and gas company sends oil to the port using containers and trucks. Each container can hold ContainerCapacity units of oil while each truck can hold TruckCapacity units of oil. Due to government restrictions, the number of trucks used must be at most TruckToContainerRatio multiplied by the number of containers used. If at least MinimumOilSent units of oil need to be sent to the port and at least MinimumContainers containers must be used, minimize the total number of containers and trucks needed."", ""keywords"": [""N.A.""], ""parameters"": {""ContainerCapacity"": {""description"": ""Number of units of oil each container can hold"", ""shape"": []}, ""TruckCapacity"": {""description"": ""Number of units of oil each truck can hold"", ""shape"": []}, ""TruckToContainerRatio"": {""description"": ""Maximum allowed ratio of number of trucks to number of containers"", ""shape"": []}, ""MinimumOilSent"": {""description"": ""Minimum number of units of oil that need to be sent to the port"", ""shape"": []}, ""MinimumContainers"": {""description"": ""Minimum number of containers that need to be used"", ""shape"": []}}, ""variables"": {""NumContainers"": {""description"": ""The number of containers used"", ""type"": ""continuous"", ""shape"": []}, ""NumTrucks"": {""description"": ""The number of trucks used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total amount of oil sent to the port must be at least 2000 units, calculated as 30 units per container plus 40 units per truck."", ""formulation"": ""ContainerCapacity \\times NumContainers + TruckCapacity \\times NumTrucks \\geq MinimumOilSent"", ""code"": {""gurobipy"": ""model.addConstr(ContainerCapacity * NumContainers + TruckCapacity * NumTrucks >= MinimumOilSent)""}}, {""description"": ""The number of trucks used must be at most half the number of containers used."", ""formulation"": ""NumTrucks \\leq TruckToContainerRatio \\times NumContainers"", ""code"": {""gurobipy"": ""model.addConstr(NumTrucks <= TruckToContainerRatio * NumContainers)""}}, {""description"": ""At least 15 containers must be used."", ""formulation"": ""NumContainers \\geq MinimumContainers"", ""code"": {""gurobipy"": ""model.addConstr(NumContainers >= MinimumContainers)""}}], ""objective"": {""description"": ""The objective is to minimize the total number of containers and trucks needed."", ""formulation"": ""Min NumContainers + NumTrucks"", ""code"": {""gurobipy"": ""model.setObjective(NumContainers + NumTrucks, GRB.MINIMIZE)""}}}","{""ContainerCapacity"": 30, ""TruckCapacity"": 40, ""TruckToContainerRatio"": 0.5, ""MinimumOilSent"": 2000, ""MinimumContainers"": 15}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
An oil and gas company sends oil to the port using containers and trucks. Each
container can hold ContainerCapacity units of oil while each truck can hold
TruckCapacity units of oil. Due to government restrictions, the number of trucks
used must be at most TruckToContainerRatio multiplied by the number of
containers used. If at least MinimumOilSent units of oil need to be sent to the
port and at least MinimumContainers containers must be used, minimize the total
number of containers and trucks needed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/147/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ContainerCapacity @Def: Number of units of oil each container can hold @Shape: [] 
ContainerCapacity = data['ContainerCapacity']
# @Parameter TruckCapacity @Def: Number of units of oil each truck can hold @Shape: [] 
TruckCapacity = data['TruckCapacity']
# @Parameter TruckToContainerRatio @Def: Maximum allowed ratio of number of trucks to number of containers @Shape: [] 
TruckToContainerRatio = data['TruckToContainerRatio']
# @Parameter MinimumOilSent @Def: Minimum number of units of oil that need to be sent to the port @Shape: [] 
MinimumOilSent = data['MinimumOilSent']
# @Parameter MinimumContainers @Def: Minimum number of containers that need to be used @Shape: [] 
MinimumContainers = data['MinimumContainers']

# Variables 
# @Variable NumContainers @Def: The number of containers used @Shape: [] 
NumContainers = model.addVar(vtype=GRB.INTEGER, name=""NumContainers"", lb=MinimumContainers)
# @Variable NumTrucks @Def: The number of trucks used @Shape: [] 
NumTrucks = model.addVar(vtype=GRB.INTEGER, name=""NumTrucks"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of oil sent to the port must be at least 2000 units, calculated as 30 units per container plus 40 units per truck.
model.addConstr(ContainerCapacity * NumContainers + TruckCapacity * NumTrucks >= MinimumOilSent)
# @Constraint Constr_2 @Def: The number of trucks used must be at most half the number of containers used.
model.addConstr(NumTrucks <= TruckToContainerRatio * NumContainers)
# @Constraint Constr_3 @Def: At least 15 containers must be used.
model.addConstr(NumContainers >= MinimumContainers)

# Objective 
# @Objective Objective @Def: The objective is to minimize the total number of containers and trucks needed.
model.setObjective(NumContainers + NumTrucks, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumContainers'] = NumContainers.x
variables['NumTrucks'] = NumTrucks.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A school is organizing a field trip to a science center and wants to hire small buses and large buses. A small bus can carry 20 students while a large bus can carry 50 students.  The school needs to provide transportation for at least 500 students.  In addition, since the parking lot is rather small, a maximum of 20% of the buses can be large buses. How many of each type of bus should be hired to minimize the total number of buses?","{""variables"": {""NumberSmallBuses"": 16.0, ""NumberLargeBuses"": 4.0}, ""objective"": 20.0}","{""parametrized_description"": ""A school hires small buses and large buses with capacities SmallBusCapacity and LargeBusCapacity respectively to transport at least MinimumStudents students. No more than MaxLargeBusPercentage of the total buses can be large buses. The objective is to minimize the total number of buses hired."", ""keywords"": [""N.A.""], ""parameters"": {""SmallBusCapacity"": {""description"": ""Capacity of a small bus"", ""shape"": []}, ""LargeBusCapacity"": {""description"": ""Capacity of a large bus"", ""shape"": []}, ""MinimumStudents"": {""description"": ""Minimum number of students to transport"", ""shape"": []}, ""MaxLargeBusPercentage"": {""description"": ""Maximum percentage of buses that can be large buses"", ""shape"": []}}, ""variables"": {""NumberSmallBuses"": {""description"": ""The number of small buses"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberLargeBuses"": {""description"": ""The number of large buses"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""A small bus transports SmallBusCapacity students and a large bus transports LargeBusCapacity students. The total number of students transported must be at least MinimumStudents."", ""formulation"": ""SmallBusCapacity \\times NumberSmallBuses + LargeBusCapacity \\times NumberLargeBuses \\geq MinimumStudents"", ""code"": {""gurobipy"": ""model.addConstr(SmallBusCapacity * NumberSmallBuses + LargeBusCapacity * NumberLargeBuses >= MinimumStudents)""}}, {""description"": ""No more than MaxLargeBusPercentage of the total buses can be large buses."", ""formulation"": ""(1 - MaxLargeBusPercentage) \\cdot NumberLargeBuses \\leq MaxLargeBusPercentage \\cdot NumberSmallBuses"", ""code"": {""gurobipy"": ""model.addConstr((1 - MaxLargeBusPercentage) * NumberLargeBuses <= MaxLargeBusPercentage * NumberSmallBuses)""}}], ""objective"": {""description"": ""The objective is to minimize the total number of buses hired."", ""formulation"": ""Min NumberSmallBuses + NumberLargeBuses"", ""code"": {""gurobipy"": ""model.setObjective(NumberSmallBuses + NumberLargeBuses, GRB.MINIMIZE)""}}}","{""SmallBusCapacity"": 20, ""LargeBusCapacity"": 50, ""MinimumStudents"": 500, ""MaxLargeBusPercentage"": 0.2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A school hires small buses and large buses with capacities SmallBusCapacity and
LargeBusCapacity respectively to transport at least MinimumStudents students. No
more than MaxLargeBusPercentage of the total buses can be large buses. The
objective is to minimize the total number of buses hired.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/148/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SmallBusCapacity @Def: Capacity of a small bus @Shape: [] 
SmallBusCapacity = data['SmallBusCapacity']
# @Parameter LargeBusCapacity @Def: Capacity of a large bus @Shape: [] 
LargeBusCapacity = data['LargeBusCapacity']
# @Parameter MinimumStudents @Def: Minimum number of students to transport @Shape: [] 
MinimumStudents = data['MinimumStudents']
# @Parameter MaxLargeBusPercentage @Def: Maximum percentage of buses that can be large buses @Shape: [] 
MaxLargeBusPercentage = data['MaxLargeBusPercentage']

# Variables 
# @Variable NumberSmallBuses @Def: The number of small buses @Shape: ['Integer'] 
NumberSmallBuses = model.addVar(vtype=GRB.INTEGER, name=""NumberSmallBuses"")
# @Variable NumberLargeBuses @Def: The number of large buses @Shape: ['Integer'] 
NumberLargeBuses = model.addVar(vtype=GRB.INTEGER, name=""NumberLargeBuses"")

# Constraints 
# @Constraint Constr_1 @Def: A small bus transports SmallBusCapacity students and a large bus transports LargeBusCapacity students. The total number of students transported must be at least MinimumStudents.
model.addConstr(SmallBusCapacity * NumberSmallBuses + LargeBusCapacity * NumberLargeBuses >= MinimumStudents)
# @Constraint Constr_2 @Def: No more than MaxLargeBusPercentage of the total buses can be large buses.
model.addConstr((1 - MaxLargeBusPercentage) * NumberLargeBuses <= MaxLargeBusPercentage * NumberSmallBuses)

# Objective 
# @Objective Objective @Def: The objective is to minimize the total number of buses hired.
model.setObjective(NumberSmallBuses + NumberLargeBuses, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberSmallBuses'] = NumberSmallBuses.x
variables['NumberLargeBuses'] = NumberLargeBuses.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A meat shop ships their burger patties using refrigerated trucks and vans. Each truck can take 1000 patties at a cost of $300 per trip. Each van can take 500 patties at a cost of $100 per trip. Because the trucks have difficulty moving around in the city, the number of trucks must not exceed the number of vans. The meat shop has to ship at least 50000 patties and they have a budget of $12500. How should they plan their shipment to minimize the total number of trips?","{""variables"": {""NumTrips"": {""0"": 25.0, ""1"": 50.0}, ""NumVehicles"": {""0"": 0.0, ""1"": -0.0}}, ""objective"": 75.0}","{""parametrized_description"": ""A company utilizes NumVehicleTypes different vehicle types to transport patties. Each vehicle type i has a Capacity[i] capacity for patties and incurs a CostPerTrip[i] cost per trip. The number of vehicles of one type must not exceed the number of vehicles of another type. The company must transport at least MinPatties patties while staying within a Budget. The objective is to minimize the total number of trips."", ""keywords"": [""N.A.""], ""parameters"": {""NumVehicleTypes"": {""description"": ""Number of vehicle types"", ""shape"": []}, ""Capacity"": {""description"": ""Capacity of each vehicle type in number of patties"", ""shape"": [""NumVehicleTypes""]}, ""CostPerTrip"": {""description"": ""Cost per trip for each vehicle type"", ""shape"": [""NumVehicleTypes""]}, ""MinPatties"": {""description"": ""Minimum number of patties to be shipped"", ""shape"": []}, ""Budget"": {""description"": ""Budget for shipping"", ""shape"": []}}, ""variables"": {""NumTrips"": {""description"": ""The number of trips for each vehicle type"", ""type"": ""continuous"", ""shape"": [""NumVehicleTypes""]}, ""NumVehicles"": {""description"": ""The number of vehicles for each vehicle type"", ""type"": ""continuous"", ""shape"": [""NumVehicleTypes""]}}, ""constraints"": [{""description"": ""At least MinPatties patties must be transported."", ""formulation"": ""\\sum_{i=1}^{NumVehicleTypes} Capacity_i \\cdot NumTrips_i \\geq MinPatties"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(Capacity[i] * NumTrips[i] for i in range(NumVehicleTypes)) >= MinPatties)""}}, {""description"": ""The total cost of all trips must not exceed the Budget."", ""formulation"": ""\\sum_{i=1}^{NumVehicleTypes} NumTrips_i \\cdot CostPerTrip_i \\leq Budget"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(NumTrips[i] * CostPerTrip[i] for i in range(NumVehicleTypes)) <= Budget)""}}, {""description"": ""The number of vehicles of one vehicle type must not exceed the number of vehicles of another vehicle type."", ""formulation"": ""NumVehicles_i \\leq NumVehicles_j"", ""code"": {""gurobipy"": ""model.addConstr(NumVehicles[i] <= NumVehicles[j], name=\""Vehicles_Constraint\"")""}}], ""objective"": {""description"": ""Minimize the total number of trips required to transport the patties."", ""formulation"": ""Min \\sum_{i=1}^{NumVehicleTypes} NumTrips_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(NumTrips[i] for i in range(NumVehicleTypes)), GRB.MINIMIZE)""}}}","{""NumVehicleTypes"": 2, ""Capacity"": [1000, 500], ""CostPerTrip"": [300, 100], ""MinPatties"": 50000, ""Budget"": 12500}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company utilizes NumVehicleTypes different vehicle types to transport patties.
Each vehicle type i has a Capacity[i] capacity for patties and incurs a
CostPerTrip[i] cost per trip. The number of vehicles of one type must not exceed
the number of vehicles of another type. The company must transport at least
MinPatties patties while staying within a Budget. The objective is to minimize
the total number of trips.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/149/parameters.json"", ""r"") as f:
    data = json.load(f)
        
# @Def: definition of a target
# @Shape: shape of a target
            
# Parameters 
# @Parameter NumVehicleTypes @Def: Number of vehicle types @Shape: [] 
NumVehicleTypes = data['NumVehicleTypes']
# @Parameter Capacity @Def: Capacity of each vehicle type in number of patties @Shape: ['NumVehicleTypes'] 
Capacity = data['Capacity']
# @Parameter CostPerTrip @Def: Cost per trip for each vehicle type @Shape: ['NumVehicleTypes'] 
CostPerTrip = data['CostPerTrip']
# @Parameter MinPatties @Def: Minimum number of patties to be shipped @Shape: [] 
MinPatties = data['MinPatties']
# @Parameter Budget @Def: Budget for shipping @Shape: [] 
Budget = data['Budget']
    
# Variables 
# @Variable NumTrips @Def: The number of trips for each vehicle type @Shape: ['NumVehicleTypes'] 
NumTrips = model.addVars(NumVehicleTypes, vtype=GRB.INTEGER, name=""NumTrips"")
# @Variable NumVehicles @Def: The number of vehicles for each vehicle type @Shape: ['NumVehicleTypes'] 
NumVehicles = model.addVars(range(NumVehicleTypes), vtype=GRB.INTEGER, name=""NumVehicles"")
    
# Constraints 
# @Constraint Constr_1 @Def: At least MinPatties patties must be transported.
model.addConstr(quicksum(Capacity[i] * NumTrips[i] for i in range(NumVehicleTypes)) >= MinPatties)
# @Constraint Constr_2 @Def: The total cost of all trips must not exceed the Budget.
model.addConstr(quicksum(NumTrips[i] * CostPerTrip[i] for i in range(NumVehicleTypes)) <= Budget)
# @Constraint Constr_3 @Def: The number of vehicles of one vehicle type must not exceed the number of vehicles of another vehicle type.
for i in range(NumVehicleTypes):
    for j in range(NumVehicleTypes):
        if i != j:
            model.addConstr(NumVehicles[i] <= NumVehicles[j], name=f""Vehicles_Constraint_{i}_{j}"")
    
# Objective 
# @Objective Objective @Def: Minimize the total number of trips required to transport the patties.
model.setObjective(quicksum(NumTrips[i] for i in range(NumVehicleTypes)), GRB.MINIMIZE)
    
# Solve 
model.optimize()
    
# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumTrips'] = {i: NumTrips[i].x for i in range(NumVehicleTypes)}
variables['NumVehicles'] = {i: NumVehicles[i].x for i in range(NumVehicleTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A florist transports his flowers to stores in small bouquets and large bouquets. A small bouquet has 5 flowers while a large bouquet has 10 flowers. The florist can transport at most 80 small bouquets and 50 large bouquets. In total, he can transport at most 70 bouquets and he must transport at least 20 large bouquets. Since small bouquets are more popular, he must transport at least twice as many small bouquets as large bouquets. How many of each bouquet should he transport to maximize the total number of flowers that reach the stores?","{""variables"": {""SmallBouquets"": 47.0, ""LargeBouquets"": 23.0}, ""objective"": 465.0}","{""parametrized_description"": ""A florist transports small and large bouquets, where each small bouquet contains FlowersPerSmallBouquet flowers and each large bouquet contains FlowersPerLargeBouquet flowers. The florist can transport at most MaxSmallBouquets small bouquets and MaxLargeBouquets large bouquets. In total, the florist can transport at most MaxTotalBouquets bouquets. The florist must transport at least MinLargeBouquets large bouquets. Additionally, the number of small bouquets transported must be at least MinSmallToLargeRatio times the number of large bouquets transported. The objective is to determine the number of small and large bouquets to transport in order to maximize the total number of flowers delivered to the stores."", ""keywords"": [""N.A.""], ""parameters"": {""FlowersPerSmallBouquet"": {""description"": ""Number of flowers in a small bouquet"", ""shape"": []}, ""FlowersPerLargeBouquet"": {""description"": ""Number of flowers in a large bouquet"", ""shape"": []}, ""MaxSmallBouquets"": {""description"": ""Maximum number of small bouquets that can be transported"", ""shape"": []}, ""MaxLargeBouquets"": {""description"": ""Maximum number of large bouquets that can be transported"", ""shape"": []}, ""MaxTotalBouquets"": {""description"": ""Maximum total number of bouquets that can be transported"", ""shape"": []}, ""MinLargeBouquets"": {""description"": ""Minimum number of large bouquets that must be transported"", ""shape"": []}, ""MinSmallToLargeRatio"": {""description"": ""Minimum ratio of small bouquets to large bouquets"", ""shape"": []}}, ""variables"": {""SmallBouquets"": {""description"": ""The number of small bouquets transported"", ""type"": ""continuous"", ""shape"": []}, ""LargeBouquets"": {""description"": ""The number of large bouquets transported"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of small bouquets transported cannot exceed MaxSmallBouquets."", ""formulation"": ""SmallBouquets \\leq MaxSmallBouquets"", ""code"": {""gurobipy"": ""model.addConstr(SmallBouquets <= MaxSmallBouquets)""}}, {""description"": ""The number of large bouquets transported cannot exceed MaxLargeBouquets."", ""formulation"": ""LargeBouquets \\leq MaxLargeBouquets"", ""code"": {""gurobipy"": ""model.addConstr(LargeBouquets <= MaxLargeBouquets)""}}, {""description"": ""The total number of bouquets transported cannot exceed MaxTotalBouquets."", ""formulation"": ""SmallBouquets + LargeBouquets \\leq MaxTotalBouquets"", ""code"": {""gurobipy"": ""model.addConstr(SmallBouquets + LargeBouquets <= MaxTotalBouquets)""}}, {""description"": ""At least MinLargeBouquets large bouquets must be transported."", ""formulation"": ""LargeBouquets \\geq MinLargeBouquets"", ""code"": {""gurobipy"": ""model.addConstr(LargeBouquets >= MinLargeBouquets)""}}, {""description"": ""The number of small bouquets transported must be at least MinSmallToLargeRatio times the number of large bouquets transported."", ""formulation"": ""SmallBouquets \\geq MinSmallToLargeRatio \\times LargeBouquets"", ""code"": {""gurobipy"": ""model.addConstr(SmallBouquets >= MinSmallToLargeRatio * LargeBouquets)""}}], ""objective"": {""description"": ""The total number of flowers delivered is the sum of FlowersPerSmallBouquet multiplied by the number of small bouquets and FlowersPerLargeBouquet multiplied by the number of large bouquets. The objective is to maximize the total number of flowers delivered to the stores."", ""formulation"": ""Max \\ FlowersPerSmallBouquet \\times SmallBouquets + FlowersPerLargeBouquet \\times LargeBouquets"", ""code"": {""gurobipy"": ""model.setObjective(FlowersPerSmallBouquet * SmallBouquets + FlowersPerLargeBouquet * LargeBouquets, GRB.MAXIMIZE)""}}}","{""FlowersPerSmallBouquet"": 5, ""FlowersPerLargeBouquet"": 10, ""MaxSmallBouquets"": 80, ""MaxLargeBouquets"": 50, ""MaxTotalBouquets"": 70, ""MinLargeBouquets"": 20, ""MinSmallToLargeRatio"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A florist transports small and large bouquets, where each small bouquet contains
FlowersPerSmallBouquet flowers and each large bouquet contains
FlowersPerLargeBouquet flowers. The florist can transport at most
MaxSmallBouquets small bouquets and MaxLargeBouquets large bouquets. In total,
the florist can transport at most MaxTotalBouquets bouquets. The florist must
transport at least MinLargeBouquets large bouquets. Additionally, the number of
small bouquets transported must be at least MinSmallToLargeRatio times the
number of large bouquets transported. The objective is to determine the number
of small and large bouquets to transport in order to maximize the total number
of flowers delivered to the stores.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/150/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter FlowersPerSmallBouquet @Def: Number of flowers in a small bouquet @Shape: [] 
FlowersPerSmallBouquet = data['FlowersPerSmallBouquet']
# @Parameter FlowersPerLargeBouquet @Def: Number of flowers in a large bouquet @Shape: [] 
FlowersPerLargeBouquet = data['FlowersPerLargeBouquet']
# @Parameter MaxSmallBouquets @Def: Maximum number of small bouquets that can be transported @Shape: [] 
MaxSmallBouquets = data['MaxSmallBouquets']
# @Parameter MaxLargeBouquets @Def: Maximum number of large bouquets that can be transported @Shape: [] 
MaxLargeBouquets = data['MaxLargeBouquets']
# @Parameter MaxTotalBouquets @Def: Maximum total number of bouquets that can be transported @Shape: [] 
MaxTotalBouquets = data['MaxTotalBouquets']
# @Parameter MinLargeBouquets @Def: Minimum number of large bouquets that must be transported @Shape: [] 
MinLargeBouquets = data['MinLargeBouquets']
# @Parameter MinSmallToLargeRatio @Def: Minimum ratio of small bouquets to large bouquets @Shape: [] 
MinSmallToLargeRatio = data['MinSmallToLargeRatio']

# Variables 
# @Variable SmallBouquets @Def: The number of small bouquets transported @Shape: [] 
SmallBouquets = model.addVar(vtype=GRB.INTEGER, ub=MaxSmallBouquets, name=""SmallBouquets"")
# @Variable LargeBouquets @Def: The number of large bouquets transported @Shape: [] 
LargeBouquets = model.addVar(lb=MinLargeBouquets, ub=MaxLargeBouquets, vtype=GRB.INTEGER, name=""LargeBouquets"")

# Constraints 
# @Constraint Constr_1 @Def: The number of small bouquets transported cannot exceed MaxSmallBouquets.
model.addConstr(SmallBouquets <= MaxSmallBouquets)
# @Constraint Constr_2 @Def: The number of large bouquets transported cannot exceed MaxLargeBouquets.
model.addConstr(LargeBouquets <= MaxLargeBouquets)
# @Constraint Constr_3 @Def: The total number of bouquets transported cannot exceed MaxTotalBouquets.
model.addConstr(SmallBouquets + LargeBouquets <= MaxTotalBouquets)
# @Constraint Constr_4 @Def: At least MinLargeBouquets large bouquets must be transported.
model.addConstr(LargeBouquets >= MinLargeBouquets)
# @Constraint Constr_5 @Def: The number of small bouquets transported must be at least MinSmallToLargeRatio times the number of large bouquets transported.
model.addConstr(SmallBouquets >= MinSmallToLargeRatio * LargeBouquets)

# Objective 
# @Objective Objective @Def: The total number of flowers delivered is the sum of FlowersPerSmallBouquet multiplied by the number of small bouquets and FlowersPerLargeBouquet multiplied by the number of large bouquets. The objective is to maximize the total number of flowers delivered to the stores.
model.setObjective(FlowersPerSmallBouquet * SmallBouquets + FlowersPerLargeBouquet * LargeBouquets, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SmallBouquets'] = SmallBouquets.x
variables['LargeBouquets'] = LargeBouquets.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A toy store decides to deliver gifts using two shipping companies, a new one and an old one. The new company can deliver 50 gifts per trip while the old company can deliver 70 gifts per trip. The new company uses 30 liters of diesel per trip while the old company uses 40 liters of diesel per trip. The toy store needs to deliver at least 1000 gifts. There can be at most 15 trips made by the new company. In order to make sure that the old company does not go out of business, at least 40% of all trips must be made by the old company. How many trips should each company make to minimize the total amount of diesel used?","{""variables"": {""TripsNewCompany"": 2.0, ""TripsOldCompany"": 13.0}, ""objective"": 580.0}","{""parametrized_description"": ""A toy store decides to deliver gifts using two shipping companies. The new company can deliver NewCompanyCapacity gifts per trip while the old company can deliver OldCompanyCapacity gifts per trip. The new company uses NewCompanyDiesel liters of diesel per trip, whereas the old company uses OldCompanyDiesel liters of diesel per trip. The toy store needs to deliver at least MinimumGifts gifts. There can be at most MaxTripsNewCompany trips made by the new shipping company. To ensure that the old company does not go out of business, at least MinimumOldCompanyTripPercentage of all trips must be made by the old shipping company. The objective is to determine the number of trips each company should make to minimize the total amount of diesel used."", ""keywords"": [""N.A.""], ""parameters"": {""NewCompanyCapacity"": {""description"": ""Delivery capacity per trip of the new shipping company"", ""shape"": []}, ""OldCompanyCapacity"": {""description"": ""Delivery capacity per trip of the old shipping company"", ""shape"": []}, ""NewCompanyDiesel"": {""description"": ""Diesel consumption per trip of the new shipping company"", ""shape"": []}, ""OldCompanyDiesel"": {""description"": ""Diesel consumption per trip of the old shipping company"", ""shape"": []}, ""MinimumGifts"": {""description"": ""Minimum number of gifts to deliver"", ""shape"": []}, ""MaxTripsNewCompany"": {""description"": ""Maximum number of trips by the new shipping company"", ""shape"": []}, ""MinimumOldCompanyTripPercentage"": {""description"": ""Minimum percentage of trips that must be made by the old shipping company"", ""shape"": []}}, ""variables"": {""TripsNewCompany"": {""description"": ""The number of trips made by the new shipping company"", ""type"": ""continuous"", ""shape"": []}, ""TripsOldCompany"": {""description"": ""The number of trips made by the old shipping company"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of gifts delivered by the new and old shipping companies must be at least MinimumGifts."", ""formulation"": ""NewCompanyCapacity \\times TripsNewCompany + OldCompanyCapacity \\times TripsOldCompany \\geq MinimumGifts"", ""code"": {""gurobipy"": ""model.addConstr(NewCompanyCapacity * TripsNewCompany + OldCompanyCapacity * TripsOldCompany >= MinimumGifts)""}}, {""description"": ""The number of trips made by the new shipping company cannot exceed MaxTripsNewCompany."", ""formulation"": ""TripsNewCompany \\leq MaxTripsNewCompany"", ""code"": {""gurobipy"": ""model.addConstr(TripsNewCompany <= MaxTripsNewCompany)""}}, {""description"": ""At least MinimumOldCompanyTripPercentage proportion of all trips must be made by the old shipping company."", ""formulation"": ""TripsOldCompany \\geq MinimumOldCompanyTripPercentage \\times ( TripsOldCompany + TripsNewCompany )"", ""code"": {""gurobipy"": ""model.addConstr(TripsOldCompany >= MinimumOldCompanyTripPercentage * (TripsOldCompany + TripsNewCompany))""}}], ""objective"": {""description"": ""Minimize the total amount of diesel used, which is the sum of diesel consumed by the new and old shipping companies."", ""formulation"": ""Min NewCompanyDiesel \\times TripsNewCompany + OldCompanyDiesel \\times TripsOldCompany"", ""code"": {""gurobipy"": ""model.setObjective(NewCompanyDiesel * TripsNewCompany + OldCompanyDiesel * TripsOldCompany, GRB.MINIMIZE)""}}}","{""NewCompanyCapacity"": 50, ""OldCompanyCapacity"": 70, ""NewCompanyDiesel"": 30, ""OldCompanyDiesel"": 40, ""MinimumGifts"": 1000, ""MaxTripsNewCompany"": 15, ""MinimumOldCompanyTripPercentage"": 0.4}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A toy store decides to deliver gifts using two shipping companies. The new
company can deliver NewCompanyCapacity gifts per trip while the old company can
deliver OldCompanyCapacity gifts per trip. The new company uses NewCompanyDiesel
liters of diesel per trip, whereas the old company uses OldCompanyDiesel liters
of diesel per trip. The toy store needs to deliver at least MinimumGifts gifts.
There can be at most MaxTripsNewCompany trips made by the new shipping company.
To ensure that the old company does not go out of business, at least
MinimumOldCompanyTripPercentage of all trips must be made by the old shipping
company. The objective is to determine the number of trips each company should
make to minimize the total amount of diesel used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/151/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NewCompanyCapacity @Def: Delivery capacity per trip of the new shipping company @Shape: [] 
NewCompanyCapacity = data['NewCompanyCapacity']
# @Parameter OldCompanyCapacity @Def: Delivery capacity per trip of the old shipping company @Shape: [] 
OldCompanyCapacity = data['OldCompanyCapacity']
# @Parameter NewCompanyDiesel @Def: Diesel consumption per trip of the new shipping company @Shape: [] 
NewCompanyDiesel = data['NewCompanyDiesel']
# @Parameter OldCompanyDiesel @Def: Diesel consumption per trip of the old shipping company @Shape: [] 
OldCompanyDiesel = data['OldCompanyDiesel']
# @Parameter MinimumGifts @Def: Minimum number of gifts to deliver @Shape: [] 
MinimumGifts = data['MinimumGifts']
# @Parameter MaxTripsNewCompany @Def: Maximum number of trips by the new shipping company @Shape: [] 
MaxTripsNewCompany = data['MaxTripsNewCompany']
# @Parameter MinimumOldCompanyTripPercentage @Def: Minimum percentage of trips that must be made by the old shipping company @Shape: [] 
MinimumOldCompanyTripPercentage = data['MinimumOldCompanyTripPercentage']

# Variables 
# @Variable TripsNewCompany @Def: The number of trips made by the new shipping company @Shape: [] 
TripsNewCompany = model.addVar(vtype=GRB.INTEGER, name=""TripsNewCompany"", ub=MaxTripsNewCompany)
# @Variable TripsOldCompany @Def: The number of trips made by the old shipping company @Shape: [] 
TripsOldCompany = model.addVar(vtype=GRB.INTEGER, name=""TripsOldCompany"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of gifts delivered by the new and old shipping companies must be at least MinimumGifts.
model.addConstr(NewCompanyCapacity * TripsNewCompany + OldCompanyCapacity * TripsOldCompany >= MinimumGifts)
# @Constraint Constr_2 @Def: The number of trips made by the new shipping company cannot exceed MaxTripsNewCompany.
model.addConstr(TripsNewCompany <= MaxTripsNewCompany)
# @Constraint Constr_3 @Def: At least MinimumOldCompanyTripPercentage proportion of all trips must be made by the old shipping company.
model.addConstr(TripsOldCompany >= MinimumOldCompanyTripPercentage * (TripsOldCompany + TripsNewCompany))

# Objective 
# @Objective Objective @Def: Minimize the total amount of diesel used, which is the sum of diesel consumed by the new and old shipping companies.
model.setObjective(NewCompanyDiesel * TripsNewCompany + OldCompanyDiesel * TripsOldCompany, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['TripsNewCompany'] = TripsNewCompany.x
variables['TripsOldCompany'] = TripsOldCompany.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A zoo needs to transport their monkeys to the vet either by bus or by car. A bus can transport 20 monkeys per trip and takes 30 minutes. A car can transport 6 monkeys per trip and takes 15 minutes. There can be at most 10 bus trips. In addition, since the monkeys get aggressive when there are too many in one place at least 60% of the trips should be by car. If the zoo needs to transport 300 monkeys, how many trips of each should be done to minimize the total time required to transport the monkeys?","{""variables"": {""BusTrips"": 9.0, ""CarTrips"": 20.0}, ""objective"": 570.0}","{""parametrized_description"": ""A zoo needs to transport TotalMonkeys monkeys to the vet using buses and cars. Each bus can carry BusCapacity monkeys per trip and takes BusTripTime minutes per trip. Each car can carry CarCapacity monkeys per trip and takes CarTripTime minutes per trip. The number of bus trips cannot exceed MaxBusTrips. Additionally, at least MinCarTripFraction of all trips must be by car. The objective is to determine the number of bus and car trips that minimize the total transportation time."", ""keywords"": [""N.A.""], ""parameters"": {""TotalMonkeys"": {""description"": ""Number of monkeys to transport"", ""shape"": []}, ""BusCapacity"": {""description"": ""Number of monkeys a bus can transport per trip"", ""shape"": []}, ""BusTripTime"": {""description"": ""Time in minutes a bus takes per trip"", ""shape"": []}, ""CarCapacity"": {""description"": ""Number of monkeys a car can transport per trip"", ""shape"": []}, ""CarTripTime"": {""description"": ""Time in minutes a car takes per trip"", ""shape"": []}, ""MaxBusTrips"": {""description"": ""Maximum number of bus trips allowed"", ""shape"": []}, ""MinCarTripFraction"": {""description"": ""Minimum fraction of trips that must be by car"", ""shape"": []}}, ""variables"": {""BusTrips"": {""description"": ""The number of bus trips"", ""type"": ""continuous"", ""shape"": []}, ""CarTrips"": {""description"": ""The number of car trips"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of bus trips cannot exceed MaxBusTrips."", ""formulation"": ""BusTrips \\leq MaxBusTrips"", ""code"": {""gurobipy"": ""model.addConstr(BusTrips <= MaxBusTrips)""}}, {""description"": ""At least MinCarTripFraction of all trips must be by car."", ""formulation"": ""CarTrips \\geq MinCarTripFraction \\times (CarTrips + BusTrips)"", ""code"": {""gurobipy"": ""model.addConstr(CarTrips >= MinCarTripFraction * (CarTrips + BusTrips))""}}, {""description"": ""The total number of monkeys transported by buses and cars must equal TotalMonkeys."", ""formulation"": ""BusTrips \\times BusCapacity + CarTrips \\times CarCapacity = TotalMonkeys"", ""code"": {""gurobipy"": ""model.addConstr(BusTrips * BusCapacity + CarTrips * CarCapacity == TotalMonkeys)""}}], ""objective"": {""description"": ""The total transportation time is the sum of the time taken by all bus trips and car trips. The objective is to minimize the total transportation time."", ""formulation"": ""Min BusTrips \\cdot BusTripTime + CarTrips \\cdot CarTripTime"", ""code"": {""gurobipy"": ""model.setObjective(BusTrips * BusTripTime + CarTrips * CarTripTime, GRB.MINIMIZE)""}}}","{""TotalMonkeys"": 300, ""BusCapacity"": 20, ""BusTripTime"": 30, ""CarCapacity"": 6, ""CarTripTime"": 15, ""MaxBusTrips"": 10, ""MinCarTripFraction"": 0.6}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A zoo needs to transport TotalMonkeys monkeys to the vet using buses and cars.
Each bus can carry BusCapacity monkeys per trip and takes BusTripTime minutes
per trip. Each car can carry CarCapacity monkeys per trip and takes CarTripTime
minutes per trip. The number of bus trips cannot exceed MaxBusTrips.
Additionally, at least MinCarTripFraction of all trips must be by car. The
objective is to determine the number of bus and car trips that minimize the
total transportation time.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/152/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalMonkeys @Def: Number of monkeys to transport @Shape: [] 
TotalMonkeys = data['TotalMonkeys']
# @Parameter BusCapacity @Def: Number of monkeys a bus can transport per trip @Shape: [] 
BusCapacity = data['BusCapacity']
# @Parameter BusTripTime @Def: Time in minutes a bus takes per trip @Shape: [] 
BusTripTime = data['BusTripTime']
# @Parameter CarCapacity @Def: Number of monkeys a car can transport per trip @Shape: [] 
CarCapacity = data['CarCapacity']
# @Parameter CarTripTime @Def: Time in minutes a car takes per trip @Shape: [] 
CarTripTime = data['CarTripTime']
# @Parameter MaxBusTrips @Def: Maximum number of bus trips allowed @Shape: [] 
MaxBusTrips = data['MaxBusTrips']
# @Parameter MinCarTripFraction @Def: Minimum fraction of trips that must be by car @Shape: [] 
MinCarTripFraction = data['MinCarTripFraction']

# Variables 
# @Variable BusTrips @Def: The number of bus trips @Shape: [] 
BusTrips = model.addVar(vtype=GRB.INTEGER, name=""BusTrips"")
# @Variable CarTrips @Def: The number of car trips @Shape: [] 
CarTrips = model.addVar(vtype=GRB.INTEGER, name=""CarTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The number of bus trips cannot exceed MaxBusTrips.
model.addConstr(BusTrips <= MaxBusTrips)
# @Constraint Constr_2 @Def: At least MinCarTripFraction of all trips must be by car.
model.addConstr(CarTrips >= MinCarTripFraction * (CarTrips + BusTrips))
# @Constraint Constr_3 @Def: The total number of monkeys transported by buses and cars must equal TotalMonkeys.
model.addConstr(BusTrips * BusCapacity + CarTrips * CarCapacity == TotalMonkeys)

# Objective 
# @Objective Objective @Def: The total transportation time is the sum of the time taken by all bus trips and car trips. The objective is to minimize the total transportation time.
model.setObjective(BusTrips * BusTripTime + CarTrips * CarTripTime, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['BusTrips'] = BusTrips.x
variables['CarTrips'] = CarTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
A farmer decides to move his cows to a nearby farm using helicopters and trucks. A helicopter can take 3 cows per trip and creates 5 units of pollution. A truck can take 7 cows per trip and creates 10 units of pollution. The farmer needs to transport 80 cows and he only has enough money for at most 8 truck trips. How many of each type of trip should be taken to minimize the total amount of pollution produced?,"{""variables"": {""NumHelicopterTrips"": 8.0, ""NumTruckTrips"": 8.0}, ""objective"": 120.0}","{""parametrized_description"": ""A farmer needs to transport TotalCows cows using helicopters and trucks. Each helicopter trip can transport HelicopterCapacity cows and produces HelicopterPollution units of pollution. Each truck trip can transport TruckCapacity cows and produces TruckPollution units of pollution. Due to budget constraints, at most MaxTruckTrips truck trips can be made. The objective is to minimize the total pollution produced."", ""keywords"": [""N.A.""], ""parameters"": {""TotalCows"": {""description"": ""The total number of cows that need to be transported"", ""shape"": []}, ""HelicopterCapacity"": {""description"": ""The number of cows that a helicopter can transport per trip"", ""shape"": []}, ""HelicopterPollution"": {""description"": ""The amount of pollution created by a helicopter per trip"", ""shape"": []}, ""TruckCapacity"": {""description"": ""The number of cows that a truck can transport per trip"", ""shape"": []}, ""TruckPollution"": {""description"": ""The amount of pollution created by a truck per trip"", ""shape"": []}, ""MaxTruckTrips"": {""description"": ""The maximum number of truck trips that can be made due to budget constraints"", ""shape"": []}}, ""variables"": {""NumHelicopterTrips"": {""description"": ""The number of trips made by helicopters"", ""type"": ""continuous"", ""shape"": []}, ""NumTruckTrips"": {""description"": ""The number of trips made by trucks"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of cows transported by helicopters and trucks must equal TotalCows."", ""formulation"": ""HelicopterCapacity \\times NumHelicopterTrips + TruckCapacity \\times NumTruckTrips = TotalCows"", ""code"": {""gurobipy"": ""model.addConstr(HelicopterCapacity * NumHelicopterTrips + TruckCapacity * NumTruckTrips == TotalCows)""}}, {""description"": ""At most MaxTruckTrips truck trips can be made."", ""formulation"": ""NumTruckTrips \\leq MaxTruckTrips"", ""code"": {""gurobipy"": ""model.addConstr(NumTruckTrips <= MaxTruckTrips)""}}], ""objective"": {""description"": ""Total pollution is the sum of the pollution from helicopter trips and truck trips. The objective is to minimize the total pollution produced."", ""formulation"": ""Min HelicopterPollution \\cdot NumHelicopterTrips + TruckPollution \\cdot NumTruckTrips"", ""code"": {""gurobipy"": ""model.setObjective(HelicopterPollution * NumHelicopterTrips + TruckPollution * NumTruckTrips, GRB.MINIMIZE)""}}}","{""TotalCows"": 80, ""HelicopterCapacity"": 3, ""HelicopterPollution"": 5, ""TruckCapacity"": 7, ""TruckPollution"": 10, ""MaxTruckTrips"": 8}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A farmer needs to transport TotalCows cows using helicopters and trucks. Each
helicopter trip can transport HelicopterCapacity cows and produces
HelicopterPollution units of pollution. Each truck trip can transport
TruckCapacity cows and produces TruckPollution units of pollution. Due to budget
constraints, at most MaxTruckTrips truck trips can be made. The objective is to
minimize the total pollution produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/153/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalCows @Def: The total number of cows that need to be transported @Shape: [] 
TotalCows = data['TotalCows']
# @Parameter HelicopterCapacity @Def: The number of cows that a helicopter can transport per trip @Shape: [] 
HelicopterCapacity = data['HelicopterCapacity']
# @Parameter HelicopterPollution @Def: The amount of pollution created by a helicopter per trip @Shape: [] 
HelicopterPollution = data['HelicopterPollution']
# @Parameter TruckCapacity @Def: The number of cows that a truck can transport per trip @Shape: [] 
TruckCapacity = data['TruckCapacity']
# @Parameter TruckPollution @Def: The amount of pollution created by a truck per trip @Shape: [] 
TruckPollution = data['TruckPollution']
# @Parameter MaxTruckTrips @Def: The maximum number of truck trips that can be made due to budget constraints @Shape: [] 
MaxTruckTrips = data['MaxTruckTrips']

# Variables 
# @Variable NumHelicopterTrips @Def: The number of trips made by helicopters @Shape: [] 
NumHelicopterTrips = model.addVar(vtype=GRB.INTEGER, name=""NumHelicopterTrips"")
# @Variable NumTruckTrips @Def: The number of trips made by trucks @Shape: [] 
NumTruckTrips = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxTruckTrips, name=""NumTruckTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of cows transported by helicopters and trucks must equal TotalCows.
model.addConstr(HelicopterCapacity * NumHelicopterTrips + TruckCapacity * NumTruckTrips == TotalCows)
# @Constraint Constr_2 @Def: At most MaxTruckTrips truck trips can be made.
model.addConstr(NumTruckTrips <= MaxTruckTrips)

# Objective 
# @Objective Objective @Def: Total pollution is the sum of the pollution from helicopter trips and truck trips. The objective is to minimize the total pollution produced.
model.setObjective(HelicopterPollution * NumHelicopterTrips + TruckPollution * NumTruckTrips, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumHelicopterTrips'] = NumHelicopterTrips.x
variables['NumTruckTrips'] = NumTruckTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A sand company delivers sand for playgrounds in small and large containers. A small container requires 1 person to unload and can hold 20 units of sand. A large container requires 3 people to unload and can hold 50 units of sand. Since most playgrounds are small, the number of small containers used must be thrice the number of large containers used. In addition, there must be at least 5 small containers and 3 large containers used. If the company has 100 people available, maximize the amount of sand that they can deliver.","{""variables"": {""SmallContainers"": 48.0, ""LargeContainers"": 16.0}, ""objective"": 1760.0}","{""parametrized_description"": ""A sand company delivers sand using small containers and large containers. Each small container requires UnloadPersonsSmall persons to unload and can hold CapacitySmall units of sand. Each large container requires UnloadPersonsLarge persons to unload and can hold CapacityLarge units of sand. The number of small containers used must be RatioSmallToLargeContainers times the number of large containers used. At least MinSmallContainers small containers and MinLargeContainers large containers must be used. The company has TotalPersonsAvailable persons available. The objective is to maximize the total units of sand delivered."", ""keywords"": [""N.A.""], ""parameters"": {""UnloadPersonsSmall"": {""description"": ""Number of persons required to unload a small container"", ""shape"": []}, ""CapacitySmall"": {""description"": ""Units of sand a small container can hold"", ""shape"": []}, ""UnloadPersonsLarge"": {""description"": ""Number of persons required to unload a large container"", ""shape"": []}, ""CapacityLarge"": {""description"": ""Units of sand a large container can hold"", ""shape"": []}, ""RatioSmallToLargeContainers"": {""description"": ""Required ratio of small containers to large containers"", ""shape"": []}, ""MinSmallContainers"": {""description"": ""Minimum number of small containers to be used"", ""shape"": []}, ""MinLargeContainers"": {""description"": ""Minimum number of large containers to be used"", ""shape"": []}, ""TotalPersonsAvailable"": {""description"": ""Total number of persons available"", ""shape"": []}}, ""variables"": {""SmallContainers"": {""description"": ""The number of small containers used"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""LargeContainers"": {""description"": ""The number of large containers used"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The number of small containers used must be RatioSmallToLargeContainers times the number of large containers used."", ""formulation"": ""SmallContainers = RatioSmallToLargeContainers \\times LargeContainers"", ""code"": {""gurobipy"": ""model.addConstr(SmallContainers == RatioSmallToLargeContainers * LargeContainers)""}}, {""description"": ""At least MinSmallContainers small containers must be used."", ""formulation"": ""SmallContainers \\geq MinSmallContainers"", ""code"": {""gurobipy"": ""model.addConstr(SmallContainers >= MinSmallContainers)""}}, {""description"": ""At least MinLargeContainers large containers must be used."", ""formulation"": ""LargeContainers \\geq MinLargeContainers"", ""code"": {""gurobipy"": ""model.addConstr(LargeContainers >= MinLargeContainers)""}}, {""description"": ""The total number of persons required to unload all containers cannot exceed TotalPersonsAvailable."", ""formulation"": ""UnloadPersonsSmall \\\\cdot SmallContainers + UnloadPersonsLarge \\\\cdot LargeContainers \\\\leq TotalPersonsAvailable"", ""code"": {""gurobipy"": ""model.addConstr(UnloadPersonsSmall * SmallContainers + UnloadPersonsLarge * LargeContainers <= TotalPersonsAvailable)""}}], ""objective"": {""description"": ""Total units of sand delivered is the sum of the sand held by small and large containers. The objective is to maximize the total units of sand delivered."", ""formulation"": ""Max \\left( SmallContainers \\times CapacitySmall + LargeContainers \\times CapacityLarge \\right )"", ""code"": {""gurobipy"": ""model.setObjective(SmallContainers * CapacitySmall + LargeContainers * CapacityLarge, GRB.MAXIMIZE)""}}}","{""UnloadPersonsSmall"": 1, ""CapacitySmall"": 20, ""UnloadPersonsLarge"": 3, ""CapacityLarge"": 50, ""RatioSmallToLargeContainers"": 3, ""MinSmallContainers"": 5, ""MinLargeContainers"": 3, ""TotalPersonsAvailable"": 100}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A sand company delivers sand using small containers and large containers. Each
small container requires UnloadPersonsSmall persons to unload and can hold
CapacitySmall units of sand. Each large container requires UnloadPersonsLarge
persons to unload and can hold CapacityLarge units of sand. The number of small
containers used must be RatioSmallToLargeContainers times the number of large
containers used. At least MinSmallContainers small containers and
MinLargeContainers large containers must be used. The company has
TotalPersonsAvailable persons available. The objective is to maximize the total
units of sand delivered.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/154/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter UnloadPersonsSmall @Def: Number of persons required to unload a small container @Shape: [] 
UnloadPersonsSmall = data['UnloadPersonsSmall']
# @Parameter CapacitySmall @Def: Units of sand a small container can hold @Shape: [] 
CapacitySmall = data['CapacitySmall']
# @Parameter UnloadPersonsLarge @Def: Number of persons required to unload a large container @Shape: [] 
UnloadPersonsLarge = data['UnloadPersonsLarge']
# @Parameter CapacityLarge @Def: Units of sand a large container can hold @Shape: [] 
CapacityLarge = data['CapacityLarge']
# @Parameter RatioSmallToLargeContainers @Def: Required ratio of small containers to large containers @Shape: [] 
RatioSmallToLargeContainers = data['RatioSmallToLargeContainers']
# @Parameter MinSmallContainers @Def: Minimum number of small containers to be used @Shape: [] 
MinSmallContainers = data['MinSmallContainers']
# @Parameter MinLargeContainers @Def: Minimum number of large containers to be used @Shape: [] 
MinLargeContainers = data['MinLargeContainers']
# @Parameter TotalPersonsAvailable @Def: Total number of persons available @Shape: [] 
TotalPersonsAvailable = data['TotalPersonsAvailable']

# Variables 
# @Variable SmallContainers @Def: The number of small containers used @Shape: ['Integer'] 
SmallContainers = model.addVar(vtype=GRB.INTEGER, name=""SmallContainers"")
# @Variable LargeContainers @Def: The number of large containers used @Shape: ['Integer'] 
LargeContainers = model.addVar(vtype=GRB.INTEGER, name='LargeContainers')

# Constraints 
# @Constraint Constr_1 @Def: The number of small containers used must be RatioSmallToLargeContainers times the number of large containers used.
model.addConstr(SmallContainers == RatioSmallToLargeContainers * LargeContainers)
# @Constraint Constr_2 @Def: At least MinSmallContainers small containers must be used.
model.addConstr(SmallContainers >= MinSmallContainers)
# @Constraint Constr_3 @Def: At least MinLargeContainers large containers must be used.
model.addConstr(LargeContainers >= MinLargeContainers)
# @Constraint Constr_4 @Def: The total number of persons required to unload all containers cannot exceed TotalPersonsAvailable.
model.addConstr(UnloadPersonsSmall * SmallContainers + UnloadPersonsLarge * LargeContainers <= TotalPersonsAvailable)

# Objective 
# @Objective Objective @Def: Total units of sand delivered is the sum of the sand held by small and large containers. The objective is to maximize the total units of sand delivered.
model.setObjective(SmallContainers * CapacitySmall + LargeContainers * CapacityLarge, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SmallContainers'] = SmallContainers.x
variables['LargeContainers'] = LargeContainers.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A meal service company delivers meals to customers either on electric bikes or scooters. A bike can hold 8 meals and requires 3 units of charge. A scooter can hold 5 meals and requires 2 units of charge. Since the city is more friendly towards scooters, at most 30% of the electric vehicles can be bikes and at least 20 scooters must be used. If the company only has 200 units of charge available, how many of each vehicle should be used to maximize the number of meals that can be delivered?","{""variables"": {""NumberOfBikes"": 26.0, ""NumberOfScooters"": 61.0}, ""objective"": 513.0}","{""parametrized_description"": ""Determine the number of bikes and scooters to maximize the total number of meals delivered, where each bike holds BikeCapacity meals and requires BikeCharge units of charge, and each scooter holds ScooterCapacity meals and requires ScooterCharge units of charge. Ensure that the proportion of bikes does not exceed MaxBikeFraction of all electric vehicles, at least MinScooters scooters are used, and the total charge consumed by all vehicles does not exceed TotalCharge units."", ""keywords"": [""N.A.""], ""parameters"": {""BikeCapacity"": {""description"": ""Number of meals a bike can hold"", ""shape"": []}, ""BikeCharge"": {""description"": ""Units of charge a bike requires"", ""shape"": []}, ""ScooterCapacity"": {""description"": ""Number of meals a scooter can hold"", ""shape"": []}, ""ScooterCharge"": {""description"": ""Units of charge a scooter requires"", ""shape"": []}, ""MaxBikeFraction"": {""description"": ""Maximum fraction of electric vehicles that can be bikes"", ""shape"": []}, ""MinScooters"": {""description"": ""Minimum number of scooters to be used"", ""shape"": []}, ""TotalCharge"": {""description"": ""Total units of charge available"", ""shape"": []}}, ""variables"": {""NumberOfBikes"": {""description"": ""The number of bikes"", ""type"": ""continuous"", ""shape"": [""integer""]}, ""NumberOfScooters"": {""description"": ""The number of scooters"", ""type"": ""continuous"", ""shape"": [""integer""]}}, ""constraints"": [{""description"": ""The proportion of bikes does not exceed MaxBikeFraction of all electric vehicles."", ""formulation"": ""NumberOfBikes \\leq MaxBikeFraction \\times \\left( NumberOfBikes + NumberOfScooters \\right)"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfBikes <= MaxBikeFraction * (NumberOfBikes + NumberOfScooters))""}}, {""description"": ""At least MinScooters scooters must be used."", ""formulation"": ""NumberOfScooters \\geq MinScooters"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfScooters >= MinScooters)""}}, {""description"": ""The total charge consumed by all vehicles does not exceed TotalCharge units."", ""formulation"": ""NumberOfBikes \\times BikeCharge + NumberOfScooters \\times ScooterCharge \\leq TotalCharge"", ""code"": {""gurobipy"": ""model.addConstr(BikeCharge * NumberOfBikes + ScooterCharge * NumberOfScooters <= TotalCharge)""}}], ""objective"": {""description"": ""Maximize the total number of meals delivered, calculated as the sum of BikeCapacity multiplied by the number of bikes and ScooterCapacity multiplied by the number of scooters."", ""formulation"": ""Max \\ BikeCapacity \\cdot NumberOfBikes + ScooterCapacity \\cdot NumberOfScooters"", ""code"": {""gurobipy"": ""model.setObjective(BikeCapacity * NumberOfBikes + ScooterCapacity * NumberOfScooters, GRB.MAXIMIZE)""}}}","{""BikeCapacity"": 8, ""BikeCharge"": 3, ""ScooterCapacity"": 5, ""ScooterCharge"": 2, ""MaxBikeFraction"": 0.3, ""MinScooters"": 20, ""TotalCharge"": 200}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Determine the number of bikes and scooters to maximize the total number of meals
delivered, where each bike holds BikeCapacity meals and requires BikeCharge
units of charge, and each scooter holds ScooterCapacity meals and requires
ScooterCharge units of charge. Ensure that the proportion of bikes does not
exceed MaxBikeFraction of all electric vehicles, at least MinScooters scooters
are used, and the total charge consumed by all vehicles does not exceed
TotalCharge units.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/155/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter BikeCapacity @Def: Number of meals a bike can hold @Shape: [] 
BikeCapacity = data['BikeCapacity']
# @Parameter BikeCharge @Def: Units of charge a bike requires @Shape: [] 
BikeCharge = data['BikeCharge']
# @Parameter ScooterCapacity @Def: Number of meals a scooter can hold @Shape: [] 
ScooterCapacity = data['ScooterCapacity']
# @Parameter ScooterCharge @Def: Units of charge a scooter requires @Shape: [] 
ScooterCharge = data['ScooterCharge']
# @Parameter MaxBikeFraction @Def: Maximum fraction of electric vehicles that can be bikes @Shape: [] 
MaxBikeFraction = data['MaxBikeFraction']
# @Parameter MinScooters @Def: Minimum number of scooters to be used @Shape: [] 
MinScooters = data['MinScooters']
# @Parameter TotalCharge @Def: Total units of charge available @Shape: [] 
TotalCharge = data['TotalCharge']

# Variables 
# @Variable NumberOfBikes @Def: The number of bikes @Shape: ['integer'] 
NumberOfBikes = model.addVar(vtype=GRB.INTEGER, name=""NumberOfBikes"")
# @Variable NumberOfScooters @Def: The number of scooters @Shape: ['integer'] 
NumberOfScooters = model.addVar(vtype=GRB.INTEGER, lb=MinScooters, name=""NumberOfScooters"")

# Constraints 
# @Constraint Constr_1 @Def: The proportion of bikes does not exceed MaxBikeFraction of all electric vehicles.
model.addConstr(NumberOfBikes <= MaxBikeFraction * (NumberOfBikes + NumberOfScooters))
# @Constraint Constr_2 @Def: At least MinScooters scooters must be used.
model.addConstr(NumberOfScooters >= MinScooters)
# @Constraint Constr_3 @Def: The total charge consumed by all vehicles does not exceed TotalCharge units.
model.addConstr(BikeCharge * NumberOfBikes + ScooterCharge * NumberOfScooters <= TotalCharge)

# Objective 
# @Objective Objective @Def: Maximize the total number of meals delivered, calculated as the sum of BikeCapacity multiplied by the number of bikes and ScooterCapacity multiplied by the number of scooters.
model.setObjective(BikeCapacity * NumberOfBikes + ScooterCapacity * NumberOfScooters, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfBikes'] = NumberOfBikes.x
variables['NumberOfScooters'] = NumberOfScooters.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A car manufacturer ships their cars on large and small planes. A large plane can carry 30 cars while a small plane can carry 10 cars. Since large planes cause more pollution, the number of large planes must be less than the number of small planes. If the manufacturer wants to deliver at least 300 cars, find the minimum number of planes that can be used.","{""variables"": {""NumLargePlanes"": 7.0, ""NumSmallPlanes"": 9.0}, ""objective"": 16.0}","{""parametrized_description"": ""A manufacturer uses large and small planes to ship their cars. Each large plane can carry CapacityLarge cars and each small plane can carry CapacitySmall cars. The number of large planes must be less than the number of small planes. The manufacturer wants to deliver at least MinCars cars. Find the minimum number of planes required."", ""keywords"": [""N.A.""], ""parameters"": {""CapacityLarge"": {""description"": ""Number of cars a large plane can carry"", ""shape"": []}, ""CapacitySmall"": {""description"": ""Number of cars a small plane can carry"", ""shape"": []}, ""MinCars"": {""description"": ""Minimum number of cars to deliver"", ""shape"": []}}, ""variables"": {""NumLargePlanes"": {""description"": ""The number of large planes used"", ""type"": ""continuous"", ""shape"": []}, ""NumSmallPlanes"": {""description"": ""The number of small planes used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""Each large plane can carry CapacityLarge cars and each small plane can carry CapacitySmall cars. The total number of cars shipped must be at least MinCars."", ""formulation"": ""CapacityLarge \\cdot NumLargePlanes + CapacitySmall \\cdot NumSmallPlanes \\geq MinCars"", ""code"": {""gurobipy"": ""model.addConstr(CapacityLarge * NumLargePlanes + CapacitySmall * NumSmallPlanes >= MinCars)""}}, {""description"": ""The number of large planes must be less than the number of small planes."", ""formulation"": ""NumLargePlanes \\leq NumSmallPlanes - 1"", ""code"": {""gurobipy"": ""model.addConstr(NumLargePlanes <= NumSmallPlanes - 1)""}}], ""objective"": {""description"": ""The objective is to minimize the total number of planes required to deliver at least MinCars cars."", ""formulation"": ""\\min \\left( NumLargePlanes + NumSmallPlanes \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumLargePlanes + NumSmallPlanes, GRB.MINIMIZE)""}}}","{""CapacityLarge"": 30, ""CapacitySmall"": 10, ""MinCars"": 300}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A manufacturer uses large and small planes to ship their cars. Each large plane
can carry CapacityLarge cars and each small plane can carry CapacitySmall cars.
The number of large planes must be less than the number of small planes. The
manufacturer wants to deliver at least MinCars cars. Find the minimum number of
planes required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/156/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CapacityLarge @Def: Number of cars a large plane can carry @Shape: [] 
CapacityLarge = data['CapacityLarge']
# @Parameter CapacitySmall @Def: Number of cars a small plane can carry @Shape: [] 
CapacitySmall = data['CapacitySmall']
# @Parameter MinCars @Def: Minimum number of cars to deliver @Shape: [] 
MinCars = data['MinCars']

# Variables 
# @Variable NumLargePlanes @Def: The number of large planes used @Shape: [] 
NumLargePlanes = model.addVar(vtype=GRB.INTEGER, name=""NumLargePlanes"")
# @Variable NumSmallPlanes @Def: The number of small planes used @Shape: [] 
NumSmallPlanes = model.addVar(vtype=GRB.INTEGER, name=""NumSmallPlanes"")

# Constraints 
# @Constraint Constr_1 @Def: Each large plane can carry CapacityLarge cars and each small plane can carry CapacitySmall cars. The total number of cars shipped must be at least MinCars.
model.addConstr(CapacityLarge * NumLargePlanes + CapacitySmall * NumSmallPlanes >= MinCars)
# @Constraint Constr_2 @Def: The number of large planes must be less than the number of small planes.
model.addConstr(NumLargePlanes <= NumSmallPlanes - 1)

# Objective 
# @Objective Objective @Def: The objective is to minimize the total number of planes required to deliver at least MinCars cars.
model.setObjective(NumLargePlanes + NumSmallPlanes, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumLargePlanes'] = NumLargePlanes.x
variables['NumSmallPlanes'] = NumSmallPlanes.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A mine sends ore to the surface in small and large wagons. A small wagon hold 20 units of ore while a large wagon holds 50 units of ore. To avoid taking up too much space on the ramps, the number of small wagons must be at least twice as much as the number or large wagons. In addition, at least 10 large wagons must be used. If 2000 units of ore need to taken to the surface, minimize the total number of wagons needed.","{""variables"": {""SmallWagons"": 45.0, ""LargeWagons"": 22.0}, ""objective"": 67.0}","{""parametrized_description"": ""A mine transports TotalOre units of ore to the surface using small wagons with capacity SmallWagonCapacity and large wagons with capacity LargeWagonCapacity. The number of small wagons must be at least MinSmallToLargeRatio times the number of large wagons. Additionally, at least MinLargeWagons large wagons must be used. The objective is to minimize the total number of wagons required."", ""keywords"": [""N.A.""], ""parameters"": {""SmallWagonCapacity"": {""description"": ""Capacity of a small wagon in units of ore"", ""shape"": []}, ""LargeWagonCapacity"": {""description"": ""Capacity of a large wagon in units of ore"", ""shape"": []}, ""MinSmallToLargeRatio"": {""description"": ""Minimum ratio of small wagons to large wagons"", ""shape"": []}, ""MinLargeWagons"": {""description"": ""Minimum number of large wagons required"", ""shape"": []}, ""TotalOre"": {""description"": ""Total units of ore to be transported"", ""shape"": []}}, ""variables"": {""SmallWagons"": {""description"": ""The number of small wagons"", ""type"": ""continuous"", ""shape"": []}, ""LargeWagons"": {""description"": ""The number of large wagons"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The combined capacity of small and large wagons must be at least TotalOre units of ore."", ""formulation"": ""SmallWagons \\cdot SmallWagonCapacity + LargeWagons \\cdot LargeWagonCapacity \\geq TotalOre"", ""code"": {""gurobipy"": ""model.addConstr(SmallWagons * SmallWagonCapacity + LargeWagons * LargeWagonCapacity >= TotalOre)""}}, {""description"": ""The number of small wagons must be at least MinSmallToLargeRatio times the number of large wagons."", ""formulation"": ""SmallWagons \\geq MinSmallToLargeRatio \\times LargeWagons"", ""code"": {""gurobipy"": ""model.addConstr(SmallWagons >= MinSmallToLargeRatio * LargeWagons)""}}, {""description"": ""At least MinLargeWagons large wagons must be used."", ""formulation"": ""LargeWagons \\geq MinLargeWagons"", ""code"": {""gurobipy"": ""model.addConstr(LargeWagons >= MinLargeWagons)""}}], ""objective"": {""description"": ""The objective is to minimize the total number of wagons required."", ""formulation"": ""Min \\ SmallWagons + LargeWagons"", ""code"": {""gurobipy"": ""model.setObjective(SmallWagons + LargeWagons, GRB.MINIMIZE)""}}}","{""SmallWagonCapacity"": 20, ""LargeWagonCapacity"": 50, ""MinSmallToLargeRatio"": 2, ""MinLargeWagons"": 10, ""TotalOre"": 2000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A mine transports TotalOre units of ore to the surface using small wagons with
capacity SmallWagonCapacity and large wagons with capacity LargeWagonCapacity.
The number of small wagons must be at least MinSmallToLargeRatio times the
number of large wagons. Additionally, at least MinLargeWagons large wagons must
be used. The objective is to minimize the total number of wagons required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/157/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SmallWagonCapacity @Def: Capacity of a small wagon in units of ore @Shape: [] 
SmallWagonCapacity = data['SmallWagonCapacity']
# @Parameter LargeWagonCapacity @Def: Capacity of a large wagon in units of ore @Shape: [] 
LargeWagonCapacity = data['LargeWagonCapacity']
# @Parameter MinSmallToLargeRatio @Def: Minimum ratio of small wagons to large wagons @Shape: [] 
MinSmallToLargeRatio = data['MinSmallToLargeRatio']
# @Parameter MinLargeWagons @Def: Minimum number of large wagons required @Shape: [] 
MinLargeWagons = data['MinLargeWagons']
# @Parameter TotalOre @Def: Total units of ore to be transported @Shape: [] 
TotalOre = data['TotalOre']

# Variables 
# @Variable SmallWagons @Def: The number of small wagons @Shape: [] 
SmallWagons = model.addVar(vtype=GRB.INTEGER, name=""SmallWagons"")
# @Variable LargeWagons @Def: The number of large wagons @Shape: [] 
LargeWagons = model.addVar(vtype=GRB.INTEGER, lb=MinLargeWagons, name=""LargeWagons"")

# Constraints 
# @Constraint Constr_1 @Def: The combined capacity of small and large wagons must be at least TotalOre units of ore.
model.addConstr(SmallWagons * SmallWagonCapacity + LargeWagons * LargeWagonCapacity >= TotalOre)
# @Constraint Constr_2 @Def: The number of small wagons must be at least MinSmallToLargeRatio times the number of large wagons.
model.addConstr(SmallWagons >= MinSmallToLargeRatio * LargeWagons)
# @Constraint Constr_3 @Def: At least MinLargeWagons large wagons must be used.
model.addConstr(LargeWagons >= MinLargeWagons)

# Objective 
# @Objective Objective @Def: The objective is to minimize the total number of wagons required.
model.setObjective(SmallWagons + LargeWagons, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SmallWagons'] = SmallWagons.x
variables['LargeWagons'] = LargeWagons.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A theme park transports its visitors around the park either by scooter or rickshaw. A scooter can carry 2 people while a rickshaw can carry 3 people. To avoid excessive pollution, at most 40% of the vehicles used can be rickshaws. If the park needs to transport at least 300 visitors, minimize the total number of scooters used.","{""variables"": {""NumScooters"": 0.0, ""NumRickshaws"": 2000000000.0}, ""objective"": 0.0}","{""parametrized_description"": ""A theme park transports its visitors using scooters and rickshaws. Each scooter can carry ScooterCapacity people while each rickshaw can carry RickshawCapacity people. At most MaxRickshawPercentage of the vehicles used can be rickshaws. The park needs to transport at least NumVisitors visitors, and the objective is to minimize the total number of scooters used."", ""keywords"": [""N.A.""], ""parameters"": {""ScooterCapacity"": {""description"": ""Capacity of a scooter in number of people"", ""shape"": []}, ""RickshawCapacity"": {""description"": ""Capacity of a rickshaw in number of people"", ""shape"": []}, ""MaxRickshawPercentage"": {""description"": ""Maximum percentage of vehicles that can be rickshaws"", ""shape"": []}, ""NumVisitors"": {""description"": ""Number of visitors to transport"", ""shape"": []}}, ""variables"": {""NumScooters"": {""description"": ""The number of scooters used to transport visitors"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumRickshaws"": {""description"": ""The number of rickshaws used to transport visitors"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""Each scooter can carry ScooterCapacity people and each rickshaw can carry RickshawCapacity people. The total number of people transported must be at least NumVisitors."", ""formulation"": ""ScooterCapacity \\times NumScooters + RickshawCapacity \\times NumRickshaws \\geq NumVisitors"", ""code"": {""gurobipy"": ""model.addConstr(ScooterCapacity * NumScooters + RickshawCapacity * NumRickshaws >= NumVisitors)""}}, {""description"": ""The number of rickshaws used must not exceed MaxRickshawPercentage of the total number of vehicles used."", ""formulation"": ""NumRickshaws \\leq MaxRickshawPercentage \\times (NumScooters + NumRickshaws)"", ""code"": {""gurobipy"": ""model.addConstr((1 - MaxRickshawPercentage) * NumRickshaws <= MaxRickshawPercentage * NumScooters)""}}], ""objective"": {""description"": ""Minimize the total number of scooters used."", ""formulation"": ""Min\\ NumScooters"", ""code"": {""gurobipy"": ""model.setObjective(NumScooters, GRB.MINIMIZE)""}}}","{""ScooterCapacity"": 2, ""RickshawCapacity"": 3, ""MaxRickshawPercentage"": 40, ""NumVisitors"": 300}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A theme park transports its visitors using scooters and rickshaws. Each scooter
can carry ScooterCapacity people while each rickshaw can carry RickshawCapacity
people. At most MaxRickshawPercentage of the vehicles used can be rickshaws. The
park needs to transport at least NumVisitors visitors, and the objective is to
minimize the total number of scooters used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/158/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ScooterCapacity @Def: Capacity of a scooter in number of people @Shape: [] 
ScooterCapacity = data['ScooterCapacity']
# @Parameter RickshawCapacity @Def: Capacity of a rickshaw in number of people @Shape: [] 
RickshawCapacity = data['RickshawCapacity']
# @Parameter MaxRickshawPercentage @Def: Maximum percentage of vehicles that can be rickshaws @Shape: [] 
MaxRickshawPercentage = data['MaxRickshawPercentage']
# @Parameter NumVisitors @Def: Number of visitors to transport @Shape: [] 
NumVisitors = data['NumVisitors']

# Variables 
# @Variable NumScooters @Def: The number of scooters used to transport visitors @Shape: ['Integer'] 
NumScooters = model.addVar(vtype=GRB.INTEGER, name=""NumScooters"", lb=0)
# @Variable NumRickshaws @Def: The number of rickshaws used to transport visitors @Shape: ['Integer'] 
NumRickshaws = model.addVar(vtype=GRB.INTEGER, name=""NumRickshaws"")

# Constraints 
# @Constraint Constr_1 @Def: Each scooter can carry ScooterCapacity people and each rickshaw can carry RickshawCapacity people. The total number of people transported must be at least NumVisitors.
model.addConstr(ScooterCapacity * NumScooters + RickshawCapacity * NumRickshaws >= NumVisitors)
# @Constraint Constr_2 @Def: The number of rickshaws used must not exceed MaxRickshawPercentage of the total number of vehicles used.
model.addConstr((1 - MaxRickshawPercentage) * NumRickshaws <= MaxRickshawPercentage * NumScooters)

# Objective 
# @Objective Objective @Def: Minimize the total number of scooters used.
model.setObjective(NumScooters, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumScooters'] = NumScooters.x
variables['NumRickshaws'] = NumRickshaws.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A company in the middle east delivers their packages to customers on camels and horses. A camel can carry 50 packages while a horse can carry 60 packages. A camel requires 20 units of food while a horse requires 30 units of food. The company needs to deliver at least 1000 packages and they have 450 units of food available. Since horses are not as suited for the hot climate, the number of horses cannot exceed the number of camels. How many of each animal should be used to minimize the total number of animals?","{""variables"": {""NumberOfCamels"": 12.0, ""NumberOfHorses"": 7.0}, ""objective"": 19.0}","{""parametrized_description"": ""A company delivers packages using camels and horses. Each camel can carry CamelCapacity packages and requires CamelFood units of food each, while each horse can carry HorseCapacity packages and requires HorseFood units of food each. The company needs to deliver at least MinPackages packages and has FoodAvailable units of food available. The number of horses cannot exceed the number of camels. Determine the number of camels and horses to minimize the total number of animals used."", ""keywords"": [""N.A.""], ""parameters"": {""CamelCapacity"": {""description"": ""Number of packages a camel can carry"", ""shape"": []}, ""HorseCapacity"": {""description"": ""Number of packages a horse can carry"", ""shape"": []}, ""CamelFood"": {""description"": ""Units of food a camel requires"", ""shape"": []}, ""HorseFood"": {""description"": ""Units of food a horse requires"", ""shape"": []}, ""MinPackages"": {""description"": ""Minimum number of packages to be delivered"", ""shape"": []}, ""FoodAvailable"": {""description"": ""Total units of food available"", ""shape"": []}}, ""variables"": {""NumberOfCamels"": {""description"": ""The number of camels used to deliver packages"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberOfHorses"": {""description"": ""The number of horses used to deliver packages"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total number of packages delivered by camels and horses must be at least MinPackages."", ""formulation"": ""NumberOfCamels \\cdot CamelCapacity + NumberOfHorses \\cdot HorseCapacity \\geq MinPackages"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfCamels * CamelCapacity + NumberOfHorses * HorseCapacity >= MinPackages)""}}, {""description"": ""The total food consumed by camels and horses must not exceed FoodAvailable units."", ""formulation"": ""CamelFood \\cdot NumberOfCamels + HorseFood \\cdot NumberOfHorses \\leq FoodAvailable"", ""code"": {""gurobipy"": ""model.addConstr(CamelFood * NumberOfCamels + HorseFood * NumberOfHorses <= FoodAvailable)""}}, {""description"": ""The number of horses cannot exceed the number of camels."", ""formulation"": ""NumberOfHorses \\leq NumberOfCamels"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfHorses <= NumberOfCamels)""}}], ""objective"": {""description"": ""Minimize the total number of camels and horses used."", ""formulation"": ""Min \\left( NumberOfCamels + NumberOfHorses \\right )"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfCamels + NumberOfHorses, GRB.MINIMIZE)""}}}","{""CamelCapacity"": 50, ""HorseCapacity"": 60, ""CamelFood"": 20, ""HorseFood"": 30, ""MinPackages"": 1000, ""FoodAvailable"": 450}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company delivers packages using camels and horses. Each camel can carry
CamelCapacity packages and requires CamelFood units of food each, while each
horse can carry HorseCapacity packages and requires HorseFood units of food
each. The company needs to deliver at least MinPackages packages and has
FoodAvailable units of food available. The number of horses cannot exceed the
number of camels. Determine the number of camels and horses to minimize the
total number of animals used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/159/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CamelCapacity @Def: Number of packages a camel can carry @Shape: [] 
CamelCapacity = data['CamelCapacity']
# @Parameter HorseCapacity @Def: Number of packages a horse can carry @Shape: [] 
HorseCapacity = data['HorseCapacity']
# @Parameter CamelFood @Def: Units of food a camel requires @Shape: [] 
CamelFood = data['CamelFood']
# @Parameter HorseFood @Def: Units of food a horse requires @Shape: [] 
HorseFood = data['HorseFood']
# @Parameter MinPackages @Def: Minimum number of packages to be delivered @Shape: [] 
MinPackages = data['MinPackages']
# @Parameter FoodAvailable @Def: Total units of food available @Shape: [] 
FoodAvailable = data['FoodAvailable']

# Variables 
# @Variable NumberOfCamels @Def: The number of camels used to deliver packages @Shape: ['Integer'] 
NumberOfCamels = model.addVar(vtype=GRB.INTEGER, name=""NumberOfCamels"")
# @Variable NumberOfHorses @Def: The number of horses used to deliver packages @Shape: ['Integer'] 
NumberOfHorses = model.addVar(vtype=GRB.INTEGER, name=""NumberOfHorses"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of packages delivered by camels and horses must be at least MinPackages.
model.addConstr(NumberOfCamels * CamelCapacity + NumberOfHorses * HorseCapacity >= MinPackages)
# @Constraint Constr_2 @Def: The total food consumed by camels and horses must not exceed FoodAvailable units.
model.addConstr(CamelFood * NumberOfCamels + HorseFood * NumberOfHorses <= FoodAvailable)
# @Constraint Constr_3 @Def: The number of horses cannot exceed the number of camels.
model.addConstr(NumberOfHorses <= NumberOfCamels)

# Objective 
# @Objective Objective @Def: Minimize the total number of camels and horses used.
model.setObjective(NumberOfCamels + NumberOfHorses, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfCamels'] = NumberOfCamels.x
variables['NumberOfHorses'] = NumberOfHorses.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A snack exporter sends snacks to his customer in small and large suitcases. A small suitcase can hold 50 snacks while a large suitcase can hold 80 snacks. Most customer prefer small suitcases, and so at least twice as many small suitcases must be used as large suitcases. The exporter has available at most 70 small suitcases and 50 large suitcases. If he must send at least 15 large suitcases and can send  at most 70 suitcases in total, how many of each should he send to maximize the total number of snacks that can be delivered?","{""variables"": {""SmallSuitcasesUsed"": 47.0, ""LargeSuitcasesUsed"": 23.0}, ""objective"": 4190.0}","{""parametrized_description"": ""A snack exporter must determine the number of small and large suitcases to send in order to maximize the total number of snacks delivered. Each small suitcase has a capacity of SmallSuitcaseCapacity snacks, and each large suitcase has a capacity of LargeSuitcaseCapacity snacks. The number of small suitcases used must be at least MinSmallToLargeRatio times the number of large suitcases. The exporter is limited by MaxSmallSuitcases available small suitcases and MaxLargeSuitcases available large suitcases. Additionally, the exporter must send at least MinLargeSuitcases large suitcases and ensure that the total number of suitcases sent does not exceed MaxTotalSuitcases."", ""keywords"": [""N.A.""], ""parameters"": {""SmallSuitcaseCapacity"": {""description"": ""Capacity of a small suitcase in snacks"", ""shape"": []}, ""LargeSuitcaseCapacity"": {""description"": ""Capacity of a large suitcase in snacks"", ""shape"": []}, ""MinSmallToLargeRatio"": {""description"": ""Minimum ratio factor indicating that the number of small suitcases must be at least twice the number of large suitcases"", ""shape"": []}, ""MaxSmallSuitcases"": {""description"": ""Maximum number of small suitcases available"", ""shape"": []}, ""MaxLargeSuitcases"": {""description"": ""Maximum number of large suitcases available"", ""shape"": []}, ""MinLargeSuitcases"": {""description"": ""Minimum number of large suitcases to send"", ""shape"": []}, ""MaxTotalSuitcases"": {""description"": ""Maximum total number of suitcases to send"", ""shape"": []}}, ""variables"": {""SmallSuitcasesUsed"": {""description"": ""The number of small suitcases used"", ""type"": ""continuous"", ""shape"": []}, ""LargeSuitcasesUsed"": {""description"": ""The number of large suitcases used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of small suitcases used must be at least MinSmallToLargeRatio times the number of large suitcases."", ""formulation"": ""SmallSuitcasesUsed \\geq MinSmallToLargeRatio \\times LargeSuitcasesUsed"", ""code"": {""gurobipy"": ""model.addConstr(SmallSuitcasesUsed >= MinSmallToLargeRatio * LargeSuitcasesUsed)""}}, {""description"": ""The number of small suitcases sent cannot exceed MaxSmallSuitcases."", ""formulation"": ""SmallSuitcasesUsed \\leq MaxSmallSuitcases"", ""code"": {""gurobipy"": ""model.addConstr(SmallSuitcasesUsed <= MaxSmallSuitcases)""}}, {""description"": ""The number of large suitcases sent cannot exceed MaxLargeSuitcases."", ""formulation"": ""LargeSuitcasesUsed \\leq MaxLargeSuitcases"", ""code"": {""gurobipy"": ""model.addConstr(LargeSuitcasesUsed <= MaxLargeSuitcases)""}}, {""description"": ""At least MinLargeSuitcases large suitcases must be sent."", ""formulation"": ""LargeSuitcasesUsed \\geq MinLargeSuitcases"", ""code"": {""gurobipy"": ""# The constraint 'LargeSuitcasesUsed >= MinLargeSuitcases' is already enforced by setting the variable's lower bound.\n# No additional constraint is needed.""}}, {""description"": ""The total number of suitcases sent cannot exceed MaxTotalSuitcases."", ""formulation"": ""SmallSuitcasesUsed + LargeSuitcasesUsed \\leq MaxTotalSuitcases"", ""code"": {""gurobipy"": ""model.addConstr(SmallSuitcasesUsed + LargeSuitcasesUsed <= MaxTotalSuitcases)""}}], ""objective"": {""description"": ""Maximize the total number of snacks delivered, calculated as (Number of Small Suitcases \u00d7 SmallSuitcaseCapacity) plus (Number of Large Suitcases \u00d7 LargeSuitcaseCapacity)."", ""formulation"": ""Max \\left( SmallSuitcasesUsed \\times SmallSuitcaseCapacity + LargeSuitcasesUsed \\times LargeSuitcaseCapacity \\right)"", ""code"": {""gurobipy"": ""model.setObjective(SmallSuitcasesUsed * SmallSuitcaseCapacity + LargeSuitcasesUsed * LargeSuitcaseCapacity, GRB.MAXIMIZE)""}}}","{""SmallSuitcaseCapacity"": 50, ""LargeSuitcaseCapacity"": 80, ""MinSmallToLargeRatio"": 2, ""MaxSmallSuitcases"": 70, ""MaxLargeSuitcases"": 50, ""MinLargeSuitcases"": 15, ""MaxTotalSuitcases"": 70}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A snack exporter must determine the number of small and large suitcases to send
in order to maximize the total number of snacks delivered. Each small suitcase
has a capacity of SmallSuitcaseCapacity snacks, and each large suitcase has a
capacity of LargeSuitcaseCapacity snacks. The number of small suitcases used
must be at least MinSmallToLargeRatio times the number of large suitcases. The
exporter is limited by MaxSmallSuitcases available small suitcases and
MaxLargeSuitcases available large suitcases. Additionally, the exporter must
send at least MinLargeSuitcases large suitcases and ensure that the total number
of suitcases sent does not exceed MaxTotalSuitcases.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/160/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SmallSuitcaseCapacity @Def: Capacity of a small suitcase in snacks @Shape: [] 
SmallSuitcaseCapacity = data['SmallSuitcaseCapacity']
# @Parameter LargeSuitcaseCapacity @Def: Capacity of a large suitcase in snacks @Shape: [] 
LargeSuitcaseCapacity = data['LargeSuitcaseCapacity']
# @Parameter MinSmallToLargeRatio @Def: Minimum ratio factor indicating that the number of small suitcases must be at least twice the number of large suitcases @Shape: [] 
MinSmallToLargeRatio = data['MinSmallToLargeRatio']
# @Parameter MaxSmallSuitcases @Def: Maximum number of small suitcases available @Shape: [] 
MaxSmallSuitcases = data['MaxSmallSuitcases']
# @Parameter MaxLargeSuitcases @Def: Maximum number of large suitcases available @Shape: [] 
MaxLargeSuitcases = data['MaxLargeSuitcases']
# @Parameter MinLargeSuitcases @Def: Minimum number of large suitcases to send @Shape: [] 
MinLargeSuitcases = data['MinLargeSuitcases']
# @Parameter MaxTotalSuitcases @Def: Maximum total number of suitcases to send @Shape: [] 
MaxTotalSuitcases = data['MaxTotalSuitcases']

# Variables 
# @Variable SmallSuitcasesUsed @Def: The number of small suitcases used @Shape: [] 
SmallSuitcasesUsed = model.addVar(ub=MaxSmallSuitcases, vtype=GRB.INTEGER, name=""SmallSuitcasesUsed"")
# @Variable LargeSuitcasesUsed @Def: The number of large suitcases used @Shape: [] 
LargeSuitcasesUsed = model.addVar(lb=MinLargeSuitcases, ub=MaxLargeSuitcases, vtype=GRB.INTEGER, name=""LargeSuitcasesUsed"")

# Constraints 
# @Constraint Constr_1 @Def: The number of small suitcases used must be at least MinSmallToLargeRatio times the number of large suitcases.
model.addConstr(SmallSuitcasesUsed >= MinSmallToLargeRatio * LargeSuitcasesUsed)
# @Constraint Constr_2 @Def: The number of small suitcases sent cannot exceed MaxSmallSuitcases.
model.addConstr(SmallSuitcasesUsed <= MaxSmallSuitcases)
# @Constraint Constr_3 @Def: The number of large suitcases sent cannot exceed MaxLargeSuitcases.
model.addConstr(LargeSuitcasesUsed <= MaxLargeSuitcases)
# @Constraint Constr_4 @Def: At least MinLargeSuitcases large suitcases must be sent.
# The constraint 'LargeSuitcasesUsed >= MinLargeSuitcases' is already enforced by setting the variable's lower bound.
# No additional constraint is needed.
# @Constraint Constr_5 @Def: The total number of suitcases sent cannot exceed MaxTotalSuitcases.
model.addConstr(SmallSuitcasesUsed + LargeSuitcasesUsed <= MaxTotalSuitcases)

# Objective 
# @Objective Objective @Def: Maximize the total number of snacks delivered, calculated as (Number of Small Suitcases × SmallSuitcaseCapacity) plus (Number of Large Suitcases × LargeSuitcaseCapacity).
model.setObjective(SmallSuitcasesUsed * SmallSuitcaseCapacity + LargeSuitcasesUsed * LargeSuitcaseCapacity, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SmallSuitcasesUsed'] = SmallSuitcasesUsed.x
variables['LargeSuitcasesUsed'] = LargeSuitcasesUsed.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A mail delivery service in an island village delivers mail by regular and speed boats. A regular boat can carry 20 pieces of mail per trip and uses 10 liters of gas. A speed boat can carry 30 pieces of mail per trip and uses 20 liters of gas. There can be at most 20 regular boat trips. Since customers want their mail as fast as possible, at least 50% of the trips must be made by speed boats. If the service needs to deliver 1000 pieces of mail, how many trips of each should be made to minimize the total amount of gas consumed?","{""variables"": {""RegularBoatTrips"": 20.0, ""SpeedBoatTrips"": 20.0}, ""objective"": 600.0}","{""parametrized_description"": ""A mail delivery service uses regular boats and speed boats. Each regular boat trip can carry RegularBoatCapacity pieces of mail and consumes RegularBoatGasConsumption liters of gas. Each speed boat trip can carry SpeedBoatCapacity pieces of mail and consumes SpeedBoatGasConsumption liters of gas. The number of regular boat trips is limited to MaxRegularBoatTrips. At least MinFractionSpeedBoatTrips of the total trips must be made by speed boats. The service needs to deliver TotalMail pieces of mail. Determine the number of trips of each type to minimize the total gas consumed."", ""keywords"": [""N.A.""], ""parameters"": {""RegularBoatCapacity"": {""description"": ""Number of pieces of mail a regular boat can carry per trip"", ""shape"": []}, ""RegularBoatGasConsumption"": {""description"": ""Amount of gas (liters) used by a regular boat per trip"", ""shape"": []}, ""SpeedBoatCapacity"": {""description"": ""Number of pieces of mail a speed boat can carry per trip"", ""shape"": []}, ""SpeedBoatGasConsumption"": {""description"": ""Amount of gas (liters) used by a speed boat per trip"", ""shape"": []}, ""MaxRegularBoatTrips"": {""description"": ""Maximum number of trips that can be made by regular boats"", ""shape"": []}, ""MinFractionSpeedBoatTrips"": {""description"": ""Minimum required fraction of trips to be made by speed boats"", ""shape"": []}, ""TotalMail"": {""description"": ""Total number of pieces of mail to be delivered"", ""shape"": []}}, ""variables"": {""RegularBoatTrips"": {""description"": ""The number of trips made by regular boats"", ""type"": ""continuous"", ""shape"": []}, ""SpeedBoatTrips"": {""description"": ""The number of trips made by speed boats"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of regular boat trips cannot exceed MaxRegularBoatTrips."", ""formulation"": ""RegularBoatTrips \\leq MaxRegularBoatTrips"", ""code"": {""gurobipy"": ""model.addConstr(RegularBoatTrips <= MaxRegularBoatTrips)""}}, {""description"": ""At least MinFractionSpeedBoatTrips fraction of the total trips must be made by speed boats."", ""formulation"": ""SpeedBoatTrips \\geq MinFractionSpeedBoatTrips \\cdot \\left(RegularBoatTrips + SpeedBoatTrips\\right)"", ""code"": {""gurobipy"": ""model.addConstr(SpeedBoatTrips >= MinFractionSpeedBoatTrips * (RegularBoatTrips + SpeedBoatTrips))""}}, {""description"": ""The total number of pieces of mail delivered by regular and speed boats must be equal to TotalMail."", ""formulation"": ""RegularBoatTrips \\times RegularBoatCapacity + SpeedBoatTrips \\times SpeedBoatCapacity = TotalMail"", ""code"": {""gurobipy"": ""model.addConstr(RegularBoatTrips * RegularBoatCapacity + SpeedBoatTrips * SpeedBoatCapacity == TotalMail)""}}], ""objective"": {""description"": ""The total gas consumed is the sum of gas consumed by regular boats and speed boats per trip multiplied by the number of their respective trips. The objective is to minimize the total gas consumed."", ""formulation"": ""Min RegularBoatGasConsumption \\times RegularBoatTrips + SpeedBoatGasConsumption \\times SpeedBoatTrips"", ""code"": {""gurobipy"": ""model.setObjective(RegularBoatGasConsumption * RegularBoatTrips + SpeedBoatGasConsumption * SpeedBoatTrips, GRB.MINIMIZE)""}}}","{""RegularBoatCapacity"": 20, ""RegularBoatGasConsumption"": 10, ""SpeedBoatCapacity"": 30, ""SpeedBoatGasConsumption"": 20, ""MaxRegularBoatTrips"": 20, ""MinFractionSpeedBoatTrips"": 0.5, ""TotalMail"": 1000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A mail delivery service uses regular boats and speed boats. Each regular boat
trip can carry RegularBoatCapacity pieces of mail and consumes
RegularBoatGasConsumption liters of gas. Each speed boat trip can carry
SpeedBoatCapacity pieces of mail and consumes SpeedBoatGasConsumption liters of
gas. The number of regular boat trips is limited to MaxRegularBoatTrips. At
least MinFractionSpeedBoatTrips of the total trips must be made by speed boats.
The service needs to deliver TotalMail pieces of mail. Determine the number of
trips of each type to minimize the total gas consumed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/161/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter RegularBoatCapacity @Def: Number of pieces of mail a regular boat can carry per trip @Shape: [] 
RegularBoatCapacity = data['RegularBoatCapacity']
# @Parameter RegularBoatGasConsumption @Def: Amount of gas (liters) used by a regular boat per trip @Shape: [] 
RegularBoatGasConsumption = data['RegularBoatGasConsumption']
# @Parameter SpeedBoatCapacity @Def: Number of pieces of mail a speed boat can carry per trip @Shape: [] 
SpeedBoatCapacity = data['SpeedBoatCapacity']
# @Parameter SpeedBoatGasConsumption @Def: Amount of gas (liters) used by a speed boat per trip @Shape: [] 
SpeedBoatGasConsumption = data['SpeedBoatGasConsumption']
# @Parameter MaxRegularBoatTrips @Def: Maximum number of trips that can be made by regular boats @Shape: [] 
MaxRegularBoatTrips = data['MaxRegularBoatTrips']
# @Parameter MinFractionSpeedBoatTrips @Def: Minimum required fraction of trips to be made by speed boats @Shape: [] 
MinFractionSpeedBoatTrips = data['MinFractionSpeedBoatTrips']
# @Parameter TotalMail @Def: Total number of pieces of mail to be delivered @Shape: [] 
TotalMail = data['TotalMail']

# Variables 
# @Variable RegularBoatTrips @Def: The number of trips made by regular boats @Shape: [] 
RegularBoatTrips = model.addVar(vtype=GRB.INTEGER, ub=MaxRegularBoatTrips, name=""RegularBoatTrips"")
# @Variable SpeedBoatTrips @Def: The number of trips made by speed boats @Shape: [] 
SpeedBoatTrips = model.addVar(vtype=GRB.INTEGER, name=""SpeedBoatTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The number of regular boat trips cannot exceed MaxRegularBoatTrips.
model.addConstr(RegularBoatTrips <= MaxRegularBoatTrips)
# @Constraint Constr_2 @Def: At least MinFractionSpeedBoatTrips fraction of the total trips must be made by speed boats.
model.addConstr(SpeedBoatTrips >= MinFractionSpeedBoatTrips * (RegularBoatTrips + SpeedBoatTrips))
# @Constraint Constr_3 @Def: The total number of pieces of mail delivered by regular and speed boats must be equal to TotalMail.
model.addConstr(RegularBoatTrips * RegularBoatCapacity + SpeedBoatTrips * SpeedBoatCapacity == TotalMail)

# Objective 
# @Objective Objective @Def: The total gas consumed is the sum of gas consumed by regular boats and speed boats per trip multiplied by the number of their respective trips. The objective is to minimize the total gas consumed.
model.setObjective(RegularBoatGasConsumption * RegularBoatTrips + SpeedBoatGasConsumption * SpeedBoatTrips, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['RegularBoatTrips'] = RegularBoatTrips.x
variables['SpeedBoatTrips'] = SpeedBoatTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A chicken farmer has sold his chicken and they need to be transported either by bus or by car. A bus can take 100 chicken and takes 2 hours per trip. A car can take 40 chicken and takes 1.5 hours per trip. There can be at most 10 bus trips and at least 60% of the trips must be by car. If the farmer needs to transport 1200 chicken, how many trips of each should be done to minimize the total time needed to transport the chicken?","{""variables"": {""NumberOfBusTrips"": 7.0, ""NumberOfCarTrips"": 13.0}, ""objective"": 33.5}","{""parametrized_description"": ""A farmer needs to transport TotalChickens chickens using buses and cars. Each bus trip can carry BusCapacity chickens and takes BusTripTime hours. Each car trip can carry CarCapacity chickens and takes CarTripTime hours. The number of bus trips cannot exceed MaxBusTrips. At least MinCarTripPercentage of the total trips must be by car. The objective is to minimize the total transportation time."", ""keywords"": [""N.A.""], ""parameters"": {""BusCapacity"": {""description"": ""Number of chickens that a bus can carry per trip"", ""shape"": []}, ""BusTripTime"": {""description"": ""Time taken by a bus per trip in hours"", ""shape"": []}, ""CarCapacity"": {""description"": ""Number of chickens that a car can carry per trip"", ""shape"": []}, ""CarTripTime"": {""description"": ""Time taken by a car per trip in hours"", ""shape"": []}, ""MaxBusTrips"": {""description"": ""Maximum allowed number of bus trips"", ""shape"": []}, ""MinCarTripPercentage"": {""description"": ""Minimum required percentage of total trips that must be by car"", ""shape"": []}, ""TotalChickens"": {""description"": ""Total number of chickens that need to be transported"", ""shape"": []}}, ""variables"": {""NumberOfBusTrips"": {""description"": ""The number of bus trips"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfCarTrips"": {""description"": ""The number of car trips"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of bus trips cannot exceed MaxBusTrips."", ""formulation"": ""NumberOfBusTrips \\leq MaxBusTrips"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfBusTrips <= MaxBusTrips)""}}, {""description"": ""At least MinCarTripPercentage of the total trips must be by car."", ""formulation"": ""NumberOfCarTrips \\geq MinCarTripPercentage \\times (NumberOfCarTrips + NumberOfBusTrips)"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfCarTrips >= MinCarTripPercentage * (NumberOfCarTrips + NumberOfBusTrips))""}}, {""description"": ""The total number of chickens transported by buses and cars must be at least TotalChickens."", ""formulation"": ""NumberOfBusTrips \\cdot BusCapacity + NumberOfCarTrips \\cdot CarCapacity \\geq TotalChickens"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfBusTrips * BusCapacity + NumberOfCarTrips * CarCapacity >= TotalChickens)""}}], ""objective"": {""description"": ""The total transportation time is the sum of the times of all bus and car trips. The objective is to minimize the total transportation time."", ""formulation"": ""Min \\left( NumberOfBusTrips \\times BusTripTime + NumberOfCarTrips \\times CarTripTime \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfBusTrips * BusTripTime + NumberOfCarTrips * CarTripTime, GRB.MINIMIZE)""}}}","{""BusCapacity"": 100, ""BusTripTime"": 2, ""CarCapacity"": 40, ""CarTripTime"": 1.5, ""MaxBusTrips"": 10, ""MinCarTripPercentage"": 0.6, ""TotalChickens"": 1200}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A farmer needs to transport TotalChickens chickens using buses and cars. Each
bus trip can carry BusCapacity chickens and takes BusTripTime hours. Each car
trip can carry CarCapacity chickens and takes CarTripTime hours. The number of
bus trips cannot exceed MaxBusTrips. At least MinCarTripPercentage of the total
trips must be by car. The objective is to minimize the total transportation
time.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/162/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter BusCapacity @Def: Number of chickens that a bus can carry per trip @Shape: [] 
BusCapacity = data['BusCapacity']
# @Parameter BusTripTime @Def: Time taken by a bus per trip in hours @Shape: [] 
BusTripTime = data['BusTripTime']
# @Parameter CarCapacity @Def: Number of chickens that a car can carry per trip @Shape: [] 
CarCapacity = data['CarCapacity']
# @Parameter CarTripTime @Def: Time taken by a car per trip in hours @Shape: [] 
CarTripTime = data['CarTripTime']
# @Parameter MaxBusTrips @Def: Maximum allowed number of bus trips @Shape: [] 
MaxBusTrips = data['MaxBusTrips']
# @Parameter MinCarTripPercentage @Def: Minimum required percentage of total trips that must be by car @Shape: [] 
MinCarTripPercentage = data['MinCarTripPercentage']
# @Parameter TotalChickens @Def: Total number of chickens that need to be transported @Shape: [] 
TotalChickens = data['TotalChickens']

# Variables 
# @Variable NumberOfBusTrips @Def: The number of bus trips @Shape: [] 
NumberOfBusTrips = model.addVar(vtype=GRB.INTEGER, name=""NumberOfBusTrips"")
# @Variable NumberOfCarTrips @Def: The number of car trips @Shape: [] 
NumberOfCarTrips = model.addVar(vtype=GRB.INTEGER, name=""NumberOfCarTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The number of bus trips cannot exceed MaxBusTrips.
model.addConstr(NumberOfBusTrips <= MaxBusTrips)
# @Constraint Constr_2 @Def: At least MinCarTripPercentage of the total trips must be by car.
model.addConstr(NumberOfCarTrips >= MinCarTripPercentage * (NumberOfCarTrips + NumberOfBusTrips))
# @Constraint Constr_3 @Def: The total number of chickens transported by buses and cars must be at least TotalChickens.
model.addConstr(NumberOfBusTrips * BusCapacity + NumberOfCarTrips * CarCapacity >= TotalChickens)

# Objective 
# @Objective Objective @Def: The total transportation time is the sum of the times of all bus and car trips. The objective is to minimize the total transportation time.
model.setObjective(NumberOfBusTrips * BusTripTime + NumberOfCarTrips * CarTripTime, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfBusTrips'] = NumberOfBusTrips.x
variables['NumberOfCarTrips'] = NumberOfCarTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Children can go to school either by van or by minibus. A van can take 6 kids and produces 7 units of pollution. A minibus can take 10 kids and produced 10 units of pollution. There are at least 150 kids than need to go to school and at most 10 minibuses can be used. In addition, the number of vans used must exceed the number of minibuses. How many of each should be used to minimize the total amount of pollution produced?","{""variables"": {""NumberOfVans"": 10.0, ""NumberOfMinibuses"": 9.0}, ""objective"": 160.0}","{""parametrized_description"": ""Use a number of vans and minibuses, where each van can transport VanCapacity children and generates VanPollution pollution, and each minibus can transport MinibusCapacity children and generates MinibusPollution pollution. The constraints are that at least MinimumNumberOfKids children must be transported, no more than MaximumNumberOfMinibuses minibuses can be used, and the number of vans must exceed the number of minibuses. The goal is to minimize the total pollution generated."", ""keywords"": [""N.A.""], ""parameters"": {""VanCapacity"": {""description"": ""Number of kids a van can take"", ""shape"": []}, ""VanPollution"": {""description"": ""Pollution produced by one van"", ""shape"": []}, ""MinibusCapacity"": {""description"": ""Number of kids a minibus can take"", ""shape"": []}, ""MinibusPollution"": {""description"": ""Pollution produced by one minibus"", ""shape"": []}, ""MinimumNumberOfKids"": {""description"": ""Minimum number of kids that need to go to school"", ""shape"": []}, ""MaximumNumberOfMinibuses"": {""description"": ""Maximum number of minibuses that can be used"", ""shape"": []}}, ""variables"": {""NumberOfVans"": {""description"": ""The number of vans used"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfMinibuses"": {""description"": ""The number of minibuses used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of children transported by vans and minibuses must be at least MinimumNumberOfKids."", ""formulation"": ""NumberOfVans \\times VanCapacity + NumberOfMinibuses \\times MinibusCapacity \\geq MinimumNumberOfKids"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfVans * VanCapacity + NumberOfMinibuses * MinibusCapacity >= MinimumNumberOfKids)""}}, {""description"": ""No more than MaximumNumberOfMinibuses minibuses can be used."", ""formulation"": ""NumberOfMinibuses \\leq MaximumNumberOfMinibuses"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfMinibuses <= MaximumNumberOfMinibuses)""}}, {""description"": ""The number of vans used must exceed the number of minibuses used."", ""formulation"": ""NumberOfVans \\geq NumberOfMinibuses + 1"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfVans >= NumberOfMinibuses + 1)""}}], ""objective"": {""description"": ""The total pollution is the sum of the pollution generated by all vans and minibuses used. The objective is to minimize the total pollution."", ""formulation"": ""Min \\; NumberOfVans \\times VanPollution + NumberOfMinibuses \\times MinibusPollution"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfVans * VanPollution + NumberOfMinibuses * MinibusPollution, GRB.MINIMIZE)""}}}","{""VanCapacity"": 6, ""VanPollution"": 7, ""MinibusCapacity"": 10, ""MinibusPollution"": 10, ""MinimumNumberOfKids"": 150, ""MaximumNumberOfMinibuses"": 10}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Use a number of vans and minibuses, where each van can transport VanCapacity
children and generates VanPollution pollution, and each minibus can transport
MinibusCapacity children and generates MinibusPollution pollution. The
constraints are that at least MinimumNumberOfKids children must be transported,
no more than MaximumNumberOfMinibuses minibuses can be used, and the number of
vans must exceed the number of minibuses. The goal is to minimize the total
pollution generated.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/163/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter VanCapacity @Def: Number of kids a van can take @Shape: [] 
VanCapacity = data['VanCapacity']
# @Parameter VanPollution @Def: Pollution produced by one van @Shape: [] 
VanPollution = data['VanPollution']
# @Parameter MinibusCapacity @Def: Number of kids a minibus can take @Shape: [] 
MinibusCapacity = data['MinibusCapacity']
# @Parameter MinibusPollution @Def: Pollution produced by one minibus @Shape: [] 
MinibusPollution = data['MinibusPollution']
# @Parameter MinimumNumberOfKids @Def: Minimum number of kids that need to go to school @Shape: [] 
MinimumNumberOfKids = data['MinimumNumberOfKids']
# @Parameter MaximumNumberOfMinibuses @Def: Maximum number of minibuses that can be used @Shape: [] 
MaximumNumberOfMinibuses = data['MaximumNumberOfMinibuses']

# Variables 
# @Variable NumberOfVans @Def: The number of vans used @Shape: [] 
NumberOfVans = model.addVar(vtype=GRB.INTEGER, name=""NumberOfVans"")
# @Variable NumberOfMinibuses @Def: The number of minibuses used @Shape: [] 
NumberOfMinibuses = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaximumNumberOfMinibuses, name=""NumberOfMinibuses"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of children transported by vans and minibuses must be at least MinimumNumberOfKids.
model.addConstr(NumberOfVans * VanCapacity + NumberOfMinibuses * MinibusCapacity >= MinimumNumberOfKids)
# @Constraint Constr_2 @Def: No more than MaximumNumberOfMinibuses minibuses can be used.
model.addConstr(NumberOfMinibuses <= MaximumNumberOfMinibuses)
# @Constraint Constr_3 @Def: The number of vans used must exceed the number of minibuses used.
model.addConstr(NumberOfVans >= NumberOfMinibuses + 1)

# Objective 
# @Objective Objective @Def: The total pollution is the sum of the pollution generated by all vans and minibuses used. The objective is to minimize the total pollution.
model.setObjective(NumberOfVans * VanPollution + NumberOfMinibuses * MinibusPollution, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfVans'] = NumberOfVans.x
variables['NumberOfMinibuses'] = NumberOfMinibuses.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A recycling company collects recycling from neighborhoods using small and large bins. A small bin requires 2 workers while a large bin requires 5 workers. A small bin can hold 25 units of recycling material and a large bin can hold 60 units of recycling material. The company has available 100 workers. Because most people don't recycle, the number of small bins must be three times the number of large bins. In addition, there must be at least 10 small bins and 4 large bins. How many of each bin type should be used to maximize the total amount of recycling material that can be collected?","{""variables"": {""NumberSmallBins"": 27.0, ""NumberLargeBins"": 9.0}, ""objective"": 1215.0}","{""parametrized_description"": ""A recycling company selects the number of SmallBins and LargeBins, where each SmallBin requires WorkersPerSmallBin workers and holds CapacitySmallBin units of recycling material, and each LargeBin requires WorkersPerLargeBin workers and holds CapacityLargeBin units of recycling material. The total number of workers used must not exceed TotalWorkers. The number of SmallBins must be SmallBinToLargeBinRatio times the number of LargeBins. Additionally, the number of SmallBins must be at least MinimumSmallBins and the number of LargeBins must be at least MinimumLargeBins. The objective is to maximize the total recycling material collected."", ""keywords"": [""N.A.""], ""parameters"": {""WorkersPerSmallBin"": {""description"": ""Number of workers required for a small bin"", ""shape"": []}, ""WorkersPerLargeBin"": {""description"": ""Number of workers required for a large bin"", ""shape"": []}, ""CapacitySmallBin"": {""description"": ""Capacity of a small bin in units of recycling material"", ""shape"": []}, ""CapacityLargeBin"": {""description"": ""Capacity of a large bin in units of recycling material"", ""shape"": []}, ""TotalWorkers"": {""description"": ""Total number of available workers"", ""shape"": []}, ""SmallBinToLargeBinRatio"": {""description"": ""Required ratio of small bins to large bins"", ""shape"": []}, ""MinimumSmallBins"": {""description"": ""Minimum number of small bins"", ""shape"": []}, ""MinimumLargeBins"": {""description"": ""Minimum number of large bins"", ""shape"": []}}, ""variables"": {""NumberSmallBins"": {""description"": ""The number of small bins used"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberLargeBins"": {""description"": ""The number of large bins used"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total number of workers used must not exceed TotalWorkers. This is calculated as WorkersPerSmallBin multiplied by the number of SmallBins plus WorkersPerLargeBin multiplied by the number of LargeBins."", ""formulation"": ""WorkersPerSmallBin \\cdot NumberSmallBins + WorkersPerLargeBin \\cdot NumberLargeBins \\leq TotalWorkers"", ""code"": {""gurobipy"": ""model.addConstr(WorkersPerSmallBin * NumberSmallBins + WorkersPerLargeBin * NumberLargeBins <= TotalWorkers)""}}, {""description"": ""The number of SmallBins must be equal to SmallBinToLargeBinRatio times the number of LargeBins."", ""formulation"": ""NumberSmallBins = SmallBinToLargeBinRatio \\times NumberLargeBins"", ""code"": {""gurobipy"": ""model.addConstr(NumberSmallBins == SmallBinToLargeBinRatio * NumberLargeBins)""}}, {""description"": ""The number of SmallBins must be at least MinimumSmallBins."", ""formulation"": ""NumberSmallBins \\geq MinimumSmallBins"", ""code"": {""gurobipy"": ""model.addConstr(NumberSmallBins >= MinimumSmallBins)""}}, {""description"": ""The number of LargeBins must be at least MinimumLargeBins."", ""formulation"": ""NumberLargeBins \\geq MinimumLargeBins"", ""code"": {""gurobipy"": ""model.addConstr(NumberLargeBins >= MinimumLargeBins, name=\""MinLargeBins\"")""}}], ""objective"": {""description"": ""Total recycling material collected is calculated as CapacitySmallBin multiplied by the number of SmallBins plus CapacityLargeBin multiplied by the number of LargeBins. The objective is to maximize the total recycling material collected."", ""formulation"": ""Max \\ CapacitySmallBin \\times NumberSmallBins + CapacityLargeBin \\times NumberLargeBins"", ""code"": {""gurobipy"": ""model.setObjective(CapacitySmallBin * NumberSmallBins + CapacityLargeBin * NumberLargeBins, GRB.MAXIMIZE)""}}}","{""WorkersPerSmallBin"": 2, ""WorkersPerLargeBin"": 5, ""CapacitySmallBin"": 25, ""CapacityLargeBin"": 60, ""TotalWorkers"": 100, ""SmallBinToLargeBinRatio"": 3, ""MinimumSmallBins"": 10, ""MinimumLargeBins"": 4}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A recycling company selects the number of SmallBins and LargeBins, where each
SmallBin requires WorkersPerSmallBin workers and holds CapacitySmallBin units of
recycling material, and each LargeBin requires WorkersPerLargeBin workers and
holds CapacityLargeBin units of recycling material. The total number of workers
used must not exceed TotalWorkers. The number of SmallBins must be
SmallBinToLargeBinRatio times the number of LargeBins. Additionally, the number
of SmallBins must be at least MinimumSmallBins and the number of LargeBins must
be at least MinimumLargeBins. The objective is to maximize the total recycling
material collected.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/164/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter WorkersPerSmallBin @Def: Number of workers required for a small bin @Shape: [] 
WorkersPerSmallBin = data['WorkersPerSmallBin']
# @Parameter WorkersPerLargeBin @Def: Number of workers required for a large bin @Shape: [] 
WorkersPerLargeBin = data['WorkersPerLargeBin']
# @Parameter CapacitySmallBin @Def: Capacity of a small bin in units of recycling material @Shape: [] 
CapacitySmallBin = data['CapacitySmallBin']
# @Parameter CapacityLargeBin @Def: Capacity of a large bin in units of recycling material @Shape: [] 
CapacityLargeBin = data['CapacityLargeBin']
# @Parameter TotalWorkers @Def: Total number of available workers @Shape: [] 
TotalWorkers = data['TotalWorkers']
# @Parameter SmallBinToLargeBinRatio @Def: Required ratio of small bins to large bins @Shape: [] 
SmallBinToLargeBinRatio = data['SmallBinToLargeBinRatio']
# @Parameter MinimumSmallBins @Def: Minimum number of small bins @Shape: [] 
MinimumSmallBins = data['MinimumSmallBins']
# @Parameter MinimumLargeBins @Def: Minimum number of large bins @Shape: [] 
MinimumLargeBins = data['MinimumLargeBins']

# Variables 
# @Variable NumberSmallBins @Def: The number of small bins used @Shape: ['Integer'] 
NumberSmallBins = model.addVar(vtype=GRB.INTEGER, name=""NumberSmallBins"")
# @Variable NumberLargeBins @Def: The number of large bins used @Shape: ['Integer'] 
NumberLargeBins = model.addVar(lb=MinimumLargeBins, vtype=GRB.INTEGER, name=""NumberLargeBins"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of workers used must not exceed TotalWorkers. This is calculated as WorkersPerSmallBin multiplied by the number of SmallBins plus WorkersPerLargeBin multiplied by the number of LargeBins.
model.addConstr(WorkersPerSmallBin * NumberSmallBins + WorkersPerLargeBin * NumberLargeBins <= TotalWorkers)
# @Constraint Constr_2 @Def: The number of SmallBins must be equal to SmallBinToLargeBinRatio times the number of LargeBins.
model.addConstr(NumberSmallBins == SmallBinToLargeBinRatio * NumberLargeBins)
# @Constraint Constr_3 @Def: The number of SmallBins must be at least MinimumSmallBins.
model.addConstr(NumberSmallBins >= MinimumSmallBins)
# @Constraint Constr_4 @Def: The number of LargeBins must be at least MinimumLargeBins.
model.addConstr(NumberLargeBins >= MinimumLargeBins, name=""MinLargeBins"")

# Objective 
# @Objective Objective @Def: Total recycling material collected is calculated as CapacitySmallBin multiplied by the number of SmallBins plus CapacityLargeBin multiplied by the number of LargeBins. The objective is to maximize the total recycling material collected.
model.setObjective(CapacitySmallBin * NumberSmallBins + CapacityLargeBin * NumberLargeBins, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberSmallBins'] = NumberSmallBins.x
variables['NumberLargeBins'] = NumberLargeBins.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A toy store hires seasonal and full-time volunteers to deliver gifts and gives them points for service. A seasonal volunteer can deliver 5 gifts and gets 2 points. A full-time volunteer can deliver 8 gifts and gets 5 points. The store can only give out 200 points. In addition, a maximum of 30% of the volunteers can be seasonal and at least 10 must be full-time. How many of each volunteer is needed to maximize the total number of gifts that can be delivered?","{""variables"": {""SeasonalVolunteers"": 14.0, ""FullTimeVolunteers"": 34.0}, ""objective"": 342.0}","{""parametrized_description"": ""Define decision variables for the number of seasonal volunteers and full-time volunteers. The objective is to maximize the total number of gifts delivered, calculated as GiftsPerSeasonal multiplied by the number of seasonal volunteers plus GiftsPerFullTime multiplied by the number of full-time volunteers. The constraints are that the total points awarded, PointsPerSeasonal times seasonal volunteers plus PointsPerFullTime times full-time volunteers, does not exceed PointsLimit; the number of seasonal volunteers does not exceed MaxSeasonalPercentage of the total number of volunteers; and the number of full-time volunteers is at least MinFullTimeVolunteers."", ""keywords"": [""N.A.""], ""parameters"": {""PointsLimit"": {""description"": ""Number of points available to distribute"", ""shape"": []}, ""MaxSeasonalPercentage"": {""description"": ""Maximum percentage of volunteers that can be seasonal"", ""shape"": []}, ""MinFullTimeVolunteers"": {""description"": ""Minimum number of full-time volunteers required"", ""shape"": []}, ""GiftsPerSeasonal"": {""description"": ""Number of gifts delivered by each seasonal volunteer"", ""shape"": []}, ""PointsPerSeasonal"": {""description"": ""Points awarded to each seasonal volunteer"", ""shape"": []}, ""GiftsPerFullTime"": {""description"": ""Number of gifts delivered by each full-time volunteer"", ""shape"": []}, ""PointsPerFullTime"": {""description"": ""Points awarded to each full-time volunteer"", ""shape"": []}}, ""variables"": {""SeasonalVolunteers"": {""description"": ""The number of seasonal volunteers"", ""type"": ""continuous"", ""shape"": [""integer""]}, ""FullTimeVolunteers"": {""description"": ""The number of full-time volunteers"", ""type"": ""continuous"", ""shape"": [""integer""]}}, ""constraints"": [{""description"": ""The total points awarded to volunteers must not exceed PointsLimit. This is calculated as PointsPerSeasonal multiplied by the number of seasonal volunteers plus PointsPerFullTime multiplied by the number of full-time volunteers."", ""formulation"": ""PointsPerSeasonal \\cdot SeasonalVolunteers + PointsPerFullTime \\cdot FullTimeVolunteers \\leq PointsLimit"", ""code"": {""gurobipy"": ""model.addConstr(PointsPerSeasonal * SeasonalVolunteers + PointsPerFullTime * FullTimeVolunteers <= PointsLimit)""}}, {""description"": ""The number of seasonal volunteers must not exceed MaxSeasonalPercentage of the total number of volunteers. Mathematically, SeasonalVolunteers \u2264 MaxSeasonalPercentage * (SeasonalVolunteers + FullTimeVolunteers)."", ""formulation"": ""SeasonalVolunteers \\leq MaxSeasonalPercentage \\times (SeasonalVolunteers + FullTimeVolunteers)"", ""code"": {""gurobipy"": ""model.addConstr(SeasonalVolunteers <= MaxSeasonalPercentage * (SeasonalVolunteers + FullTimeVolunteers))""}}, {""description"": ""The number of full-time volunteers must be at least MinFullTimeVolunteers."", ""formulation"": ""FullTimeVolunteers \\geq MinFullTimeVolunteers"", ""code"": {""gurobipy"": ""model.addConstr(FullTimeVolunteers >= MinFullTimeVolunteers)""}}], ""objective"": {""description"": ""Maximize the total number of gifts delivered, calculated as GiftsPerSeasonal multiplied by the number of seasonal volunteers plus GiftsPerFullTime multiplied by the number of full-time volunteers."", ""formulation"": ""Max \\left( GiftsPerSeasonal \\times SeasonalVolunteers + GiftsPerFullTime \\times FullTimeVolunteers \\right)"", ""code"": {""gurobipy"": ""model.setObjective(GiftsPerSeasonal * SeasonalVolunteers + GiftsPerFullTime * FullTimeVolunteers, GRB.MAXIMIZE)""}}}","{""PointsLimit"": 200, ""MaxSeasonalPercentage"": 0.3, ""MinFullTimeVolunteers"": 10, ""GiftsPerSeasonal"": 5, ""PointsPerSeasonal"": 2, ""GiftsPerFullTime"": 8, ""PointsPerFullTime"": 5}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Define decision variables for the number of seasonal volunteers and full-time
volunteers. The objective is to maximize the total number of gifts delivered,
calculated as GiftsPerSeasonal multiplied by the number of seasonal volunteers
plus GiftsPerFullTime multiplied by the number of full-time volunteers. The
constraints are that the total points awarded, PointsPerSeasonal times seasonal
volunteers plus PointsPerFullTime times full-time volunteers, does not exceed
PointsLimit; the number of seasonal volunteers does not exceed
MaxSeasonalPercentage of the total number of volunteers; and the number of full-
time volunteers is at least MinFullTimeVolunteers.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/165/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter PointsLimit @Def: Number of points available to distribute @Shape: [] 
PointsLimit = data['PointsLimit']
# @Parameter MaxSeasonalPercentage @Def: Maximum percentage of volunteers that can be seasonal @Shape: [] 
MaxSeasonalPercentage = data['MaxSeasonalPercentage']
# @Parameter MinFullTimeVolunteers @Def: Minimum number of full-time volunteers required @Shape: [] 
MinFullTimeVolunteers = data['MinFullTimeVolunteers']
# @Parameter GiftsPerSeasonal @Def: Number of gifts delivered by each seasonal volunteer @Shape: [] 
GiftsPerSeasonal = data['GiftsPerSeasonal']
# @Parameter PointsPerSeasonal @Def: Points awarded to each seasonal volunteer @Shape: [] 
PointsPerSeasonal = data['PointsPerSeasonal']
# @Parameter GiftsPerFullTime @Def: Number of gifts delivered by each full-time volunteer @Shape: [] 
GiftsPerFullTime = data['GiftsPerFullTime']
# @Parameter PointsPerFullTime @Def: Points awarded to each full-time volunteer @Shape: [] 
PointsPerFullTime = data['PointsPerFullTime']

# Variables 
# @Variable SeasonalVolunteers @Def: The number of seasonal volunteers @Shape: ['integer'] 
SeasonalVolunteers = model.addVar(vtype=GRB.INTEGER, name=""SeasonalVolunteers"")
# @Variable FullTimeVolunteers @Def: The number of full-time volunteers @Shape: ['integer'] 
FullTimeVolunteers = model.addVar(lb=MinFullTimeVolunteers, vtype=GRB.INTEGER, name=""FullTimeVolunteers"")

# Constraints 
# @Constraint Constr_1 @Def: The total points awarded to volunteers must not exceed PointsLimit. This is calculated as PointsPerSeasonal multiplied by the number of seasonal volunteers plus PointsPerFullTime multiplied by the number of full-time volunteers.
model.addConstr(PointsPerSeasonal * SeasonalVolunteers + PointsPerFullTime * FullTimeVolunteers <= PointsLimit)
# @Constraint Constr_2 @Def: The number of seasonal volunteers must not exceed MaxSeasonalPercentage of the total number of volunteers. Mathematically, SeasonalVolunteers ≤ MaxSeasonalPercentage * (SeasonalVolunteers + FullTimeVolunteers).
model.addConstr(SeasonalVolunteers <= MaxSeasonalPercentage * (SeasonalVolunteers + FullTimeVolunteers))
# @Constraint Constr_3 @Def: The number of full-time volunteers must be at least MinFullTimeVolunteers.
model.addConstr(FullTimeVolunteers >= MinFullTimeVolunteers)

# Objective 
# @Objective Objective @Def: Maximize the total number of gifts delivered, calculated as GiftsPerSeasonal multiplied by the number of seasonal volunteers plus GiftsPerFullTime multiplied by the number of full-time volunteers.
model.setObjective(GiftsPerSeasonal * SeasonalVolunteers + GiftsPerFullTime * FullTimeVolunteers, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SeasonalVolunteers'] = SeasonalVolunteers.x
variables['FullTimeVolunteers'] = FullTimeVolunteers.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A jam company sends its product out in small and large jars. A small jar can hold 50 ml of jam while a large jar can hold 200 ml of jam. Most store prefer the smaller size and so the number of large jars cannot exceed the number of small jars. If the company wants to ship at least 100000 ml of jam, find the minimum number of jars that can be used.","{""variables"": {""NumberOfSmallJars"": 400.0, ""NumberOfLargeJars"": 400.0}, ""objective"": 800.0}","{""parametrized_description"": ""A jam company sends its product out in small and large jars. A small jar can hold SmallJarCapacity milliliters of jam while a large jar can hold LargeJarCapacity milliliters of jam. Most stores prefer the smaller size and so the number of large jars cannot exceed MaxLargeJarsRatio times the number of small jars. If the company wants to ship at least MinJamVolume milliliters of jam, find the minimum number of jars that can be used."", ""keywords"": [""N.A.""], ""parameters"": {""SmallJarCapacity"": {""description"": ""Capacity of a small jar in milliliters"", ""shape"": []}, ""LargeJarCapacity"": {""description"": ""Capacity of a large jar in milliliters"", ""shape"": []}, ""MinJamVolume"": {""description"": ""Minimum total volume of jam to ship in milliliters"", ""shape"": []}, ""MaxLargeJarsRatio"": {""description"": ""Maximum allowed ratio of large jars to small jars"", ""shape"": []}}, ""variables"": {""NumberOfSmallJars"": {""description"": ""The number of small jars to ship"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfLargeJars"": {""description"": ""The number of large jars to ship"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total volume of jam shipped is at least MinJamVolume milliliters."", ""formulation"": ""SmallJarCapacity \\times NumberOfSmallJars + LargeJarCapacity \\times NumberOfLargeJars \\geq MinJamVolume"", ""code"": {""gurobipy"": ""model.addConstr(SmallJarCapacity * NumberOfSmallJars + LargeJarCapacity * NumberOfLargeJars >= MinJamVolume)""}}, {""description"": ""The number of large jars does not exceed MaxLargeJarsRatio times the number of small jars."", ""formulation"": ""NumberOfLargeJars \\leq MaxLargeJarsRatio \\cdot NumberOfSmallJars"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfLargeJars <= MaxLargeJarsRatio * NumberOfSmallJars)""}}], ""objective"": {""description"": ""Minimize the total number of small and large jars used to ship the jam."", ""formulation"": ""Min NumberOfSmallJars + NumberOfLargeJars"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfSmallJars + NumberOfLargeJars, GRB.MINIMIZE)""}}}","{""SmallJarCapacity"": 50, ""LargeJarCapacity"": 200, ""MinJamVolume"": 100000, ""MaxLargeJarsRatio"": 1}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A jam company sends its product out in small and large jars. A small jar can
hold SmallJarCapacity milliliters of jam while a large jar can hold
LargeJarCapacity milliliters of jam. Most stores prefer the smaller size and so
the number of large jars cannot exceed MaxLargeJarsRatio times the number of
small jars. If the company wants to ship at least MinJamVolume milliliters of
jam, find the minimum number of jars that can be used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/166/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SmallJarCapacity @Def: Capacity of a small jar in milliliters @Shape: [] 
SmallJarCapacity = data['SmallJarCapacity']
# @Parameter LargeJarCapacity @Def: Capacity of a large jar in milliliters @Shape: [] 
LargeJarCapacity = data['LargeJarCapacity']
# @Parameter MinJamVolume @Def: Minimum total volume of jam to ship in milliliters @Shape: [] 
MinJamVolume = data['MinJamVolume']
# @Parameter MaxLargeJarsRatio @Def: Maximum allowed ratio of large jars to small jars @Shape: [] 
MaxLargeJarsRatio = data['MaxLargeJarsRatio']

# Variables 
# @Variable NumberOfSmallJars @Def: The number of small jars to ship @Shape: [] 
NumberOfSmallJars = model.addVar(vtype=GRB.INTEGER, name='NumberOfSmallJars')
# @Variable NumberOfLargeJars @Def: The number of large jars to ship @Shape: [] 
NumberOfLargeJars = model.addVar(vtype=GRB.INTEGER, name=""NumberOfLargeJars"")

# Constraints 
# @Constraint Constr_1 @Def: The total volume of jam shipped is at least MinJamVolume milliliters.
model.addConstr(SmallJarCapacity * NumberOfSmallJars + LargeJarCapacity * NumberOfLargeJars >= MinJamVolume)
# @Constraint Constr_2 @Def: The number of large jars does not exceed MaxLargeJarsRatio times the number of small jars.
model.addConstr(NumberOfLargeJars <= MaxLargeJarsRatio * NumberOfSmallJars)

# Objective 
# @Objective Objective @Def: Minimize the total number of small and large jars used to ship the jam.
model.setObjective(NumberOfSmallJars + NumberOfLargeJars, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfSmallJars'] = NumberOfSmallJars.x
variables['NumberOfLargeJars'] = NumberOfLargeJars.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A corn farmer sends his corn to the city by either tractor or car.  A tractor can carry 40 kg of corn while a car can carry 20 kg of corn. Since tractors are very slow, the number of cars used has to be at least twice the number of tractors used. If at least 500 kg of corn need to be sent to the city, minimize the total number of tractors and cars needed.","{""variables"": {""NumberOfCarsUsed"": 13.0, ""NumberOfTractorsUsed"": 6.0, ""CornTractor"": 240.0, ""CornCar"": 260.0}, ""objective"": 19.0}","{""parametrized_description"": ""A farmer sends corn to the city by either tractor or car. A tractor can carry TractorCapacity kilograms of corn while a car can carry CarCapacity kilograms of corn. Since tractors are very slow, the number of cars used must be at least MinimumCarMultiplier times the number of tractors used. If at least MinimumCornToSend kilograms of corn need to be sent to the city, minimize the total number of tractors and cars needed."", ""keywords"": [""N.A.""], ""parameters"": {""TractorCapacity"": {""description"": ""Capacity of one tractor in kilograms"", ""shape"": []}, ""CarCapacity"": {""description"": ""Capacity of one car in kilograms"", ""shape"": []}, ""MinimumCarMultiplier"": {""description"": ""Minimum multiplier for the number of cars relative to tractors"", ""shape"": []}, ""MinimumCornToSend"": {""description"": ""Minimum total amount of corn to send in kilograms"", ""shape"": []}}, ""variables"": {""NumberOfCarsUsed"": {""description"": ""The number of cars used"", ""type"": ""continuous"", ""shape"": [""NonNegative"", ""Integer""]}, ""NumberOfTractorsUsed"": {""description"": ""The number of tractors used"", ""type"": ""continuous"", ""shape"": [""NonNegative"", ""Integer""]}, ""CornTractor"": {""description"": ""The amount of corn carried by tractors in kilograms"", ""type"": ""continuous"", ""shape"": [""NonNegative""]}, ""CornCar"": {""description"": ""The amount of corn carried by cars in kilograms"", ""type"": ""continuous"", ""shape"": [""NonNegative""]}}, ""constraints"": [{""description"": ""The number of cars used must be at least MinimumCarMultiplier times the number of tractors used."", ""formulation"": ""NumberOfCarsUsed \\geq MinimumCarMultiplier \\times NumberOfTractorsUsed"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfCarsUsed >= MinimumCarMultiplier * NumberOfTractorsUsed)""}}, {""description"": ""Each tractor can carry TractorCapacity kilograms of corn."", ""formulation"": ""CornTractor \\leq NumberOfTractorsUsed \\times TractorCapacity"", ""code"": {""gurobipy"": ""model.addConstr(CornTractor <= NumberOfTractorsUsed * TractorCapacity)""}}, {""description"": ""Each car can carry CarCapacity kilograms of corn."", ""formulation"": ""CornCar \\leq CarCapacity \\times NumberOfCarsUsed"", ""code"": {""gurobipy"": ""model.addConstr(CornCar <= CarCapacity * NumberOfCarsUsed)""}}, {""description"": ""At least MinimumCornToSend kilograms of corn must be sent to the city."", ""formulation"": ""CornTractor + CornCar \\geq MinimumCornToSend"", ""code"": {""gurobipy"": ""model.addConstr(CornTractor + CornCar >= MinimumCornToSend)""}}], ""objective"": {""description"": ""Minimize the total number of tractors and cars needed."", ""formulation"": ""Min \\left( NumberOfCarsUsed + NumberOfTractorsUsed \\right )"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfCarsUsed + NumberOfTractorsUsed, GRB.MINIMIZE)""}}}","{""TractorCapacity"": 40, ""CarCapacity"": 20, ""MinimumCarMultiplier"": 2, ""MinimumCornToSend"": 500}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A farmer sends corn to the city by either tractor or car. A tractor can carry
TractorCapacity kilograms of corn while a car can carry CarCapacity kilograms of
corn. Since tractors are very slow, the number of cars used must be at least
MinimumCarMultiplier times the number of tractors used. If at least
MinimumCornToSend kilograms of corn need to be sent to the city, minimize the
total number of tractors and cars needed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/167/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TractorCapacity @Def: Capacity of one tractor in kilograms @Shape: [] 
TractorCapacity = data['TractorCapacity']
# @Parameter CarCapacity @Def: Capacity of one car in kilograms @Shape: [] 
CarCapacity = data['CarCapacity']
# @Parameter MinimumCarMultiplier @Def: Minimum multiplier for the number of cars relative to tractors @Shape: [] 
MinimumCarMultiplier = data['MinimumCarMultiplier']
# @Parameter MinimumCornToSend @Def: Minimum total amount of corn to send in kilograms @Shape: [] 
MinimumCornToSend = data['MinimumCornToSend']

# Variables 
# @Variable NumberOfCarsUsed @Def: The number of cars used @Shape: ['NonNegative', 'Integer'] 
NumberOfCarsUsed = model.addVar(vtype=GRB.INTEGER, name=""NumberOfCarsUsed"")
# @Variable NumberOfTractorsUsed @Def: The number of tractors used @Shape: ['NonNegative', 'Integer'] 
NumberOfTractorsUsed = model.addVar(vtype=GRB.INTEGER, lb=0, name=""NumberOfTractorsUsed"")
# @Variable CornTractor @Def: The amount of corn carried by tractors in kilograms @Shape: ['NonNegative'] 
CornTractor = model.addVar(vtype=GRB.CONTINUOUS, name=""CornTractor"")
# @Variable CornCar @Def: The amount of corn carried by cars in kilograms @Shape: ['NonNegative'] 
CornCar = model.addVar(vtype=GRB.CONTINUOUS, name=""CornCar"")

# Constraints 
# @Constraint Constr_1 @Def: The number of cars used must be at least MinimumCarMultiplier times the number of tractors used.
model.addConstr(NumberOfCarsUsed >= MinimumCarMultiplier * NumberOfTractorsUsed)
# @Constraint Constr_2 @Def: Each tractor can carry TractorCapacity kilograms of corn.
model.addConstr(CornTractor <= NumberOfTractorsUsed * TractorCapacity)
# @Constraint Constr_3 @Def: Each car can carry CarCapacity kilograms of corn.
model.addConstr(CornCar <= CarCapacity * NumberOfCarsUsed)
# @Constraint Constr_4 @Def: At least MinimumCornToSend kilograms of corn must be sent to the city.
model.addConstr(CornTractor + CornCar >= MinimumCornToSend)

# Objective 
# @Objective Objective @Def: Minimize the total number of tractors and cars needed.
model.setObjective(NumberOfCarsUsed + NumberOfTractorsUsed, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfCarsUsed'] = NumberOfCarsUsed.x
variables['NumberOfTractorsUsed'] = NumberOfTractorsUsed.x
variables['CornTractor'] = CornTractor.x
variables['CornCar'] = CornCar.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A village hosts a banquet and provides bike and car transportation for everyone. A bike can take 3 people while a car can take 5 people. Since cars are more expensive, at most 40% of the vehicles can be cars. If the village needs to transport at least 500 people, how many of each vehicle should be used to minimize the total number of bikes needed?","{""variables"": {""NumberOfBikes"": 80.0, ""NumberOfCars"": 53.0}, ""objective"": 80.0}","{""parametrized_description"": ""A village needs to transport at least NumberOfPeople individuals using bikes and cars. Each bike has a capacity of BikeCapacity people, and each car has a capacity of CarCapacity people. At most MaxCarPercentage of the total vehicles can be cars. Determine the number of bikes and cars required to minimize the total number of bikes needed."", ""keywords"": [""N.A.""], ""parameters"": {""BikeCapacity"": {""description"": ""Number of people each bike can transport"", ""shape"": []}, ""CarCapacity"": {""description"": ""Number of people each car can transport"", ""shape"": []}, ""MaxCarPercentage"": {""description"": ""Maximum percentage of vehicles that can be cars"", ""shape"": []}, ""NumberOfPeople"": {""description"": ""Total number of people to transport"", ""shape"": []}}, ""variables"": {""NumberOfBikes"": {""description"": ""The number of bikes used for transportation"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfCars"": {""description"": ""The number of cars used for transportation"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of people transported by bikes and cars must be at least NumberOfPeople."", ""formulation"": ""BikeCapacity \\times NumberOfBikes + CarCapacity \\times NumberOfCars \\geq NumberOfPeople"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfBikes * BikeCapacity + NumberOfCars * CarCapacity >= NumberOfPeople)""}}, {""description"": ""The number of cars used cannot exceed MaxCarPercentage of the total number of vehicles."", ""formulation"": ""NumberOfCars \\leq MaxCarPercentage \\times (NumberOfCars + NumberOfBikes)"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfCars <= MaxCarPercentage * (NumberOfCars + NumberOfBikes))""}}], ""objective"": {""description"": ""Minimize the total number of bikes needed."", ""formulation"": ""\\min \\ NumberOfBikes"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfBikes, GRB.MINIMIZE)""}}}","{""BikeCapacity"": 3, ""CarCapacity"": 5, ""MaxCarPercentage"": 0.4, ""NumberOfPeople"": 500}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A village needs to transport at least NumberOfPeople individuals using bikes and
cars. Each bike has a capacity of BikeCapacity people, and each car has a
capacity of CarCapacity people. At most MaxCarPercentage of the total vehicles
can be cars. Determine the number of bikes and cars required to minimize the
total number of bikes needed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/168/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter BikeCapacity @Def: Number of people each bike can transport @Shape: [] 
BikeCapacity = data['BikeCapacity']
# @Parameter CarCapacity @Def: Number of people each car can transport @Shape: [] 
CarCapacity = data['CarCapacity']
# @Parameter MaxCarPercentage @Def: Maximum percentage of vehicles that can be cars @Shape: [] 
MaxCarPercentage = data['MaxCarPercentage']
# @Parameter NumberOfPeople @Def: Total number of people to transport @Shape: [] 
NumberOfPeople = data['NumberOfPeople']

# Variables 
# @Variable NumberOfBikes @Def: The number of bikes used for transportation @Shape: [] 
NumberOfBikes = model.addVar(vtype=GRB.INTEGER, name=""NumberOfBikes"")
# @Variable NumberOfCars @Def: The number of cars used for transportation @Shape: [] 
NumberOfCars = model.addVar(vtype=GRB.INTEGER, name=""NumberOfCars"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of people transported by bikes and cars must be at least NumberOfPeople.
model.addConstr(NumberOfBikes * BikeCapacity + NumberOfCars * CarCapacity >= NumberOfPeople)
# @Constraint Constr_2 @Def: The number of cars used cannot exceed MaxCarPercentage of the total number of vehicles.
model.addConstr(NumberOfCars <= MaxCarPercentage * (NumberOfCars + NumberOfBikes))

# Objective 
# @Objective Objective @Def: Minimize the total number of bikes needed.
model.setObjective(NumberOfBikes, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfBikes'] = NumberOfBikes.x
variables['NumberOfCars'] = NumberOfCars.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An industrial tire company delivers large tires for equipment to remote engineering sites either by cargo planes or ultrawide trucks. Each cargo plane can transport 10 tires per trip and costs $1000. Each ultrawide truck can transport 6 tires per trip and costs $700. The company needs to transport at least 200 tires and has available $22000. Because most remote sites don't have proper airports, the number of plane trips cannot exceed the number of ultrawide truck trips. How many trips of each should be done to minimize the total number of trips?","{""variables"": {""PlaneTrips"": 12.0, ""TruckTrips"": 14.0}, ""objective"": 26.0}","{""parametrized_description"": ""An industrial tire company transports tires using cargo planes and ultrawide trucks. Each cargo plane trip transports TiresPerPlaneTrip tires and costs CostPerPlaneTrip dollars. Each ultrawide truck trip transports TiresPerTruckTrip tires and costs CostPerTruckTrip dollars. The company needs to transport at least MinTires tires and has a budget of AvailableBudget dollars. The number of cargo plane trips cannot exceed the number of ultrawide truck trips. Determine the number of cargo plane trips and ultrawide truck trips to minimize the total number of trips."", ""keywords"": [""N.A.""], ""parameters"": {""TiresPerPlaneTrip"": {""description"": ""Number of tires that can be transported by one cargo plane per trip"", ""shape"": []}, ""CostPerPlaneTrip"": {""description"": ""Cost of one cargo plane trip in dollars"", ""shape"": []}, ""TiresPerTruckTrip"": {""description"": ""Number of tires that can be transported by one ultrawide truck per trip"", ""shape"": []}, ""CostPerTruckTrip"": {""description"": ""Cost of one ultrawide truck trip in dollars"", ""shape"": []}, ""MinTires"": {""description"": ""Minimum number of tires to be transported"", ""shape"": []}, ""AvailableBudget"": {""description"": ""Available budget in dollars for transportation"", ""shape"": []}}, ""variables"": {""PlaneTrips"": {""description"": ""The number of cargo plane trips"", ""type"": ""continuous"", ""shape"": [""integer""]}, ""TruckTrips"": {""description"": ""The number of ultrawide truck trips"", ""type"": ""continuous"", ""shape"": [""integer""]}}, ""constraints"": [{""description"": ""The total number of tires transported by cargo planes and ultrawide trucks must be at least MinTires."", ""formulation"": ""PlaneTrips \\cdot TiresPerPlaneTrip + TruckTrips \\cdot TiresPerTruckTrip \\geq MinTires"", ""code"": {""gurobipy"": ""model.addConstr(PlaneTrips * TiresPerPlaneTrip + TruckTrips * TiresPerTruckTrip >= MinTires)""}}, {""description"": ""The total cost of cargo plane and ultrawide truck trips must not exceed AvailableBudget dollars."", ""formulation"": ""CostPerPlaneTrip \\cdot PlaneTrips + CostPerTruckTrip \\cdot TruckTrips \\leq AvailableBudget"", ""code"": {""gurobipy"": ""model.addConstr(CostPerPlaneTrip * PlaneTrips + CostPerTruckTrip * TruckTrips <= AvailableBudget)""}}, {""description"": ""The number of cargo plane trips cannot exceed the number of ultrawide truck trips."", ""formulation"": ""PlaneTrips \\leq TruckTrips"", ""code"": {""gurobipy"": ""model.addConstr(PlaneTrips <= TruckTrips)""}}], ""objective"": {""description"": ""Minimize the total number of cargo plane trips and ultrawide truck trips required to transport all tires within the budget and logistical constraints."", ""formulation"": ""Min PlaneTrips + TruckTrips"", ""code"": {""gurobipy"": ""model.setObjective(PlaneTrips + TruckTrips, GRB.MINIMIZE)""}}}","{""TiresPerPlaneTrip"": 10, ""CostPerPlaneTrip"": 1000, ""TiresPerTruckTrip"": 6, ""CostPerTruckTrip"": 700, ""MinTires"": 200, ""AvailableBudget"": 22000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
An industrial tire company transports tires using cargo planes and ultrawide
trucks. Each cargo plane trip transports TiresPerPlaneTrip tires and costs
CostPerPlaneTrip dollars. Each ultrawide truck trip transports TiresPerTruckTrip
tires and costs CostPerTruckTrip dollars. The company needs to transport at
least MinTires tires and has a budget of AvailableBudget dollars. The number of
cargo plane trips cannot exceed the number of ultrawide truck trips. Determine
the number of cargo plane trips and ultrawide truck trips to minimize the total
number of trips.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/169/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TiresPerPlaneTrip @Def: Number of tires that can be transported by one cargo plane per trip @Shape: [] 
TiresPerPlaneTrip = data['TiresPerPlaneTrip']
# @Parameter CostPerPlaneTrip @Def: Cost of one cargo plane trip in dollars @Shape: [] 
CostPerPlaneTrip = data['CostPerPlaneTrip']
# @Parameter TiresPerTruckTrip @Def: Number of tires that can be transported by one ultrawide truck per trip @Shape: [] 
TiresPerTruckTrip = data['TiresPerTruckTrip']
# @Parameter CostPerTruckTrip @Def: Cost of one ultrawide truck trip in dollars @Shape: [] 
CostPerTruckTrip = data['CostPerTruckTrip']
# @Parameter MinTires @Def: Minimum number of tires to be transported @Shape: [] 
MinTires = data['MinTires']
# @Parameter AvailableBudget @Def: Available budget in dollars for transportation @Shape: [] 
AvailableBudget = data['AvailableBudget']

# Variables 
# @Variable PlaneTrips @Def: The number of cargo plane trips @Shape: ['integer'] 
PlaneTrips = model.addVar(vtype=GRB.INTEGER, name=""PlaneTrips"")
# @Variable TruckTrips @Def: The number of ultrawide truck trips @Shape: ['integer'] 
TruckTrips = model.addVar(vtype=GRB.INTEGER, name=""TruckTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of tires transported by cargo planes and ultrawide trucks must be at least MinTires.
model.addConstr(PlaneTrips * TiresPerPlaneTrip + TruckTrips * TiresPerTruckTrip >= MinTires)
# @Constraint Constr_2 @Def: The total cost of cargo plane and ultrawide truck trips must not exceed AvailableBudget dollars.
model.addConstr(CostPerPlaneTrip * PlaneTrips + CostPerTruckTrip * TruckTrips <= AvailableBudget)
# @Constraint Constr_3 @Def: The number of cargo plane trips cannot exceed the number of ultrawide truck trips.
model.addConstr(PlaneTrips <= TruckTrips)

# Objective 
# @Objective Objective @Def: Minimize the total number of cargo plane trips and ultrawide truck trips required to transport all tires within the budget and logistical constraints.
model.setObjective(PlaneTrips + TruckTrips, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['PlaneTrips'] = PlaneTrips.x
variables['TruckTrips'] = TruckTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A water salesman collects water from a glacier and transports it in either small or large kegs. A small keg can hold 40 liters of water while a large keg can hold 100 liters of water. The salesman has available at most 30 small kegs and 10 large kegs. Since small kegs are easier to carry, at least twice as may small kegs must be used than large kegs. If he can transport at most 25 kegs total and at least 5 kegs must be large, how many of each should he use to maximize the total amount of glacial water he can transport?","{""variables"": {""NumSmallKegsUsed"": 17.0, ""NumLargeKegsUsed"": 8.0}, ""objective"": 1480.0}","{""parametrized_description"": ""A water salesman transports water using small and large kegs. Each small keg has a capacity of SmallKegCapacity liters, while each large keg has a capacity of LargeKegCapacity liters. The salesman can use at most MaxSmallKegsAvailable small kegs and MaxLargeKegsAvailable large kegs. The number of small kegs used must be at least SmallKegMultiplier times the number of large kegs used. The total number of kegs transported cannot exceed MaxTotalKegs, and at least MinLargeKegs large kegs must be used. Determine the number of small and large kegs to maximize the total amount of water transported."", ""keywords"": [""N.A.""], ""parameters"": {""SmallKegCapacity"": {""description"": ""Capacity of a small keg in liters"", ""shape"": []}, ""LargeKegCapacity"": {""description"": ""Capacity of a large keg in liters"", ""shape"": []}, ""MaxSmallKegsAvailable"": {""description"": ""Maximum number of small kegs available"", ""shape"": []}, ""MaxLargeKegsAvailable"": {""description"": ""Maximum number of large kegs available"", ""shape"": []}, ""SmallKegMultiplier"": {""description"": ""The multiplier for the number of small kegs to be used compared to large kegs"", ""shape"": []}, ""MaxTotalKegs"": {""description"": ""Maximum total number of kegs that can be transported"", ""shape"": []}, ""MinLargeKegs"": {""description"": ""Minimum number of large kegs that must be used"", ""shape"": []}}, ""variables"": {""NumSmallKegsUsed"": {""description"": ""The number of small kegs used"", ""type"": ""continuous"", ""shape"": []}, ""NumLargeKegsUsed"": {""description"": ""The number of large kegs used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of small kegs used must not exceed MaxSmallKegsAvailable."", ""formulation"": ""NumSmallKegsUsed \\leq MaxSmallKegsAvailable"", ""code"": {""gurobipy"": ""model.addConstr(NumSmallKegsUsed <= MaxSmallKegsAvailable)""}}, {""description"": ""The number of large kegs used must not exceed MaxLargeKegsAvailable."", ""formulation"": ""NumLargeKegsUsed \\leq MaxLargeKegsAvailable"", ""code"": {""gurobipy"": ""model.addConstr(NumLargeKegsUsed <= MaxLargeKegsAvailable)""}}, {""description"": ""The number of small kegs used must be at least SmallKegMultiplier times the number of large kegs used."", ""formulation"": ""NumSmallKegsUsed \\geq SmallKegMultiplier \\times NumLargeKegsUsed"", ""code"": {""gurobipy"": ""model.addConstr(NumSmallKegsUsed >= SmallKegMultiplier * NumLargeKegsUsed)""}}, {""description"": ""The total number of kegs transported cannot exceed MaxTotalKegs."", ""formulation"": ""NumSmallKegsUsed + NumLargeKegsUsed \\leq MaxTotalKegs"", ""code"": {""gurobipy"": ""model.addConstr(NumSmallKegsUsed + NumLargeKegsUsed <= MaxTotalKegs)""}}, {""description"": ""At least MinLargeKegs large kegs must be used."", ""formulation"": ""NumLargeKegsUsed \\geq MinLargeKegs"", ""code"": {""gurobipy"": ""model.addConstr(NumLargeKegsUsed >= MinLargeKegs)""}}], ""objective"": {""description"": ""Maximize the total amount of water transported, which is the sum of the capacities of the small and large kegs used."", ""formulation"": ""Max \\left( NumSmallKegsUsed \\times SmallKegCapacity + NumLargeKegsUsed \\times LargeKegCapacity \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumSmallKegsUsed * SmallKegCapacity + NumLargeKegsUsed * LargeKegCapacity, GRB.MAXIMIZE)""}}}","{""SmallKegCapacity"": 40, ""LargeKegCapacity"": 100, ""MaxSmallKegsAvailable"": 30, ""MaxLargeKegsAvailable"": 10, ""SmallKegMultiplier"": 2, ""MaxTotalKegs"": 25, ""MinLargeKegs"": 5}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A water salesman transports water using small and large kegs. Each small keg has
a capacity of SmallKegCapacity liters, while each large keg has a capacity of
LargeKegCapacity liters. The salesman can use at most MaxSmallKegsAvailable
small kegs and MaxLargeKegsAvailable large kegs. The number of small kegs used
must be at least SmallKegMultiplier times the number of large kegs used. The
total number of kegs transported cannot exceed MaxTotalKegs, and at least
MinLargeKegs large kegs must be used. Determine the number of small and large
kegs to maximize the total amount of water transported.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/170/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SmallKegCapacity @Def: Capacity of a small keg in liters @Shape: [] 
SmallKegCapacity = data['SmallKegCapacity']
# @Parameter LargeKegCapacity @Def: Capacity of a large keg in liters @Shape: [] 
LargeKegCapacity = data['LargeKegCapacity']
# @Parameter MaxSmallKegsAvailable @Def: Maximum number of small kegs available @Shape: [] 
MaxSmallKegsAvailable = data['MaxSmallKegsAvailable']
# @Parameter MaxLargeKegsAvailable @Def: Maximum number of large kegs available @Shape: [] 
MaxLargeKegsAvailable = data['MaxLargeKegsAvailable']
# @Parameter SmallKegMultiplier @Def: The multiplier for the number of small kegs to be used compared to large kegs @Shape: [] 
SmallKegMultiplier = data['SmallKegMultiplier']
# @Parameter MaxTotalKegs @Def: Maximum total number of kegs that can be transported @Shape: [] 
MaxTotalKegs = data['MaxTotalKegs']
# @Parameter MinLargeKegs @Def: Minimum number of large kegs that must be used @Shape: [] 
MinLargeKegs = data['MinLargeKegs']

# Variables 
# @Variable NumSmallKegsUsed @Def: The number of small kegs used @Shape: [] 
NumSmallKegsUsed = model.addVar(lb=0, ub=MaxSmallKegsAvailable, vtype=GRB.INTEGER, name=""NumSmallKegsUsed"")
# @Variable NumLargeKegsUsed @Def: The number of large kegs used @Shape: [] 
NumLargeKegsUsed = model.addVar(vtype=GRB.INTEGER, name=""NumLargeKegsUsed"")

# Constraints 
# @Constraint Constr_1 @Def: The number of small kegs used must not exceed MaxSmallKegsAvailable.
model.addConstr(NumSmallKegsUsed <= MaxSmallKegsAvailable)
# @Constraint Constr_2 @Def: The number of large kegs used must not exceed MaxLargeKegsAvailable.
model.addConstr(NumLargeKegsUsed <= MaxLargeKegsAvailable)
# @Constraint Constr_3 @Def: The number of small kegs used must be at least SmallKegMultiplier times the number of large kegs used.
model.addConstr(NumSmallKegsUsed >= SmallKegMultiplier * NumLargeKegsUsed)
# @Constraint Constr_4 @Def: The total number of kegs transported cannot exceed MaxTotalKegs.
model.addConstr(NumSmallKegsUsed + NumLargeKegsUsed <= MaxTotalKegs)
# @Constraint Constr_5 @Def: At least MinLargeKegs large kegs must be used.
model.addConstr(NumLargeKegsUsed >= MinLargeKegs)

# Objective 
# @Objective Objective @Def: Maximize the total amount of water transported, which is the sum of the capacities of the small and large kegs used.
model.setObjective(NumSmallKegsUsed * SmallKegCapacity + NumLargeKegsUsed * LargeKegCapacity, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumSmallKegsUsed'] = NumSmallKegsUsed.x
variables['NumLargeKegsUsed'] = NumLargeKegsUsed.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A tropical city full of islands sends mail either by submarine or by boat. A submarine can carry 100 pieces of mail per trip and uses 30 liters of gas. A boat can carry 80 pieces of mail per trip and uses 25 liters of gas. There can be at most 6 submarine trips and a minimum of 50% of the trips must be by boat. If the city needs to transport at least 1000 pieces of mail, how many of each transportation should they use to minimize the total amount of gas used?",{},"{""parametrized_description"": ""A tropical city sends mail using submarines and boats. Each submarine can carry SubmarineCapacity pieces of mail per trip and consumes SubmarineGasUsage liters of gas per trip. Each boat can carry BoatCapacity pieces of mail per trip and consumes BoatGasUsage liters of gas per trip. The number of submarine trips is limited to MaxSubmarineTrips. At least MinBoatTripPercentage of all trips must be by boat. The city needs to transport at least MailRequired pieces of mail. The objective is to minimize the total gas usage."", ""keywords"": [""N.A.""], ""parameters"": {""SubmarineCapacity"": {""description"": ""Number of pieces of mail a submarine can carry per trip"", ""shape"": []}, ""SubmarineGasUsage"": {""description"": ""Amount of gas a submarine uses per trip in liters"", ""shape"": []}, ""BoatCapacity"": {""description"": ""Number of pieces of mail a boat can carry per trip"", ""shape"": []}, ""BoatGasUsage"": {""description"": ""Amount of gas a boat uses per trip in liters"", ""shape"": []}, ""MaxSubmarineTrips"": {""description"": ""Maximum number of submarine trips allowed"", ""shape"": []}, ""MinBoatTripPercentage"": {""description"": ""Minimum percentage of trips that must be by boat"", ""shape"": []}, ""MailRequired"": {""description"": ""Minimum number of pieces of mail to transport"", ""shape"": []}}, ""variables"": {""SubmarineTrips"": {""description"": ""The number of submarine trips"", ""type"": ""continuous"", ""shape"": []}, ""BoatTrips"": {""description"": ""The number of boat trips"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of submarine trips cannot exceed MaxSubmarineTrips."", ""formulation"": ""SubmarineTrips \\leq MaxSubmarineTrips"", ""code"": {""gurobipy"": ""model.addConstr(SubmarineTrips <= MaxSubmarineTrips)""}}, {""description"": ""At least MinBoatTripPercentage of all trips must be by boat."", ""formulation"": ""BoatTrips \\geq MinBoatTripPercentage \\times (BoatTrips + SubmarineTrips)"", ""code"": {""gurobipy"": ""model.addConstr(BoatTrips >= MinBoatTripPercentage * (BoatTrips + SubmarineTrips))""}}, {""description"": ""The total number of pieces of mail transported must be at least MailRequired."", ""formulation"": ""SubmarineTrips \\times SubmarineCapacity + BoatTrips \\times BoatCapacity \\geq MailRequired"", ""code"": {""gurobipy"": ""model.addConstr(SubmarineTrips * SubmarineCapacity + BoatTrips * BoatCapacity >= MailRequired)""}}], ""objective"": {""description"": ""Minimize the total gas usage, calculated as the sum of gas consumed by all submarine and boat trips."", ""formulation"": ""Min SubmarineGasUsage \\times SubmarineTrips + BoatGasUsage \\times BoatTrips"", ""code"": {""gurobipy"": ""model.setObjective(SubmarineGasUsage * SubmarineTrips + BoatGasUsage * BoatTrips, GRB.MINIMIZE)""}}}","{""SubmarineCapacity"": 100, ""SubmarineGasUsage"": 30, ""BoatCapacity"": 80, ""BoatGasUsage"": 25, ""MaxSubmarineTrips"": 6, ""MinBoatTripPercentage"": 50, ""MailRequired"": 1000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A tropical city sends mail using submarines and boats. Each submarine can carry
SubmarineCapacity pieces of mail per trip and consumes SubmarineGasUsage liters
of gas per trip. Each boat can carry BoatCapacity pieces of mail per trip and
consumes BoatGasUsage liters of gas per trip. The number of submarine trips is
limited to MaxSubmarineTrips. At least MinBoatTripPercentage of all trips must
be by boat. The city needs to transport at least MailRequired pieces of mail.
The objective is to minimize the total gas usage.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/171/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SubmarineCapacity @Def: Number of pieces of mail a submarine can carry per trip @Shape: [] 
SubmarineCapacity = data['SubmarineCapacity']
# @Parameter SubmarineGasUsage @Def: Amount of gas a submarine uses per trip in liters @Shape: [] 
SubmarineGasUsage = data['SubmarineGasUsage']
# @Parameter BoatCapacity @Def: Number of pieces of mail a boat can carry per trip @Shape: [] 
BoatCapacity = data['BoatCapacity']
# @Parameter BoatGasUsage @Def: Amount of gas a boat uses per trip in liters @Shape: [] 
BoatGasUsage = data['BoatGasUsage']
# @Parameter MaxSubmarineTrips @Def: Maximum number of submarine trips allowed @Shape: [] 
MaxSubmarineTrips = data['MaxSubmarineTrips']
# @Parameter MinBoatTripPercentage @Def: Minimum percentage of trips that must be by boat @Shape: [] 
MinBoatTripPercentage = data['MinBoatTripPercentage']
# @Parameter MailRequired @Def: Minimum number of pieces of mail to transport @Shape: [] 
MailRequired = data['MailRequired']

# Variables 
# @Variable SubmarineTrips @Def: The number of submarine trips @Shape: [] 
SubmarineTrips = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxSubmarineTrips, name=""SubmarineTrips"")
# @Variable BoatTrips @Def: The number of boat trips @Shape: [] 
BoatTrips = model.addVar(vtype=GRB.INTEGER, name='BoatTrips')

# Constraints 
# @Constraint Constr_1 @Def: The number of submarine trips cannot exceed MaxSubmarineTrips.
model.addConstr(SubmarineTrips <= MaxSubmarineTrips)
# @Constraint Constr_2 @Def: At least MinBoatTripPercentage of all trips must be by boat.
model.addConstr(BoatTrips >= MinBoatTripPercentage * (BoatTrips + SubmarineTrips))
# @Constraint Constr_3 @Def: The total number of pieces of mail transported must be at least MailRequired.
model.addConstr(SubmarineTrips * SubmarineCapacity + BoatTrips * BoatCapacity >= MailRequired)

# Objective 
# @Objective Objective @Def: Minimize the total gas usage, calculated as the sum of gas consumed by all submarine and boat trips.
model.setObjective(SubmarineGasUsage * SubmarineTrips + BoatGasUsage * BoatTrips, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SubmarineTrips'] = SubmarineTrips.x
variables['BoatTrips'] = BoatTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"The weather is freezing and the fish in the pond need to be transported either by helicopter or car. A helicopter can take 30 fish per trip and takes 40 minutes. A car can take 20 fish per trip and takes 30 minutes. Since helicopter trips are expensive, there can be at most 5 helicopter trips. In addition, at least 60% of the trips should be by car. If at least 300 fish need to transported, how many of each trip should be taken to minimize the total time needed?","{""variables"": {""HelicopterTrips"": 4.0, ""CarTrips"": 9.0}, ""objective"": 430.0}","{""parametrized_description"": ""Determine the number of helicopter trips and car trips to transport at least MinFishToTransport fish. Each helicopter trip carries HelicopterCapacity fish and takes HelicopterTime minutes, and each car trip carries CarCapacity fish and takes CarTime minutes. The number of helicopter trips must not exceed MaxHelicopterTrips, and at least MinPercentageCarTrips of all trips must be by car. The objective is to minimize the total time required for all trips."", ""keywords"": [""N.A.""], ""parameters"": {""HelicopterCapacity"": {""description"": ""Number of fish a helicopter can transport per trip"", ""shape"": []}, ""HelicopterTime"": {""description"": ""Time a helicopter takes per trip in minutes"", ""shape"": []}, ""CarCapacity"": {""description"": ""Number of fish a car can transport per trip"", ""shape"": []}, ""CarTime"": {""description"": ""Time a car takes per trip in minutes"", ""shape"": []}, ""MaxHelicopterTrips"": {""description"": ""Maximum number of helicopter trips allowed"", ""shape"": []}, ""MinPercentageCarTrips"": {""description"": ""Minimum percentage of trips that must be by car"", ""shape"": []}, ""MinFishToTransport"": {""description"": ""Minimum number of fish to transport"", ""shape"": []}}, ""variables"": {""HelicopterTrips"": {""description"": ""Number of helicopter trips"", ""type"": ""continuous"", ""shape"": []}, ""CarTrips"": {""description"": ""Number of car trips"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of fish transported by helicopters and cars must be at least MinFishToTransport."", ""formulation"": ""HelicopterCapacity \\times HelicopterTrips + CarCapacity \\times CarTrips \\geq MinFishToTransport"", ""code"": {""gurobipy"": ""model.addConstr(HelicopterCapacity * HelicopterTrips + CarCapacity * CarTrips >= MinFishToTransport)""}}, {""description"": ""The number of helicopter trips must not exceed MaxHelicopterTrips."", ""formulation"": ""HelicopterTrips \\leq MaxHelicopterTrips"", ""code"": {""gurobipy"": ""model.addConstr(HelicopterTrips <= MaxHelicopterTrips)""}}, {""description"": ""At least MinPercentageCarTrips of all trips must be by car."", ""formulation"": ""CarTrips \\geq MinPercentageCarTrips \\cdot (HelicopterTrips + CarTrips)"", ""code"": {""gurobipy"": ""model.addConstr(CarTrips >= MinPercentageCarTrips * (HelicopterTrips + CarTrips))""}}], ""objective"": {""description"": ""Minimize the total time required for all trips, calculated as the sum of the time taken by helicopter trips and car trips."", ""formulation"": ""Min \\ HelicopterTrips \\times HelicopterTime + CarTrips \\times CarTime"", ""code"": {""gurobipy"": ""model.setObjective(HelicopterTrips * HelicopterTime + CarTrips * CarTime, GRB.MINIMIZE)""}}}","{""HelicopterCapacity"": 30, ""HelicopterTime"": 40, ""CarCapacity"": 20, ""CarTime"": 30, ""MaxHelicopterTrips"": 5, ""MinPercentageCarTrips"": 0.6, ""MinFishToTransport"": 300}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Determine the number of helicopter trips and car trips to transport at least
MinFishToTransport fish. Each helicopter trip carries HelicopterCapacity fish
and takes HelicopterTime minutes, and each car trip carries CarCapacity fish and
takes CarTime minutes. The number of helicopter trips must not exceed
MaxHelicopterTrips, and at least MinPercentageCarTrips of all trips must be by
car. The objective is to minimize the total time required for all trips.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/172/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter HelicopterCapacity @Def: Number of fish a helicopter can transport per trip @Shape: [] 
HelicopterCapacity = data['HelicopterCapacity']
# @Parameter HelicopterTime @Def: Time a helicopter takes per trip in minutes @Shape: [] 
HelicopterTime = data['HelicopterTime']
# @Parameter CarCapacity @Def: Number of fish a car can transport per trip @Shape: [] 
CarCapacity = data['CarCapacity']
# @Parameter CarTime @Def: Time a car takes per trip in minutes @Shape: [] 
CarTime = data['CarTime']
# @Parameter MaxHelicopterTrips @Def: Maximum number of helicopter trips allowed @Shape: [] 
MaxHelicopterTrips = data['MaxHelicopterTrips']
# @Parameter MinPercentageCarTrips @Def: Minimum percentage of trips that must be by car @Shape: [] 
MinPercentageCarTrips = data['MinPercentageCarTrips']
# @Parameter MinFishToTransport @Def: Minimum number of fish to transport @Shape: [] 
MinFishToTransport = data['MinFishToTransport']

# Variables 
# @Variable HelicopterTrips @Def: Number of helicopter trips @Shape: [] 
HelicopterTrips = model.addVar(vtype=GRB.INTEGER, name=""HelicopterTrips"")
# @Variable CarTrips @Def: Number of car trips @Shape: [] 
CarTrips = model.addVar(vtype=GRB.INTEGER, name=""CarTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of fish transported by helicopters and cars must be at least MinFishToTransport.
model.addConstr(HelicopterCapacity * HelicopterTrips + CarCapacity * CarTrips >= MinFishToTransport)
# @Constraint Constr_2 @Def: The number of helicopter trips must not exceed MaxHelicopterTrips.
model.addConstr(HelicopterTrips <= MaxHelicopterTrips)
# @Constraint Constr_3 @Def: At least MinPercentageCarTrips of all trips must be by car.
model.addConstr(CarTrips >= MinPercentageCarTrips * (HelicopterTrips + CarTrips))

# Objective 
# @Objective Objective @Def: Minimize the total time required for all trips, calculated as the sum of the time taken by helicopter trips and car trips.
model.setObjective(HelicopterTrips * HelicopterTime + CarTrips * CarTime, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['HelicopterTrips'] = HelicopterTrips.x
variables['CarTrips'] = CarTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
A tourist spot in the mountains allows visitors to travel to the top either by hot-air balloon or gondola lift. A hot air balloon can carry 4 visitors while a gondola lift can carry 6 visitors. Each hot air balloon produces 10 units of pollution while each gondola lift produces 15 units of pollution. There can be at most 10 hot-air balloon rides and at least 70 visitors need to be transported. How many of each type of transport method should be taken to minimize the total pollution produced?,"{""variables"": {""BalloonRides"": 1.0, ""GondolaLifts"": 11.0}, ""objective"": 175.0}","{""parametrized_description"": ""A tourist spot provides two transportation options: hot-air balloons and gondola lifts. Each hot-air balloon carries VisitorsPerBalloon visitors and generates PollutionPerBalloon pollution units per ride, while each gondola lift carries VisitorsPerGondola visitors and generates PollutionPerGondola pollution units per ride. The number of hot-air balloon rides is limited to MaxBalloonRides, and a minimum of MinVisitors visitors must be transported. The objective is to minimize the total pollution produced."", ""keywords"": [""N.A.""], ""parameters"": {""VisitorsPerBalloon"": {""description"": ""Number of visitors that can be carried by one hot-air balloon"", ""shape"": []}, ""VisitorsPerGondola"": {""description"": ""Number of visitors that can be carried by one gondola lift"", ""shape"": []}, ""PollutionPerBalloon"": {""description"": ""Units of pollution produced by one hot-air balloon ride"", ""shape"": []}, ""PollutionPerGondola"": {""description"": ""Units of pollution produced by one gondola lift ride"", ""shape"": []}, ""MaxBalloonRides"": {""description"": ""Maximum number of hot-air balloon rides allowed"", ""shape"": []}, ""MinVisitors"": {""description"": ""Minimum number of visitors that need to be transported"", ""shape"": []}}, ""variables"": {""BalloonRides"": {""description"": ""The number of hot-air balloon rides"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""GondolaLifts"": {""description"": ""The number of gondola lift rides"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The number of hot-air balloon rides cannot exceed MaxBalloonRides."", ""formulation"": ""BalloonRides \\leq MaxBalloonRides"", ""code"": {""gurobipy"": ""model.addConstr(BalloonRides <= MaxBalloonRides)""}}, {""description"": ""A minimum of MinVisitors visitors must be transported using hot-air balloons and gondola lifts."", ""formulation"": ""VisitorsPerBalloon \\times BalloonRides + VisitorsPerGondola \\times GondolaLifts \\geq MinVisitors"", ""code"": {""gurobipy"": ""model.addConstr(VisitorsPerBalloon * BalloonRides + VisitorsPerGondola * GondolaLifts >= MinVisitors)""}}], ""objective"": {""description"": ""The objective is to minimize the total pollution produced by the transportation options."", ""formulation"": ""Min \\ PollutionPerBalloon \\cdot BalloonRides + PollutionPerGondola \\cdot GondolaLifts"", ""code"": {""gurobipy"": ""model.setObjective(PollutionPerBalloon * BalloonRides + PollutionPerGondola * GondolaLifts, GRB.MINIMIZE)""}}}","{""VisitorsPerBalloon"": 4, ""VisitorsPerGondola"": 6, ""PollutionPerBalloon"": 10, ""PollutionPerGondola"": 15, ""MaxBalloonRides"": 10, ""MinVisitors"": 70}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A tourist spot provides two transportation options: hot-air balloons and gondola
lifts. Each hot-air balloon carries VisitorsPerBalloon visitors and generates
PollutionPerBalloon pollution units per ride, while each gondola lift carries
VisitorsPerGondola visitors and generates PollutionPerGondola pollution units
per ride. The number of hot-air balloon rides is limited to MaxBalloonRides, and
a minimum of MinVisitors visitors must be transported. The objective is to
minimize the total pollution produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/173/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter VisitorsPerBalloon @Def: Number of visitors that can be carried by one hot-air balloon @Shape: [] 
VisitorsPerBalloon = data['VisitorsPerBalloon']
# @Parameter VisitorsPerGondola @Def: Number of visitors that can be carried by one gondola lift @Shape: [] 
VisitorsPerGondola = data['VisitorsPerGondola']
# @Parameter PollutionPerBalloon @Def: Units of pollution produced by one hot-air balloon ride @Shape: [] 
PollutionPerBalloon = data['PollutionPerBalloon']
# @Parameter PollutionPerGondola @Def: Units of pollution produced by one gondola lift ride @Shape: [] 
PollutionPerGondola = data['PollutionPerGondola']
# @Parameter MaxBalloonRides @Def: Maximum number of hot-air balloon rides allowed @Shape: [] 
MaxBalloonRides = data['MaxBalloonRides']
# @Parameter MinVisitors @Def: Minimum number of visitors that need to be transported @Shape: [] 
MinVisitors = data['MinVisitors']

# Variables 
# @Variable BalloonRides @Def: The number of hot-air balloon rides @Shape: ['Integer'] 
BalloonRides = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxBalloonRides, name=""BalloonRides"")
# @Variable GondolaLifts @Def: The number of gondola lift rides @Shape: ['Integer'] 
GondolaLifts = model.addVar(vtype=GRB.INTEGER, name=""GondolaLifts"")

# Constraints 
# @Constraint Constr_1 @Def: The number of hot-air balloon rides cannot exceed MaxBalloonRides.
model.addConstr(BalloonRides <= MaxBalloonRides)
# @Constraint Constr_2 @Def: A minimum of MinVisitors visitors must be transported using hot-air balloons and gondola lifts.
model.addConstr(VisitorsPerBalloon * BalloonRides + VisitorsPerGondola * GondolaLifts >= MinVisitors)

# Objective 
# @Objective Objective @Def: The objective is to minimize the total pollution produced by the transportation options.
model.setObjective(PollutionPerBalloon * BalloonRides + PollutionPerGondola * GondolaLifts, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['BalloonRides'] = BalloonRides.x
variables['GondolaLifts'] = GondolaLifts.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A factory transports rice to the city in horse-drawn carts that are either medium or large size. A medium sized cart requires 2 horses and can carry 30 kg of rice. A large sized cart requires 4 horses and can carry 70 kg of rice.  The factory has 60 horses available. Because the horses don't get along well, the number of medium sized carts must be three times the number of large sized carts. In addition, there must be at least 5 medium sized carts and at least 5 large sized carts. How many of each cart size should be used to maximize the amount of rice that can be transported?","{""variables"": {""NumberMediumCarts"": 18.0, ""NumberLargeCarts"": 6.0}, ""objective"": 960.0}","{""parametrized_description"": ""A factory transports rice using medium and large horse-drawn carts. Each medium sized cart requires HorsesPerMediumCart horses and can carry CapacityMediumCart kilograms of rice. Each large sized cart requires HorsesPerLargeCart horses and can carry CapacityLargeCart kilograms of rice. The factory has TotalHorsesAvailable horses available. The number of medium sized carts must be MediumToLargeCartRatio times the number of large sized carts. Additionally, there must be at least MinMediumCarts medium sized carts and at least MinLargeCarts large sized carts. Determine the number of medium and large sized carts to maximize the total amount of rice transported."", ""keywords"": [""N.A.""], ""parameters"": {""TotalHorsesAvailable"": {""description"": ""Total number of horses available for transportation"", ""shape"": []}, ""HorsesPerMediumCart"": {""description"": ""Number of horses required to operate one medium sized cart"", ""shape"": []}, ""HorsesPerLargeCart"": {""description"": ""Number of horses required to operate one large sized cart"", ""shape"": []}, ""CapacityMediumCart"": {""description"": ""Rice carrying capacity of one medium sized cart in kilograms"", ""shape"": []}, ""CapacityLargeCart"": {""description"": ""Rice carrying capacity of one large sized cart in kilograms"", ""shape"": []}, ""MediumToLargeCartRatio"": {""description"": ""Required ratio of medium sized carts to large sized carts"", ""shape"": []}, ""MinMediumCarts"": {""description"": ""Minimum number of medium sized carts required"", ""shape"": []}, ""MinLargeCarts"": {""description"": ""Minimum number of large sized carts required"", ""shape"": []}}, ""variables"": {""NumberMediumCarts"": {""description"": ""The number of medium sized carts used"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberLargeCarts"": {""description"": ""The number of large sized carts used"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total number of horses used by medium and large sized carts does not exceed TotalHorsesAvailable."", ""formulation"": ""HorsesPerMediumCart \\cdot NumberMediumCarts + HorsesPerLargeCart \\cdot NumberLargeCarts \\leq TotalHorsesAvailable"", ""code"": {""gurobipy"": ""model.addConstr(HorsesPerMediumCart * NumberMediumCarts + HorsesPerLargeCart * NumberLargeCarts <= TotalHorsesAvailable)""}}, {""description"": ""The number of medium sized carts must be MediumToLargeCartRatio times the number of large sized carts."", ""formulation"": ""NumberMediumCarts = MediumToLargeCartRatio \\times NumberLargeCarts"", ""code"": {""gurobipy"": ""model.addConstr(NumberMediumCarts == MediumToLargeCartRatio * NumberLargeCarts)""}}, {""description"": ""There must be at least MinMediumCarts medium sized carts."", ""formulation"": ""NumberMediumCarts \\geq MinMediumCarts"", ""code"": {""gurobipy"": ""model.addConstr(NumberMediumCarts >= MinMediumCarts)""}}, {""description"": ""There must be at least MinLargeCarts large sized carts."", ""formulation"": ""NumberLargeCarts \\geq MinLargeCarts"", ""code"": {""gurobipy"": ""model.addConstr(NumberLargeCarts >= MinLargeCarts)""}}], ""objective"": {""description"": ""Maximize the total amount of rice transported by the medium and large sized carts."", ""formulation"": ""Max NumberMediumCarts \\times CapacityMediumCart + NumberLargeCarts \\times CapacityLargeCart"", ""code"": {""gurobipy"": ""model.setObjective(NumberMediumCarts * CapacityMediumCart + NumberLargeCarts * CapacityLargeCart, GRB.MAXIMIZE)""}}}","{""TotalHorsesAvailable"": 60, ""HorsesPerMediumCart"": 2, ""HorsesPerLargeCart"": 4, ""CapacityMediumCart"": 30, ""CapacityLargeCart"": 70, ""MediumToLargeCartRatio"": 3, ""MinMediumCarts"": 5, ""MinLargeCarts"": 5}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A factory transports rice using medium and large horse-drawn carts. Each medium
sized cart requires HorsesPerMediumCart horses and can carry CapacityMediumCart
kilograms of rice. Each large sized cart requires HorsesPerLargeCart horses and
can carry CapacityLargeCart kilograms of rice. The factory has
TotalHorsesAvailable horses available. The number of medium sized carts must be
MediumToLargeCartRatio times the number of large sized carts. Additionally,
there must be at least MinMediumCarts medium sized carts and at least
MinLargeCarts large sized carts. Determine the number of medium and large sized
carts to maximize the total amount of rice transported.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/174/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalHorsesAvailable @Def: Total number of horses available for transportation @Shape: [] 
TotalHorsesAvailable = data['TotalHorsesAvailable']
# @Parameter HorsesPerMediumCart @Def: Number of horses required to operate one medium sized cart @Shape: [] 
HorsesPerMediumCart = data['HorsesPerMediumCart']
# @Parameter HorsesPerLargeCart @Def: Number of horses required to operate one large sized cart @Shape: [] 
HorsesPerLargeCart = data['HorsesPerLargeCart']
# @Parameter CapacityMediumCart @Def: Rice carrying capacity of one medium sized cart in kilograms @Shape: [] 
CapacityMediumCart = data['CapacityMediumCart']
# @Parameter CapacityLargeCart @Def: Rice carrying capacity of one large sized cart in kilograms @Shape: [] 
CapacityLargeCart = data['CapacityLargeCart']
# @Parameter MediumToLargeCartRatio @Def: Required ratio of medium sized carts to large sized carts @Shape: [] 
MediumToLargeCartRatio = data['MediumToLargeCartRatio']
# @Parameter MinMediumCarts @Def: Minimum number of medium sized carts required @Shape: [] 
MinMediumCarts = data['MinMediumCarts']
# @Parameter MinLargeCarts @Def: Minimum number of large sized carts required @Shape: [] 
MinLargeCarts = data['MinLargeCarts']

# Variables 
# @Variable NumberMediumCarts @Def: The number of medium sized carts used @Shape: ['Integer'] 
NumberMediumCarts = model.addVar(vtype=GRB.INTEGER, name=""NumberMediumCarts"")
# @Variable NumberLargeCarts @Def: The number of large sized carts used @Shape: ['Integer'] 
NumberLargeCarts = model.addVar(vtype=GRB.INTEGER, lb=MinLargeCarts, name=""NumberLargeCarts"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of horses used by medium and large sized carts does not exceed TotalHorsesAvailable.
model.addConstr(HorsesPerMediumCart * NumberMediumCarts + HorsesPerLargeCart * NumberLargeCarts <= TotalHorsesAvailable)
# @Constraint Constr_2 @Def: The number of medium sized carts must be MediumToLargeCartRatio times the number of large sized carts.
model.addConstr(NumberMediumCarts == MediumToLargeCartRatio * NumberLargeCarts)
# @Constraint Constr_3 @Def: There must be at least MinMediumCarts medium sized carts.
model.addConstr(NumberMediumCarts >= MinMediumCarts)
# @Constraint Constr_4 @Def: There must be at least MinLargeCarts large sized carts.
model.addConstr(NumberLargeCarts >= MinLargeCarts)

# Objective 
# @Objective Objective @Def: Maximize the total amount of rice transported by the medium and large sized carts.
model.setObjective(NumberMediumCarts * CapacityMediumCart + NumberLargeCarts * CapacityLargeCart, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberMediumCarts'] = NumberMediumCarts.x
variables['NumberLargeCarts'] = NumberLargeCarts.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A dog school trains labradors and golden retrievers to deliver newspaper. A labrador can deliver 7 newspapers at a time and requires 5 small bone treats for service. A golden retriever can deliver 10 newspapers at a time and requires 6 small bone treats per service. The school only has 1500 small bone treats available. In addition, at least 50 golden retrievers must be used and at most 60% of the dogs can be labradors. How many of each dog should be used to maximize the number of newspapers that can be delivered?","{""variables"": {""ServicesDelivered"": {""0"": -0.0, ""1"": 250.0}, ""NumGoldenRetrievers"": 50.0, ""NumLabradors"": -0.0}, ""objective"": 2500.0}","{""parametrized_description"": ""A dog school trains NumDogTypes different dog types to deliver newspapers. Each dog type delivers NewspapersPerService newspapers per service and requires TreatsPerService small bone treats per service. The total number of small bone treats available is TotalBoneTreatsAvailable. At least MinGoldenRetrievers golden retrievers must be used, and at most MaxPercentageLabradors of the dogs can be labradors. The goal is to maximize the number of newspapers delivered."", ""keywords"": [""N.A.""], ""parameters"": {""NumDogTypes"": {""description"": ""Number of different dog types used in the school"", ""shape"": []}, ""NewspapersPerService"": {""description"": ""Number of newspapers delivered per service by each dog type"", ""shape"": [""NumDogTypes""]}, ""TreatsPerService"": {""description"": ""Number of small bone treats required per service by each dog type"", ""shape"": [""NumDogTypes""]}, ""TotalBoneTreatsAvailable"": {""description"": ""Total number of small bone treats available"", ""shape"": []}, ""MinGoldenRetrievers"": {""description"": ""Minimum number of golden retrievers to be used"", ""shape"": []}, ""MaxPercentageLabradors"": {""description"": ""Maximum percentage of dogs that can be labradors"", ""shape"": []}}, ""variables"": {""ServicesDelivered"": {""description"": ""The number of services delivered by each dog type"", ""type"": ""continuous"", ""shape"": [""NumDogTypes""]}, ""NumGoldenRetrievers"": {""description"": ""The number of golden retrievers used"", ""type"": ""continuous"", ""shape"": []}, ""NumLabradors"": {""description"": ""The number of Labradors used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of small bone treats required by all dog types cannot exceed TotalBoneTreatsAvailable."", ""formulation"": ""\\sum_{d=1}^{NumDogTypes} \\text{TreatsPerService}_{d} \\cdot \\text{ServicesDelivered}_{d} \\leq \\text{TotalBoneTreatsAvailable}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(TreatsPerService[d] * ServicesDelivered[d] for d in range(NumDogTypes)) <= TotalBoneTreatsAvailable)""}}, {""description"": ""At least MinGoldenRetrievers golden retrievers must be used."", ""formulation"": ""NumGoldenRetrievers \\geq MinGoldenRetrievers"", ""code"": {""gurobipy"": ""model.addConstr(NumGoldenRetrievers >= MinGoldenRetrievers)""}}, {""description"": ""No more than MaxPercentageLabradors of the total number of dogs can be labradors."", ""formulation"": ""NumLabradors \\leq MaxPercentageLabradors \\times (NumGoldenRetrievers + NumLabradors)"", ""code"": {""gurobipy"": ""model.addConstr(NumLabradors <= MaxPercentageLabradors * (NumGoldenRetrievers + NumLabradors))""}}], ""objective"": {""description"": ""Maximize the total number of newspapers delivered by the dog school while adhering to constraints on treat availability, minimum golden retrievers, and the proportion of labradors."", ""formulation"": ""Max \\sum_{i=1}^{NumDogTypes} ServicesDelivered_{i} \\times NewspapersPerService_{i}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ServicesDelivered[i] * NewspapersPerService[i] for i in range(NumDogTypes)), GRB.MAXIMIZE)""}}}","{""NumDogTypes"": 2, ""NewspapersPerService"": [7, 10], ""TreatsPerService"": [5, 6], ""TotalBoneTreatsAvailable"": 1500, ""MinGoldenRetrievers"": 50, ""MaxPercentageLabradors"": 60}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A dog school trains NumDogTypes different dog types to deliver newspapers. Each
dog type delivers NewspapersPerService newspapers per service and requires
TreatsPerService small bone treats per service. The total number of small bone
treats available is TotalBoneTreatsAvailable. At least MinGoldenRetrievers
golden retrievers must be used, and at most MaxPercentageLabradors of the dogs
can be labradors. The goal is to maximize the number of newspapers delivered.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/175/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumDogTypes @Def: Number of different dog types used in the school @Shape: [] 
NumDogTypes = data['NumDogTypes']
# @Parameter NewspapersPerService @Def: Number of newspapers delivered per service by each dog type @Shape: ['NumDogTypes'] 
NewspapersPerService = data['NewspapersPerService']
# @Parameter TreatsPerService @Def: Number of small bone treats required per service by each dog type @Shape: ['NumDogTypes'] 
TreatsPerService = data['TreatsPerService']
# @Parameter TotalBoneTreatsAvailable @Def: Total number of small bone treats available @Shape: [] 
TotalBoneTreatsAvailable = data['TotalBoneTreatsAvailable']
# @Parameter MinGoldenRetrievers @Def: Minimum number of golden retrievers to be used @Shape: [] 
MinGoldenRetrievers = data['MinGoldenRetrievers']
# @Parameter MaxPercentageLabradors @Def: Maximum percentage of dogs that can be labradors @Shape: [] 
MaxPercentageLabradors = data['MaxPercentageLabradors']

# Variables 
# @Variable ServicesDelivered @Def: The number of services delivered by each dog type @Shape: ['NumDogTypes'] 
ServicesDelivered = model.addVars(NumDogTypes, vtype=GRB.INTEGER, name=""ServicesDelivered"")
# @Variable NumGoldenRetrievers @Def: The number of golden retrievers used @Shape: [] 
NumGoldenRetrievers = model.addVar(vtype=GRB.INTEGER, name=""NumGoldenRetrievers"")
# @Variable NumLabradors @Def: The number of Labradors used @Shape: [] 
NumLabradors = model.addVar(vtype=GRB.INTEGER, name=""NumLabradors"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of small bone treats required by all dog types cannot exceed TotalBoneTreatsAvailable.
model.addConstr(quicksum(TreatsPerService[d] * ServicesDelivered[d] for d in range(NumDogTypes)) <= TotalBoneTreatsAvailable)
# @Constraint Constr_2 @Def: At least MinGoldenRetrievers golden retrievers must be used.
model.addConstr(NumGoldenRetrievers >= MinGoldenRetrievers)
# @Constraint Constr_3 @Def: No more than MaxPercentageLabradors of the total number of dogs can be labradors.
model.addConstr(NumLabradors <= MaxPercentageLabradors * (NumGoldenRetrievers + NumLabradors))

# Objective 
# @Objective Objective @Def: Maximize the total number of newspapers delivered by the dog school while adhering to constraints on treat availability, minimum golden retrievers, and the proportion of labradors.
model.setObjective(quicksum(ServicesDelivered[i] * NewspapersPerService[i] for i in range(NumDogTypes)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ServicesDelivered'] = {d: ServicesDelivered[d].x for d in range(NumDogTypes)}
variables['NumGoldenRetrievers'] = NumGoldenRetrievers.x
variables['NumLabradors'] = NumLabradors.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A construction company in the tropics uses cows and elephants to carry bricks. A cow can carry 20 bricks on its back while an elephant can carry 50 bricks on its back. To avoid having elephants create too much traffic, the number of elephant cannot exceed the number of cows. In addition, there can be at most twice the number of cows as elephants. If the company needs to transport at least 1000 bricks, find the minimum number of animals, cows and elephants, that can be used..","{""variables"": {""NumberOfCows"": 15.0, ""NumberOfElephants"": 14.0}, ""objective"": 29.0}","{""parametrized_description"": ""A construction company uses cows and elephants to carry bricks. Each cow can carry BrickCapacityCow bricks and each elephant can carry BrickCapacityElephant bricks. The number of elephants cannot exceed MaxElephantsToCowsRatio times the number of cows, and the number of cows cannot exceed MaxCowsToElephantsRatio times the number of elephants. The company needs to transport at least RequiredBricks bricks. Determine the minimum number of animals, cows, and elephants required."", ""keywords"": [""N.A.""], ""parameters"": {""BrickCapacityCow"": {""description"": ""Number of bricks a cow can carry on its back"", ""shape"": []}, ""BrickCapacityElephant"": {""description"": ""Number of bricks an elephant can carry on its back"", ""shape"": []}, ""MaxElephantsToCowsRatio"": {""description"": ""Maximum ratio of elephants to cows"", ""shape"": []}, ""MaxCowsToElephantsRatio"": {""description"": ""Maximum ratio of cows to elephants"", ""shape"": []}, ""RequiredBricks"": {""description"": ""Minimum number of bricks to transport"", ""shape"": []}}, ""variables"": {""NumberOfCows"": {""description"": ""The number of cows"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfElephants"": {""description"": ""The number of elephants"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""Each cow can carry BrickCapacityCow bricks and each elephant can carry BrickCapacityElephant bricks. The total number of bricks transported must be at least RequiredBricks."", ""formulation"": ""BrickCapacityCow \\cdot NumberOfCows + BrickCapacityElephant \\cdot NumberOfElephants \\geq RequiredBricks"", ""code"": {""gurobipy"": ""model.addConstr(BrickCapacityCow * NumberOfCows + BrickCapacityElephant * NumberOfElephants >= RequiredBricks)""}}, {""description"": ""The number of elephants cannot exceed MaxElephantsToCowsRatio times the number of cows."", ""formulation"": ""NumberOfElephants \\leq MaxElephantsToCowsRatio \\times NumberOfCows"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfElephants <= MaxElephantsToCowsRatio * NumberOfCows)""}}, {""description"": ""The number of cows cannot exceed MaxCowsToElephantsRatio times the number of elephants."", ""formulation"": ""NumberOfCows \\leq MaxCowsToElephantsRatio \\times NumberOfElephants"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfCows <= MaxCowsToElephantsRatio * NumberOfElephants)""}}], ""objective"": {""description"": ""Minimize the total number of animals (cows and elephants) required to transport at least RequiredBricks bricks while adhering to the specified ratio constraints between cows and elephants."", ""formulation"": ""\\min \\left( NumberOfCows + NumberOfElephants \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfCows + NumberOfElephants, GRB.MINIMIZE)""}}}","{""BrickCapacityCow"": 20, ""BrickCapacityElephant"": 50, ""MaxElephantsToCowsRatio"": 1, ""MaxCowsToElephantsRatio"": 2, ""RequiredBricks"": 1000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A construction company uses cows and elephants to carry bricks. Each cow can
carry BrickCapacityCow bricks and each elephant can carry BrickCapacityElephant
bricks. The number of elephants cannot exceed MaxElephantsToCowsRatio times the
number of cows, and the number of cows cannot exceed MaxCowsToElephantsRatio
times the number of elephants. The company needs to transport at least
RequiredBricks bricks. Determine the minimum number of animals, cows, and
elephants required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/176/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter BrickCapacityCow @Def: Number of bricks a cow can carry on its back @Shape: [] 
BrickCapacityCow = data['BrickCapacityCow']
# @Parameter BrickCapacityElephant @Def: Number of bricks an elephant can carry on its back @Shape: [] 
BrickCapacityElephant = data['BrickCapacityElephant']
# @Parameter MaxElephantsToCowsRatio @Def: Maximum ratio of elephants to cows @Shape: [] 
MaxElephantsToCowsRatio = data['MaxElephantsToCowsRatio']
# @Parameter MaxCowsToElephantsRatio @Def: Maximum ratio of cows to elephants @Shape: [] 
MaxCowsToElephantsRatio = data['MaxCowsToElephantsRatio']
# @Parameter RequiredBricks @Def: Minimum number of bricks to transport @Shape: [] 
RequiredBricks = data['RequiredBricks']

# Variables 
# @Variable NumberOfCows @Def: The number of cows @Shape: [] 
NumberOfCows = model.addVar(vtype=GRB.INTEGER, name=""NumberOfCows"")
# @Variable NumberOfElephants @Def: The number of elephants @Shape: [] 
NumberOfElephants = model.addVar(vtype=GRB.INTEGER, name=""NumberOfElephants"")

# Constraints 
# @Constraint Constr_1 @Def: Each cow can carry BrickCapacityCow bricks and each elephant can carry BrickCapacityElephant bricks. The total number of bricks transported must be at least RequiredBricks.
model.addConstr(BrickCapacityCow * NumberOfCows + BrickCapacityElephant * NumberOfElephants >= RequiredBricks)
# @Constraint Constr_2 @Def: The number of elephants cannot exceed MaxElephantsToCowsRatio times the number of cows.
model.addConstr(NumberOfElephants <= MaxElephantsToCowsRatio * NumberOfCows)
# @Constraint Constr_3 @Def: The number of cows cannot exceed MaxCowsToElephantsRatio times the number of elephants.
model.addConstr(NumberOfCows <= MaxCowsToElephantsRatio * NumberOfElephants)

# Objective 
# @Objective Objective @Def: Minimize the total number of animals (cows and elephants) required to transport at least RequiredBricks bricks while adhering to the specified ratio constraints between cows and elephants.
model.setObjective(NumberOfCows + NumberOfElephants, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfCows'] = NumberOfCows.x
variables['NumberOfElephants'] = NumberOfElephants.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A farmer on an island sends corn to the main land either by ferry or light rail. Each ferry trip can take 20 boxes of corn while each light rail trip can take 15 boxes of corn. Since ferry trips are slow, the number of light rail trip has to be at least 4 times the number of ferry trips. If the farmer wants to send at least 500 boxes of corn, minimize the total number of trips of either type needed.","{""variables"": {""FerryTrips"": 6.0, ""LightRailTrips"": 26.0}, ""objective"": 32.0}","{""parametrized_description"": ""A farmer sends boxes of corn via ferry and light rail. Each ferry trip transports FerryTripCapacity boxes, and each light rail trip transports LightRailTripCapacity boxes. The number of light rail trips must be at least MinLightRailMultiplier times the number of ferry trips. The farmer aims to send at least MinBoxesToSend boxes of corn. The objective is to minimize the total number of ferry and light rail trips."", ""keywords"": [""N.A.""], ""parameters"": {""FerryTripCapacity"": {""description"": ""Number of boxes of corn that can be sent per ferry trip"", ""shape"": []}, ""LightRailTripCapacity"": {""description"": ""Number of boxes of corn that can be sent per light rail trip"", ""shape"": []}, ""MinLightRailMultiplier"": {""description"": ""Minimum multiple that the number of light rail trips must be compared to ferry trips"", ""shape"": []}, ""MinBoxesToSend"": {""description"": ""Minimum number of boxes of corn that the farmer wants to send"", ""shape"": []}}, ""variables"": {""FerryTrips"": {""description"": ""The number of ferry trips"", ""type"": ""continuous"", ""shape"": []}, ""LightRailTrips"": {""description"": ""The number of light rail trips"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of light rail trips must be at least MinLightRailMultiplier times the number of ferry trips."", ""formulation"": ""LightRailTrips \\geq MinLightRailMultiplier \\times FerryTrips"", ""code"": {""gurobipy"": ""model.addConstr(LightRailTrips >= MinLightRailMultiplier * FerryTrips)""}}, {""description"": ""FerryTripCapacity multiplied by the number of ferry trips plus LightRailTripCapacity multiplied by the number of light rail trips must be at least MinBoxesToSend."", ""formulation"": ""FerryTripCapacity \\cdot FerryTrips + LightRailTripCapacity \\cdot LightRailTrips \\geq MinBoxesToSend"", ""code"": {""gurobipy"": ""model.addConstr(FerryTripCapacity * FerryTrips + LightRailTripCapacity * LightRailTrips >= MinBoxesToSend)""}}], ""objective"": {""description"": ""Minimize the total number of ferry and light rail trips."", ""formulation"": ""Min FerryTrips + LightRailTrips"", ""code"": {""gurobipy"": ""model.setObjective(quicksum([FerryTrips, LightRailTrips]), GRB.MINIMIZE)""}}}","{""FerryTripCapacity"": 20, ""LightRailTripCapacity"": 15, ""MinLightRailMultiplier"": 4, ""MinBoxesToSend"": 500}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A farmer sends boxes of corn via ferry and light rail. Each ferry trip
transports FerryTripCapacity boxes, and each light rail trip transports
LightRailTripCapacity boxes. The number of light rail trips must be at least
MinLightRailMultiplier times the number of ferry trips. The farmer aims to send
at least MinBoxesToSend boxes of corn. The objective is to minimize the total
number of ferry and light rail trips.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/177/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter FerryTripCapacity @Def: Number of boxes of corn that can be sent per ferry trip @Shape: [] 
FerryTripCapacity = data['FerryTripCapacity']
# @Parameter LightRailTripCapacity @Def: Number of boxes of corn that can be sent per light rail trip @Shape: [] 
LightRailTripCapacity = data['LightRailTripCapacity']
# @Parameter MinLightRailMultiplier @Def: Minimum multiple that the number of light rail trips must be compared to ferry trips @Shape: [] 
MinLightRailMultiplier = data['MinLightRailMultiplier']
# @Parameter MinBoxesToSend @Def: Minimum number of boxes of corn that the farmer wants to send @Shape: [] 
MinBoxesToSend = data['MinBoxesToSend']

# Variables 
# @Variable FerryTrips @Def: The number of ferry trips @Shape: [] 
FerryTrips = model.addVar(vtype=GRB.INTEGER, name=""FerryTrips"")
# @Variable LightRailTrips @Def: The number of light rail trips @Shape: [] 
LightRailTrips = model.addVar(vtype=GRB.INTEGER, name=""LightRailTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The number of light rail trips must be at least MinLightRailMultiplier times the number of ferry trips.
model.addConstr(LightRailTrips >= MinLightRailMultiplier * FerryTrips)
# @Constraint Constr_2 @Def: FerryTripCapacity multiplied by the number of ferry trips plus LightRailTripCapacity multiplied by the number of light rail trips must be at least MinBoxesToSend.
model.addConstr(FerryTripCapacity * FerryTrips + LightRailTripCapacity * LightRailTrips >= MinBoxesToSend)

# Objective 
# @Objective Objective @Def: Minimize the total number of ferry and light rail trips.
model.setObjective(quicksum([FerryTrips, LightRailTrips]), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['FerryTrips'] = FerryTrips.x
variables['LightRailTrips'] = LightRailTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A factory provides rides for its employees in either taxis or company cars. Each taxi ride can take 2 employees while each company car ride can take 3 employees. Since buying and maintaining cars is expensive, at most 60% of the rides can be company car rides. However, there has to be at least 30 company car rides. If the company needs to transport at least 500 employees, how many rides of each should be done to minimize the total number of taxi rides.","{""variables"": {""NumberOfTaxiRides"": 0.0, ""NumberOfCompanyCarRides"": 2000000000.0}, ""objective"": 0.0}","{""parametrized_description"": ""A factory provides rides for its employees using either taxis or company cars. Each taxi ride can transport EmployeesPerTaxiRide employees, and each company car ride can transport EmployeesPerCompanyCarRide employees. At most MaxCompanyCarRidePercentage of the total rides can be company car rides, and there must be at least MinCompanyCarRides company car rides. The company needs to transport at least MinEmployees employees. Determine the number of taxi and company car rides to minimize the total number of taxi rides."", ""keywords"": [""N.A.""], ""parameters"": {""EmployeesPerTaxiRide"": {""description"": ""Number of employees that can be transported in one taxi ride."", ""shape"": []}, ""EmployeesPerCompanyCarRide"": {""description"": ""Number of employees that can be transported in one company car ride."", ""shape"": []}, ""MaxCompanyCarRidePercentage"": {""description"": ""The upper limit on the proportion of total rides that can be company car rides."", ""shape"": []}, ""MinCompanyCarRides"": {""description"": ""The minimum required number of company car rides."", ""shape"": []}, ""MinEmployees"": {""description"": ""The minimum number of employees that need to be transported."", ""shape"": []}}, ""variables"": {""NumberOfTaxiRides"": {""description"": ""The number of taxi rides"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfCompanyCarRides"": {""description"": ""The number of company car rides"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of employees transported by taxi and company car rides must be at least MinEmployees."", ""formulation"": ""EmployeesPerTaxiRide \\times NumberOfTaxiRides + EmployeesPerCompanyCarRides \\times NumberOfCompanyCarRides \\geq MinEmployees"", ""code"": {""gurobipy"": ""model.addConstr(EmployeesPerTaxiRide * NumberOfTaxiRides + EmployeesPerCompanyCarRides * NumberOfCompanyCarRides >= MinEmployees)""}}, {""description"": ""The number of company car rides must not exceed MaxCompanyCarRidePercentage of the total number of rides."", ""formulation"": ""(1 - MaxCompanyCarRidePercentage) \\times NumberOfCompanyCarRides \\leq MaxCompanyCarRidePercentage \\times NumberOfTaxiRides"", ""code"": {""gurobipy"": ""model.addConstr((1 - MaxCompanyCarRidePercentage) * NumberOfCompanyCarRides <= MaxCompanyCarRidePercentage * NumberOfTaxiRides)""}}, {""description"": ""There must be at least MinCompanyCarRides company car rides."", ""formulation"": ""NumberOfCompanyCarRides \\geq MinCompanyCarRides"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfCompanyCarRides >= MinCompanyCarRides)""}}], ""objective"": {""description"": ""Minimize the total number of taxi rides."", ""formulation"": ""Min \\ NumberOfTaxiRides"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfTaxiRides, GRB.MINIMIZE)""}}}","{""EmployeesPerTaxiRide"": 2, ""EmployeesPerCompanyCarRide"": 3, ""MaxCompanyCarRidePercentage"": 60, ""MinCompanyCarRides"": 30, ""MinEmployees"": 500}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A factory provides rides for its employees using either taxis or company cars.
Each taxi ride can transport EmployeesPerTaxiRide employees, and each company
car ride can transport EmployeesPerCompanyCarRide employees. At most
MaxCompanyCarRidePercentage of the total rides can be company car rides, and
there must be at least MinCompanyCarRides company car rides. The company needs
 to transport at least MinEmployees employees. Determine the number of taxi and
company car rides to minimize the total number of taxi rides.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/178/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter EmployeesPerTaxiRide @Def: Number of employees that can be transported in one taxi ride. @Shape: [] 
EmployeesPerTaxiRide = data['EmployeesPerTaxiRide']
# @Parameter EmployeesPerCompanyCarRide @Def: Number of employees that can be transported in one company car ride. @Shape: [] 
EmployeesPerCompanyCarRide = data['EmployeesPerCompanyCarRide']
# @Parameter MaxCompanyCarRidePercentage @Def: The upper limit on the proportion of total rides that can be company car rides. @Shape: [] 
MaxCompanyCarRidePercentage = data['MaxCompanyCarRidePercentage']
# @Parameter MinCompanyCarRides @Def: The minimum required number of company car rides. @Shape: [] 
MinCompanyCarRides = data['MinCompanyCarRides']
# @Parameter MinEmployees @Def: The minimum number of employees that need to be transported. @Shape: [] 
MinEmployees = data['MinEmployees']

# Variables 
# @Variable NumberOfTaxiRides @Def: The number of taxi rides @Shape: [] 
NumberOfTaxiRides = model.addVar(vtype=GRB.INTEGER, name=""NumberOfTaxiRides"")
# @Variable NumberOfCompanyCarRides @Def: The number of company car rides @Shape: [] 
NumberOfCompanyCarRides = model.addVar(vtype=GRB.INTEGER, name=""NumberOfCompanyCarRides"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of employees transported by taxi and company car rides must be at least MinEmployees.
model.addConstr(EmployeesPerTaxiRide * NumberOfTaxiRides + EmployeesPerCompanyCarRide * NumberOfCompanyCarRides >= MinEmployees)
# @Constraint Constr_2 @Def: The number of company car rides must not exceed MaxCompanyCarRidePercentage of the total number of rides.
model.addConstr((1 - MaxCompanyCarRidePercentage) * NumberOfCompanyCarRides <= MaxCompanyCarRidePercentage * NumberOfTaxiRides)
# @Constraint Constr_3 @Def: There must be at least MinCompanyCarRides company car rides.
model.addConstr(NumberOfCompanyCarRides >= MinCompanyCarRides)

# Objective 
# @Objective Objective @Def: Minimize the total number of taxi rides.
model.setObjective(NumberOfTaxiRides, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfTaxiRides'] = NumberOfTaxiRides.x
variables['NumberOfCompanyCarRides'] = NumberOfCompanyCarRides.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A chemical company is transporting their hydrogen using two different methods, high pressure tube trailers and liquefied hydrogen tankers. The first method is a high-pressure tube trailer which can transport 50 cubic meters each per trip at a cost of $500. The second method is using liquefied hydrogen tankers which can transport 30 cubic meters each per trip at a cost of $200. The company needs to transport at least 1000 cubic meters of hydrogen and they have budget of $3750 available. In addition, the number of transports done by the high pressure tube trailer method has to be less than the number of transports done by the liquefied hydrogen tanker method. How many of each transportation method should they use to minimize the total number of trips?",{},"{""parametrized_description"": ""A chemical company is transporting their hydrogen using NumTransportMethods different transportation methods. Each method has a transport capacity per trip given by TransportCapacity and a cost per trip given by TransportCost. The company needs to transport at least MinimumHydrogen amount of hydrogen and has a budget of Budget available. Additionally, the number of transports done by the first transportation method must be less than the number of transports done by the second transportation method. The company aims to determine the number of each transportation method to minimize the total number of trips."", ""keywords"": [""N.A.""], ""parameters"": {""TransportCapacity"": {""description"": ""Transport capacity per trip for each transportation method"", ""shape"": [""NumTransportMethods""]}, ""TransportCost"": {""description"": ""Transport cost per trip for each transportation method"", ""shape"": [""NumTransportMethods""]}, ""MinimumHydrogen"": {""description"": ""Minimum total hydrogen to transport"", ""shape"": []}, ""Budget"": {""description"": ""Available budget for transportation"", ""shape"": []}, ""NumTransportMethods"": {""description"": ""Number of transportation methods"", ""shape"": []}}, ""variables"": {""NumTrips"": {""description"": ""The number of trips for each transportation method"", ""type"": ""continuous"", ""shape"": [""NumTransportMethods""]}}, ""constraints"": [{""description"": ""The total amount of hydrogen transported must be at least MinimumHydrogen."", ""formulation"": ""\\sum_{i=1}^{\\text{NumTransportMethods}} TransportCapacity_{i} \\times NumTrips_{i} \\geq MinimumHydrogen"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(TransportCapacity[i] * NumTrips[i] for i in range(NumTransportMethods)) >= MinimumHydrogen)""}}, {""description"": ""The total transportation cost must not exceed Budget."", ""formulation"": ""\\sum_{i=1}^{\\text{NumTransportMethods}} \\text{TransportCost}_i \\times \\text{NumTrips}_i \\leq \\text{Budget}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(TransportCost[i] * NumTrips[i] for i in range(NumTransportMethods)) <= Budget)""}}, {""description"": ""The number of transports done by the first transportation method must be less than the number of transports done by the second transportation method."", ""formulation"": ""NumTrips_{0} \\leq NumTrips_{1} - 1"", ""code"": {""gurobipy"": ""model.addConstr(NumTrips[0] <= NumTrips[1] - 1)""}}], ""objective"": {""description"": ""The total number of trips is the sum of the number of transports for each transportation method. The objective is to minimize the total number of trips."", ""formulation"": ""Min \\sum_{i=1}^{NumTransportMethods} NumTrips_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(NumTrips[i] for i in range(NumTransportMethods)), GRB.MINIMIZE)""}}}","{""TransportCapacity"": [50, 30], ""TransportCost"": [500, 200], ""MinimumHydrogen"": 1000, ""Budget"": 3750, ""NumTransportMethods"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A chemical company is transporting their hydrogen using NumTransportMethods
different transportation methods. Each method has a transport capacity per trip
given by TransportCapacity and a cost per trip given by TransportCost. The
company needs to transport at least MinimumHydrogen amount of hydrogen and has a
budget of Budget available. Additionally, the number of transports done by the
first transportation method must be less than the number of transports done by
the second transportation method. The company aims to determine the number of
each transportation method to minimize the total number of trips.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/179/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TransportCapacity @Def: Transport capacity per trip for each transportation method @Shape: ['NumTransportMethods'] 
TransportCapacity = data['TransportCapacity']
# @Parameter TransportCost @Def: Transport cost per trip for each transportation method @Shape: ['NumTransportMethods'] 
TransportCost = data['TransportCost']
# @Parameter MinimumHydrogen @Def: Minimum total hydrogen to transport @Shape: [] 
MinimumHydrogen = data['MinimumHydrogen']
# @Parameter Budget @Def: Available budget for transportation @Shape: [] 
Budget = data['Budget']
# @Parameter NumTransportMethods @Def: Number of transportation methods @Shape: [] 
NumTransportMethods = data['NumTransportMethods']

# Variables 
# @Variable NumTrips @Def: The number of trips for each transportation method @Shape: ['NumTransportMethods'] 
NumTrips = model.addVars(NumTransportMethods, vtype=GRB.INTEGER, name=""NumTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of hydrogen transported must be at least MinimumHydrogen.
model.addConstr(quicksum(TransportCapacity[i] * NumTrips[i] for i in range(NumTransportMethods)) >= MinimumHydrogen)
# @Constraint Constr_2 @Def: The total transportation cost must not exceed Budget.
model.addConstr(quicksum(TransportCost[i] * NumTrips[i] for i in range(NumTransportMethods)) <= Budget)
# @Constraint Constr_3 @Def: The number of transports done by the first transportation method must be less than the number of transports done by the second transportation method.
model.addConstr(NumTrips[0] <= NumTrips[1] - 1)

# Objective 
# @Objective Objective @Def: The total number of trips is the sum of the number of transports for each transportation method. The objective is to minimize the total number of trips.
model.setObjective(quicksum(NumTrips[i] for i in range(NumTransportMethods)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumTrips'] = model.getAttr(""X"", NumTrips)
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A grape farmer transports his grapes in either small crates or large crates. A small crate can take 200 grapes while a large crate can take 500.  Because his customers prefer smaller crates, at least 3 times as many small crates must be used than large crates. The farmer has available at most 100 small crates and at most 50 large crates. In addition, his truck can take at most 60 crates total and he must use at least 10 large crates. How many of each crate should he use to maximize the total number of grapes he can transport?","{""variables"": {""NumSmallCrates"": 45.0, ""NumLargeCrates"": 15.0}, ""objective"": 16500.0}","{""parametrized_description"": ""A grape farmer uses small and large crates to transport grapes. Each small crate holds SmallCrateCapacity grapes, and each large crate holds LargeCrateCapacity grapes. The number of small crates used must be at least MinimumSmallToLargeRatio times the number of large crates. The farmer can use up to MaxSmallCrates small crates and up to MaxLargeCrates large crates. Additionally, the truck can carry up to MaxTotalCrates crates in total, and at least MinLargeCrates large crates must be used. The objective is to determine the number of small and large crates to maximize the total number of grapes transported."", ""keywords"": [""N.A.""], ""parameters"": {""SmallCrateCapacity"": {""description"": ""Number of grapes a small crate can hold"", ""shape"": []}, ""LargeCrateCapacity"": {""description"": ""Number of grapes a large crate can hold"", ""shape"": []}, ""MinimumSmallToLargeRatio"": {""description"": ""Minimum ratio of small crates to large crates"", ""shape"": []}, ""MaxSmallCrates"": {""description"": ""Maximum number of small crates available"", ""shape"": []}, ""MaxLargeCrates"": {""description"": ""Maximum number of large crates available"", ""shape"": []}, ""MaxTotalCrates"": {""description"": ""Maximum number of crates the truck can carry"", ""shape"": []}, ""MinLargeCrates"": {""description"": ""Minimum number of large crates to be used"", ""shape"": []}}, ""variables"": {""NumSmallCrates"": {""description"": ""The number of small crates used"", ""type"": ""continuous"", ""shape"": []}, ""NumLargeCrates"": {""description"": ""The number of large crates used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of small crates used must be at least MinimumSmallToLargeRatio times the number of large crates."", ""formulation"": ""NumSmallCrates \\geq MinimumSmallToLargeRatio \\times NumLargeCrates"", ""code"": {""gurobipy"": ""model.addConstr(NumSmallCrates >= MinimumSmallToLargeRatio * NumLargeCrates)""}}, {""description"": ""The number of small crates used cannot exceed MaxSmallCrates."", ""formulation"": ""NumSmallCrates \\leq MaxSmallCrates"", ""code"": {""gurobipy"": ""model.addConstr(NumSmallCrates <= MaxSmallCrates)""}}, {""description"": ""The number of large crates used cannot exceed MaxLargeCrates."", ""formulation"": ""NumLargeCrates \\leq MaxLargeCrates"", ""code"": {""gurobipy"": ""model.addConstr(NumLargeCrates <= MaxLargeCrates)""}}, {""description"": ""The total number of crates used cannot exceed MaxTotalCrates."", ""formulation"": ""NumSmallCrates + NumLargeCrates \\leq MaxTotalCrates"", ""code"": {""gurobipy"": ""model.addConstr(NumSmallCrates + NumLargeCrates <= MaxTotalCrates)""}}, {""description"": ""At least MinLargeCrates large crates must be used."", ""formulation"": ""NumLargeCrates \\geq MinLargeCrates"", ""code"": {""gurobipy"": ""model.addConstr(NumLargeCrates >= MinLargeCrates)""}}], ""objective"": {""description"": ""The total number of grapes transported is the sum of the grapes in small crates and large crates. The objective is to maximize the total number of grapes transported."", ""formulation"": ""Max (NumSmallCrates \\times SmallCrateCapacity + NumLargeCrates \\times LargeCrateCapacity)"", ""code"": {""gurobipy"": ""model.setObjective(NumSmallCrates * SmallCrateCapacity + NumLargeCrates * LargeCrateCapacity, GRB.MAXIMIZE)""}}}","{""SmallCrateCapacity"": 200, ""LargeCrateCapacity"": 500, ""MinimumSmallToLargeRatio"": 3, ""MaxSmallCrates"": 100, ""MaxLargeCrates"": 50, ""MaxTotalCrates"": 60, ""MinLargeCrates"": 10}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A grape farmer uses small and large crates to transport grapes. Each small crate
holds SmallCrateCapacity grapes, and each large crate holds LargeCrateCapacity
grapes. The number of small crates used must be at least
MinimumSmallToLargeRatio times the number of large crates. The farmer can use up
to MaxSmallCrates small crates and up to MaxLargeCrates large crates.
Additionally, the truck can carry up to MaxTotalCrates crates in total, and at
least MinLargeCrates large crates must be used. The objective is to determine
the number of small and large crates to maximize the total number of grapes
transported.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/180/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SmallCrateCapacity @Def: Number of grapes a small crate can hold @Shape: [] 
SmallCrateCapacity = data['SmallCrateCapacity']
# @Parameter LargeCrateCapacity @Def: Number of grapes a large crate can hold @Shape: [] 
LargeCrateCapacity = data['LargeCrateCapacity']
# @Parameter MinimumSmallToLargeRatio @Def: Minimum ratio of small crates to large crates @Shape: [] 
MinimumSmallToLargeRatio = data['MinimumSmallToLargeRatio']
# @Parameter MaxSmallCrates @Def: Maximum number of small crates available @Shape: [] 
MaxSmallCrates = data['MaxSmallCrates']
# @Parameter MaxLargeCrates @Def: Maximum number of large crates available @Shape: [] 
MaxLargeCrates = data['MaxLargeCrates']
# @Parameter MaxTotalCrates @Def: Maximum number of crates the truck can carry @Shape: [] 
MaxTotalCrates = data['MaxTotalCrates']
# @Parameter MinLargeCrates @Def: Minimum number of large crates to be used @Shape: [] 
MinLargeCrates = data['MinLargeCrates']

# Variables 
# @Variable NumSmallCrates @Def: The number of small crates used @Shape: [] 
NumSmallCrates = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxSmallCrates, name=""NumSmallCrates"")
# @Variable NumLargeCrates @Def: The number of large crates used @Shape: [] 
NumLargeCrates = model.addVar(vtype=GRB.INTEGER, lb=MinLargeCrates, ub=MaxLargeCrates, name=""NumLargeCrates"")

# Constraints 
# @Constraint Constr_1 @Def: The number of small crates used must be at least MinimumSmallToLargeRatio times the number of large crates.
model.addConstr(NumSmallCrates >= MinimumSmallToLargeRatio * NumLargeCrates)
# @Constraint Constr_2 @Def: The number of small crates used cannot exceed MaxSmallCrates.
model.addConstr(NumSmallCrates <= MaxSmallCrates)
# @Constraint Constr_3 @Def: The number of large crates used cannot exceed MaxLargeCrates.
model.addConstr(NumLargeCrates <= MaxLargeCrates)
# @Constraint Constr_4 @Def: The total number of crates used cannot exceed MaxTotalCrates.
model.addConstr(NumSmallCrates + NumLargeCrates <= MaxTotalCrates)
# @Constraint Constr_5 @Def: At least MinLargeCrates large crates must be used.
model.addConstr(NumLargeCrates >= MinLargeCrates)

# Objective 
# @Objective Objective @Def: The total number of grapes transported is the sum of the grapes in small crates and large crates. The objective is to maximize the total number of grapes transported.
model.setObjective(NumSmallCrates * SmallCrateCapacity + NumLargeCrates * LargeCrateCapacity, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumSmallCrates'] = NumSmallCrates.x
variables['NumLargeCrates'] = NumLargeCrates.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A shipping company need to transport packages by either truck or car. A truck can transport 50 packages per trip while a car can transport 30 packages per trip. In addition, a truck uses 20 liters of gas per trip while a car uses 15 liters of gas per trip. There can be at most 5 truck trips made and at least 30% of all the trips must be made by car. The company needs to transport at least 500 packages. How many of each transportation should they use to minimize the total amount of gas consumed?",{},"{""parametrized_description"": ""A shipping company transports packages using trucks and cars. Each truck transports TruckCapacity packages per trip and uses TruckGas liters of gas per trip. Each car transports CarCapacity packages per trip and uses CarGas liters of gas per trip. The number of truck trips is limited by MaxTruckTrips. At least MinCarTripPercentage of all trips must be made by car. The company needs to transport at least MinTotalPackages packages. The objective is to minimize the total gas consumed."", ""keywords"": [""N.A.""], ""parameters"": {""TruckCapacity"": {""description"": ""Number of packages a truck can transport per trip"", ""shape"": []}, ""CarCapacity"": {""description"": ""Number of packages a car can transport per trip"", ""shape"": []}, ""TruckGas"": {""description"": ""Liters of gas a truck uses per trip"", ""shape"": []}, ""CarGas"": {""description"": ""Liters of gas a car uses per trip"", ""shape"": []}, ""MaxTruckTrips"": {""description"": ""Maximum number of truck trips allowed"", ""shape"": []}, ""MinCarTripPercentage"": {""description"": ""Minimum percentage of trips that must be made by car"", ""shape"": []}, ""MinTotalPackages"": {""description"": ""Minimum number of packages to transport"", ""shape"": []}}, ""variables"": {""TruckTrips"": {""description"": ""The number of truck trips"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""CarTrips"": {""description"": ""The number of car trips"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The number of truck trips cannot exceed MaxTruckTrips."", ""formulation"": ""TruckTrips \\leq MaxTruckTrips"", ""code"": {""gurobipy"": ""model.addConstr(TruckTrips <= MaxTruckTrips)""}}, {""description"": ""At least MinCarTripPercentage of all trips must be made by car."", ""formulation"": ""(1 - \\text{MinCarTripPercentage}) \\times \\text{CarTrips} \\geq \\text{MinCarTripPercentage} \\times \\text{TruckTrips}"", ""code"": {""gurobipy"": ""model.addConstr((1 - MinCarTripPercentage) * CarTrips >= MinCarTripPercentage * TruckTrips)""}}, {""description"": ""At least MinTotalPackages packages must be transported."", ""formulation"": ""TruckTrips \\cdot TruckCapacity + CarTrips \\cdot CarCapacity \\geq MinTotalPackages"", ""code"": {""gurobipy"": ""model.addConstr(TruckTrips * TruckCapacity + CarTrips * CarCapacity >= MinTotalPackages, \""MinTotalPackagesConstr\"")""}}], ""objective"": {""description"": ""Total gas consumed is the sum of gas used by trucks and cars per trip. The objective is to minimize the total gas consumed."", ""formulation"": ""Min \\ TruckGas \\times TruckTrips + CarGas \\times CarTrips"", ""code"": {""gurobipy"": ""model.setObjective(TruckGas * TruckTrips + CarGas * CarTrips, GRB.MINIMIZE)""}}}","{""TruckCapacity"": 50, ""CarCapacity"": 30, ""TruckGas"": 20, ""CarGas"": 15, ""MaxTruckTrips"": 5, ""MinCarTripPercentage"": 30, ""MinTotalPackages"": 500}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A shipping company transports packages using trucks and cars. Each truck
transports TruckCapacity packages per trip and uses TruckGas liters of gas per
trip. Each car transports CarCapacity packages per trip and uses CarGas liters
of gas per trip. The number of truck trips is limited by MaxTruckTrips. At least
MinCarTripPercentage of all trips must be made by car. The company needs to
transport at least MinTotalPackages packages. The objective is to minimize the
total gas consumed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/181/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TruckCapacity @Def: Number of packages a truck can transport per trip @Shape: [] 
TruckCapacity = data['TruckCapacity']
# @Parameter CarCapacity @Def: Number of packages a car can transport per trip @Shape: [] 
CarCapacity = data['CarCapacity']
# @Parameter TruckGas @Def: Liters of gas a truck uses per trip @Shape: [] 
TruckGas = data['TruckGas']
# @Parameter CarGas @Def: Liters of gas a car uses per trip @Shape: [] 
CarGas = data['CarGas']
# @Parameter MaxTruckTrips @Def: Maximum number of truck trips allowed @Shape: [] 
MaxTruckTrips = data['MaxTruckTrips']
# @Parameter MinCarTripPercentage @Def: Minimum percentage of trips that must be made by car @Shape: [] 
MinCarTripPercentage = data['MinCarTripPercentage']
# @Parameter MinTotalPackages @Def: Minimum number of packages to transport @Shape: [] 
MinTotalPackages = data['MinTotalPackages']

# Variables 
# @Variable TruckTrips @Def: The number of truck trips @Shape: ['Integer'] 
TruckTrips = model.addVar(vtype=GRB.INTEGER, name=""TruckTrips"", ub=MaxTruckTrips)
# @Variable CarTrips @Def: The number of car trips @Shape: ['Integer'] 
CarTrips = model.addVar(vtype=GRB.INTEGER, name=""CarTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The number of truck trips cannot exceed MaxTruckTrips.
model.addConstr(TruckTrips <= MaxTruckTrips)
# @Constraint Constr_2 @Def: At least MinCarTripPercentage of all trips must be made by car.
model.addConstr((1 - MinCarTripPercentage) * CarTrips >= MinCarTripPercentage * TruckTrips)
# @Constraint Constr_3 @Def: At least MinTotalPackages packages must be transported.
model.addConstr(TruckTrips * TruckCapacity + CarTrips * CarCapacity >= MinTotalPackages, ""MinTotalPackagesConstr"")

# Objective 
# @Objective Objective @Def: Total gas consumed is the sum of gas used by trucks and cars per trip. The objective is to minimize the total gas consumed.
model.setObjective(TruckGas * TruckTrips + CarGas * CarTrips, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['TruckTrips'] = TruckTrips.x
variables['CarTrips'] = CarTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"There has been a horrible accident and patients need to be taken to the hospital by either a helicopter or bus. A helicopter can transport 5 patients per trip and takes 1 hour. On the other hand, a bus can transport 8 patients per trip and takes 3 hours. At least 120 patients need to be transported and at least 30% of the trips should be by helicopter. In addition, there can be at most 10 bus trips. How should the patients be taken to minimize the total time to transport the patients?","{""variables"": {""HelicopterTrips"": 24.0, ""BusTrips"": 0.0, ""PatientsHelicopter"": -0.0, ""PatientsBus"": -0.0}, ""objective"": 24.0}","{""parametrized_description"": ""There has been an accident and patients need to be transported to the hospital by either helicopter or bus. A helicopter can transport HelicopterCapacity patients per trip and takes HelicopterTripTime time. On the other hand, a bus can transport BusCapacity patients per trip and takes BusTripTime time. At least MinPatients patients need to be transported and at least MinHelicopterTripPercentage of the trips should be by helicopter. In addition, there can be at most MaxBusTrips bus trips. The objective is to minimize the total transportation time."", ""keywords"": [""N.A.""], ""parameters"": {""HelicopterCapacity"": {""description"": ""Number of patients that can be transported by helicopter in one trip"", ""shape"": []}, ""HelicopterTripTime"": {""description"": ""Time taken for one helicopter trip"", ""shape"": []}, ""BusCapacity"": {""description"": ""Number of patients that can be transported by bus in one trip"", ""shape"": []}, ""BusTripTime"": {""description"": ""Time taken for one bus trip"", ""shape"": []}, ""MinPatients"": {""description"": ""Minimum number of patients that need to be transported"", ""shape"": []}, ""MinHelicopterTripPercentage"": {""description"": ""Minimum percentage of trips that should be by helicopter"", ""shape"": []}, ""MaxBusTrips"": {""description"": ""Maximum number of bus trips allowed"", ""shape"": []}}, ""variables"": {""HelicopterTrips"": {""description"": ""The number of helicopter trips"", ""type"": ""continuous"", ""shape"": []}, ""BusTrips"": {""description"": ""The number of bus trips"", ""type"": ""continuous"", ""shape"": []}, ""PatientsHelicopter"": {""description"": ""The number of patients transported by helicopter"", ""type"": ""continuous"", ""shape"": []}, ""PatientsBus"": {""description"": ""The number of patients transported by bus"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""At least MinPatients patients need to be transported."", ""formulation"": ""HelicopterTrips \\times HelicopterCapacity + BusTrips \\times BusCapacity \\geq MinPatients"", ""code"": {""gurobipy"": ""model.addConstr(HelicopterTrips * HelicopterCapacity + BusTrips * BusCapacity >= MinPatients)""}}, {""description"": ""At least MinHelicopterTripPercentage of the trips should be by helicopter."", ""formulation"": ""HelicopterTrips \\geq MinHelicopterTripPercentage \\times (HelicopterTrips + BusTrips)"", ""code"": {""gurobipy"": ""model.addConstr(HelicopterTrips >= MinHelicopterTripPercentage * (HelicopterTrips + BusTrips))""}}, {""description"": ""At most MaxBusTrips bus trips are allowed."", ""formulation"": ""BusTrips \\leq MaxBusTrips"", ""code"": {""gurobipy"": ""model.addConstr(BusTrips <= MaxBusTrips)""}}, {""description"": ""Each helicopter trip can transport up to HelicopterCapacity patients."", ""formulation"": ""PatientsHelicopter \\leq HelicopterCapacity \\times HelicopterTrips"", ""code"": {""gurobipy"": ""model.addConstr(PatientsHelicopter <= HelicopterCapacity * HelicopterTrips)""}}, {""description"": ""Each bus trip can transport up to BusCapacity patients."", ""formulation"": ""PatientsBus \\leq BusCapacity \\times BusTrips"", ""code"": {""gurobipy"": ""model.addConstr(PatientsBus <= BusCapacity * BusTrips)""}}], ""objective"": {""description"": ""Minimize the total transportation time."", ""formulation"": ""Min \\ HelicopterTrips \\times HelicopterTripTime + BusTrips \\times BusTripTime"", ""code"": {""gurobipy"": ""model.setObjective(HelicopterTrips * HelicopterTripTime + BusTrips * BusTripTime, GRB.MINIMIZE)""}}}","{""HelicopterCapacity"": 5, ""HelicopterTripTime"": 1, ""BusCapacity"": 8, ""BusTripTime"": 3, ""MinPatients"": 120, ""MinHelicopterTripPercentage"": 0.3, ""MaxBusTrips"": 10}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
There has been an accident and patients need to be transported to the hospital
by either helicopter or bus. A helicopter can transport HelicopterCapacity
patients per trip and takes HelicopterTripTime time. On the other hand, a bus
can transport BusCapacity patients per trip and takes BusTripTime time. At least
MinPatients patients need to be transported and at least
MinHelicopterTripPercentage of the trips should be by helicopter. In addition,
there can be at most MaxBusTrips bus trips. The objective is to minimize the
total transportation time.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/182/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter HelicopterCapacity @Def: Number of patients that can be transported by helicopter in one trip @Shape: [] 
HelicopterCapacity = data['HelicopterCapacity']
# @Parameter HelicopterTripTime @Def: Time taken for one helicopter trip @Shape: [] 
HelicopterTripTime = data['HelicopterTripTime']
# @Parameter BusCapacity @Def: Number of patients that can be transported by bus in one trip @Shape: [] 
BusCapacity = data['BusCapacity']
# @Parameter BusTripTime @Def: Time taken for one bus trip @Shape: [] 
BusTripTime = data['BusTripTime']
# @Parameter MinPatients @Def: Minimum number of patients that need to be transported @Shape: [] 
MinPatients = data['MinPatients']
# @Parameter MinHelicopterTripPercentage @Def: Minimum percentage of trips that should be by helicopter @Shape: [] 
MinHelicopterTripPercentage = data['MinHelicopterTripPercentage']
# @Parameter MaxBusTrips @Def: Maximum number of bus trips allowed @Shape: [] 
MaxBusTrips = data['MaxBusTrips']

# Variables 
# @Variable HelicopterTrips @Def: The number of helicopter trips @Shape: [] 
HelicopterTrips = model.addVar(vtype=GRB.INTEGER, name=""HelicopterTrips"")
# @Variable BusTrips @Def: The number of bus trips @Shape: [] 
BusTrips = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxBusTrips, name=""BusTrips"")
# @Variable PatientsHelicopter @Def: The number of patients transported by helicopter @Shape: [] 
PatientsHelicopter = model.addVar(vtype=GRB.INTEGER, name=""PatientsHelicopter"")
# @Variable PatientsBus @Def: The number of patients transported by bus @Shape: [] 
PatientsBus = model.addVar(vtype=GRB.INTEGER, name=""PatientsBus"")

# Constraints 
# @Constraint Constr_1 @Def: At least MinPatients patients need to be transported.
model.addConstr(HelicopterTrips * HelicopterCapacity + BusTrips * BusCapacity >= MinPatients)
# @Constraint Constr_2 @Def: At least MinHelicopterTripPercentage of the trips should be by helicopter.
model.addConstr(HelicopterTrips >= MinHelicopterTripPercentage * (HelicopterTrips + BusTrips))
# @Constraint Constr_3 @Def: At most MaxBusTrips bus trips are allowed.
model.addConstr(BusTrips <= MaxBusTrips)
# @Constraint Constr_4 @Def: Each helicopter trip can transport up to HelicopterCapacity patients.
model.addConstr(PatientsHelicopter <= HelicopterCapacity * HelicopterTrips)
# @Constraint Constr_5 @Def: Each bus trip can transport up to BusCapacity patients.
model.addConstr(PatientsBus <= BusCapacity * BusTrips)

# Objective 
# @Objective Objective @Def: Minimize the total transportation time.
model.setObjective(HelicopterTrips * HelicopterTripTime + BusTrips * BusTripTime, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['HelicopterTrips'] = HelicopterTrips.x
variables['BusTrips'] = BusTrips.x
variables['PatientsHelicopter'] = PatientsHelicopter.x
variables['PatientsBus'] = PatientsBus.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Employees have the option of car-pooling to work or taking the company bus. A car can take 4 employees and produces 10 units of pollution, while a bus can take 20 employees and produces 30 units of pollution. At least 300 employees need to be transported and at most 4 buses can be used. How many of each type of transport should be taken to minimize the total pollution produced.","{""variables"": {""xCars"": 55.0, ""xBuses"": 4.0}, ""objective"": 670.0}","{""parametrized_description"": ""Employees have the option of using Car or Bus for transportation. A Car can carry CarCapacity employees and produces CarPollution units of pollution, while a Bus can carry BusCapacity employees and produces BusPollution units of pollution. At least MinEmployeesToTransport employees must be transported, and no more than MaxBuses Buses can be used. The objective is to minimize the total pollution produced."", ""keywords"": [""N.A.""], ""parameters"": {""CarCapacity"": {""description"": ""The number of employees that a car can take"", ""shape"": []}, ""CarPollution"": {""description"": ""The pollution produced by a car"", ""shape"": []}, ""BusCapacity"": {""description"": ""The number of employees that a bus can take"", ""shape"": []}, ""BusPollution"": {""description"": ""The pollution produced by a bus"", ""shape"": []}, ""MinEmployeesToTransport"": {""description"": ""The minimum number of employees that need to be transported"", ""shape"": []}, ""MaxBuses"": {""description"": ""The maximum number of buses that can be used"", ""shape"": []}}, ""variables"": {""xCars"": {""description"": ""The number of cars used for transportation"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""xBuses"": {""description"": ""The number of buses used for transportation"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""At least MinEmployeesToTransport employees must be transported."", ""formulation"": ""xCars \\cdot CarCapacity + xBuses \\cdot BusCapacity \\geq MinEmployeesToTransport"", ""code"": {""gurobipy"": ""model.addConstr(xCars * CarCapacity + xBuses * BusCapacity >= MinEmployeesToTransport)""}}, {""description"": ""No more than MaxBuses buses can be used."", ""formulation"": ""xBuses \\leq MaxBuses"", ""code"": {""gurobipy"": """"}}], ""objective"": {""description"": ""Total pollution produced is the sum of pollution from cars and buses. The objective is to minimize the total pollution produced."", ""formulation"": ""Min \\ xCars \\times CarPollution + xBuses \\times BusPollution"", ""code"": {""gurobipy"": ""model.setObjective(xCars * CarPollution + xBuses * BusPollution, GRB.MINIMIZE)""}}}","{""CarCapacity"": 4, ""CarPollution"": 10, ""BusCapacity"": 20, ""BusPollution"": 30, ""MinEmployeesToTransport"": 300, ""MaxBuses"": 4}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Employees have the option of using Car or Bus for transportation. A Car can
carry CarCapacity employees and produces CarPollution units of pollution, while
a Bus can carry BusCapacity employees and produces BusPollution units of
pollution. At least MinEmployeesToTransport employees must be transported, and
no more than MaxBuses Buses can be used. The objective is to minimize the total
pollution produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/183/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CarCapacity @Def: The number of employees that a car can take @Shape: [] 
CarCapacity = data['CarCapacity']
# @Parameter CarPollution @Def: The pollution produced by a car @Shape: [] 
CarPollution = data['CarPollution']
# @Parameter BusCapacity @Def: The number of employees that a bus can take @Shape: [] 
BusCapacity = data['BusCapacity']
# @Parameter BusPollution @Def: The pollution produced by a bus @Shape: [] 
BusPollution = data['BusPollution']
# @Parameter MinEmployeesToTransport @Def: The minimum number of employees that need to be transported @Shape: [] 
MinEmployeesToTransport = data['MinEmployeesToTransport']
# @Parameter MaxBuses @Def: The maximum number of buses that can be used @Shape: [] 
MaxBuses = data['MaxBuses']

# Variables 
# @Variable xCars @Def: The number of cars used for transportation @Shape: ['Integer'] 
xCars = model.addVar(vtype=GRB.INTEGER, name=""xCars"")
# @Variable xBuses @Def: The number of buses used for transportation @Shape: ['Integer'] 
xBuses = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxBuses, name=""xBuses"")

# Constraints 
# @Constraint Constr_1 @Def: At least MinEmployeesToTransport employees must be transported.
model.addConstr(xCars * CarCapacity + xBuses * BusCapacity >= MinEmployeesToTransport)
# @Constraint Constr_2 @Def: No more than MaxBuses buses can be used.


# Objective 
# @Objective Objective @Def: Total pollution produced is the sum of pollution from cars and buses. The objective is to minimize the total pollution produced.
model.setObjective(xCars * CarPollution + xBuses * BusPollution, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['xCars'] = xCars.x
variables['xBuses'] = xBuses.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A snow removal company removes snow from neighborhoods using small trucks and large trucks. A small truck requires 2 people to shovel the snow and can carry 30 units of snow. A large truck require 4 people to shovel the snow and car carry 50 units of snow. The company has available 30 people. In addition, because some neighbourhood don’t allow big trucks, at least 10 trucks must be small. There must be at least 3 large trucks as well and the number of small trucks must be twice as much as the number of large trucks. How many of each truck should be used to maximize the total amount of snow that can be transported?",{},"{""parametrized_description"": ""Maximize the total snow transported by small and large trucks, where each small truck has a snow carrying capacity of SnowCapacitySmallTruck and each large truck has a snow carrying capacity of SnowCapacityLargeTruck. This is subject to the constraint that the total number of people required, calculated as PeoplePerSmallTruck multiplied by the number of small trucks plus PeoplePerLargeTruck multiplied by the number of large trucks, does not exceed TotalPeople. Additionally, the number of small trucks must be at least MinSmallTrucks, the number of large trucks must be at least MinLargeTrucks, and the number of small trucks must be SmallTrucksPerLargeTruck times the number of large trucks."", ""keywords"": [""N.A.""], ""parameters"": {""PeoplePerSmallTruck"": {""description"": ""Number of people required to shovel snow per small truck"", ""shape"": []}, ""PeoplePerLargeTruck"": {""description"": ""Number of people required to shovel snow per large truck"", ""shape"": []}, ""SnowCapacitySmallTruck"": {""description"": ""Snow carrying capacity of a small truck (in units)"", ""shape"": []}, ""SnowCapacityLargeTruck"": {""description"": ""Snow carrying capacity of a large truck (in units)"", ""shape"": []}, ""TotalPeople"": {""description"": ""Total number of people available for snow shoveling"", ""shape"": []}, ""MinSmallTrucks"": {""description"": ""Minimum number of small trucks required"", ""shape"": []}, ""MinLargeTrucks"": {""description"": ""Minimum number of large trucks required"", ""shape"": []}, ""SmallTrucksPerLargeTruck"": {""description"": ""Number of small trucks per large truck"", ""shape"": []}}, ""variables"": {""NumberSmallTrucks"": {""description"": ""The number of small trucks"", ""type"": ""continuous"", ""shape"": []}, ""NumberLargeTrucks"": {""description"": ""The number of large trucks"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of people required, calculated as PeoplePerSmallTruck multiplied by the number of small trucks plus PeoplePerLargeTruck multiplied by the number of large trucks, does not exceed TotalPeople."", ""formulation"": ""PeoplePerSmallTruck \\times NumberSmallTrucks + PeoplePerLargeTruck \\times NumberLargeTrucks \\leq TotalPeople"", ""code"": {""gurobipy"": ""model.addConstr(PeoplePerSmallTruck * NumberSmallTrucks + PeoplePerLargeTruck * NumberLargeTrucks <= TotalPeople)""}}, {""description"": ""The number of small trucks must be at least MinSmallTrucks."", ""formulation"": ""NumberSmallTrucks \\geq MinSmallTrucks"", ""code"": {""gurobipy"": ""model.addConstr(NumberSmallTrucks >= MinSmallTrucks)""}}, {""description"": ""The number of large trucks must be at least MinLargeTrucks."", ""formulation"": ""NumberLargeTrucks \\geq MinLargeTrucks"", ""code"": {""gurobipy"": ""model.addConstr(NumberLargeTrucks >= MinLargeTrucks)""}}, {""description"": ""The number of small trucks must be SmallTrucksPerLargeTruck times the number of large trucks."", ""formulation"": ""NumberSmallTrucks = SmallTrucksPerLargeTruck \\times NumberLargeTrucks"", ""code"": {""gurobipy"": ""model.addConstr(NumberSmallTrucks == SmallTrucksPerLargeTruck * NumberLargeTrucks)""}}], ""objective"": {""description"": ""Maximize the total snow transported by small and large trucks, where each small truck has a snow carrying capacity of SnowCapacitySmallTruck and each large truck has a snow carrying capacity of SnowCapacityLargeTruck."", ""formulation"": ""Max NumberSmallTrucks \\times SnowCapacitySmallTruck + NumberLargeTrucks \\times SnowCapacityLargeTruck"", ""code"": {""gurobipy"": ""model.setObjective(NumberSmallTrucks * SnowCapacitySmallTruck + NumberLargeTrucks * SnowCapacityLargeTruck, GRB.MAXIMIZE)""}}}","{""PeoplePerSmallTruck"": 2, ""PeoplePerLargeTruck"": 4, ""SnowCapacitySmallTruck"": 30, ""SnowCapacityLargeTruck"": 50, ""TotalPeople"": 30, ""MinSmallTrucks"": 10, ""MinLargeTrucks"": 3, ""SmallTrucksPerLargeTruck"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Maximize the total snow transported by small and large trucks, where each small
truck has a snow carrying capacity of SnowCapacitySmallTruck and each large
truck has a snow carrying capacity of SnowCapacityLargeTruck. This is subject to
the constraint that the total number of people required, calculated as
PeoplePerSmallTruck multiplied by the number of small trucks plus
PeoplePerLargeTruck multiplied by the number of large trucks, does not exceed
TotalPeople. Additionally, the number of small trucks must be at least
MinSmallTrucks, the number of large trucks must be at least MinLargeTrucks, and
the number of small trucks must be SmallTrucksPerLargeTruck times the number of
large trucks.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/184/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter PeoplePerSmallTruck @Def: Number of people required to shovel snow per small truck @Shape: [] 
PeoplePerSmallTruck = data['PeoplePerSmallTruck']
# @Parameter PeoplePerLargeTruck @Def: Number of people required to shovel snow per large truck @Shape: [] 
PeoplePerLargeTruck = data['PeoplePerLargeTruck']
# @Parameter SnowCapacitySmallTruck @Def: Snow carrying capacity of a small truck (in units) @Shape: [] 
SnowCapacitySmallTruck = data['SnowCapacitySmallTruck']
# @Parameter SnowCapacityLargeTruck @Def: Snow carrying capacity of a large truck (in units) @Shape: [] 
SnowCapacityLargeTruck = data['SnowCapacityLargeTruck']
# @Parameter TotalPeople @Def: Total number of people available for snow shoveling @Shape: [] 
TotalPeople = data['TotalPeople']
# @Parameter MinSmallTrucks @Def: Minimum number of small trucks required @Shape: [] 
MinSmallTrucks = data['MinSmallTrucks']
# @Parameter MinLargeTrucks @Def: Minimum number of large trucks required @Shape: [] 
MinLargeTrucks = data['MinLargeTrucks']
# @Parameter SmallTrucksPerLargeTruck @Def: Number of small trucks per large truck @Shape: [] 
SmallTrucksPerLargeTruck = data['SmallTrucksPerLargeTruck']

# Variables 
# @Variable NumberSmallTrucks @Def: The number of small trucks @Shape: [] 
NumberSmallTrucks = model.addVar(vtype=GRB.INTEGER, name=""NumberSmallTrucks"")
# @Variable NumberLargeTrucks @Def: The number of large trucks @Shape: [] 
NumberLargeTrucks = model.addVar(vtype=GRB.INTEGER, lb=MinLargeTrucks, name=""NumberLargeTrucks"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of people required, calculated as PeoplePerSmallTruck multiplied by the number of small trucks plus PeoplePerLargeTruck multiplied by the number of large trucks, does not exceed TotalPeople.
model.addConstr(PeoplePerSmallTruck * NumberSmallTrucks + PeoplePerLargeTruck * NumberLargeTrucks <= TotalPeople)
# @Constraint Constr_2 @Def: The number of small trucks must be at least MinSmallTrucks.
model.addConstr(NumberSmallTrucks >= MinSmallTrucks)
# @Constraint Constr_3 @Def: The number of large trucks must be at least MinLargeTrucks.
model.addConstr(NumberLargeTrucks >= MinLargeTrucks)
# @Constraint Constr_4 @Def: The number of small trucks must be SmallTrucksPerLargeTruck times the number of large trucks.
model.addConstr(NumberSmallTrucks == SmallTrucksPerLargeTruck * NumberLargeTrucks)

# Objective 
# @Objective Objective @Def: Maximize the total snow transported by small and large trucks, where each small truck has a snow carrying capacity of SnowCapacitySmallTruck and each large truck has a snow carrying capacity of SnowCapacityLargeTruck.
model.setObjective(NumberSmallTrucks * SnowCapacitySmallTruck + NumberLargeTrucks * SnowCapacityLargeTruck, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberSmallTrucks'] = NumberSmallTrucks.x
variables['NumberLargeTrucks'] = NumberLargeTrucks.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A magic school sends letters to student either by carrier pigeons or owls. A carrier pigeon can carry two letters at a time and requires 3 treats for service. An owl can carry 5 letters at a time and requires 5 treats for service.  At most 40% of the birds can be owls. In addition, the school only has 1000 treats available and at least 20 carrier pigeons must be uses. How many of each bird can be used to maximize the total number of letters that can be sent.","{""variables"": {""NumPigeons"": 158.0, ""NumOwls"": 105.0}, ""objective"": 841.0}","{""parametrized_description"": ""A magic school sends letters to students using carrier pigeons and owls. Each carrier pigeon can carry PigeonLetterCapacity letters per trip and requires PigeonTreatCost treats for service. Each owl can carry OwlLetterCapacity letters per trip and requires OwlTreatCost treats for service. At most MaxOwlProportion of the total birds can be owls. The school has TotalTreats treats available. At least MinPigeons carrier pigeons must be used. The goal is to determine the number of carrier pigeons and owls to maximize the total number of letters sent."", ""keywords"": [""N.A.""], ""parameters"": {""PigeonLetterCapacity"": {""description"": ""The number of letters a carrier pigeon can carry at a time"", ""shape"": []}, ""PigeonTreatCost"": {""description"": ""The number of treats required for a carrier pigeon's service"", ""shape"": []}, ""OwlLetterCapacity"": {""description"": ""The number of letters an owl can carry at a time"", ""shape"": []}, ""OwlTreatCost"": {""description"": ""The number of treats required for an owl's service"", ""shape"": []}, ""MaxOwlProportion"": {""description"": ""The maximum proportion of birds that can be owls"", ""shape"": []}, ""TotalTreats"": {""description"": ""The total number of treats available"", ""shape"": []}, ""MinPigeons"": {""description"": ""The minimum number of carrier pigeons that must be used"", ""shape"": []}}, ""variables"": {""NumPigeons"": {""description"": ""The number of carrier pigeons used"", ""type"": ""continuous"", ""shape"": []}, ""NumOwls"": {""description"": ""The number of owls used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of treats required for carrier pigeons and owls must not exceed TotalTreats."", ""formulation"": ""PigeonTreatCost \\cdot NumPigeons + OwlTreatCost \\cdot NumOwls \\leq TotalTreats"", ""code"": {""gurobipy"": ""model.addConstr(PigeonTreatCost * NumPigeons + OwlTreatCost * NumOwls <= TotalTreats, \""TotalTreats\"")""}}, {""description"": ""The number of owls used must be at most MaxOwlProportion of the total number of birds."", ""formulation"": ""NumOwls \\leq MaxOwlProportion \\times (NumOwls + NumPigeons)"", ""code"": {""gurobipy"": ""model.addConstr(NumOwls <= MaxOwlProportion * (NumOwls + NumPigeons))""}}, {""description"": ""At least MinPigeons carrier pigeons must be used."", ""formulation"": ""NumPigeons \\geq MinPigeons"", ""code"": {""gurobipy"": ""model.addConstr(NumPigeons >= MinPigeons)""}}], ""objective"": {""description"": ""Maximize the total number of letters sent, which is the sum of letters carried by carrier pigeons and owls."", ""formulation"": ""Max \\; NumPigeons \\times PigeonLetterCapacity + NumOwls \\times OwlLetterCapacity"", ""code"": {""gurobipy"": ""model.setObjective(NumPigeons * PigeonLetterCapacity + NumOwls * OwlLetterCapacity, GRB.MAXIMIZE)""}}}","{""PigeonLetterCapacity"": 2, ""PigeonTreatCost"": 3, ""OwlLetterCapacity"": 5, ""OwlTreatCost"": 5, ""MaxOwlProportion"": 0.4, ""TotalTreats"": 1000, ""MinPigeons"": 20}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A magic school sends letters to students using carrier pigeons and owls. Each
carrier pigeon can carry PigeonLetterCapacity letters per trip and requires
PigeonTreatCost treats for service. Each owl can carry OwlLetterCapacity letters
per trip and requires OwlTreatCost treats for service. At most MaxOwlProportion
of the total birds can be owls. The school has TotalTreats treats available. At
least MinPigeons carrier pigeons must be used. The goal is to determine the
number of carrier pigeons and owls to maximize the total number of letters sent.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/185/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter PigeonLetterCapacity @Def: The number of letters a carrier pigeon can carry at a time @Shape: [] 
PigeonLetterCapacity = data['PigeonLetterCapacity']
# @Parameter PigeonTreatCost @Def: The number of treats required for a carrier pigeon's service @Shape: [] 
PigeonTreatCost = data['PigeonTreatCost']
# @Parameter OwlLetterCapacity @Def: The number of letters an owl can carry at a time @Shape: [] 
OwlLetterCapacity = data['OwlLetterCapacity']
# @Parameter OwlTreatCost @Def: The number of treats required for an owl's service @Shape: [] 
OwlTreatCost = data['OwlTreatCost']
# @Parameter MaxOwlProportion @Def: The maximum proportion of birds that can be owls @Shape: [] 
MaxOwlProportion = data['MaxOwlProportion']
# @Parameter TotalTreats @Def: The total number of treats available @Shape: [] 
TotalTreats = data['TotalTreats']
# @Parameter MinPigeons @Def: The minimum number of carrier pigeons that must be used @Shape: [] 
MinPigeons = data['MinPigeons']

# Variables 
# @Variable NumPigeons @Def: The number of carrier pigeons used @Shape: [] 
NumPigeons = model.addVar(vtype=GRB.INTEGER, name=""NumPigeons"")
# @Variable NumOwls @Def: The number of owls used @Shape: [] 
NumOwls = model.addVar(vtype=GRB.INTEGER, name=""NumOwls"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of treats required for carrier pigeons and owls must not exceed TotalTreats.
model.addConstr(PigeonTreatCost * NumPigeons + OwlTreatCost * NumOwls <= TotalTreats, ""TotalTreats"")
# @Constraint Constr_2 @Def: The number of owls used must be at most MaxOwlProportion of the total number of birds.
model.addConstr(NumOwls <= MaxOwlProportion * (NumOwls + NumPigeons))
# @Constraint Constr_3 @Def: At least MinPigeons carrier pigeons must be used.
model.addConstr(NumPigeons >= MinPigeons)

# Objective 
# @Objective Objective @Def: Maximize the total number of letters sent, which is the sum of letters carried by carrier pigeons and owls.
model.setObjective(NumPigeons * PigeonLetterCapacity + NumOwls * OwlLetterCapacity, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumPigeons'] = NumPigeons.x
variables['NumOwls'] = NumOwls.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An international shipping company uses large and small ships to transport containers around the world. A large ship can carry 500 containers while a small ship can carry 200 containers. Because most ports are small, the number of large ships cannot exceed the number of small ships. If the company is under contract needs to transport at least 3000 containers, find the minimum number of ships that can be used.","{""variables"": {""NumberLargeShips"": 4.0, ""NumberSmallShips"": 5.0}, ""objective"": 9.0}","{""parametrized_description"": ""An international shipping company uses large ships and small ships to transport containers. A large ship can carry LargeShipCapacity containers while a small ship can carry SmallShipCapacity containers. The number of large ships cannot exceed the number of small ships. The company needs to transport at least RequiredContainers containers. Find the minimum number of ships that can be used."", ""keywords"": [""N.A.""], ""parameters"": {""LargeShipCapacity"": {""description"": ""Number of containers a large ship can carry"", ""shape"": []}, ""SmallShipCapacity"": {""description"": ""Number of containers a small ship can carry"", ""shape"": []}, ""RequiredContainers"": {""description"": ""Minimum number of containers to transport"", ""shape"": []}}, ""variables"": {""NumberLargeShips"": {""description"": ""The number of large ships"", ""type"": ""continuous"", ""shape"": []}, ""NumberSmallShips"": {""description"": ""The number of small ships"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of large ships does not exceed the number of small ships."", ""formulation"": ""NumberLargeShips \\leq NumberSmallShips"", ""code"": {""gurobipy"": ""model.addConstr(NumberLargeShips <= NumberSmallShips)""}}, {""description"": ""The total number of containers transported by large and small ships is at least RequiredContainers."", ""formulation"": ""NumberLargeShips \\times LargeShipCapacity + NumberSmallShips \\times SmallShipCapacity \\geq RequiredContainers"", ""code"": {""gurobipy"": ""model.addConstr(NumberLargeShips * LargeShipCapacity + NumberSmallShips * SmallShipCapacity >= RequiredContainers)""}}], ""objective"": {""description"": ""Minimize the total number of ships used, which is the sum of large ships and small ships."", ""formulation"": ""Min \\left( NumberLargeShips + NumberSmallShips \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumberLargeShips + NumberSmallShips, GRB.MINIMIZE)""}}}","{""LargeShipCapacity"": 500, ""SmallShipCapacity"": 200, ""RequiredContainers"": 3000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
An international shipping company uses large ships and small ships to transport
containers. A large ship can carry LargeShipCapacity containers while a small
ship can carry SmallShipCapacity containers. The number of large ships cannot
exceed the number of small ships. The company needs to transport at least
RequiredContainers containers. Find the minimum number of ships that can be
used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/186/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter LargeShipCapacity @Def: Number of containers a large ship can carry @Shape: [] 
LargeShipCapacity = data['LargeShipCapacity']
# @Parameter SmallShipCapacity @Def: Number of containers a small ship can carry @Shape: [] 
SmallShipCapacity = data['SmallShipCapacity']
# @Parameter RequiredContainers @Def: Minimum number of containers to transport @Shape: [] 
RequiredContainers = data['RequiredContainers']

# Variables 
# @Variable NumberLargeShips @Def: The number of large ships @Shape: [] 
NumberLargeShips = model.addVar(vtype=GRB.INTEGER, name=""NumberLargeShips"")
# @Variable NumberSmallShips @Def: The number of small ships @Shape: [] 
NumberSmallShips = model.addVar(vtype=GRB.INTEGER, name=""NumberSmallShips"")

# Constraints 
# @Constraint Constr_1 @Def: The number of large ships does not exceed the number of small ships.
model.addConstr(NumberLargeShips <= NumberSmallShips)
# @Constraint Constr_2 @Def: The total number of containers transported by large and small ships is at least RequiredContainers.
model.addConstr(NumberLargeShips * LargeShipCapacity + NumberSmallShips * SmallShipCapacity >= RequiredContainers)

# Objective 
# @Objective Objective @Def: Minimize the total number of ships used, which is the sum of large ships and small ships.
model.setObjective(NumberLargeShips + NumberSmallShips, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberLargeShips'] = NumberLargeShips.x
variables['NumberSmallShips'] = NumberSmallShips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A large fishing boat sends fish back to shore either by small canoes or smaller diesel boats. A canoe can carry back 10 fish while a small diesel boat can carry back 15 fish. In order to follow environmental rules, the number of small canoes used has to be at least 3 times as many as the number of diesel boats uses. If  at least 1000 fish need to be transported to shore, minimize the total number of canoes and diesel boats needed.","{""variables"": {""NumberOfCanoes"": 67.0, ""NumberOfDieselBoats"": 22.0}, ""objective"": 89.0}","{""parametrized_description"": ""A fishing boat transports fish to shore using canoes and diesel boats. Each canoe can carry CanoeCapacity fish, and each diesel boat can carry DieselBoatCapacity fish. The number of canoes used must be at least CanoeToBoatRatio times the number of diesel boats used. To transport at least MinFish fish, minimize the total number of canoes and diesel boats required."", ""keywords"": [""N.A.""], ""parameters"": {""CanoeCapacity"": {""description"": ""Number of fish that a canoe can carry"", ""shape"": []}, ""DieselBoatCapacity"": {""description"": ""Number of fish that a small diesel boat can carry"", ""shape"": []}, ""CanoeToBoatRatio"": {""description"": ""Minimum ratio of canoes to diesel boats"", ""shape"": []}, ""MinFish"": {""description"": ""Minimum number of fish to be transported to shore"", ""shape"": []}}, ""variables"": {""NumberOfCanoes"": {""description"": ""The number of canoes used"", ""type"": ""continuous"", ""shape"": [""integer""]}, ""NumberOfDieselBoats"": {""description"": ""The number of diesel boats used"", ""type"": ""continuous"", ""shape"": [""integer""]}}, ""constraints"": [{""description"": ""Each canoe can carry CanoeCapacity fish and each diesel boat can carry DieselBoatCapacity fish. The total number of fish transported must be at least MinFish."", ""formulation"": ""CanoeCapacity \\cdot NumberOfCanoes + DieselBoatCapacity \\cdot NumberOfDieselBoats \\geq MinFish"", ""code"": {""gurobipy"": ""model.addConstr(CanoeCapacity * NumberOfCanoes + DieselBoatCapacity * NumberOfDieselBoats >= MinFish)""}}, {""description"": ""The number of canoes used must be at least CanoeToBoatRatio times the number of diesel boats used."", ""formulation"": ""NumberOfCanoes \\geq CanoeToBoatRatio \\times NumberOfDieselBoats"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfCanoes >= CanoeToBoatRatio * NumberOfDieselBoats)""}}], ""objective"": {""description"": ""Minimize the total number of canoes and diesel boats required."", ""formulation"": ""Min \\left( NumberOfCanoes + NumberOfDieselBoats \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfCanoes + NumberOfDieselBoats, GRB.MINIMIZE)""}}}","{""CanoeCapacity"": 10, ""DieselBoatCapacity"": 15, ""CanoeToBoatRatio"": 3, ""MinFish"": 1000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A fishing boat transports fish to shore using canoes and diesel boats. Each
canoe can carry CanoeCapacity fish, and each diesel boat can carry
DieselBoatCapacity fish. The number of canoes used must be at least
CanoeToBoatRatio times the number of diesel boats used. To transport at least
MinFish fish, minimize the total number of canoes and diesel boats required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/187/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CanoeCapacity @Def: Number of fish that a canoe can carry @Shape: [] 
CanoeCapacity = data['CanoeCapacity']
# @Parameter DieselBoatCapacity @Def: Number of fish that a small diesel boat can carry @Shape: [] 
DieselBoatCapacity = data['DieselBoatCapacity']
# @Parameter CanoeToBoatRatio @Def: Minimum ratio of canoes to diesel boats @Shape: [] 
CanoeToBoatRatio = data['CanoeToBoatRatio']
# @Parameter MinFish @Def: Minimum number of fish to be transported to shore @Shape: [] 
MinFish = data['MinFish']

# Variables 
# @Variable NumberOfCanoes @Def: The number of canoes used @Shape: ['integer'] 
NumberOfCanoes = model.addVar(vtype=GRB.INTEGER, name=""NumberOfCanoes"")
# @Variable NumberOfDieselBoats @Def: The number of diesel boats used @Shape: ['integer'] 
NumberOfDieselBoats = model.addVar(vtype=GRB.INTEGER, name=""NumberOfDieselBoats"")

# Constraints 
# @Constraint Constr_1 @Def: Each canoe can carry CanoeCapacity fish and each diesel boat can carry DieselBoatCapacity fish. The total number of fish transported must be at least MinFish.
model.addConstr(CanoeCapacity * NumberOfCanoes + DieselBoatCapacity * NumberOfDieselBoats >= MinFish)
# @Constraint Constr_2 @Def: The number of canoes used must be at least CanoeToBoatRatio times the number of diesel boats used.
model.addConstr(NumberOfCanoes >= CanoeToBoatRatio * NumberOfDieselBoats)

# Objective 
# @Objective Objective @Def: Minimize the total number of canoes and diesel boats required.
model.setObjective(NumberOfCanoes + NumberOfDieselBoats, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfCanoes'] = NumberOfCanoes.x
variables['NumberOfDieselBoats'] = NumberOfDieselBoats.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A volunteer organization transports voters to the polls on Election Day either by vans or cars. They have vans which can carry 6 people and cars which can carry 3 people.  They need to transport at least 200 voters to the polls. In addition, at most 30% of the vehicles can be vans. How many of each vehicle should be used to minimize the total number of cars used?","{""variables"": {""NumberOfVans"": 2000000000.0, ""NumberOfCars"": 0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A volunteer organization transports voters to the polls using vans and cars, where each van can carry VoterCapacityVan voters and each car can carry VoterCapacityCar voters. They need to transport at least MinVoters voters, and no more than MaxVanPercentage of the vehicles can be vans. The objective is to minimize the number of cars used."", ""keywords"": [""N.A.""], ""parameters"": {""VoterCapacityVan"": {""description"": ""Number of voters a van can carry"", ""shape"": []}, ""VoterCapacityCar"": {""description"": ""Number of voters a car can carry"", ""shape"": []}, ""MinVoters"": {""description"": ""Minimum number of voters to transport"", ""shape"": []}, ""MaxVanPercentage"": {""description"": ""Maximum percentage of vehicles that can be vans"", ""shape"": []}}, ""variables"": {""NumberOfVans"": {""description"": ""The number of vans used"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfCars"": {""description"": ""The number of cars used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""Each van can carry VoterCapacityVan voters and each car can carry VoterCapacityCar voters. The organization needs to transport at least 200 voters."", ""formulation"": ""VoterCapacityVan \\\\cdot NumberOfVans + VoterCapacityCar \\\\cdot NumberOfCars \\\\geq MinVoters"", ""code"": {""gurobipy"": ""model.addConstr(VoterCapacityVan * NumberOfVans + VoterCapacityCar * NumberOfCars >= MinVoters)""}}, {""description"": ""No more than 30% of the vehicles can be vans."", ""formulation"": ""NumberOfVans \\leq MaxVanPercentage \\times (NumberOfVans + NumberOfCars)"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfVans <= MaxVanPercentage * (NumberOfVans + NumberOfCars))""}}], ""objective"": {""description"": ""Minimize the number of cars used."", ""formulation"": ""Min NumberOfCars"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfCars, GRB.MINIMIZE)""}}}","{""VoterCapacityVan"": 6, ""VoterCapacityCar"": 3, ""MinVoters"": 200, ""MaxVanPercentage"": 30}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A volunteer organization transports voters to the polls using vans and cars,
where each van can carry VoterCapacityVan voters and each car can carry
VoterCapacityCar voters. They need to transport at least MinVoters voters, and
no more than MaxVanPercentage of the vehicles can be vans. The objective is to
minimize the number of cars used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/188/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter VoterCapacityVan @Def: Number of voters a van can carry @Shape: [] 
VoterCapacityVan = data['VoterCapacityVan']
# @Parameter VoterCapacityCar @Def: Number of voters a car can carry @Shape: [] 
VoterCapacityCar = data['VoterCapacityCar']
# @Parameter MinVoters @Def: Minimum number of voters to transport @Shape: [] 
MinVoters = data['MinVoters']
# @Parameter MaxVanPercentage @Def: Maximum percentage of vehicles that can be vans @Shape: [] 
MaxVanPercentage = data['MaxVanPercentage']

# Variables 
# @Variable NumberOfVans @Def: The number of vans used @Shape: [] 
NumberOfVans = model.addVar(vtype=GRB.INTEGER, name=""NumberOfVans"")
# @Variable NumberOfCars @Def: The number of cars used @Shape: [] 
NumberOfCars = model.addVar(vtype=GRB.INTEGER, name=""NumberOfCars"")

# Constraints 
# @Constraint Constr_1 @Def: Each van can carry VoterCapacityVan voters and each car can carry VoterCapacityCar voters. The organization needs to transport at least 200 voters.
model.addConstr(VoterCapacityVan * NumberOfVans + VoterCapacityCar * NumberOfCars >= MinVoters)
# @Constraint Constr_2 @Def: No more than 30% of the vehicles can be vans.
model.addConstr(NumberOfVans <= MaxVanPercentage * (NumberOfVans + NumberOfCars))

# Objective 
# @Objective Objective @Def: Minimize the number of cars used.
model.setObjective(NumberOfCars, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfVans'] = NumberOfVans.x
variables['NumberOfCars'] = NumberOfCars.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A car manufacturing company makes hamburgers and chicken wraps for workers. They need to ensure workers get at least 2200 calories, 50 grams of protein, and 70 grams of carbs. One hamburger costs $6.5 and contains 800 calories, 19 grams of protein, and 20 grams of carbs. One chicken wrap costs $4 and contains 450 calories, 12 grams of protein, and 10 grams of carbs. What is the minimum cost diet that the company can provide for its workers?","{""variables"": {""Quantity"": {""0"": 3.5, ""1"": 0.0}}, ""objective"": 22.75}","{""parametrized_description"": ""A company offers NumFoods different food items, each with an associated Price and containing specific amounts of NumNutrients nutrients as defined by the NutrientContent matrix. The company must ensure that the combination of selected food items provides at least the minimum required amount for each nutrient, specified by MinNutrient. The objective is to determine the selection of food items that satisfies all nutrient requirements while minimizing the total Price."", ""keywords"": [""N.A.""], ""parameters"": {""NumFoods"": {""description"": ""Number of food items"", ""shape"": []}, ""NumNutrients"": {""description"": ""Number of nutrients"", ""shape"": []}, ""MinNutrient"": {""description"": ""Minimum required amount for each nutrient"", ""shape"": [""NumNutrients""]}, ""Price"": {""description"": ""Price of each food item"", ""shape"": [""NumFoods""]}, ""NutrientContent"": {""description"": ""Amount of each nutrient in each food item"", ""shape"": [""NumNutrients"", ""NumFoods""]}}, ""variables"": {""Quantity"": {""description"": ""The quantity of each food item"", ""type"": ""continuous"", ""shape"": [""NumFoods""]}}, ""constraints"": [{""description"": ""The combination of selected food items provides at least the minimum required amount for each nutrient as specified by MinNutrient."", ""formulation"": ""\\sum_{f=1}^{\\text{NumFoods}} \\text{NutrientContent}_{n,f} \\times \\text{Quantity}_f \\geq \\text{MinNutrient}_n \\quad \\forall n \\in \\{1, \\dots, \\text{NumNutrients}\\}"", ""code"": {""gurobipy"": ""for n in range(NumNutrients):\n    model.addConstr(quicksum(NutrientContent[n][f] * Quantity[f] for f in range(NumFoods)) >= MinNutrient[n])""}}], ""objective"": {""description"": ""Minimize the total Price of the selected food items while satisfying all nutrient requirements."", ""formulation"": ""Min \\sum_{i=1}^{NumFoods} Price_i \\times Quantity_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(Price[i] * Quantity[i] for i in range(NumFoods)), GRB.MINIMIZE)""}}}","{""NumFoods"": 2, ""NumNutrients"": 3, ""MinNutrient"": [2200, 50, 70], ""Price"": [6.5, 4], ""NutrientContent"": [[800, 450], [19, 12], [20, 10]]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A company offers NumFoods different food items, each with an associated Price
and containing specific amounts of NumNutrients nutrients as defined by the
NutrientContent matrix. The company must ensure that the combination of selected
food items provides at least the minimum required amount for each nutrient,
specified by MinNutrient. The objective is to determine the selection of food
items that satisfies all nutrient requirements while minimizing the total Price.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/189/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumFoods @Def: Number of food items @Shape: [] 
NumFoods = data['NumFoods']
# @Parameter NumNutrients @Def: Number of nutrients @Shape: [] 
NumNutrients = data['NumNutrients']
# @Parameter MinNutrient @Def: Minimum required amount for each nutrient @Shape: ['NumNutrients'] 
MinNutrient = data['MinNutrient']
# @Parameter Price @Def: Price of each food item @Shape: ['NumFoods'] 
Price = data['Price']
# @Parameter NutrientContent @Def: Amount of each nutrient in each food item @Shape: ['NumNutrients', 'NumFoods'] 
NutrientContent = data['NutrientContent']

# Variables 
# @Variable Quantity @Def: The quantity of each food item @Shape: ['NumFoods'] 
Quantity = model.addVars(NumFoods, vtype=GRB.CONTINUOUS, name=""Quantity"")

# Constraints 
# @Constraint Constr_1 @Def: The combination of selected food items provides at least the minimum required amount for each nutrient as specified by MinNutrient.
for n in range(NumNutrients):
    model.addConstr(quicksum(NutrientContent[n][f] * Quantity[f] for f in range(NumFoods)) >= MinNutrient[n])

# Objective 
# @Objective Objective @Def: Minimize the total Price of the selected food items while satisfying all nutrient requirements.
model.setObjective(quicksum(Price[i] * Quantity[i] for i in range(NumFoods)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Quantity'] = model.getAttr(""X"", Quantity)
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A meat processing plant uses two machines, a meat slicer and a meat packer, to make their hams and pork ribs. To produce one batch of hams requires 4 hours on the meat slicer and 2.5 hours on the meat packer. To produce one batch of pork ribs requires 2 hours on the meat slicer and 3.5 hours on the meat packer. Each machine runs for at most 4000 hours per year. If the profit per batch of hams is $150 and the profit per batch of pork ribs is $300, how many batches of each should be made to maximize profit?","{""variables"": {""BatchesProduced"": {""0"": 0.0, ""1"": 1142.857142857143}}, ""objective"": 342857.14285714284}","{""parametrized_description"": ""A meat processing plant utilizes NumMachines different machines to produce NumProducts products. The time required on each machine to produce one batch of each product is specified by TimeRequired. Each machine is available for no more than MaxHours hours per year. The profit obtained per batch for each product is ProfitPerBatch. The objective is to determine the number of batches of each product to produce in order to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""NumProducts"": {""description"": ""Number of products"", ""shape"": []}, ""NumMachines"": {""description"": ""Number of machines"", ""shape"": []}, ""ProfitPerBatch"": {""description"": ""Profit per batch of each product"", ""shape"": [""NumProducts""]}, ""TimeRequired"": {""description"": ""Time required on each machine to produce one batch of each product"", ""shape"": [""NumMachines"", ""NumProducts""]}, ""MaxHours"": {""description"": ""Maximum available hours per year for each machine"", ""shape"": [""NumMachines""]}}, ""variables"": {""BatchesProduced"": {""description"": ""The number of batches of each product to produce"", ""type"": ""continuous"", ""shape"": [""NumProducts""]}}, ""constraints"": [{""description"": ""For each machine, the total time required to produce all batches of each product does not exceed the machine's maximum available hours per year."", ""formulation"": ""\\sum_{p=1}^{\\text{NumProducts}} \\text{TimeRequired}_{m,p} \\times \\text{BatchesProduced}_p \\leq \\text{MaxHours}_m \\quad \\forall m \\in \\{1, \\dots, \\text{NumMachines}\\}"", ""code"": {""gurobipy"": ""for m in range(NumMachines):\n    model.addConstr(quicksum(TimeRequired[m, p] * BatchesProduced[p] for p in range(NumProducts)) <= MaxHours[m])""}}], ""objective"": {""description"": ""Maximize the total profit obtained from producing the batches of each product."", ""formulation"": ""Max \\sum_{i=1}^{\\text{NumProducts}} \\text{ProfitPerBatch}_i \\times \\text{BatchesProduced}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProfitPerBatch[i] * BatchesProduced[i] for i in range(NumProducts)), GRB.MAXIMIZE)""}}}","{""NumProducts"": 2, ""NumMachines"": 2, ""ProfitPerBatch"": [150, 300], ""TimeRequired"": [[4, 2], [2.5, 3.5]], ""MaxHours"": [4000, 4000]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A meat processing plant utilizes NumMachines different machines to produce
NumProducts products. The time required on each machine to produce one batch of
each product is specified by TimeRequired. Each machine is available for no more
than MaxHours hours per year. The profit obtained per batch for each product is
ProfitPerBatch. The objective is to determine the number of batches of each
product to produce in order to maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/190/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumProducts @Def: Number of products @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter NumMachines @Def: Number of machines @Shape: [] 
NumMachines = data['NumMachines']
# @Parameter ProfitPerBatch @Def: Profit per batch of each product @Shape: ['NumProducts'] 
ProfitPerBatch = data['ProfitPerBatch']
# @Parameter TimeRequired @Def: Time required on each machine to produce one batch of each product @Shape: ['NumMachines', 'NumProducts'] 
TimeRequired = data['TimeRequired']
# @Parameter MaxHours @Def: Maximum available hours per year for each machine @Shape: ['NumMachines'] 
MaxHours = data['MaxHours']
    
# Variables 
# @Variable BatchesProduced @Def: The number of batches of each product to produce @Shape: ['NumProducts'] 
BatchesProduced = model.addVars(NumProducts, vtype=GRB.CONTINUOUS, name=""BatchesProduced"")
    
# Constraints 
# @Constraint Constr_1 @Def: For each machine, the total time required to produce all batches of each product does not exceed the machine's maximum available hours per year.
for m in range(NumMachines):
    model.addConstr(quicksum(TimeRequired[m][p] * BatchesProduced[p] for p in range(NumProducts)) <= MaxHours[m])
    
# Objective 
# @Objective Objective @Def: Maximize the total profit obtained from producing the batches of each product.
model.setObjective(quicksum(ProfitPerBatch[i] * BatchesProduced[i] for i in range(NumProducts)), GRB.MAXIMIZE)
    
# Solve 
model.optimize()
    
# Extract solution 
solution = {}
variables = {}
objective = []
variables['BatchesProduced'] = {p: BatchesProduced[p].X for p in range(NumProducts)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"An appliance company sells and installs refrigerators and stoves. Each refrigerator takes 60 minutes of mover time and 20 minutes of setup time. Each stove takes 45 minutes of mover time and 25 minutes of setup time. The company has available 20000 minutes of mover time and 13000 minutes of setup time. If the profit per refrigerator is $400 and the profit per stove is $260, how many of each should they sell in order to maximize profit?","{""variables"": {""QuantityOfProduct"": {""0"": 333.3333333333333, ""1"": 0.0}}, ""objective"": 133333.3333333333}","{""parametrized_description"": ""A company sells NumProducts different products. Each product requires MoverTimePerProduct amount of mover time and SetupTimePerProduct amount of setup time to sell one unit. The company has TotalMoverTime available mover time and TotalSetupTime available setup time. The profit for each product is ProfitPerProduct per unit. Determine the number of each product to sell in order to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""NumProducts"": {""description"": ""Number of different products sold by the company"", ""shape"": []}, ""MoverTimePerProduct"": {""description"": ""Amount of mover time required to sell one unit of each product"", ""shape"": [""NumProducts""]}, ""SetupTimePerProduct"": {""description"": ""Amount of setup time required to sell one unit of each product"", ""shape"": [""NumProducts""]}, ""ProfitPerProduct"": {""description"": ""Profit per unit of each product"", ""shape"": [""NumProducts""]}, ""TotalMoverTime"": {""description"": ""Total available mover time"", ""shape"": []}, ""TotalSetupTime"": {""description"": ""Total available setup time"", ""shape"": []}}, ""variables"": {""QuantityOfProduct"": {""description"": ""The quantity of each product sold"", ""type"": ""continuous"", ""shape"": [""NumProducts""]}}, ""constraints"": [{""description"": ""Each product requires MoverTimePerProduct amount of mover time to sell one unit. The total mover time used cannot exceed TotalMoverTime."", ""formulation"": ""\\sum_{i=1}^{\\text{NumProducts}} \\text{MoverTimePerProduct}_i \\cdot \\text{QuantityOfProduct}_i \\leq \\text{TotalMoverTime}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(MoverTimePerProduct[i] * QuantityOfProduct[i] for i in range(NumProducts)) <= TotalMoverTime)""}}, {""description"": ""Each product requires SetupTimePerProduct amount of setup time to sell one unit. The total setup time used cannot exceed TotalSetupTime."", ""formulation"": ""\\sum_{p=1}^{NumProducts} SetupTimePerProduct_p \\times QuantityOfProduct_p \\leq TotalSetupTime"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(SetupTimePerProduct[p] * QuantityOfProduct[p] for p in range(NumProducts)) <= TotalSetupTime)""}}], ""objective"": {""description"": ""The total profit is the sum of the profits of each product sold. The objective is to maximize the total profit."", ""formulation"": ""Max \\sum_{i=1}^{\\text{NumProducts}} \\text{ProfitPerProduct}_i \\times \\text{QuantityOfProduct}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProfitPerProduct[i] * QuantityOfProduct[i] for i in range(NumProducts)), GRB.MAXIMIZE)""}}}","{""NumProducts"": 2, ""MoverTimePerProduct"": [60, 45], ""SetupTimePerProduct"": [20, 25], ""ProfitPerProduct"": [400, 260], ""TotalMoverTime"": 20000, ""TotalSetupTime"": 13000}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A company sells NumProducts different products. Each product requires
MoverTimePerProduct amount of mover time and SetupTimePerProduct amount of setup
time to sell one unit. The company has TotalMoverTime available mover time and
TotalSetupTime available setup time. The profit for each product is
ProfitPerProduct per unit. Determine the number of each product to sell in order
to maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/191/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumProducts @Def: Number of different products sold by the company @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter MoverTimePerProduct @Def: Amount of mover time required to sell one unit of each product @Shape: ['NumProducts'] 
MoverTimePerProduct = data['MoverTimePerProduct']
# @Parameter SetupTimePerProduct @Def: Amount of setup time required to sell one unit of each product @Shape: ['NumProducts'] 
SetupTimePerProduct = data['SetupTimePerProduct']
# @Parameter ProfitPerProduct @Def: Profit per unit of each product @Shape: ['NumProducts'] 
ProfitPerProduct = data['ProfitPerProduct']
# @Parameter TotalMoverTime @Def: Total available mover time @Shape: [] 
TotalMoverTime = data['TotalMoverTime']
# @Parameter TotalSetupTime @Def: Total available setup time @Shape: [] 
TotalSetupTime = data['TotalSetupTime']

# Variables 
# @Variable QuantityOfProduct @Def: The quantity of each product sold @Shape: ['NumProducts'] 
QuantityOfProduct = model.addVars(NumProducts, vtype=GRB.CONTINUOUS, name=""QuantityOfProduct"")

# Constraints 
# @Constraint Constr_1 @Def: Each product requires MoverTimePerProduct amount of mover time to sell one unit. The total mover time used cannot exceed TotalMoverTime.
model.addConstr(quicksum(MoverTimePerProduct[i] * QuantityOfProduct[i] for i in range(NumProducts)) <= TotalMoverTime)
# @Constraint Constr_2 @Def: Each product requires SetupTimePerProduct amount of setup time to sell one unit. The total setup time used cannot exceed TotalSetupTime.
model.addConstr(quicksum(SetupTimePerProduct[p] * QuantityOfProduct[p] for p in range(NumProducts)) <= TotalSetupTime)

# Objective 
# @Objective Objective @Def: The total profit is the sum of the profits of each product sold. The objective is to maximize the total profit.
model.setObjective(quicksum(ProfitPerProduct[i] * QuantityOfProduct[i] for i in range(NumProducts)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityOfProduct'] = {i: QuantityOfProduct[i].X for i in range(NumProducts)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"An office company makes desks and drawers. Each desk requires 40 minutes of assembly and 20 minutes of sanding. Each drawer requires 30 minutes of assembly and 10 minutes of sanding. The company has available 4000 minutes for assembly and 3500 minutes for sanding. If the profit per desk is $100 and the profit per drawer is $90, how many of each should the company make to maximize profit?","{""variables"": {""NumberOfDesks"": 0.0, ""NumberOfDrawers"": 133.33333333333334}, ""objective"": 12000.0}","{""parametrized_description"": ""A company manufactures desks and drawers. Each desk requires AssemblyTimeDesk minutes of assembly and SandingTimeDesk minutes of sanding. Each drawer requires AssemblyTimeDrawer minutes of assembly and SandingTimeDrawer minutes of sanding. The company has TotalAssemblyTime minutes available for assembly and TotalSandingTime minutes available for sanding. The profit per desk is ProfitPerDesk and the profit per drawer is ProfitPerDrawer. Determine the number of desks and drawers to produce to maximize profit."", ""keywords"": [""N.A.""], ""parameters"": {""AssemblyTimeDesk"": {""description"": ""Minutes required for assembly per desk"", ""shape"": []}, ""SandingTimeDesk"": {""description"": ""Minutes required for sanding per desk"", ""shape"": []}, ""AssemblyTimeDrawer"": {""description"": ""Minutes required for assembly per drawer"", ""shape"": []}, ""SandingTimeDrawer"": {""description"": ""Minutes required for sanding per drawer"", ""shape"": []}, ""TotalAssemblyTime"": {""description"": ""Total available assembly minutes"", ""shape"": []}, ""TotalSandingTime"": {""description"": ""Total available sanding minutes"", ""shape"": []}, ""ProfitPerDesk"": {""description"": ""Profit per desk"", ""shape"": []}, ""ProfitPerDrawer"": {""description"": ""Profit per drawer"", ""shape"": []}}, ""variables"": {""NumberOfDesks"": {""description"": ""The number of desks to be produced"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfDrawers"": {""description"": ""The number of drawers to be produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""AssemblyTimeDesk multiplied by the number of desks plus AssemblyTimeDrawer multiplied by the number of drawers must not exceed TotalAssemblyTime."", ""formulation"": ""AssemblyTimeDesk \\cdot NumberOfDesks + AssemblyTimeDrawer \\cdot NumberOfDrawers \\leq TotalAssemblyTime"", ""code"": {""gurobipy"": ""model.addConstr(AssemblyTimeDesk * NumberOfDesks + AssemblyTimeDrawer * NumberOfDrawers <= TotalAssemblyTime)""}}, {""description"": ""SandingTimeDesk multiplied by the number of desks plus SandingTimeDrawer multiplied by the number of drawers must not exceed TotalSandingTime."", ""formulation"": ""SandingTimeDesk \\cdot NumberOfDesks + SandingTimeDrawer \\cdot NumberOfDrawers \\leq TotalSandingTime"", ""code"": {""gurobipy"": ""model.addConstr(SandingTimeDesk * NumberOfDesks + SandingTimeDrawer * NumberOfDrawers <= TotalSandingTime)""}}], ""objective"": {""description"": ""Maximize the total profit, which is ProfitPerDesk multiplied by the number of desks plus ProfitPerDrawer multiplied by the number of drawers."", ""formulation"": ""Max ProfitPerDesk \\cdot NumberOfDesks + ProfitPerDrawer \\cdot NumberOfDrawers"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPerDesk * NumberOfDesks + ProfitPerDrawer * NumberOfDrawers, GRB.MAXIMIZE)""}}}","{""AssemblyTimeDesk"": 40, ""SandingTimeDesk"": 20, ""AssemblyTimeDrawer"": 30, ""SandingTimeDrawer"": 10, ""TotalAssemblyTime"": 4000, ""TotalSandingTime"": 3500, ""ProfitPerDesk"": 100, ""ProfitPerDrawer"": 90}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A company manufactures desks and drawers. Each desk requires AssemblyTimeDesk
minutes of assembly and SandingTimeDesk minutes of sanding. Each drawer requires
AssemblyTimeDrawer minutes of assembly and SandingTimeDrawer minutes of sanding.
The company has TotalAssemblyTime minutes available for assembly and
TotalSandingTime minutes available for sanding. The profit per desk is
ProfitPerDesk and the profit per drawer is ProfitPerDrawer. Determine the number
of desks and drawers to produce to maximize profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/192/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter AssemblyTimeDesk @Def: Minutes required for assembly per desk @Shape: [] 
AssemblyTimeDesk = data['AssemblyTimeDesk']
# @Parameter SandingTimeDesk @Def: Minutes required for sanding per desk @Shape: [] 
SandingTimeDesk = data['SandingTimeDesk']
# @Parameter AssemblyTimeDrawer @Def: Minutes required for assembly per drawer @Shape: [] 
AssemblyTimeDrawer = data['AssemblyTimeDrawer']
# @Parameter SandingTimeDrawer @Def: Minutes required for sanding per drawer @Shape: [] 
SandingTimeDrawer = data['SandingTimeDrawer']
# @Parameter TotalAssemblyTime @Def: Total available assembly minutes @Shape: [] 
TotalAssemblyTime = data['TotalAssemblyTime']
# @Parameter TotalSandingTime @Def: Total available sanding minutes @Shape: [] 
TotalSandingTime = data['TotalSandingTime']
# @Parameter ProfitPerDesk @Def: Profit per desk @Shape: [] 
ProfitPerDesk = data['ProfitPerDesk']
# @Parameter ProfitPerDrawer @Def: Profit per drawer @Shape: [] 
ProfitPerDrawer = data['ProfitPerDrawer']

# Variables 
# @Variable NumberOfDesks @Def: The number of desks to be produced @Shape: [] 
NumberOfDesks = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfDesks"")
# @Variable NumberOfDrawers @Def: The number of drawers to be produced @Shape: [] 
NumberOfDrawers = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfDrawers"")

# Constraints 
# @Constraint Constr_1 @Def: AssemblyTimeDesk multiplied by the number of desks plus AssemblyTimeDrawer multiplied by the number of drawers must not exceed TotalAssemblyTime.
model.addConstr(AssemblyTimeDesk * NumberOfDesks + AssemblyTimeDrawer * NumberOfDrawers <= TotalAssemblyTime)
# @Constraint Constr_2 @Def: SandingTimeDesk multiplied by the number of desks plus SandingTimeDrawer multiplied by the number of drawers must not exceed TotalSandingTime.
model.addConstr(SandingTimeDesk * NumberOfDesks + SandingTimeDrawer * NumberOfDrawers <= TotalSandingTime)

# Objective 
# @Objective Objective @Def: Maximize the total profit, which is ProfitPerDesk multiplied by the number of desks plus ProfitPerDrawer multiplied by the number of drawers.
model.setObjective(ProfitPerDesk * NumberOfDesks + ProfitPerDrawer * NumberOfDrawers, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfDesks'] = NumberOfDesks.x
variables['NumberOfDrawers'] = NumberOfDrawers.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A milk tea shop owner would like to sell two different milk teas: black milk tea and matcha milk tea. Each contains both milk and honey. A bottle of black milk tea contains 600 grams of milk and 10 grams of honey, whereas a bottle of matcha milk tea contains 525 grams of milk and 5 grams of honey. The profit from each bottle of black milk tea sold is $7.5 and the profit from each bottle of matcha milk tea sold is $5. If his total production must not exceed his available stock of 30000 grams of milk and 500 grams of honey, how many bottles of each type of milk tea should be made to maximize profits?","{""variables"": {""Produce"": {""0"": 50.0, ""1"": 0.0}}, ""objective"": 375.0}","{""parametrized_description"": ""A milk tea shop owner aims to produce NumMilkTeaTypes different types of milk tea. Each type requires specific amounts of NumResources different resources as defined by ResourceUsage. The profit earned from each bottle of milk tea type j is ProfitPerBottle[j]. The total usage of each resource i must not exceed AvailableResource[i]. The objective is to determine the number of bottles of each milk tea type to produce in order to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""NumMilkTeaTypes"": {""description"": ""Number of different milk tea types to be produced"", ""shape"": []}, ""NumResources"": {""description"": ""Number of different resources used in production"", ""shape"": []}, ""ResourceUsage"": {""description"": ""Amount of resource i required to produce one bottle of milk tea type j"", ""shape"": [""NumResources"", ""NumMilkTeaTypes""]}, ""ProfitPerBottle"": {""description"": ""Profit earned from selling one bottle of milk tea type j"", ""shape"": [""NumMilkTeaTypes""]}, ""AvailableResource"": {""description"": ""Total available amount of resource i"", ""shape"": [""NumResources""]}}, ""variables"": {""Produce"": {""description"": ""The number of bottles produced for each milk tea type"", ""type"": ""continuous"", ""shape"": [""NumMilkTeaTypes""]}}, ""constraints"": [{""description"": ""The total usage of each resource must not exceed the available amount of that resource."", ""formulation"": ""\\sum_{j=1}^{NumMilkTeaTypes} ResourceUsage_{i,j} \\cdot Produce_j \\leq AvailableResource_i, \\quad \\forall i \\in \\{1, \\dots, NumResources\\}"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(ResourceUsage[i][j] * Produce[j] for j in range(NumMilkTeaTypes)) <= AvailableResource[i] for i in range(NumResources)), name='ResourceLimits')""}}, {""description"": ""The number of bottles of each milk tea type to produce must be non-negative."", ""formulation"": ""Produce \\geq 0"", ""code"": {""gurobipy"": ""model.addConstrs((Produce[j] >= 0 for j in range(NumMilkTeaTypes)), \""ProduceNonNegative\"")""}}], ""objective"": {""description"": ""Total profit is the sum of the profits from each milk tea type. The objective is to maximize the total profit."", ""formulation"": ""Max \\sum_{j=1}^{\\text{NumMilkTeaTypes}} \\text{ProfitPerBottle}_j \\cdot \\text{Produce}_j"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProfitPerBottle[j] * Produce[j] for j in range(NumMilkTeaTypes)), GRB.MAXIMIZE)""}}}","{""NumMilkTeaTypes"": 2, ""NumResources"": 2, ""ResourceUsage"": [[600, 525], [10, 5]], ""ProfitPerBottle"": [7.5, 5], ""AvailableResource"": [30000, 500]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A milk tea shop owner aims to produce NumMilkTeaTypes different types of milk
tea. Each type requires specific amounts of NumResources different resources as
defined by ResourceUsage. The profit earned from each bottle of milk tea type j
is ProfitPerBottle[j]. The total usage of each resource i must not exceed
AvailableResource[i]. The objective is to determine the number of bottles of
each milk tea type to produce in order to maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/193/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumMilkTeaTypes @Def: Number of different milk tea types to be produced @Shape: [] 
NumMilkTeaTypes = data['NumMilkTeaTypes']
# @Parameter NumResources @Def: Number of different resources used in production @Shape: [] 
NumResources = data['NumResources']
# @Parameter ResourceUsage @Def: Amount of resource i required to produce one bottle of milk tea type j @Shape: ['NumResources', 'NumMilkTeaTypes'] 
ResourceUsage = data['ResourceUsage']
# @Parameter ProfitPerBottle @Def: Profit earned from selling one bottle of milk tea type j @Shape: ['NumMilkTeaTypes'] 
ProfitPerBottle = data['ProfitPerBottle']
# @Parameter AvailableResource @Def: Total available amount of resource i @Shape: ['NumResources'] 
AvailableResource = data['AvailableResource']

# Variables 
# @Variable Produce @Def: The number of bottles produced for each milk tea type @Shape: ['NumMilkTeaTypes'] 
Produce = model.addVars(NumMilkTeaTypes, vtype=GRB.CONTINUOUS, name=""Produce"")

# Constraints 
# @Constraint Constr_1 @Def: The total usage of each resource must not exceed the available amount of that resource.
model.addConstrs((quicksum(ResourceUsage[i][j] * Produce[j] for j in range(NumMilkTeaTypes)) <= AvailableResource[i] for i in range(NumResources)), name='ResourceLimits')
# @Constraint Constr_2 @Def: The number of bottles of each milk tea type to produce must be non-negative.
model.addConstrs((Produce[j] >= 0 for j in range(NumMilkTeaTypes)), ""ProduceNonNegative"")

# Objective 
# @Objective Objective @Def: Total profit is the sum of the profits from each milk tea type. The objective is to maximize the total profit.
model.setObjective(quicksum(ProfitPerBottle[j] * Produce[j] for j in range(NumMilkTeaTypes)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Produce'] = model.getAttr(""X"", Produce)
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
A young boy is trying to grow taller by drinking milk and eating vegetables. He wants to get a minimum of 100 units of calcium and 50 units of iron per day. A glass of milk costs $1 and contains 40 units of calcium and 25 units of iron. A plate of vegetables costs $2 and contains 15 units of calcium and 30 units of iron. How many of each should he consume to minimize his cost?,"{""variables"": {""MilkAmount"": 2.5, ""VegetablesAmount"": 0.0}, ""objective"": 2.5}","{""parametrized_description"": ""A young boy aims to meet at least MinCalcium units of calcium and MinIron units of iron per day by consuming milk and vegetables. Each serving of milk costs MilkCost and contains MilkCalcium units of calcium and MilkIron units of iron. Each serving of vegetables costs VegetableCost and contains VegetableCalcium units of calcium and VegetableIron units of iron. The objective is to determine the number of milk and vegetable servings to minimize the total cost."", ""keywords"": [""N.A.""], ""parameters"": {""MinCalcium"": {""description"": ""Minimum required units of calcium per day"", ""shape"": []}, ""MinIron"": {""description"": ""Minimum required units of iron per day"", ""shape"": []}, ""MilkCost"": {""description"": ""Cost of a glass of milk"", ""shape"": []}, ""MilkCalcium"": {""description"": ""Units of calcium in a glass of milk"", ""shape"": []}, ""MilkIron"": {""description"": ""Units of iron in a glass of milk"", ""shape"": []}, ""VegetableCost"": {""description"": ""Cost of a plate of vegetables"", ""shape"": []}, ""VegetableCalcium"": {""description"": ""Units of calcium in a plate of vegetables"", ""shape"": []}, ""VegetableIron"": {""description"": ""Units of iron in a plate of vegetables"", ""shape"": []}}, ""variables"": {""MilkAmount"": {""description"": ""The number of glasses of milk consumed per day"", ""type"": ""continuous"", ""shape"": []}, ""VegetablesAmount"": {""description"": ""The number of plates of vegetables consumed per day"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total calcium obtained from milk and vegetables must be at least MinCalcium units per day."", ""formulation"": ""MilkCalcium \\cdot MilkAmount + VegetableCalcium \\cdot VegetablesAmount \\geq MinCalcium"", ""code"": {""gurobipy"": ""model.addConstr(MilkCalcium * MilkAmount + VegetableCalcium * VegetablesAmount >= MinCalcium)""}}, {""description"": ""The total iron obtained from milk and vegetables must be at least MinIron units per day."", ""formulation"": ""MilkIron \\cdot MilkAmount + VegetableIron \\cdot VegetablesAmount \\geq MinIron"", ""code"": {""gurobipy"": ""model.addConstr(MilkIron * MilkAmount + VegetableIron * VegetablesAmount >= MinIron, 'IronRequirement')""}}, {""description"": ""The number of milk servings and vegetable servings must be non-negative."", ""formulation"": ""MilkAmount \\geq 0 \\n VegetablesAmount \\geq 0"", ""code"": {""gurobipy"": ""model.addConstr(MilkAmount >= 0, \""MilkAmount_nonnegative\"")\nmodel.addConstr(VegetablesAmount >= 0, \""VegetablesAmount_nonnegative\"")""}}], ""objective"": {""description"": ""Minimize the total cost, which is the sum of the costs of milk servings and vegetable servings."", ""formulation"": ""Min \\; MilkCost \\cdot MilkAmount + VegetableCost \\cdot VegetablesAmount"", ""code"": {""gurobipy"": ""model.setObjective(MilkCost * MilkAmount + VegetableCost * VegetablesAmount, GRB.MINIMIZE)""}}}","{""MinCalcium"": 100, ""MinIron"": 50, ""MilkCost"": 1, ""MilkCalcium"": 40, ""MilkIron"": 25, ""VegetableCost"": 2, ""VegetableCalcium"": 15, ""VegetableIron"": 30}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A young boy aims to meet at least MinCalcium units of calcium and MinIron units
of iron per day by consuming milk and vegetables. Each serving of milk costs
MilkCost and contains MilkCalcium units of calcium and MilkIron units of iron.
Each serving of vegetables costs VegetableCost and contains VegetableCalcium
units of calcium and VegetableIron units of iron. The objective is to determine
the number of milk and vegetable servings to minimize the total cost.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/194/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MinCalcium @Def: Minimum required units of calcium per day @Shape: [] 
MinCalcium = data['MinCalcium']
# @Parameter MinIron @Def: Minimum required units of iron per day @Shape: [] 
MinIron = data['MinIron']
# @Parameter MilkCost @Def: Cost of a glass of milk @Shape: [] 
MilkCost = data['MilkCost']
# @Parameter MilkCalcium @Def: Units of calcium in a glass of milk @Shape: [] 
MilkCalcium = data['MilkCalcium']
# @Parameter MilkIron @Def: Units of iron in a glass of milk @Shape: [] 
MilkIron = data['MilkIron']
# @Parameter VegetableCost @Def: Cost of a plate of vegetables @Shape: [] 
VegetableCost = data['VegetableCost']
# @Parameter VegetableCalcium @Def: Units of calcium in a plate of vegetables @Shape: [] 
VegetableCalcium = data['VegetableCalcium']
# @Parameter VegetableIron @Def: Units of iron in a plate of vegetables @Shape: [] 
VegetableIron = data['VegetableIron']

# Variables 
# @Variable MilkAmount @Def: The number of glasses of milk consumed per day @Shape: [] 
MilkAmount = model.addVar(vtype=GRB.CONTINUOUS, name=""MilkAmount"")
# @Variable VegetablesAmount @Def: The number of plates of vegetables consumed per day @Shape: [] 
VegetablesAmount = model.addVar(vtype=GRB.CONTINUOUS, name=""VegetablesAmount"")

# Constraints 
# @Constraint Constr_1 @Def: The total calcium obtained from milk and vegetables must be at least MinCalcium units per day.
model.addConstr(MilkCalcium * MilkAmount + VegetableCalcium * VegetablesAmount >= MinCalcium)
# @Constraint Constr_2 @Def: The total iron obtained from milk and vegetables must be at least MinIron units per day.
model.addConstr(MilkIron * MilkAmount + VegetableIron * VegetablesAmount >= MinIron, 'IronRequirement')
# @Constraint Constr_3 @Def: The number of milk servings and vegetable servings must be non-negative.
model.addConstr(MilkAmount >= 0, ""MilkAmount_nonnegative"")
model.addConstr(VegetablesAmount >= 0, ""VegetablesAmount_nonnegative"")

# Objective 
# @Objective Objective @Def: Minimize the total cost, which is the sum of the costs of milk servings and vegetable servings.
model.setObjective(MilkCost * MilkAmount + VegetableCost * VegetablesAmount, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['MilkAmount'] = MilkAmount.x
variables['VegetablesAmount'] = VegetablesAmount.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
Bob wants to design a diet consisting of protein bars and noodles. Assume that each serving of noodles costs $5 and contains 600 calories and 1.5 grams of protein. Assume that each serving of protein bar costs $2.5 and contains 250 calories and 5 grams of protein. He's interested in spending as little money as possible but he wants to ensure that his meals have at least 2000 calories and at least 16 grams of protein per day. Formulate a linear programming problem that will help minimize the cost of the diet.,"{""variables"": {""ServingsNoodles"": 2.2857142857142856, ""ServingsProteinBars"": 2.5142857142857142}, ""objective"": 17.71428571428571}","{""parametrized_description"": ""Minimize CostProteinBars * x + CostNoodles * y subject to CaloriesProteinBars * x + CaloriesNoodles * y \u2265 MinCalories and ProteinProteinBars * x + ProteinNoodles * y \u2265 MinProtein, where x and y are non-negative variables representing the number of servings of protein bars and noodles respectively."", ""keywords"": [""N.A.""], ""parameters"": {""CostNoodles"": {""description"": ""Cost per serving of noodles"", ""shape"": []}, ""CostProteinBars"": {""description"": ""Cost per serving of protein bars"", ""shape"": []}, ""CaloriesNoodles"": {""description"": ""Calories per serving of noodles"", ""shape"": []}, ""CaloriesProteinBars"": {""description"": ""Calories per serving of protein bars"", ""shape"": []}, ""ProteinNoodles"": {""description"": ""Protein per serving of noodles"", ""shape"": []}, ""ProteinProteinBars"": {""description"": ""Protein per serving of protein bars"", ""shape"": []}, ""MinCalories"": {""description"": ""Minimum required calories per day"", ""shape"": []}, ""MinProtein"": {""description"": ""Minimum required protein per day"", ""shape"": []}}, ""variables"": {""ServingsNoodles"": {""description"": ""The number of servings of noodles"", ""type"": ""continuous"", ""shape"": []}, ""ServingsProteinBars"": {""description"": ""The number of servings of protein bars"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total calories from protein bars and noodles must be at least MinCalories."", ""formulation"": ""CaloriesNoodles \\cdot ServingsNoodles + CaloriesProteinBars \\cdot ServingsProteinBars \\geq MinCalories"", ""code"": {""gurobipy"": ""model.addConstr(CaloriesNoodles * ServingsNoodles + CaloriesProteinBars * ServingsProteinBars >= MinCalories)""}}, {""description"": ""The total protein from protein bars and noodles must be at least MinProtein."", ""formulation"": ""ProteinNoodles \\times ServingsNoodles + ProteinProteinBars \\times ServingsProteinBars \\geq MinProtein"", ""code"": {""gurobipy"": ""model.addConstr(ProteinNoodles * ServingsNoodles + ProteinProteinBars * ServingsProteinBars >= MinProtein)""}}], ""objective"": {""description"": ""The objective is to minimize the total cost of protein bars and noodles while meeting the minimum daily calorie and protein requirements."", ""formulation"": ""Min CostNoodles \\times ServingsNoodles + CostProteinBars \\times ServingsProteinBars"", ""code"": {""gurobipy"": ""model.setObjective(CostNoodles * ServingsNoodles + CostProteinBars * ServingsProteinBars, GRB.MINIMIZE)""}}}","{""CostNoodles"": 5, ""CostProteinBars"": 2.5, ""CaloriesNoodles"": 600, ""CaloriesProteinBars"": 250, ""ProteinNoodles"": 1.5, ""ProteinProteinBars"": 5, ""MinCalories"": 2000, ""MinProtein"": 16}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Minimize CostProteinBars * x + CostNoodles * y subject to CaloriesProteinBars *
x + CaloriesNoodles * y ≥ MinCalories and ProteinProteinBars * x +
ProteinNoodles * y ≥ MinProtein, where x and y are non-negative variables
representing the number of servings of protein bars and noodles respectively.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/195/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CostNoodles @Def: Cost per serving of noodles @Shape: [] 
CostNoodles = data['CostNoodles']
# @Parameter CostProteinBars @Def: Cost per serving of protein bars @Shape: [] 
CostProteinBars = data['CostProteinBars']
# @Parameter CaloriesNoodles @Def: Calories per serving of noodles @Shape: [] 
CaloriesNoodles = data['CaloriesNoodles']
# @Parameter CaloriesProteinBars @Def: Calories per serving of protein bars @Shape: [] 
CaloriesProteinBars = data['CaloriesProteinBars']
# @Parameter ProteinNoodles @Def: Protein per serving of noodles @Shape: [] 
ProteinNoodles = data['ProteinNoodles']
# @Parameter ProteinProteinBars @Def: Protein per serving of protein bars @Shape: [] 
ProteinProteinBars = data['ProteinProteinBars']
# @Parameter MinCalories @Def: Minimum required calories per day @Shape: [] 
MinCalories = data['MinCalories']
# @Parameter MinProtein @Def: Minimum required protein per day @Shape: [] 
MinProtein = data['MinProtein']

# Variables 
# @Variable ServingsNoodles @Def: The number of servings of noodles @Shape: [] 
ServingsNoodles = model.addVar(vtype=GRB.CONTINUOUS, name=""ServingsNoodles"")
# @Variable ServingsProteinBars @Def: The number of servings of protein bars @Shape: [] 
ServingsProteinBars = model.addVar(vtype=GRB.CONTINUOUS, name=""ServingsProteinBars"")

# Constraints 
# @Constraint Constr_1 @Def: The total calories from protein bars and noodles must be at least MinCalories.
model.addConstr(CaloriesNoodles * ServingsNoodles + CaloriesProteinBars * ServingsProteinBars >= MinCalories)
# @Constraint Constr_2 @Def: The total protein from protein bars and noodles must be at least MinProtein.
model.addConstr(ProteinNoodles * ServingsNoodles + ProteinProteinBars * ServingsProteinBars >= MinProtein)

# Objective 
# @Objective Objective @Def: The objective is to minimize the total cost of protein bars and noodles while meeting the minimum daily calorie and protein requirements.
model.setObjective(CostNoodles * ServingsNoodles + CostProteinBars * ServingsProteinBars, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ServingsNoodles'] = ServingsNoodles.x
variables['ServingsProteinBars'] = ServingsProteinBars.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
A toy store sells plush toys and dolls. Each plush toy costs the store $3 and each doll costs the store $2. The store owner can spend at most $700 on inventory. Each plush toy is then sold for a profit of $4 while each doll is sold for a profit of $2. The owner estimates that at least 90 plush toys but at most 190 plush toys are sold each month. He also estimates that the number of dolls sold is at most twice the amount of plush toys sold. How many of each should be bought and sold to maximize profit?,"{""variables"": {""NumberPlushToys"": 190.0, ""NumberDolls"": 65.0, ""NumberPlushToysSold"": 190.0, ""NumberDollsSold"": 65.0}, ""objective"": 890.0}","{""parametrized_description"": ""A store purchases quantities of plush toys and dolls. The cost per plush toy is CostPlushToy and the cost per doll is CostDoll. The total inventory cost must not exceed InventoryBudget. Each plush toy sold yields ProfitPlushToy profit and each doll sold yields ProfitDoll profit. The number of plush toys sold must be at least MinPlushSold and at most MaxPlushSold. Additionally, the number of dolls sold must not exceed MaxDollToPlushRatio multiplied by the number of plush toys sold. The objective is to determine the quantities to buy and sell to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""CostPlushToy"": {""description"": ""Cost to the store for one plush toy"", ""shape"": []}, ""CostDoll"": {""description"": ""Cost to the store for one doll"", ""shape"": []}, ""InventoryBudget"": {""description"": ""Maximum total cost for inventory"", ""shape"": []}, ""ProfitPlushToy"": {""description"": ""Profit earned per plush toy sold"", ""shape"": []}, ""ProfitDoll"": {""description"": ""Profit earned per doll sold"", ""shape"": []}, ""MinPlushSold"": {""description"": ""Minimum number of plush toys sold each month"", ""shape"": []}, ""MaxPlushSold"": {""description"": ""Maximum number of plush toys sold each month"", ""shape"": []}, ""MaxDollToPlushRatio"": {""description"": ""Maximum ratio of number of dolls sold to number of plush toys sold"", ""shape"": []}}, ""variables"": {""NumberPlushToys"": {""description"": ""The number of plush toys purchased"", ""type"": ""continuous"", ""shape"": []}, ""NumberDolls"": {""description"": ""The number of dolls purchased"", ""type"": ""continuous"", ""shape"": []}, ""NumberPlushToysSold"": {""description"": ""The number of plush toys sold each month"", ""type"": ""continuous"", ""shape"": []}, ""NumberDollsSold"": {""description"": ""The number of dolls sold each month"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total cost of purchasing plush toys and dolls must not exceed InventoryBudget."", ""formulation"": ""NumberPlushToys \\cdot CostPlushToy + NumberDolls \\cdot CostDoll \\leq InventoryBudget"", ""code"": {""gurobipy"": ""model.addConstr(NumberPlushToys * CostPlushToy + NumberDolls * CostDoll <= InventoryBudget)""}}, {""description"": ""The number of plush toys sold must be at least MinPlushSold and at most MaxPlushSold."", ""formulation"": ""NumberPlushToysSold \\geq MinPlushSold \\n NumberPlushToysSold \\leq MaxPlushSold"", ""code"": {""gurobipy"": ""model.addConstr(NumberPlushToysSold >= MinPlushSold)\nmodel.addConstr(NumberPlushToysSold <= MaxPlushSold)""}}, {""description"": ""The number of dolls sold must not exceed MaxDollToPlushRatio multiplied by the number of plush toys sold."", ""formulation"": ""NumberDollsSold \\leq MaxDollToPlushRatio \\times NumberPlushToysSold"", ""code"": {""gurobipy"": ""model.addConstr(NumberDollsSold <= MaxDollToPlushRatio * NumberPlushToysSold)""}}, {""description"": ""The quantity of plush toys purchased must be at least equal to the number of plush toys sold."", ""formulation"": ""NumberPlushToys \\geq NumberPlushToysSold"", ""code"": {""gurobipy"": ""model.addConstr(NumberPlushToys >= NumberPlushToysSold)""}}, {""description"": ""The quantity of dolls purchased must be at least equal to the number of dolls sold."", ""formulation"": ""NumberDolls \\geq NumberDollsSold"", ""code"": {""gurobipy"": ""model.addConstr(NumberDolls >= NumberDollsSold)""}}], ""objective"": {""description"": ""Total profit is the sum of ProfitPlushToy multiplied by the number of plush toys sold and ProfitDoll multiplied by the number of dolls sold. The objective is to maximize total profit."", ""formulation"": ""Max \\ ProfitPlushToy \\times NumberPlushToysSold + ProfitDoll \\times NumberDollsSold"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPlushToy * NumberPlushToysSold + ProfitDoll * NumberDollsSold, GRB.MAXIMIZE)""}}}","{""CostPlushToy"": 3, ""CostDoll"": 2, ""InventoryBudget"": 700, ""ProfitPlushToy"": 4, ""ProfitDoll"": 2, ""MinPlushSold"": 90, ""MaxPlushSold"": 190, ""MaxDollToPlushRatio"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A store purchases quantities of plush toys and dolls. The cost per plush toy is
CostPlushToy and the cost per doll is CostDoll. The total inventory cost must
not exceed InventoryBudget. Each plush toy sold yields ProfitPlushToy profit and
each doll sold yields ProfitDoll profit. The number of plush toys sold must be
at least MinPlushSold and at most MaxPlushSold. Additionally, the number of
dolls sold must not exceed MaxDollToPlushRatio multiplied by the number of plush
toys sold. The objective is to determine the quantities to buy and sell to
maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/196/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CostPlushToy @Def: Cost to the store for one plush toy @Shape: [] 
CostPlushToy = data['CostPlushToy']
# @Parameter CostDoll @Def: Cost to the store for one doll @Shape: [] 
CostDoll = data['CostDoll']
# @Parameter InventoryBudget @Def: Maximum total cost for inventory @Shape: [] 
InventoryBudget = data['InventoryBudget']
# @Parameter ProfitPlushToy @Def: Profit earned per plush toy sold @Shape: [] 
ProfitPlushToy = data['ProfitPlushToy']
# @Parameter ProfitDoll @Def: Profit earned per doll sold @Shape: [] 
ProfitDoll = data['ProfitDoll']
# @Parameter MinPlushSold @Def: Minimum number of plush toys sold each month @Shape: [] 
MinPlushSold = data['MinPlushSold']
# @Parameter MaxPlushSold @Def: Maximum number of plush toys sold each month @Shape: [] 
MaxPlushSold = data['MaxPlushSold']
# @Parameter MaxDollToPlushRatio @Def: Maximum ratio of number of dolls sold to number of plush toys sold @Shape: [] 
MaxDollToPlushRatio = data['MaxDollToPlushRatio']

# Variables 
# @Variable NumberPlushToys @Def: The number of plush toys purchased @Shape: [] 
NumberPlushToys = model.addVar(vtype=GRB.INTEGER, name=""NumberPlushToys"")
# @Variable NumberDolls @Def: The number of dolls purchased @Shape: [] 
NumberDolls = model.addVar(vtype=GRB.INTEGER, name=""NumberDolls"")
# @Variable NumberPlushToysSold @Def: The number of plush toys sold each month @Shape: [] 
NumberPlushToysSold = model.addVar(vtype=GRB.INTEGER, name=""NumberPlushToysSold"")
# @Variable NumberDollsSold @Def: The number of dolls sold each month @Shape: [] 
NumberDollsSold = model.addVar(vtype=GRB.INTEGER, name=""NumberDollsSold"")

# Constraints 
# @Constraint Constr_1 @Def: The total cost of purchasing plush toys and dolls must not exceed InventoryBudget.
model.addConstr(NumberPlushToys * CostPlushToy + NumberDolls * CostDoll <= InventoryBudget)
# @Constraint Constr_2 @Def: The number of plush toys sold must be at least MinPlushSold and at most MaxPlushSold.
model.addConstr(NumberPlushToysSold >= MinPlushSold)
model.addConstr(NumberPlushToysSold <= MaxPlushSold)
# @Constraint Constr_3 @Def: The number of dolls sold must not exceed MaxDollToPlushRatio multiplied by the number of plush toys sold.
model.addConstr(NumberDollsSold <= MaxDollToPlushRatio * NumberPlushToysSold)
# @Constraint Constr_4 @Def: The quantity of plush toys purchased must be at least equal to the number of plush toys sold.
model.addConstr(NumberPlushToys >= NumberPlushToysSold)
# @Constraint Constr_5 @Def: The quantity of dolls purchased must be at least equal to the number of dolls sold.
model.addConstr(NumberDolls >= NumberDollsSold)

# Objective 
# @Objective Objective @Def: Total profit is the sum of ProfitPlushToy multiplied by the number of plush toys sold and ProfitDoll multiplied by the number of dolls sold. The objective is to maximize total profit.
model.setObjective(ProfitPlushToy * NumberPlushToysSold + ProfitDoll * NumberDollsSold, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberPlushToys'] = NumberPlushToys.x
variables['NumberDolls'] = NumberDolls.x
variables['NumberPlushToysSold'] = NumberPlushToysSold.x
variables['NumberDollsSold'] = NumberDollsSold.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Forest Paper makes two types of products: graph paper and music paper. Each type of paper requires the use of two machines, a printing machine and a scanning machine. It takes 3 minutes on the printing machine and 5.5 minutes on the scanning machine to make a ream of graph paper. On the other hand, it takes 1.5 minutes on the printing machine and 3 minutes on the scanning machine to make a ream of music paper. Each machine is available for a maximum of 350 minutes per day. The company sells a package of graph paper at a profit of $4 and a package of music paper at a profit of $2.5. The company can sell all the paper it makes. How many reams of each type should the company produce in a day in order to maximize profit? What is that profit?","{""variables"": {""ProductionQuantity"": {""0"": 0.0, ""1"": 116.66666666666667}}, ""objective"": 291.6666666666667}","{""parametrized_description"": ""Forest Paper produces NumProducts different types of products using NumMachines different machine types. Each product requires a specific amount of time on each machine, as defined by TimeRequired. Each machine type has a limited AvailableTime per day. The company aims to determine the number of each product to produce in order to maximize total profit, given the ProfitPerProduct for each product."", ""keywords"": [""N.A.""], ""parameters"": {""NumProducts"": {""description"": ""Number of different products manufactured"", ""shape"": []}, ""NumMachines"": {""description"": ""Number of different machine types"", ""shape"": []}, ""TimeRequired"": {""description"": ""Time required by each machine to produce each product"", ""shape"": [""NumMachines"", ""NumProducts""]}, ""AvailableTime"": {""description"": ""Available time per machine per day"", ""shape"": [""NumMachines""]}, ""ProfitPerProduct"": {""description"": ""Profit per product"", ""shape"": [""NumProducts""]}}, ""variables"": {""ProductionQuantity"": {""description"": ""The quantity of each product to produce"", ""type"": ""continuous"", ""shape"": [""NumProducts""]}}, ""constraints"": [{""description"": ""For each machine type, the total time required to produce all products cannot exceed the AvailableTime per day."", ""formulation"": ""\\sum_{j=1}^{NumProducts} TimeRequired_{i,j} \\cdot ProductionQuantity_{j} \\leq AvailableTime_{i} \\quad \\forall i \\in \\{1, \\dots, NumMachines\\}"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(TimeRequired[i][j] * ProductionQuantity[j] for j in range(NumProducts)) <= AvailableTime[i] for i in range(NumMachines)), name=\""MachineTime\"")""}}], ""objective"": {""description"": ""Total profit is the sum of ProfitPerProduct for each product multiplied by the number of each product produced. The objective is to maximize the total profit."", ""formulation"": ""Max \\sum_{i=1}^{\\text{NumProducts}} \\text{ProfitPerProduct}_i \\times \\text{ProductionQuantity}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProfitPerProduct[i] * ProductionQuantity[i] for i in range(NumProducts)), GRB.MAXIMIZE)""}}}","{""NumProducts"": 2, ""NumMachines"": 2, ""TimeRequired"": [[3, 1.5], [5.5, 3]], ""AvailableTime"": [350, 350], ""ProfitPerProduct"": [4, 2.5]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Forest Paper produces NumProducts different types of products using NumMachines
different machine types. Each product requires a specific amount of time on each
machine, as defined by TimeRequired. Each machine type has a limited
AvailableTime per day. The company aims to determine the number of each product
to produce in order to maximize total profit, given the ProfitPerProduct for
each product.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/197/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumProducts @Def: Number of different products manufactured @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter NumMachines @Def: Number of different machine types @Shape: [] 
NumMachines = data['NumMachines']
# @Parameter TimeRequired @Def: Time required by each machine to produce each product @Shape: ['NumMachines', 'NumProducts'] 
TimeRequired = data['TimeRequired']
# @Parameter AvailableTime @Def: Available time per machine per day @Shape: ['NumMachines'] 
AvailableTime = data['AvailableTime']
# @Parameter ProfitPerProduct @Def: Profit per product @Shape: ['NumProducts'] 
ProfitPerProduct = data['ProfitPerProduct']

# Variables 
# @Variable ProductionQuantity @Def: The quantity of each product to produce @Shape: ['NumProducts'] 
ProductionQuantity = model.addVars(NumProducts, vtype=GRB.CONTINUOUS, name=""ProductionQuantity"")

# Constraints 
# @Constraint Constr_1 @Def: For each machine type, the total time required to produce all products cannot exceed the AvailableTime per day.
model.addConstrs((quicksum(TimeRequired[i][j] * ProductionQuantity[j] for j in range(NumProducts)) <= AvailableTime[i] for i in range(NumMachines)), name=""MachineTime"")

# Objective 
# @Objective Objective @Def: Total profit is the sum of ProfitPerProduct for each product multiplied by the number of each product produced. The objective is to maximize the total profit.
model.setObjective(quicksum(ProfitPerProduct[j] * ProductionQuantity[j] for j in range(NumProducts)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ProductionQuantity'] = {j: ProductionQuantity[j].X for j in range(NumProducts)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"Calcium and Magnesium are found in two health supplements, health supplement A and health supplement B. One serving of health supplement A contains 30 grams of Calcium and 50 grams of Magnesium. One serving of health supplement B contains 60 grams of Calcium and 10 grams of Magnesium. The cost per health supplement for health supplement A is $14 and the cost per health supplement for health supplement B is $25. A patient must consume these two health supplements every day to get at least 400 grams of Calcium and 50 grams of Magnesium. Determine how much servings of each supplement the patient needs to minimize her daily cost.","{""variables"": {""Servings"": {""0"": 0.0, ""1"": 6.666666666666667}}, ""objective"": 166.66666666666669}","{""parametrized_description"": ""A patient consumes NumSupplements different health supplements, each providing various amounts of NumNutrients nutrients per serving. Each supplement has a CostPerServing. The patient must consume enough supplements to meet the MinimumRequirement for each nutrient. The objective is to determine the number of servings of each supplement to minimize the total daily cost."", ""keywords"": [""N.A.""], ""parameters"": {""NumSupplements"": {""description"": ""Number of health supplements"", ""shape"": []}, ""NumNutrients"": {""description"": ""Number of nutrients"", ""shape"": []}, ""AmountPerServing"": {""description"": ""Amount of nutrient i per serving of supplement j"", ""shape"": [""NumNutrients"", ""NumSupplements""]}, ""CostPerServing"": {""description"": ""Cost per serving of supplement j"", ""shape"": [""NumSupplements""]}, ""MinimumRequirement"": {""description"": ""Minimum required amount of nutrient i"", ""shape"": [""NumNutrients""]}}, ""variables"": {""Servings"": {""description"": ""The number of servings for each supplement"", ""type"": ""continuous"", ""shape"": [""NumSupplements""]}}, ""constraints"": [{""description"": ""The total amount of Calcium obtained from the supplements must meet or exceed the minimum required."", ""formulation"": ""\\sum_{j=1}^{\\text{NumSupplements}} \\text{AmountPerServing}_{\\text{Calcium},j} \\cdot \\text{Servings}_j \\geq \\text{MinimumRequirement}_{\\text{Calcium}}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(AmountPerServing[0][j] * Servings[j] for j in range(NumSupplements)) >= MinimumRequirement[0])""}}, {""description"": ""The total amount of Magnesium obtained from the supplements must meet or exceed the minimum required."", ""formulation"": ""\\sum_{j=1}^{NumSupplements} \\text{AmountPerServing}_{\\text{Mg},j} \\cdot \\text{Servings}_j \\geq \\text{MinimumRequirement}_{\\text{Mg}}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(AmountPerServing[0][j] * Servings[j] for j in range(NumSupplements)) >= MinimumRequirement[0])""}}], ""objective"": {""description"": ""Minimize the total daily cost of supplements while meeting the minimum requirements for Calcium and Magnesium."", ""formulation"": ""Min \\sum_{j=1}^{NumSupplements} CostPerServing_j \\times Servings_j"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(CostPerServing[j] * Servings[j] for j in range(NumSupplements)), GRB.MINIMIZE)""}}}","{""NumSupplements"": 2, ""NumNutrients"": 2, ""AmountPerServing"": [[30, 60], [50, 10]], ""CostPerServing"": [14, 25], ""MinimumRequirement"": [400, 50]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A patient consumes NumSupplements different health supplements, each providing
various amounts of NumNutrients nutrients per serving. Each supplement has a
CostPerServing. The patient must consume enough supplements to meet the
MinimumRequirement for each nutrient. The objective is to determine the number
of servings of each supplement to minimize the total daily cost.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/198/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumSupplements @Def: Number of health supplements @Shape: [] 
NumSupplements = data['NumSupplements']
# @Parameter NumNutrients @Def: Number of nutrients @Shape: [] 
NumNutrients = data['NumNutrients']
# @Parameter AmountPerServing @Def: Amount of nutrient i per serving of supplement j @Shape: ['NumNutrients', 'NumSupplements'] 
AmountPerServing = data['AmountPerServing']
# @Parameter CostPerServing @Def: Cost per serving of supplement j @Shape: ['NumSupplements'] 
CostPerServing = data['CostPerServing']
# @Parameter MinimumRequirement @Def: Minimum required amount of nutrient i @Shape: ['NumNutrients'] 
MinimumRequirement = data['MinimumRequirement']

# Variables 
# @Variable Servings @Def: The number of servings for each supplement @Shape: ['NumSupplements'] 
Servings = model.addVars(NumSupplements, vtype=GRB.CONTINUOUS, name=""Servings"")

# Constraints 
# @Constraint Constr_1 @Def: The total amount of Calcium obtained from the supplements must meet or exceed the minimum required.
model.addConstr(quicksum(AmountPerServing[0][j] * Servings[j] for j in range(NumSupplements)) >= MinimumRequirement[0])
# @Constraint Constr_2 @Def: The total amount of Magnesium obtained from the supplements must meet or exceed the minimum required.
model.addConstr(quicksum(AmountPerServing[1][j] * Servings[j] for j in range(NumSupplements)) >= MinimumRequirement[1])

# Objective 
# @Objective Objective @Def: Minimize the total daily cost of supplements while meeting the minimum requirements for Calcium and Magnesium.
model.setObjective(quicksum(CostPerServing[j] * Servings[j] for j in range(NumSupplements)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Servings'] = {j: Servings[j].X for j in range(NumSupplements)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"Lucy has a dog and she wants his food to be mixed.  In order to keep the dog healthy but also keep the food tasty, the mix needs to have a minimum of 15 units of calcium, 20 units of vitamin mix, and 20 units of protein. A regular brand costs $20 per bag and contains 4 units of calcium, 7 units of vitamin mix, and 10 units of protein. A premium brand costs $35 per bag and contains 12 units of calcium, 10 units of vitamin mix, and 16 units of protein. How many bags of each brand should Lucy mix in order to minimize cost while also meeting the taste and health requirements.","{""variables"": {""NumRegularBags"": 0.0, ""NumPremiumBags"": 2.0}, ""objective"": 70.0}","{""parametrized_description"": ""Lucy aims to determine the number of regular and premium bags to purchase to minimize the total cost, subject to the constraints that the combined calcium from regular and premium bags is at least MinCalcium, the combined vitamin mix is at least MinVitaminMix, and the combined protein is at least MinProtein. The cost per regular bag is PriceRegular and per premium bag is PricePremium. Each regular bag provides CalciumRegular units of calcium, VitaminMixRegular units of vitamin mix, and ProteinRegular units of protein, while each premium bag provides CalciumPremium units of calcium, VitaminMixPremium units of vitamin mix, and ProteinPremium units of protein."", ""keywords"": [""N.A.""], ""parameters"": {""MinCalcium"": {""description"": ""Minimum required units of calcium"", ""shape"": []}, ""MinVitaminMix"": {""description"": ""Minimum required units of vitamin mix"", ""shape"": []}, ""MinProtein"": {""description"": ""Minimum required units of protein"", ""shape"": []}, ""PriceRegular"": {""description"": ""Price per bag of regular brand"", ""shape"": []}, ""PricePremium"": {""description"": ""Price per bag of premium brand"", ""shape"": []}, ""CalciumRegular"": {""description"": ""Units of calcium per bag of regular brand"", ""shape"": []}, ""CalciumPremium"": {""description"": ""Units of calcium per bag of premium brand"", ""shape"": []}, ""VitaminMixRegular"": {""description"": ""Units of vitamin mix per bag of regular brand"", ""shape"": []}, ""VitaminMixPremium"": {""description"": ""Units of vitamin mix per bag of premium brand"", ""shape"": []}, ""ProteinRegular"": {""description"": ""Units of protein per bag of regular brand"", ""shape"": []}, ""ProteinPremium"": {""description"": ""Units of protein per bag of premium brand"", ""shape"": []}}, ""variables"": {""NumRegularBags"": {""description"": ""The number of regular bags"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumPremiumBags"": {""description"": ""The number of premium bags"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The combined calcium from regular and premium bags is at least MinCalcium."", ""formulation"": ""CalciumRegular \\times NumRegularBags + CalciumPremium \\times NumPremiumBags \\geq MinCalcium"", ""code"": {""gurobipy"": ""model.addConstr(CalciumRegular * NumRegularBags + CalciumPremium * NumPremiumBags >= MinCalcium)""}}, {""description"": ""The combined vitamin mix from regular and premium bags is at least MinVitaminMix."", ""formulation"": ""VitaminMixRegular \\cdot NumRegularBags + VitaminMixPremium \\cdot NumPremiumBags \\geq MinVitaminMix"", ""code"": {""gurobipy"": ""model.addConstr(VitaminMixRegular * NumRegularBags + VitaminMixPremium * NumPremiumBags >= MinVitaminMix)""}}, {""description"": ""The combined protein from regular and premium bags is at least MinProtein."", ""formulation"": ""ProteinRegular \\cdot NumRegularBags + ProteinPremium \\cdot NumPremiumBags \\geq MinProtein"", ""code"": {""gurobipy"": ""model.addConstr(ProteinRegular * NumRegularBags + ProteinPremium * NumPremiumBags >= MinProtein)""}}], ""objective"": {""description"": ""Total cost is PriceRegular multiplied by the number of regular bags plus PricePremium multiplied by the number of premium bags. The objective is to minimize the total cost while meeting the nutritional requirements for calcium, vitamin mix, and protein."", ""formulation"": ""Min PriceRegular \\times NumRegularBags + PricePremium \\times NumPremiumBags"", ""code"": {""gurobipy"": ""model.setObjective(PriceRegular * NumRegularBags + PricePremium * NumPremiumBags, GRB.MINIMIZE)""}}}","{""MinCalcium"": 15, ""MinVitaminMix"": 20, ""MinProtein"": 20, ""PriceRegular"": 20, ""PricePremium"": 35, ""CalciumRegular"": 4, ""CalciumPremium"": 12, ""VitaminMixRegular"": 7, ""VitaminMixPremium"": 10, ""ProteinRegular"": 10, ""ProteinPremium"": 16}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Lucy aims to determine the number of regular and premium bags to purchase to
minimize the total cost, subject to the constraints that the combined calcium
from regular and premium bags is at least MinCalcium, the combined vitamin mix
is at least MinVitaminMix, and the combined protein is at least MinProtein. The
cost per regular bag is PriceRegular and per premium bag is PricePremium. Each
regular bag provides CalciumRegular units of calcium, VitaminMixRegular units of
vitamin mix, and ProteinRegular units of protein, while each premium bag
provides CalciumPremium units of calcium, VitaminMixPremium units of vitamin
mix, and ProteinPremium units of protein.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/199/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MinCalcium @Def: Minimum required units of calcium @Shape: [] 
MinCalcium = data['MinCalcium']
# @Parameter MinVitaminMix @Def: Minimum required units of vitamin mix @Shape: [] 
MinVitaminMix = data['MinVitaminMix']
# @Parameter MinProtein @Def: Minimum required units of protein @Shape: [] 
MinProtein = data['MinProtein']
# @Parameter PriceRegular @Def: Price per bag of regular brand @Shape: [] 
PriceRegular = data['PriceRegular']
# @Parameter PricePremium @Def: Price per bag of premium brand @Shape: [] 
PricePremium = data['PricePremium']
# @Parameter CalciumRegular @Def: Units of calcium per bag of regular brand @Shape: [] 
CalciumRegular = data['CalciumRegular']
# @Parameter CalciumPremium @Def: Units of calcium per bag of premium brand @Shape: [] 
CalciumPremium = data['CalciumPremium']
# @Parameter VitaminMixRegular @Def: Units of vitamin mix per bag of regular brand @Shape: [] 
VitaminMixRegular = data['VitaminMixRegular']
# @Parameter VitaminMixPremium @Def: Units of vitamin mix per bag of premium brand @Shape: [] 
VitaminMixPremium = data['VitaminMixPremium']
# @Parameter ProteinRegular @Def: Units of protein per bag of regular brand @Shape: [] 
ProteinRegular = data['ProteinRegular']
# @Parameter ProteinPremium @Def: Units of protein per bag of premium brand @Shape: [] 
ProteinPremium = data['ProteinPremium']

# Variables 
# @Variable NumRegularBags @Def: The number of regular bags @Shape: ['Integer'] 
NumRegularBags = model.addVar(vtype=GRB.INTEGER, name=""NumRegularBags"")
# @Variable NumPremiumBags @Def: The number of premium bags @Shape: ['Integer'] 
NumPremiumBags = model.addVar(vtype=GRB.INTEGER, name=""NumPremiumBags"")

# Constraints 
# @Constraint Constr_1 @Def: The combined calcium from regular and premium bags is at least MinCalcium.
model.addConstr(CalciumRegular * NumRegularBags + CalciumPremium * NumPremiumBags >= MinCalcium)
# @Constraint Constr_2 @Def: The combined vitamin mix from regular and premium bags is at least MinVitaminMix.
model.addConstr(VitaminMixRegular * NumRegularBags + VitaminMixPremium * NumPremiumBags >= MinVitaminMix)
# @Constraint Constr_3 @Def: The combined protein from regular and premium bags is at least MinProtein.
model.addConstr(ProteinRegular * NumRegularBags + ProteinPremium * NumPremiumBags >= MinProtein)

# Objective 
# @Objective Objective @Def: Total cost is PriceRegular multiplied by the number of regular bags plus PricePremium multiplied by the number of premium bags. The objective is to minimize the total cost while meeting the nutritional requirements for calcium, vitamin mix, and protein.
model.setObjective(PriceRegular * NumRegularBags + PricePremium * NumPremiumBags, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumRegularBags'] = NumRegularBags.x
variables['NumPremiumBags'] = NumPremiumBags.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Maple Oil processes three types of crude oil: light oil, non-sticky oil and heavy oil. Each tank of light oil produces a net revenue of $550, each tank of non-sticky oil produces a net revenue of $750, and each tank of heavy oil produces a net revenue of $950. To process a tank of light oil, 3 units of compound A and 3 units of compound B are required. To process a tank of non-sticky oil, 6 units of compound A and 2 units of compound B are required. To process a tank of heavy oil, 9 units of compound A and 3 units of compound B are required. Currently the company has 250 units of compound A and 150 units of compound B to process. How many full or partial tanks of each oil should the company process so that net revenue is maximized?","{""variables"": {""NumTanksProcessed"": {""0"": 33.333333333333336, ""1"": 25.0, ""2"": 0.0}}, ""objective"": 37083.333333333336}","{""parametrized_description"": ""A company processes NumOilTypes different types of crude oil. Each type of crude oil generates a NetRevenue per tank processed. Processing one tank of each type of crude oil requires specific amounts of each of the NumCompounds compounds, as defined by the CompoundRequirement matrix. The company has a limited supply of each compound, specified by TotalCompoundAvailable. The objective is to determine the number of full or partial tanks of each type of crude oil to process in order to maximize the total NetRevenue."", ""keywords"": [""N.A.""], ""parameters"": {""NumOilTypes"": {""description"": ""Number of different types of crude oil"", ""shape"": []}, ""NumCompounds"": {""description"": ""Number of different compounds required to process oil"", ""shape"": []}, ""NetRevenue"": {""description"": ""Net revenue per tank for each type of crude oil"", ""shape"": [""NumOilTypes""]}, ""CompoundRequirement"": {""description"": ""Amount of each compound required to process one tank of each type of crude oil"", ""shape"": [""NumCompounds"", ""NumOilTypes""]}, ""TotalCompoundAvailable"": {""description"": ""Total units of each compound available for processing"", ""shape"": [""NumCompounds""]}}, ""variables"": {""NumTanksProcessed"": {""description"": ""The number of tanks processed for each type of crude oil"", ""type"": ""continuous"", ""shape"": [""NumOilTypes""]}}, ""constraints"": [{""description"": ""Processing one tank of each type of crude oil requires specific amounts of each compound as defined by the CompoundRequirement matrix. The total usage of each compound cannot exceed the TotalCompoundAvailable."", ""formulation"": ""\\sum_{o=1}^{\\text{NumOilTypes}} CompoundRequirement_{c,o} \\times NumTanksProcessed_{o} \\leq TotalCompoundAvailable_{c}, \\quad \\forall c \\in \\{1, \\dots, NumCompounds\\}"", ""code"": {""gurobipy"": ""model.addConstrs(\n    (quicksum(CompoundRequirement[c][o] * NumTanksProcessed[o] for o in range(NumOilTypes)) <= TotalCompoundAvailable[c] for c in range(NumCompounds)),\n    name=\""CompoundUsage\""\n)""}}], ""objective"": {""description"": ""Total NetRevenue is the sum of the NetRevenue per tank for each type of crude oil processed. The objective is to maximize the total NetRevenue."", ""formulation"": ""Max \\sum_{i=1}^{NumOilTypes} NetRevenue_{i} \\times NumTanksProcessed_{i}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(NetRevenue[i] * NumTanksProcessed[i] for i in range(NumOilTypes)), GRB.MAXIMIZE)""}}}","{""NumOilTypes"": 3, ""NumCompounds"": 2, ""NetRevenue"": [550, 750, 950], ""CompoundRequirement"": [[3, 6, 9], [3, 2, 3]], ""TotalCompoundAvailable"": [250, 150]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A company processes NumOilTypes different types of crude oil. Each type of crude
oil generates a NetRevenue per tank processed. Processing one tank of each type
of crude oil requires specific amounts of each of the NumCompounds compounds, as
defined by the CompoundRequirement matrix. The company has a limited supply of
each compound, specified by TotalCompoundAvailable. The objective is to
determine the number of full or partial tanks of each type of crude oil to
process in order to maximize the total NetRevenue.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/200/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumOilTypes @Def: Number of different types of crude oil @Shape: [] 
NumOilTypes = data['NumOilTypes']
# @Parameter NumCompounds @Def: Number of different compounds required to process oil @Shape: [] 
NumCompounds = data['NumCompounds']
# @Parameter NetRevenue @Def: Net revenue per tank for each type of crude oil @Shape: ['NumOilTypes'] 
NetRevenue = data['NetRevenue']
# @Parameter CompoundRequirement @Def: Amount of each compound required to process one tank of each type of crude oil @Shape: ['NumCompounds', 'NumOilTypes'] 
CompoundRequirement = data['CompoundRequirement']
# @Parameter TotalCompoundAvailable @Def: Total units of each compound available for processing @Shape: ['NumCompounds'] 
TotalCompoundAvailable = data['TotalCompoundAvailable']

# Variables 
# @Variable NumTanksProcessed @Def: The number of tanks processed for each type of crude oil @Shape: ['NumOilTypes'] 
NumTanksProcessed = model.addVars(NumOilTypes, vtype=GRB.CONTINUOUS, name=""NumTanksProcessed"")

# Constraints 
# @Constraint Constr_1 @Def: Processing one tank of each type of crude oil requires specific amounts of each compound as defined by the CompoundRequirement matrix. The total usage of each compound cannot exceed the TotalCompoundAvailable.
model.addConstrs(
    (quicksum(CompoundRequirement[c][o] * NumTanksProcessed[o] for o in range(NumOilTypes)) <= TotalCompoundAvailable[c] for c in range(NumCompounds)),
    name=""CompoundUsage""
)

# Objective 
# @Objective Objective @Def: Total NetRevenue is the sum of the NetRevenue per tank for each type of crude oil processed. The objective is to maximize the total NetRevenue.
model.setObjective(quicksum(NetRevenue[i] * NumTanksProcessed[i] for i in range(NumOilTypes)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumTanksProcessed'] = {o: NumTanksProcessed[o].X for o in range(NumOilTypes)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A flooring company produces engineered laminate planks and carpets. The chief marketer reports an expected demand of at least 15,000 square feet of laminate planks and 5,000 square feet of carpets each week. The shipping contract requires a total of at least 50,000 square feet of products each week. However, due to a shortage of raw materials, no more than 40,000 square feet of laminate planks and 20,000 square feet of carpets can be produced weekly. If a square foot of laminate planks produces a $2.1 profit and a square foot of carpets yields a $3.3 profit, how many of each type of product should be made weekly to maximize the company's profit?","{""variables"": {""LaminateProduction"": 40000.0, ""CarpetProduction"": 20000.0}, ""objective"": 150000.0}","{""parametrized_description"": ""A company produces two types of flooring products: laminate planks and carpets. Let the production levels of laminate planks and carpets be represented by variables. The objective is to maximize the total profit, which is calculated by multiplying the production level of laminate planks by LaminateProfitPerSqFt and the production level of carpets by CarpetProfitPerSqFt, then summing these two amounts. The production levels must satisfy the following constraints: the production of laminate planks must be at least MinLaminateDemand and no more than MaxLaminateProduction; the production of carpets must be at least MinCarpetDemand and no more than MaxCarpetProduction; and the combined production of both products must meet or exceed MinTotalShipping."", ""keywords"": [""N.A.""], ""parameters"": {""MinLaminateDemand"": {""description"": ""Minimum weekly demand for laminate planks"", ""shape"": []}, ""MinCarpetDemand"": {""description"": ""Minimum weekly demand for carpets"", ""shape"": []}, ""MinTotalShipping"": {""description"": ""Minimum total weekly shipping requirement"", ""shape"": []}, ""MaxLaminateProduction"": {""description"": ""Maximum weekly production capacity for laminate planks"", ""shape"": []}, ""MaxCarpetProduction"": {""description"": ""Maximum weekly production capacity for carpets"", ""shape"": []}, ""LaminateProfitPerSqFt"": {""description"": ""Profit per square foot for laminate planks"", ""shape"": []}, ""CarpetProfitPerSqFt"": {""description"": ""Profit per square foot for carpets"", ""shape"": []}}, ""variables"": {""LaminateProduction"": {""description"": ""The weekly production level of laminate planks"", ""type"": ""continuous"", ""shape"": []}, ""CarpetProduction"": {""description"": ""The weekly production level of carpets"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The production level of laminate planks must be at least MinLaminateDemand."", ""formulation"": ""LaminateProduction \\geq MinLaminateDemand"", ""code"": {""gurobipy"": ""model.addConstr(LaminateProduction >= MinLaminateDemand)""}}, {""description"": ""The production level of laminate planks must be no more than MaxLaminateProduction."", ""formulation"": ""LaminateProduction \\leq MaxLaminateProduction"", ""code"": {""gurobipy"": ""model.addConstr(LaminateProduction <= MaxLaminateProduction, \""LaminateProductionLimit\"")""}}, {""description"": ""The production level of carpets must be at least MinCarpetDemand."", ""formulation"": ""CarpetProduction \\geq MinCarpetDemand"", ""code"": {""gurobipy"": ""model.addConstr(CarpetProduction >= MinCarpetDemand)""}}, {""description"": ""The production level of carpets must be no more than MaxCarpetProduction."", ""formulation"": ""CarpetProduction \\leq MaxCarpetProduction"", ""code"": {""gurobipy"": ""model.addConstr(CarpetProduction <= MaxCarpetProduction)""}}, {""description"": ""The combined production levels of laminate planks and carpets must meet or exceed MinTotalShipping."", ""formulation"": ""LaminateProduction + CarpetProduction \\geq MinTotalShipping"", ""code"": {""gurobipy"": ""model.addConstr(LaminateProduction + CarpetProduction >= MinTotalShipping)""}}], ""objective"": {""description"": ""Total profit is calculated by multiplying the production level of laminate planks by LaminateProfitPerSqFt and the production level of carpets by CarpetProfitPerSqFt, then summing these two amounts. The objective is to maximize the total profit."", ""formulation"": ""Max \\left( LaminateProfitPerSqFt \\cdot LaminateProduction + CarpetProfitPerSqFt \\cdot CarpetProduction \\right )"", ""code"": {""gurobipy"": ""model.setObjective(LaminateProfitPerSqFt * LaminateProduction + CarpetProfitPerSqFt * CarpetProduction, GRB.MAXIMIZE)""}}}","{""MinLaminateDemand"": 15000, ""MinCarpetDemand"": 5000, ""MinTotalShipping"": 50000, ""MaxLaminateProduction"": 40000, ""MaxCarpetProduction"": 20000, ""LaminateProfitPerSqFt"": 2.1, ""CarpetProfitPerSqFt"": 3.3}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A company produces two types of flooring products: laminate planks and carpets.
Let the production levels of laminate planks and carpets be represented by
variables. The objective is to maximize the total profit, which is calculated by
multiplying the production level of laminate planks by LaminateProfitPerSqFt and
the production level of carpets by CarpetProfitPerSqFt, then summing these two
amounts. The production levels must satisfy the following constraints: the
production of laminate planks must be at least MinLaminateDemand and no more
than MaxLaminateProduction; the production of carpets must be at least
MinCarpetDemand and no more than MaxCarpetProduction; and the combined
production of both products must meet or exceed MinTotalShipping.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/201/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MinLaminateDemand @Def: Minimum weekly demand for laminate planks @Shape: [] 
MinLaminateDemand = data['MinLaminateDemand']
# @Parameter MinCarpetDemand @Def: Minimum weekly demand for carpets @Shape: [] 
MinCarpetDemand = data['MinCarpetDemand']
# @Parameter MinTotalShipping @Def: Minimum total weekly shipping requirement @Shape: [] 
MinTotalShipping = data['MinTotalShipping']
# @Parameter MaxLaminateProduction @Def: Maximum weekly production capacity for laminate planks @Shape: [] 
MaxLaminateProduction = data['MaxLaminateProduction']
# @Parameter MaxCarpetProduction @Def: Maximum weekly production capacity for carpets @Shape: [] 
MaxCarpetProduction = data['MaxCarpetProduction']
# @Parameter LaminateProfitPerSqFt @Def: Profit per square foot for laminate planks @Shape: [] 
LaminateProfitPerSqFt = data['LaminateProfitPerSqFt']
# @Parameter CarpetProfitPerSqFt @Def: Profit per square foot for carpets @Shape: [] 
CarpetProfitPerSqFt = data['CarpetProfitPerSqFt']

# Variables 
# @Variable LaminateProduction @Def: The weekly production level of laminate planks @Shape: [] 
LaminateProduction = model.addVar(lb=0, ub=MaxLaminateProduction, vtype=GRB.CONTINUOUS, name=""LaminateProduction"")
# @Variable CarpetProduction @Def: The weekly production level of carpets @Shape: [] 
CarpetProduction = model.addVar(vtype=GRB.CONTINUOUS, name=""CarpetProduction"")

# Constraints 
# @Constraint Constr_1 @Def: The production level of laminate planks must be at least MinLaminateDemand.
model.addConstr(LaminateProduction >= MinLaminateDemand)
# @Constraint Constr_2 @Def: The production level of laminate planks must be no more than MaxLaminateProduction.
model.addConstr(LaminateProduction <= MaxLaminateProduction, ""LaminateProductionLimit"")
# @Constraint Constr_3 @Def: The production level of carpets must be at least MinCarpetDemand.
model.addConstr(CarpetProduction >= MinCarpetDemand)
# @Constraint Constr_4 @Def: The production level of carpets must be no more than MaxCarpetProduction.
model.addConstr(CarpetProduction <= MaxCarpetProduction)
# @Constraint Constr_5 @Def: The combined production levels of laminate planks and carpets must meet or exceed MinTotalShipping.
model.addConstr(LaminateProduction + CarpetProduction >= MinTotalShipping)

# Objective 
# @Objective Objective @Def: Total profit is calculated by multiplying the production level of laminate planks by LaminateProfitPerSqFt and the production level of carpets by CarpetProfitPerSqFt, then summing these two amounts. The objective is to maximize the total profit.
model.setObjective(LaminateProfitPerSqFt * LaminateProduction + CarpetProfitPerSqFt * CarpetProduction, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['LaminateProduction'] = LaminateProduction.x
variables['CarpetProduction'] = CarpetProduction.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A man takes two supplements to get his daily iron and calcium requirements. A pill of supplement A has 5 units of iron and 10 units of calcium. A pill of supplement B contains 4 units of iron and 15 units of calcium.  The man needs a minimum of 40 units of iron and 50 units of calcium per day. If the cost per pill of supplement A is $2 and the cost per pill of supplement B is  $3, how many of each should he buy to minimize costs?","{""variables"": {""NumPillsSupplement"": {""0"": 8.0, ""1"": 0.0}}, ""objective"": 16.0}","{""parametrized_description"": ""A person purchases a number of each of NumSupplements supplement types to meet the minimum requirements for NumNutrients nutrients. Each supplement type i provides NutrientContent[i][j] units of nutrient j and has a cost of CostPerPill[i] per pill. The objective is to minimize the total cost while ensuring that for each nutrient j, the total obtained is at least MinRequirement[j]."", ""keywords"": [""N.A.""], ""parameters"": {""NumSupplements"": {""description"": ""Number of supplement types"", ""shape"": []}, ""NumNutrients"": {""description"": ""Number of nutrient types"", ""shape"": []}, ""NutrientContent"": {""description"": ""Amount of nutrient j per pill of supplement i"", ""shape"": [""NumSupplements"", ""NumNutrients""]}, ""MinRequirement"": {""description"": ""Minimum required units of nutrient j"", ""shape"": [""NumNutrients""]}, ""CostPerPill"": {""description"": ""Cost per pill of supplement i"", ""shape"": [""NumSupplements""]}}, ""variables"": {""NumPillsSupplement"": {""description"": ""Number of pills of supplement i"", ""type"": ""continuous"", ""shape"": [""NumSupplements""]}}, ""constraints"": [{""description"": ""For each nutrient j, the total amount of nutrient j obtained from the supplements must be at least MinRequirement[j]."", ""formulation"": ""\\sum_{i=1}^{\\text{NumSupplements}} \\text{NutrientContent}_{i,j} \\cdot \\text{NumPillsSupplement}_{i} \\geq \\text{MinRequirement}_{j} \\quad \\forall j \\in \\{1, \\dots, \\text{NumNutrients}\\}"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(NutrientContent[i][j] * NumPillsSupplement[i] for i in range(NumSupplements)) >= MinRequirement[j] for j in range(NumNutrients)))""}}, {""description"": ""The number of pills purchased for each supplement must be a non-negative integer."", ""formulation"": ""NumPillsSupplement \\geq 0"", ""code"": {""gurobipy"": ""model.addConstrs((NumPillsSupplement[i] >= 0 for i in range(NumSupplements)), 'NumPillsSupplementNonNeg')""}}], ""objective"": {""description"": ""Minimize the total cost, which is the sum of CostPerPill[i] multiplied by the number of pills purchased for each supplement i, while ensuring that for each nutrient j, the total obtained is at least MinRequirement[j]."", ""formulation"": ""Min \\sum_{i=1}^{\\text{NumSupplements}} \\text{CostPerPill}_i \\times \\text{NumPillsSupplement}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(CostPerPill[i] * NumPillsSupplement[i] for i in range(NumSupplements)), GRB.MINIMIZE)""}}}","{""NumSupplements"": 2, ""NumNutrients"": 2, ""NutrientContent"": [[5, 10], [4, 15]], ""MinRequirement"": [40, 50], ""CostPerPill"": [2, 3]}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A person purchases a number of each of NumSupplements supplement types to meet
the minimum requirements for NumNutrients nutrients. Each supplement type i
provides NutrientContent[i][j] units of nutrient j and has a cost of
CostPerPill[i] per pill. The objective is to minimize the total cost while
ensuring that for each nutrient j, the total obtained is at least
MinRequirement[j].
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/202/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumSupplements @Def: Number of supplement types @Shape: [] 
NumSupplements = data['NumSupplements']
# @Parameter NumNutrients @Def: Number of nutrient types @Shape: [] 
NumNutrients = data['NumNutrients']
# @Parameter NutrientContent @Def: Amount of nutrient j per pill of supplement i @Shape: ['NumSupplements', 'NumNutrients'] 
NutrientContent = data['NutrientContent']
# @Parameter MinRequirement @Def: Minimum required units of nutrient j @Shape: ['NumNutrients'] 
MinRequirement = data['MinRequirement']
# @Parameter CostPerPill @Def: Cost per pill of supplement i @Shape: ['NumSupplements'] 
CostPerPill = data['CostPerPill']

# Variables 
# @Variable NumPillsSupplement @Def: Number of pills of supplement i @Shape: ['NumSupplements'] 
NumPillsSupplement = model.addVars(NumSupplements, vtype=GRB.INTEGER, name=""NumPillsSupplement"")

# Constraints 
# @Constraint Constr_1 @Def: For each nutrient j, the total amount of nutrient j obtained from the supplements must be at least MinRequirement[j].
model.addConstrs((quicksum(NutrientContent[i][j] * NumPillsSupplement[i] for i in range(NumSupplements)) >= MinRequirement[j] for j in range(NumNutrients)))
# @Constraint Constr_2 @Def: The number of pills purchased for each supplement must be a non-negative integer.
model.addConstrs((NumPillsSupplement[i] >= 0 for i in range(NumSupplements)), 'NumPillsSupplementNonNeg')

# Objective 
# @Objective Objective @Def: Minimize the total cost, which is the sum of CostPerPill[i] multiplied by the number of pills purchased for each supplement i, while ensuring that for each nutrient j, the total obtained is at least MinRequirement[j].
model.setObjective(quicksum(CostPerPill[i] * NumPillsSupplement[i] for i in range(NumSupplements)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumPillsSupplement'] = {i: NumPillsSupplement[i].X for i in range(NumSupplements)}
solution['variables'] = variables
solution['objective'] = model.objVal if model.status == GRB.OPTIMAL else None
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
A fashion company sells regular handbags and premium handbags made of higher quality material. They can sell regular handbags at a profit of $30 each and premium handbags at a profit of $180 each. The total monthly cost of manufacturing is $200 per regular handbag and $447 per premium handbag. The company has a total budget of $250000 and can sell at most 475 handbags of either type per month. How many of each handbag should they sell to maximize its monthly profit?,"{""variables"": {""NumberRegularHandbags"": -0.0, ""NumberPremiumHandbags"": 475.0}, ""objective"": 85500.0}","{""parametrized_description"": ""The company sells a quantity of regular handbags and a quantity of premium handbags, generating profits equal to RegularHandbagProfit multiplied by the number of regular handbags and PremiumHandbagProfit multiplied by the number of premium handbags. The total manufacturing cost is calculated as RegularHandbagCost multiplied by the number of regular handbags plus PremiumHandbagCost multiplied by the number of premium handbags, which must not exceed TotalBudget. Additionally, the combined number of regular and premium handbags sold must not exceed MaxHandbagsPerMonth. The objective is to determine the quantities of each type of handbag to sell in order to maximize the total profit."", ""keywords"": [""N.A.""], ""parameters"": {""RegularHandbagProfit"": {""description"": ""Profit per regular handbag"", ""shape"": []}, ""PremiumHandbagProfit"": {""description"": ""Profit per premium handbag"", ""shape"": []}, ""RegularHandbagCost"": {""description"": ""Manufacturing cost per regular handbag"", ""shape"": []}, ""PremiumHandbagCost"": {""description"": ""Manufacturing cost per premium handbag"", ""shape"": []}, ""TotalBudget"": {""description"": ""Total budget available for manufacturing"", ""shape"": []}, ""MaxHandbagsPerMonth"": {""description"": ""Maximum number of handbags that can be sold per month"", ""shape"": []}}, ""variables"": {""NumberRegularHandbags"": {""description"": ""The number of regular handbags to manufacture"", ""type"": ""continuous"", ""shape"": [""Integer"", ""NonNegative""]}, ""NumberPremiumHandbags"": {""description"": ""The number of premium handbags to manufacture"", ""type"": ""continuous"", ""shape"": [""Integer"", ""NonNegative""]}}, ""constraints"": [{""description"": ""The total manufacturing cost, calculated as RegularHandbagCost multiplied by the number of regular handbags plus PremiumHandbagCost multiplied by the number of premium handbags, must not exceed TotalBudget."", ""formulation"": ""RegularHandbagCost \\times NumberRegularHandbags + PremiumHandbagCost \\times NumberPremiumHandbags \\leq TotalBudget"", ""code"": {""gurobipy"": ""model.addConstr(RegularHandbagCost * NumberRegularHandbags + PremiumHandbagCost * NumberPremiumHandbags <= TotalBudget)""}}, {""description"": ""The combined number of regular and premium handbags sold must not exceed MaxHandbagsPerMonth."", ""formulation"": ""NumberRegularHandbags + NumberPremiumHandbags \\leq MaxHandbagsPerMonth"", ""code"": {""gurobipy"": ""model.addConstr(NumberRegularHandbags + NumberPremiumHandbags <= MaxHandbagsPerMonth)""}}], ""objective"": {""description"": ""Maximize the total profit, which is the sum of RegularHandbagProfit multiplied by the number of regular handbags and PremiumHandbagProfit multiplied by the number of premium handbags."", ""formulation"": ""Max \\ RegularHandbagProfit \\cdot NumberRegularHandbags + PremiumHandbagProfit \\cdot NumberPremiumHandbags"", ""code"": {""gurobipy"": ""model.setObjective(RegularHandbagProfit * NumberRegularHandbags + PremiumHandbagProfit * NumberPremiumHandbags, GRB.MAXIMIZE)""}}}","{""RegularHandbagProfit"": 30, ""PremiumHandbagProfit"": 180, ""RegularHandbagCost"": 200, ""PremiumHandbagCost"": 447, ""TotalBudget"": 250000, ""MaxHandbagsPerMonth"": 475}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
The company sells a quantity of regular handbags and a quantity of premium
handbags, generating profits equal to RegularHandbagProfit multiplied by the
number of regular handbags and PremiumHandbagProfit multiplied by the number of
premium handbags. The total manufacturing cost is calculated as
RegularHandbagCost multiplied by the number of regular handbags plus
PremiumHandbagCost multiplied by the number of premium handbags, which must not
exceed TotalBudget. Additionally, the combined number of regular and premium
handbags sold must not exceed MaxHandbagsPerMonth. The objective is to determine
the quantities of each type of handbag to sell in order to maximize the total
profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/203/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter RegularHandbagProfit @Def: Profit per regular handbag @Shape: [] 
RegularHandbagProfit = data['RegularHandbagProfit']
# @Parameter PremiumHandbagProfit @Def: Profit per premium handbag @Shape: [] 
PremiumHandbagProfit = data['PremiumHandbagProfit']
# @Parameter RegularHandbagCost @Def: Manufacturing cost per regular handbag @Shape: [] 
RegularHandbagCost = data['RegularHandbagCost']
# @Parameter PremiumHandbagCost @Def: Manufacturing cost per premium handbag @Shape: [] 
PremiumHandbagCost = data['PremiumHandbagCost']
# @Parameter TotalBudget @Def: Total budget available for manufacturing @Shape: [] 
TotalBudget = data['TotalBudget']
# @Parameter MaxHandbagsPerMonth @Def: Maximum number of handbags that can be sold per month @Shape: [] 
MaxHandbagsPerMonth = data['MaxHandbagsPerMonth']

# Variables 
# @Variable NumberRegularHandbags @Def: The number of regular handbags to manufacture @Shape: ['Integer', 'NonNegative'] 
NumberRegularHandbags = model.addVar(vtype=GRB.INTEGER, lb=0, name=""NumberRegularHandbags"")
# @Variable NumberPremiumHandbags @Def: The number of premium handbags to manufacture @Shape: ['Integer', 'NonNegative'] 
NumberPremiumHandbags = model.addVar(vtype=GRB.INTEGER, lb=0, name=""NumberPremiumHandbags"")

# Constraints 
# @Constraint Constr_1 @Def: The total manufacturing cost, calculated as RegularHandbagCost multiplied by the number of regular handbags plus PremiumHandbagCost multiplied by the number of premium handbags, must not exceed TotalBudget.
model.addConstr(RegularHandbagCost * NumberRegularHandbags + PremiumHandbagCost * NumberPremiumHandbags <= TotalBudget)
# @Constraint Constr_2 @Def: The combined number of regular and premium handbags sold must not exceed MaxHandbagsPerMonth.
model.addConstr(NumberRegularHandbags + NumberPremiumHandbags <= MaxHandbagsPerMonth)

# Objective 
# @Objective Objective @Def: Maximize the total profit, which is the sum of RegularHandbagProfit multiplied by the number of regular handbags and PremiumHandbagProfit multiplied by the number of premium handbags.
model.setObjective(RegularHandbagProfit * NumberRegularHandbags + PremiumHandbagProfit * NumberPremiumHandbags, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberRegularHandbags'] = NumberRegularHandbags.x
variables['NumberPremiumHandbags'] = NumberPremiumHandbags.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A woman has $100000 to gamble on two sports bets: a basketball tournament, a horse race, and a soccer game. Based on simple analysis, the woman determines her chance of losing her money would be 50% for basketball tournament, 25% for horse race, and 10% for the soccer game. The payout for each dollar put on each bet will be $1.2 for basketball tournament, $0.5 for horse race, and $0.1 for the soccer game. Knowing herself, she limits her average chance of losing her money should be at most 30%. Could you help her determine how much to money to put on each sport bet to maximize her average payout?","{""variables"": {""Allocation"": {""0"": 20000.0, ""1"": 80000.0, ""2"": 0.0}}, ""objective"": 42000.0}","{""parametrized_description"": ""A woman has TotalMoney to gamble on NumBets different sports bets. Each sport bet has a loss probability given by LossProbabilities and a payout per dollar given by Payouts. She limits her average chance of losing her money to at most MaxAverageLossProbability. Determine the allocation of money to each sport bet to maximize her average payout."", ""keywords"": [""N.A.""], ""parameters"": {""TotalMoney"": {""description"": ""Total amount of money available to gamble"", ""shape"": []}, ""NumBets"": {""description"": ""Number of different sports bets"", ""shape"": []}, ""LossProbabilities"": {""description"": ""Chance of losing money for each sport bet"", ""shape"": [""NumBets""]}, ""Payouts"": {""description"": ""Payout per dollar for each sport bet"", ""shape"": [""NumBets""]}, ""MaxAverageLossProbability"": {""description"": ""Maximum average chance of losing money"", ""shape"": []}}, ""variables"": {""Allocation"": {""description"": ""The amount of money allocated to each sports bet"", ""type"": ""continuous"", ""shape"": [""NumBets""]}}, ""constraints"": [{""description"": ""The sum of allocations to all sports bets must equal TotalMoney."", ""formulation"": ""\\sum_{i=1}^{NumBets} Allocation_i = TotalMoney"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(Allocation[i] for i in range(NumBets)) == TotalMoney)""}}, {""description"": ""The weighted average of LossProbabilities, based on the allocation, must not exceed MaxAverageLossProbability."", ""formulation"": ""\\sum_{i=1}^{NumBets} Allocation_i \\cdot LossProbabilities_i \\leq TotalMoney \\cdot MaxAverageLossProbability"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(Allocation[i] * LossProbabilities[i] for i in range(NumBets)) <= TotalMoney * MaxAverageLossProbability)""}}], ""objective"": {""description"": ""Maximize the total expected payout from all sports bets."", ""formulation"": ""Max \\sum_{i=1}^{NumBets} Allocation_i \\cdot Payouts_i \\cdot (1 - LossProbabilities_i)"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(Allocation[i] * Payouts[i] * (1 - LossProbabilities[i]) for i in range(NumBets)), GRB.MAXIMIZE)""}}}","{""TotalMoney"": 100000, ""NumBets"": 3, ""LossProbabilities"": [0.5, 0.25, 0.1], ""Payouts"": [1.2, 0.5, 0.1], ""MaxAverageLossProbability"": 0.3}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A woman has TotalMoney to gamble on NumBets different sports bets. Each sport
bet has a loss probability given by LossProbabilities and a payout per dollar
given by Payouts. She limits her average chance of losing her money to at most
MaxAverageLossProbability. Determine the allocation of money to each sport bet
to maximize her average payout.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/204/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalMoney @Def: Total amount of money available to gamble @Shape: [] 
TotalMoney = data['TotalMoney']
# @Parameter NumBets @Def: Number of different sports bets @Shape: [] 
NumBets = data['NumBets']
# @Parameter LossProbabilities @Def: Chance of losing money for each sport bet @Shape: ['NumBets'] 
LossProbabilities = data['LossProbabilities']
# @Parameter Payouts @Def: Payout per dollar for each sport bet @Shape: ['NumBets'] 
Payouts = data['Payouts']
# @Parameter MaxAverageLossProbability @Def: Maximum average chance of losing money @Shape: [] 
MaxAverageLossProbability = data['MaxAverageLossProbability']

# Variables 
# @Variable Allocation @Def: The amount of money allocated to each sports bet @Shape: ['NumBets'] 
Allocation = model.addVars(NumBets, vtype=GRB.CONTINUOUS, name=""Allocation"")

# Constraints 
# @Constraint Constr_1 @Def: The sum of allocations to all sports bets must equal TotalMoney.
model.addConstr(quicksum(Allocation[i] for i in range(NumBets)) == TotalMoney)
# @Constraint Constr_2 @Def: The weighted average of LossProbabilities, based on the allocation, must not exceed MaxAverageLossProbability.
model.addConstr(quicksum(Allocation[i] * LossProbabilities[i] for i in range(NumBets)) <= TotalMoney * MaxAverageLossProbability)

# Objective 
# @Objective Objective @Def: Maximize the total expected payout from all sports bets.
model.setObjective(quicksum(Allocation[i] * Payouts[i] * (1 - LossProbabilities[i]) for i in range(NumBets)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Allocation'] = {i: Allocation[i].x for i in range(NumBets)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A repairman fixes washing machines and freezers. Each washing machine takes 30 minutes of inspection and 90 minutes of fixing time. Each freezer takes 20 minutes of inspection and 125 minutes of fixing time. The repairman has 5000 minutes available for inspection and 20000 minutes available in his schedule. If each washing machine repaired earns him $250 and each freezer repaired earns his $375, how many of each appliance should he fix to maximize his earnings?","{""variables"": {""WashingMachinesInspected"": 0.0, ""FreezersInspected"": 0.0, ""WashingMachinesRepaired"": -0.0, ""FreezersRepaired"": 160.0}, ""objective"": 60000.0}","{""parametrized_description"": ""A repairman repairs WashingMachines and Freezers. Each WashingMachine requires InspectionTimeWashingMachine minutes for inspection and FixingTimeWashingMachine minutes for fixing, while each Freezer requires InspectionTimeFreezer minutes for inspection and FixingTimeFreezer minutes for fixing. The total available InspectionTime is TotalInspectionTime minutes and the total available schedule time is TotalScheduleTime minutes. Repairing each WashingMachine yields EarningsPerWashingMachine and each Freezer yields EarningsPerFreezer. Determine the number of WashingMachines and Freezers to repair to maximize total earnings."", ""keywords"": [""N.A.""], ""parameters"": {""InspectionTimeWashingMachine"": {""description"": ""Time required to inspect one washing machine"", ""shape"": []}, ""FixingTimeWashingMachine"": {""description"": ""Time required to fix one washing machine"", ""shape"": []}, ""InspectionTimeFreezer"": {""description"": ""Time required to inspect one freezer"", ""shape"": []}, ""FixingTimeFreezer"": {""description"": ""Time required to fix one freezer"", ""shape"": []}, ""TotalInspectionTime"": {""description"": ""Total available time for inspections"", ""shape"": []}, ""TotalScheduleTime"": {""description"": ""Total available schedule time"", ""shape"": []}, ""EarningsPerWashingMachine"": {""description"": ""Earnings per washing machine repaired"", ""shape"": []}, ""EarningsPerFreezer"": {""description"": ""Earnings per freezer repaired"", ""shape"": []}}, ""variables"": {""WashingMachinesInspected"": {""description"": ""The number of washing machines to inspect"", ""type"": ""continuous"", ""shape"": []}, ""FreezersInspected"": {""description"": ""The number of freezers to inspect"", ""type"": ""continuous"", ""shape"": []}, ""WashingMachinesRepaired"": {""description"": ""The number of washing machines to repair"", ""type"": ""continuous"", ""shape"": []}, ""FreezersRepaired"": {""description"": ""The number of freezers to repair"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total inspection time for washing machines and freezers must not exceed the available TotalInspectionTime."", ""formulation"": ""InspectionTimeWashingMachine \\cdot WashingMachinesInspected + InspectionTimeFreezer \\cdot FreezersInspected \\leq TotalInspectionTime"", ""code"": {""gurobipy"": ""model.addConstr(InspectionTimeWashingMachine * WashingMachinesInspected + InspectionTimeFreezer * FreezersInspected <= TotalInspectionTime)""}}, {""description"": ""The total schedule time for repairing washing machines and freezers must not exceed the available TotalScheduleTime."", ""formulation"": ""FixingTimeWashingMachine \\times WashingMachinesRepaired + FixingTimeFreezer \\times FreezersRepaired \\leq TotalScheduleTime"", ""code"": {""gurobipy"": ""model.addConstr(FixingTimeWashingMachine * WashingMachinesRepaired + FixingTimeFreezer * FreezersRepaired <= TotalScheduleTime)""}}], ""objective"": {""description"": ""Total earnings is the sum of earnings from washing machines and freezers. The objective is to maximize the total earnings."", ""formulation"": ""Max EarningsPerWashingMachine \\times WashingMachinesRepaired + EarningsPerFreezer \\times FreezersRepaired"", ""code"": {""gurobipy"": ""model.setObjective(EarningsPerWashingMachine * WashingMachinesRepaired + EarningsPerFreezer * FreezersRepaired, GRB.MAXIMIZE)""}}}","{""InspectionTimeWashingMachine"": 30, ""FixingTimeWashingMachine"": 90, ""InspectionTimeFreezer"": 20, ""FixingTimeFreezer"": 125, ""TotalInspectionTime"": 5000, ""TotalScheduleTime"": 20000, ""EarningsPerWashingMachine"": 250, ""EarningsPerFreezer"": 375}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A repairman repairs WashingMachines and Freezers. Each WashingMachine requires
InspectionTimeWashingMachine minutes for inspection and FixingTimeWashingMachine
minutes for fixing, while each Freezer requires InspectionTimeFreezer minutes
for inspection and FixingTimeFreezer minutes for fixing. The total available
InspectionTime is TotalInspectionTime minutes and the total available schedule
time is TotalScheduleTime minutes. Repairing each WashingMachine yields
EarningsPerWashingMachine and each Freezer yields EarningsPerFreezer. Determine
the number of WashingMachines and Freezers to repair to maximize total earnings.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/205/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter InspectionTimeWashingMachine @Def: Time required to inspect one washing machine @Shape: [] 
InspectionTimeWashingMachine = data['InspectionTimeWashingMachine']
# @Parameter FixingTimeWashingMachine @Def: Time required to fix one washing machine @Shape: [] 
FixingTimeWashingMachine = data['FixingTimeWashingMachine']
# @Parameter InspectionTimeFreezer @Def: Time required to inspect one freezer @Shape: [] 
InspectionTimeFreezer = data['InspectionTimeFreezer']
# @Parameter FixingTimeFreezer @Def: Time required to fix one freezer @Shape: [] 
FixingTimeFreezer = data['FixingTimeFreezer']
# @Parameter TotalInspectionTime @Def: Total available time for inspections @Shape: [] 
TotalInspectionTime = data['TotalInspectionTime']
# @Parameter TotalScheduleTime @Def: Total available schedule time @Shape: [] 
TotalScheduleTime = data['TotalScheduleTime']
# @Parameter EarningsPerWashingMachine @Def: Earnings per washing machine repaired @Shape: [] 
EarningsPerWashingMachine = data['EarningsPerWashingMachine']
# @Parameter EarningsPerFreezer @Def: Earnings per freezer repaired @Shape: [] 
EarningsPerFreezer = data['EarningsPerFreezer']

# Variables 
# @Variable WashingMachinesInspected @Def: The number of washing machines to inspect @Shape: [] 
WashingMachinesInspected = model.addVar(vtype=GRB.CONTINUOUS, name=""WashingMachinesInspected"")
# @Variable FreezersInspected @Def: The number of freezers to inspect @Shape: [] 
FreezersInspected = model.addVar(vtype=GRB.CONTINUOUS, name=""FreezersInspected"")
# @Variable WashingMachinesRepaired @Def: The number of washing machines to repair @Shape: [] 
WashingMachinesRepaired = model.addVar(vtype=GRB.INTEGER, name=""WashingMachinesRepaired"")
# @Variable FreezersRepaired @Def: The number of freezers to repair @Shape: [] 
FreezersRepaired = model.addVar(vtype=GRB.CONTINUOUS, name=""FreezersRepaired"")

# Constraints 
# @Constraint Constr_1 @Def: The total inspection time for washing machines and freezers must not exceed the available TotalInspectionTime.
model.addConstr(InspectionTimeWashingMachine * WashingMachinesInspected + InspectionTimeFreezer * FreezersInspected <= TotalInspectionTime)
# @Constraint Constr_2 @Def: The total schedule time for repairing washing machines and freezers must not exceed the available TotalScheduleTime.
model.addConstr(FixingTimeWashingMachine * WashingMachinesRepaired + FixingTimeFreezer * FreezersRepaired <= TotalScheduleTime)

# Objective 
# @Objective Objective @Def: Total earnings is the sum of earnings from washing machines and freezers. The objective is to maximize the total earnings.
model.setObjective(EarningsPerWashingMachine * WashingMachinesRepaired + EarningsPerFreezer * FreezersRepaired, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['WashingMachinesInspected'] = WashingMachinesInspected.x
variables['FreezersInspected'] = FreezersInspected.x
variables['WashingMachinesRepaired'] = WashingMachinesRepaired.x
variables['FreezersRepaired'] = FreezersRepaired.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A small bakery has 20000 grams of batter and 14000 grams of milk to make their crepe cakes, sponge cakes, and birthday cakes. A crepe cake needs 400 grams of batter and 200 grams of milk. A sponge cake requires 500 grams of batter and 300 grams of milk. A birthday cake requires 450 grams of batter and 350 grams of milk. If the profit per crepe cake is $12, the profit per sponge cake is $10, and the profit per birthday cake is $15, how many of each should the bakery make to maximize their profit?","{""variables"": {""UnitsToProduce"": {""0"": 14.0, ""1"": 0.0, ""2"": 32.0}}, ""objective"": 648.0}","{""parametrized_description"": ""A bakery has BatterAvailable grams of batter and MilkAvailable grams of milk to produce NumProducts different products. Each product requires a specific amount of batter as defined by BatterPerProduct and a specific amount of milk as defined by MilkPerProduct. The profit earned from each product is given by ProfitPerProduct. The bakery aims to determine the number of each product to produce in order to maximize total profit."", ""keywords"": [""N.A.""], ""parameters"": {""BatterAvailable"": {""description"": ""Total amount of batter available (in grams)"", ""shape"": []}, ""MilkAvailable"": {""description"": ""Total amount of milk available (in grams)"", ""shape"": []}, ""NumProducts"": {""description"": ""Number of different products"", ""shape"": []}, ""BatterPerProduct"": {""description"": ""Amount of batter required to produce one unit of each product"", ""shape"": [""NumProducts""]}, ""MilkPerProduct"": {""description"": ""Amount of milk required to produce one unit of each product"", ""shape"": [""NumProducts""]}, ""ProfitPerProduct"": {""description"": ""Profit per unit of each product"", ""shape"": [""NumProducts""]}}, ""variables"": {""UnitsToProduce"": {""description"": ""The number of units to produce for each product"", ""type"": ""continuous"", ""shape"": [""NumProducts""]}}, ""constraints"": [{""description"": ""The total batter used to produce all products cannot exceed BatterAvailable grams."", ""formulation"": ""\\sum_{i=1}^{\\text{NumProducts}} \\text{BatterPerProduct}_i \\times \\text{UnitsToProduce}_i \\leq \\text{BatterAvailable}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(BatterPerProduct[i] * UnitsToProduce[i] for i in range(NumProducts)) <= BatterAvailable)""}}, {""description"": ""The total milk used to produce all products cannot exceed MilkAvailable grams."", ""formulation"": ""\\sum_{i=1}^{NumProducts} MilkPerProduct_i \\cdot UnitsToProduce_i \\leq MilkAvailable"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(MilkPerProduct[i] * UnitsToProduce[i] for i in range(NumProducts)) <= MilkAvailable)""}}], ""objective"": {""description"": ""Total profit is the sum of the profits from all products produced. The objective is to maximize the total profit."", ""formulation"": ""Max \\sum_{i=1}^{\\text{NumProducts}} \\text{ProfitPerProduct}_i \\times \\text{UnitsToProduce}_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(UnitsToProduce[i] * ProfitPerProduct[i] for i in range(NumProducts)), GRB.MAXIMIZE)""}}}","{""BatterAvailable"": 20000, ""MilkAvailable"": 14000, ""NumProducts"": 3, ""BatterPerProduct"": [400, 500, 450], ""MilkPerProduct"": [200, 300, 350], ""ProfitPerProduct"": [12, 10, 15]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A bakery has BatterAvailable grams of batter and MilkAvailable grams of milk to
produce NumProducts different products. Each product requires a specific amount
of batter as defined by BatterPerProduct and a specific amount of milk as
defined by MilkPerProduct. The profit earned from each product is given by
ProfitPerProduct. The bakery aims to determine the number of each product to
produce in order to maximize total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/206/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter BatterAvailable @Def: Total amount of batter available (in grams) @Shape: [] 
BatterAvailable = data['BatterAvailable']
# @Parameter MilkAvailable @Def: Total amount of milk available (in grams) @Shape: [] 
MilkAvailable = data['MilkAvailable']
# @Parameter NumProducts @Def: Number of different products @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter BatterPerProduct @Def: Amount of batter required to produce one unit of each product @Shape: ['NumProducts'] 
BatterPerProduct = data['BatterPerProduct']
# @Parameter MilkPerProduct @Def: Amount of milk required to produce one unit of each product @Shape: ['NumProducts'] 
MilkPerProduct = data['MilkPerProduct']
# @Parameter ProfitPerProduct @Def: Profit per unit of each product @Shape: ['NumProducts'] 
ProfitPerProduct = data['ProfitPerProduct']

# Variables 
# @Variable UnitsToProduce @Def: The number of units to produce for each product @Shape: ['NumProducts'] 
UnitsToProduce = model.addVars(NumProducts, vtype=GRB.CONTINUOUS, name=""UnitsToProduce"")

# Constraints 
# @Constraint Constr_1 @Def: The total batter used to produce all products cannot exceed BatterAvailable grams.
model.addConstr(quicksum(BatterPerProduct[i] * UnitsToProduce[i] for i in range(NumProducts)) <= BatterAvailable)
# @Constraint Constr_2 @Def: The total milk used to produce all products cannot exceed MilkAvailable grams.
model.addConstr(quicksum(MilkPerProduct[i] * UnitsToProduce[i] for i in range(NumProducts)) <= MilkAvailable)

# Objective 
# @Objective Objective @Def: Total profit is the sum of the profits from all products produced. The objective is to maximize the total profit.
model.setObjective(quicksum(UnitsToProduce[i] * ProfitPerProduct[i] for i in range(NumProducts)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['UnitsToProduce'] = model.getAttr(""X"", UnitsToProduce)
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Super Shop sells cat paw snacks and gold shark snacks in bulk. It plans to sell them into two snack mix products. The first mix contains 20% cat paw snacks and 80% gold shark snacks. The second mix contains 35% cat paw snacks and 65% gold shark snacks. The store has on hand 20 kg of cat paw snacks and 50 kg of gold shark snacks. If the profit per kg of the first mix is $12 and the profit per kg of the second mix is $15, how many kg of each should be prepared to maximize profit?","{""variables"": {""Mix1"": 1.0, ""Mix2"": 0.0}, ""objective"": 12.0}","{""parametrized_description"": ""Super Shop sells two types of snack mixes. The first mix contains PercentageCatPawMix1 of cat paw snacks and a corresponding percentage of gold shark snacks. The second mix contains PercentageCatPawMix2 of cat paw snacks and a corresponding percentage of gold shark snacks. The store has AvailableCatPawKg kilograms of cat paw snacks and AvailableGoldSharkKg kilograms of gold shark snacks available. The profit per kilogram of the first mix is ProfitPerKgMix1 and the profit per kilogram of the second mix is ProfitPerKgMix2. Determine the number of kilograms of each mix to prepare in order to maximize profit."", ""keywords"": [""N.A.""], ""parameters"": {""PercentageCatPawMix1"": {""description"": ""Percentage of cat paw snacks in the first mix"", ""shape"": []}, ""PercentageCatPawMix2"": {""description"": ""Percentage of cat paw snacks in the second mix"", ""shape"": []}, ""AvailableCatPawKg"": {""description"": ""Available kilograms of cat paw snacks"", ""shape"": []}, ""AvailableGoldSharkKg"": {""description"": ""Available kilograms of gold shark snacks"", ""shape"": []}, ""ProfitPerKgMix1"": {""description"": ""Profit per kilogram of the first mix"", ""shape"": []}, ""ProfitPerKgMix2"": {""description"": ""Profit per kilogram of the second mix"", ""shape"": []}}, ""variables"": {""Mix1"": {""description"": ""The quantity of the first mix in kilograms"", ""type"": ""continuous"", ""shape"": []}, ""Mix2"": {""description"": ""The quantity of the second mix in kilograms"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total cat paw snacks used in both mixes must not exceed AvailableCatPawKg kilograms, calculated as (PercentageCatPawMix1 * Mix1) + (PercentageCatPawMix2 * Mix2)."", ""formulation"": ""PercentageCatPawMix1 \\times Mix1 + PercentageCatPawMix2 \\times Mix2 \\leq AvailableCatPawKg"", ""code"": {""gurobipy"": ""model.addConstr(PercentageCatPawMix1 * Mix1 + PercentageCatPawMix2 * Mix2 <= AvailableCatPawKg)""}}, {""description"": ""The total gold shark snacks used in both mixes must not exceed AvailableGoldSharkKg kilograms, calculated as ((100 - PercentageCatPawMix1) * Mix1) + ((100 - PercentageCatPawMix2) * Mix2)."", ""formulation"": ""\\frac{(100 - PercentageCatPawMix1)}{100} \\cdot Mix1 + \\frac{(100 - PercentageCatPawMix2)}{100} \\cdot Mix2 \\leq AvailableGoldSharkKg"", ""code"": {""gurobipy"": ""model.addConstr(((100 - PercentageCatPawMix1) / 100) * Mix1 + ((100 - PercentageCatPawMix2) / 100) * Mix2 <= AvailableGoldSharkKg)""}}], ""objective"": {""description"": ""The objective is to maximize the total profit, calculated as (ProfitPerKgMix1 * Mix1) + (ProfitPerKgMix2 * Mix2)."", ""formulation"": ""Max \\left( ProfitPerKgMix1 \\times Mix1 + ProfitPerKgMix2 \\times Mix2 \\right)"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPerKgMix1 * Mix1 + ProfitPerKgMix2 * Mix2, GRB.MAXIMIZE)""}}}","{""PercentageCatPawMix1"": 20, ""PercentageCatPawMix2"": 35, ""AvailableCatPawKg"": 20, ""AvailableGoldSharkKg"": 50, ""ProfitPerKgMix1"": 12, ""ProfitPerKgMix2"": 15}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Super Shop sells two types of snack mixes. The first mix contains
PercentageCatPawMix1 of cat paw snacks and a corresponding percentage of gold
shark snacks. The second mix contains PercentageCatPawMix2 of cat paw snacks and
a corresponding percentage of gold shark snacks. The store has AvailableCatPawKg
kilograms of cat paw snacks and AvailableGoldSharkKg kilograms of gold shark
snacks available. The profit per kilogram of the first mix is ProfitPerKgMix1
and the profit per kilogram of the second mix is ProfitPerKgMix2. Determine the
number of kilograms of each mix to prepare in order to maximize profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/207/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter PercentageCatPawMix1 @Def: Percentage of cat paw snacks in the first mix @Shape: [] 
PercentageCatPawMix1 = data['PercentageCatPawMix1']
# @Parameter PercentageCatPawMix2 @Def: Percentage of cat paw snacks in the second mix @Shape: [] 
PercentageCatPawMix2 = data['PercentageCatPawMix2']
# @Parameter AvailableCatPawKg @Def: Available kilograms of cat paw snacks @Shape: [] 
AvailableCatPawKg = data['AvailableCatPawKg']
# @Parameter AvailableGoldSharkKg @Def: Available kilograms of gold shark snacks @Shape: [] 
AvailableGoldSharkKg = data['AvailableGoldSharkKg']
# @Parameter ProfitPerKgMix1 @Def: Profit per kilogram of the first mix @Shape: [] 
ProfitPerKgMix1 = data['ProfitPerKgMix1']
# @Parameter ProfitPerKgMix2 @Def: Profit per kilogram of the second mix @Shape: [] 
ProfitPerKgMix2 = data['ProfitPerKgMix2']

# Variables 
# @Variable Mix1 @Def: The quantity of the first mix in kilograms @Shape: [] 
Mix1 = model.addVar(vtype=GRB.CONTINUOUS, name=""Mix1"")
# @Variable Mix2 @Def: The quantity of the second mix in kilograms @Shape: [] 
Mix2 = model.addVar(vtype=GRB.CONTINUOUS, name=""Mix2"")

# Constraints 
# @Constraint Constr_1 @Def: The total cat paw snacks used in both mixes must not exceed AvailableCatPawKg kilograms, calculated as (PercentageCatPawMix1 * Mix1) + (PercentageCatPawMix2 * Mix2).
model.addConstr(PercentageCatPawMix1 * Mix1 + PercentageCatPawMix2 * Mix2 <= AvailableCatPawKg)
# @Constraint Constr_2 @Def: The total gold shark snacks used in both mixes must not exceed AvailableGoldSharkKg kilograms, calculated as ((100 - PercentageCatPawMix1) * Mix1) + ((100 - PercentageCatPawMix2) * Mix2).
model.addConstr(((100 - PercentageCatPawMix1) / 100) * Mix1 + ((100 - PercentageCatPawMix2) / 100) * Mix2 <= AvailableGoldSharkKg)

# Objective 
# @Objective Objective @Def: The objective is to maximize the total profit, calculated as (ProfitPerKgMix1 * Mix1) + (ProfitPerKgMix2 * Mix2).
model.setObjective(ProfitPerKgMix1 * Mix1 + ProfitPerKgMix2 * Mix2, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['Mix1'] = Mix1.x
variables['Mix2'] = Mix2.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
A taco stand sells regular tacos and deluxe tacos with extra meat. The stand makes x1 regular tacos at a profit of $2.50 each and x2 deluxe tacos at a profit of $3.55 each (x1 and x2 are unknown variables both greater than or equal to 0). There is a demand for at most 50 regular tacos and at most 40 deluxe tacos. The stand only has enough supplies to sell at most 70 tacos of either type. How many of each taco should the stand make to maximize profit?,"{""variables"": {""RegularTacosProduced"": 30.0, ""DeluxeTacosProduced"": 40.0}, ""objective"": 217.0}","{""parametrized_description"": ""A taco stand sells regular tacos and deluxe tacos with extra meat. The stand makes x1 regular tacos at a profit of ProfitPerRegularTaco each and x2 deluxe tacos at a profit of ProfitPerDeluxeTaco each (x1 and x2 are unknown variables both greater than or equal to 0). There is a demand for at most MaxDemandRegularTacos regular tacos and at most MaxDemandDeluxeTacos deluxe tacos. The stand only has enough supplies to sell at most MaxTotalSupplyTacos tacos of either type. How many of each taco should the stand make to maximize profit?"", ""keywords"": [""N.A.""], ""parameters"": {""ProfitPerRegularTaco"": {""description"": ""Profit per regular taco"", ""shape"": []}, ""ProfitPerDeluxeTaco"": {""description"": ""Profit per deluxe taco"", ""shape"": []}, ""MaxDemandRegularTacos"": {""description"": ""Maximum demand for regular tacos"", ""shape"": []}, ""MaxDemandDeluxeTacos"": {""description"": ""Maximum demand for deluxe tacos"", ""shape"": []}, ""MaxTotalSupplyTacos"": {""description"": ""Maximum total supply of tacos"", ""shape"": []}}, ""variables"": {""RegularTacosProduced"": {""description"": ""The number of regular tacos produced"", ""type"": ""continuous"", ""shape"": []}, ""DeluxeTacosProduced"": {""description"": ""The number of deluxe tacos produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of regular tacos produced does not exceed the maximum demand for regular tacos."", ""formulation"": ""RegularTacosProduced \\leq MaxDemandRegularTacos"", ""code"": {""gurobipy"": ""model.addConstr(RegularTacosProduced <= MaxDemandRegularTacos)""}}, {""description"": ""The number of deluxe tacos produced does not exceed the maximum demand for deluxe tacos."", ""formulation"": ""DeluxeTacosProduced \\leq MaxDemandDeluxeTacos"", ""code"": {""gurobipy"": ""model.addConstr(DeluxeTacosProduced <= MaxDemandDeluxeTacos)""}}, {""description"": ""The total number of tacos produced does not exceed the maximum total supply of tacos."", ""formulation"": ""RegularTacosProduced + DeluxeTacosProduced \\leq MaxTotalSupplyTacos"", ""code"": {""gurobipy"": ""model.addConstr(RegularTacosProduced + DeluxeTacosProduced <= MaxTotalSupplyTacos)""}}, {""description"": ""The number of regular tacos produced is non-negative."", ""formulation"": ""RegularTacosProduced \\geq 0"", ""code"": {""gurobipy"": ""model.addConstr(RegularTacosProduced >= 0)""}}, {""description"": ""The number of deluxe tacos produced is non-negative."", ""formulation"": ""DeluxeTacosProduced \\geq 0"", ""code"": {""gurobipy"": ""model.addConstr(DeluxeTacosProduced >= 0)""}}], ""objective"": {""description"": ""The objective is to maximize the total profit, calculated as the sum of the profits from regular and deluxe tacos."", ""formulation"": ""Max \\ ProfitPerRegularTaco \\times RegularTacosProduced + ProfitPerDeluxeTaco \\times DeluxeTacosProduced"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPerRegularTaco * RegularTacosProduced + ProfitPerDeluxeTaco * DeluxeTacosProduced, GRB.MAXIMIZE)""}}}","{""ProfitPerRegularTaco"": 2.5, ""ProfitPerDeluxeTaco"": 3.55, ""MaxDemandRegularTacos"": 50, ""MaxDemandDeluxeTacos"": 40, ""MaxTotalSupplyTacos"": 70}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A taco stand sells regular tacos and deluxe tacos with extra meat. The stand
makes x1 regular tacos at a profit of ProfitPerRegularTaco each and x2 deluxe
tacos at a profit of ProfitPerDeluxeTaco each (x1 and x2 are unknown variables
both greater than or equal to 0). There is a demand for at most
MaxDemandRegularTacos regular tacos and at most MaxDemandDeluxeTacos deluxe
tacos. The stand only has enough supplies to sell at most MaxTotalSupplyTacos
tacos of either type. How many of each taco should the stand make to maximize
profit?
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/208/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProfitPerRegularTaco @Def: Profit per regular taco @Shape: [] 
ProfitPerRegularTaco = data['ProfitPerRegularTaco']
# @Parameter ProfitPerDeluxeTaco @Def: Profit per deluxe taco @Shape: [] 
ProfitPerDeluxeTaco = data['ProfitPerDeluxeTaco']
# @Parameter MaxDemandRegularTacos @Def: Maximum demand for regular tacos @Shape: [] 
MaxDemandRegularTacos = data['MaxDemandRegularTacos']
# @Parameter MaxDemandDeluxeTacos @Def: Maximum demand for deluxe tacos @Shape: [] 
MaxDemandDeluxeTacos = data['MaxDemandDeluxeTacos']
# @Parameter MaxTotalSupplyTacos @Def: Maximum total supply of tacos @Shape: [] 
MaxTotalSupplyTacos = data['MaxTotalSupplyTacos']

# Variables 
# @Variable RegularTacosProduced @Def: The number of regular tacos produced @Shape: [] 
RegularTacosProduced = model.addVar(vtype=GRB.CONTINUOUS, name=""RegularTacosProduced"")
# @Variable DeluxeTacosProduced @Def: The number of deluxe tacos produced @Shape: [] 
DeluxeTacosProduced = model.addVar(vtype=GRB.CONTINUOUS, name=""DeluxeTacosProduced"")

# Constraints 
# @Constraint Constr_1 @Def: The number of regular tacos produced does not exceed the maximum demand for regular tacos.
model.addConstr(RegularTacosProduced <= MaxDemandRegularTacos)
# @Constraint Constr_2 @Def: The number of deluxe tacos produced does not exceed the maximum demand for deluxe tacos.
model.addConstr(DeluxeTacosProduced <= MaxDemandDeluxeTacos)
# @Constraint Constr_3 @Def: The total number of tacos produced does not exceed the maximum total supply of tacos.
model.addConstr(RegularTacosProduced + DeluxeTacosProduced <= MaxTotalSupplyTacos)
# @Constraint Constr_4 @Def: The number of regular tacos produced is non-negative.
model.addConstr(RegularTacosProduced >= 0)
# @Constraint Constr_5 @Def: The number of deluxe tacos produced is non-negative.
model.addConstr(DeluxeTacosProduced >= 0)

# Objective 
# @Objective Objective @Def: The objective is to maximize the total profit, calculated as the sum of the profits from regular and deluxe tacos.
model.setObjective(ProfitPerRegularTaco * RegularTacosProduced + ProfitPerDeluxeTaco * DeluxeTacosProduced, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['RegularTacosProduced'] = RegularTacosProduced.x
variables['DeluxeTacosProduced'] = DeluxeTacosProduced.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A printing company sells math workbooks and English workbooks. To meet demand, they must make at least 40 math workbooks and at least 60 English workbooks. However, they can make at most 140 math workbooks and at most 170 English workbooks. The company has a contract with a school to send at least 200 workbooks of either type. If the profit per math workbook is $15 and the profit per English workbook is $17, how many of each should the company make to maximize profit?","{""variables"": {""QuantityMathWorkbooks"": 140.0, ""QuantityEnglishWorkbooks"": 170.0}, ""objective"": 4990.0}","{""parametrized_description"": ""The company produces two types of workbooks: math and English. It must produce at least MinMathWorkbooks math workbooks and at least MinEnglishWorkbooks English workbooks, but no more than MaxMathWorkbooks math workbooks and no more than MaxEnglishWorkbooks English workbooks. Additionally, the total number of workbooks produced must be at least MinTotalWorkbooks. The objective is to maximize the total profit, which is calculated as ProfitMathWorkbook multiplied by the number of math workbooks plus ProfitEnglishWorkbook multiplied by the number of English workbooks."", ""keywords"": [""N.A.""], ""parameters"": {""MinMathWorkbooks"": {""description"": ""Minimum number of math workbooks to produce"", ""shape"": []}, ""MinEnglishWorkbooks"": {""description"": ""Minimum number of English workbooks to produce"", ""shape"": []}, ""MaxMathWorkbooks"": {""description"": ""Maximum number of math workbooks to produce"", ""shape"": []}, ""MaxEnglishWorkbooks"": {""description"": ""Maximum number of English workbooks to produce"", ""shape"": []}, ""MinTotalWorkbooks"": {""description"": ""Minimum total number of workbooks to produce"", ""shape"": []}, ""ProfitMathWorkbook"": {""description"": ""Profit per math workbook"", ""shape"": []}, ""ProfitEnglishWorkbook"": {""description"": ""Profit per English workbook"", ""shape"": []}}, ""variables"": {""QuantityMathWorkbooks"": {""description"": ""The number of math workbooks produced"", ""type"": ""continuous"", ""shape"": []}, ""QuantityEnglishWorkbooks"": {""description"": ""The number of English workbooks produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of math workbooks produced must be at least MinMathWorkbooks."", ""formulation"": ""QuantityMathWorkbooks \\geq MinMathWorkbooks"", ""code"": {""gurobipy"": ""model.addConstr(QuantityMathWorkbooks >= MinMathWorkbooks)""}}, {""description"": ""The number of English workbooks produced must be at least MinEnglishWorkbooks."", ""formulation"": ""QuantityEnglishWorkbooks \\geq MinEnglishWorkbooks"", ""code"": {""gurobipy"": ""model.addConstr(QuantityEnglishWorkbooks >= MinEnglishWorkbooks)""}}, {""description"": ""The number of math workbooks produced must not exceed MaxMathWorkbooks."", ""formulation"": ""QuantityMathWorkbooks \\leq MaxMathWorkbooks"", ""code"": {""gurobipy"": ""model.addConstr(QuantityMathWorkbooks <= MaxMathWorkbooks)""}}, {""description"": ""The number of English workbooks produced must not exceed MaxEnglishWorkbooks."", ""formulation"": ""QuantityEnglishWorkbooks \\leq MaxEnglishWorkbooks"", ""code"": {""gurobipy"": ""model.addConstr(QuantityEnglishWorkbooks <= MaxEnglishWorkbooks)""}}, {""description"": ""The total number of workbooks produced must be at least MinTotalWorkbooks."", ""formulation"": ""QuantityMathWorkbooks + QuantityEnglishWorkbooks \\geq MinTotalWorkbooks"", ""code"": {""gurobipy"": ""model.addConstr(QuantityMathWorkbooks + QuantityEnglishWorkbooks >= MinTotalWorkbooks, \""TotalWorkbooks\"")""}}], ""objective"": {""description"": ""Total profit is calculated as ProfitMathWorkbook multiplied by the number of math workbooks plus ProfitEnglishWorkbook multiplied by the number of English workbooks. The objective is to maximize the total profit."", ""formulation"": ""Max \\ ProfitMathWorkbook \\times QuantityMathWorkbooks + ProfitEnglishWorkbook \\times QuantityEnglishWorkbooks"", ""code"": {""gurobipy"": ""model.setObjective(ProfitMathWorkbook * QuantityMathWorkbooks + ProfitEnglishWorkbook * QuantityEnglishWorkbooks, GRB.MAXIMIZE)""}}}","{""MinMathWorkbooks"": 40, ""MinEnglishWorkbooks"": 60, ""MaxMathWorkbooks"": 140, ""MaxEnglishWorkbooks"": 170, ""MinTotalWorkbooks"": 200, ""ProfitMathWorkbook"": 15, ""ProfitEnglishWorkbook"": 17}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
The company produces two types of workbooks: math and English. It must produce
at least MinMathWorkbooks math workbooks and at least MinEnglishWorkbooks
English workbooks, but no more than MaxMathWorkbooks math workbooks and no more
than MaxEnglishWorkbooks English workbooks. Additionally, the total number of
workbooks produced must be at least MinTotalWorkbooks. The objective is to
maximize the total profit, which is calculated as ProfitMathWorkbook multiplied
by the number of math workbooks plus ProfitEnglishWorkbook multiplied by the
number of English workbooks.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/209/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MinMathWorkbooks @Def: Minimum number of math workbooks to produce @Shape: [] 
MinMathWorkbooks = data['MinMathWorkbooks']
# @Parameter MinEnglishWorkbooks @Def: Minimum number of English workbooks to produce @Shape: [] 
MinEnglishWorkbooks = data['MinEnglishWorkbooks']
# @Parameter MaxMathWorkbooks @Def: Maximum number of math workbooks to produce @Shape: [] 
MaxMathWorkbooks = data['MaxMathWorkbooks']
# @Parameter MaxEnglishWorkbooks @Def: Maximum number of English workbooks to produce @Shape: [] 
MaxEnglishWorkbooks = data['MaxEnglishWorkbooks']
# @Parameter MinTotalWorkbooks @Def: Minimum total number of workbooks to produce @Shape: [] 
MinTotalWorkbooks = data['MinTotalWorkbooks']
# @Parameter ProfitMathWorkbook @Def: Profit per math workbook @Shape: [] 
ProfitMathWorkbook = data['ProfitMathWorkbook']
# @Parameter ProfitEnglishWorkbook @Def: Profit per English workbook @Shape: [] 
ProfitEnglishWorkbook = data['ProfitEnglishWorkbook']

# Variables 
# @Variable QuantityMathWorkbooks @Def: The number of math workbooks produced @Shape: [] 
QuantityMathWorkbooks = model.addVar(vtype=GRB.CONTINUOUS, lb=MinMathWorkbooks, ub=MaxMathWorkbooks, name=""QuantityMathWorkbooks"")
# @Variable QuantityEnglishWorkbooks @Def: The number of English workbooks produced @Shape: [] 
QuantityEnglishWorkbooks = model.addVar(lb=MinEnglishWorkbooks, ub=MaxEnglishWorkbooks, vtype=GRB.CONTINUOUS, name=""QuantityEnglishWorkbooks"")

# Constraints 
# @Constraint Constr_1 @Def: The number of math workbooks produced must be at least MinMathWorkbooks.
model.addConstr(QuantityMathWorkbooks >= MinMathWorkbooks)
# @Constraint Constr_2 @Def: The number of English workbooks produced must be at least MinEnglishWorkbooks.
model.addConstr(QuantityEnglishWorkbooks >= MinEnglishWorkbooks)
# @Constraint Constr_3 @Def: The number of math workbooks produced must not exceed MaxMathWorkbooks.
model.addConstr(QuantityMathWorkbooks <= MaxMathWorkbooks)
# @Constraint Constr_4 @Def: The number of English workbooks produced must not exceed MaxEnglishWorkbooks.
model.addConstr(QuantityEnglishWorkbooks <= MaxEnglishWorkbooks)
# @Constraint Constr_5 @Def: The total number of workbooks produced must be at least MinTotalWorkbooks.
model.addConstr(QuantityMathWorkbooks + QuantityEnglishWorkbooks >= MinTotalWorkbooks, ""TotalWorkbooks"")

# Objective 
# @Objective Objective @Def: Total profit is calculated as ProfitMathWorkbook multiplied by the number of math workbooks plus ProfitEnglishWorkbook multiplied by the number of English workbooks. The objective is to maximize the total profit.
model.setObjective(ProfitMathWorkbook * QuantityMathWorkbooks + ProfitEnglishWorkbook * QuantityEnglishWorkbooks, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityMathWorkbooks'] = QuantityMathWorkbooks.x
variables['QuantityEnglishWorkbooks'] = QuantityEnglishWorkbooks.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A music company produces two types of digital keyboards, one is full-weighted and another is semi-weighted. Both keyboards are sold for $2800 and $2400 respectively. There are about 3500 oscillator chips available every day from which the full-weighted version requires 20 chips while the semi-weighted version requires 15 chips. The company has a total of 6 working hours a day. Both of these keyboards require a production time of 1.2 hours. What should be the manufacturing quantity for each of the keyboards to maximize the total revenue?","{""variables"": {""QuantityFullWeighted"": 5.0, ""QuantitySemiWeighted"": 0.0}, ""objective"": 14000.0}","{""parametrized_description"": ""Determine the quantities of FullWeighted and SemiWeighted keyboards to manufacture in order to maximize total revenue, where total revenue is calculated as PriceFullWeighted multiplied by the quantity of FullWeighted keyboards plus PriceSemiWeighted multiplied by the quantity of SemiWeighted keyboards. The production must satisfy two constraints: the total oscillator chips used, calculated as ChipsPerFullWeighted multiplied by the quantity of FullWeighted keyboards plus ChipsPerSemiWeighted multiplied by the quantity of SemiWeighted keyboards, must not exceed TotalChipsAvailable, and the total production time, calculated as ProductionTimePerKeyboard multiplied by the sum of the quantities of FullWeighted and SemiWeighted keyboards, must not exceed TotalProductionHours."", ""keywords"": [""N.A.""], ""parameters"": {""PriceFullWeighted"": {""description"": ""Price of the full-weighted keyboard"", ""shape"": []}, ""PriceSemiWeighted"": {""description"": ""Price of the semi-weighted keyboard"", ""shape"": []}, ""TotalChipsAvailable"": {""description"": ""Total oscillator chips available per day"", ""shape"": []}, ""ChipsPerFullWeighted"": {""description"": ""Number of oscillator chips required per full-weighted keyboard"", ""shape"": []}, ""ChipsPerSemiWeighted"": {""description"": ""Number of oscillator chips required per semi-weighted keyboard"", ""shape"": []}, ""TotalProductionHours"": {""description"": ""Total production hours available per day"", ""shape"": []}, ""ProductionTimePerKeyboard"": {""description"": ""Production time required to manufacture one keyboard"", ""shape"": []}}, ""variables"": {""QuantityFullWeighted"": {""description"": ""The quantity of FullWeighted keyboards"", ""type"": ""continuous"", ""shape"": []}, ""QuantitySemiWeighted"": {""description"": ""The quantity of SemiWeighted keyboards"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total oscillator chips used, calculated as ChipsPerFullWeighted multiplied by the quantity of FullWeighted keyboards plus ChipsPerSemiWeighted multiplied by the quantity of SemiWeighted keyboards, must not exceed TotalChipsAvailable."", ""formulation"": ""ChipsPerFullWeighted \\times QuantityFullWeighted + ChipsPerSemiWeighted \\times QuantitySemiWeighted \\leq TotalChipsAvailable"", ""code"": {""gurobipy"": ""model.addConstr(ChipsPerFullWeighted * QuantityFullWeighted + ChipsPerSemiWeighted * QuantitySemiWeighted <= TotalChipsAvailable)""}}, {""description"": ""The total production time, calculated as ProductionTimePerKeyboard multiplied by the sum of the quantities of FullWeighted and SemiWeighted keyboards, must not exceed TotalProductionHours."", ""formulation"": ""ProductionTimePerKeyboard \\times (QuantityFullWeighted + QuantitySemiWeighted) \\leq TotalProductionHours"", ""code"": {""gurobipy"": ""model.addConstr(ProductionTimePerKeyboard * (QuantityFullWeighted + QuantitySemiWeighted) <= TotalProductionHours)""}}], ""objective"": {""description"": ""Total revenue is calculated as PriceFullWeighted multiplied by the quantity of FullWeighted keyboards plus PriceSemiWeighted multiplied by the quantity of SemiWeighted keyboards. The objective is to maximize total revenue."", ""formulation"": ""Max \\ PriceFullWeighted \\times QuantityFullWeighted + PriceSemiWeighted \\times QuantitySemiWeighted"", ""code"": {""gurobipy"": ""model.setObjective(PriceFullWeighted * QuantityFullWeighted + PriceSemiWeighted * QuantitySemiWeighted, GRB.MAXIMIZE)""}}}","{""PriceFullWeighted"": 2800, ""PriceSemiWeighted"": 2400, ""TotalChipsAvailable"": 3500, ""ChipsPerFullWeighted"": 20, ""ChipsPerSemiWeighted"": 15, ""TotalProductionHours"": 6, ""ProductionTimePerKeyboard"": 1.2}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Determine the quantities of FullWeighted and SemiWeighted keyboards to
manufacture in order to maximize total revenue, where total revenue is
calculated as PriceFullWeighted multiplied by the quantity of FullWeighted
keyboards plus PriceSemiWeighted multiplied by the quantity of SemiWeighted
keyboards. The production must satisfy two constraints: the total oscillator
chips used, calculated as ChipsPerFullWeighted multiplied by the quantity of
FullWeighted keyboards plus ChipsPerSemiWeighted multiplied by the quantity of
SemiWeighted keyboards, must not exceed TotalChipsAvailable, and the total
production time, calculated as ProductionTimePerKeyboard multiplied by the sum
of the quantities of FullWeighted and SemiWeighted keyboards, must not exceed
TotalProductionHours.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/210/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter PriceFullWeighted @Def: Price of the full-weighted keyboard @Shape: [] 
PriceFullWeighted = data['PriceFullWeighted']
# @Parameter PriceSemiWeighted @Def: Price of the semi-weighted keyboard @Shape: [] 
PriceSemiWeighted = data['PriceSemiWeighted']
# @Parameter TotalChipsAvailable @Def: Total oscillator chips available per day @Shape: [] 
TotalChipsAvailable = data['TotalChipsAvailable']
# @Parameter ChipsPerFullWeighted @Def: Number of oscillator chips required per full-weighted keyboard @Shape: [] 
ChipsPerFullWeighted = data['ChipsPerFullWeighted']
# @Parameter ChipsPerSemiWeighted @Def: Number of oscillator chips required per semi-weighted keyboard @Shape: [] 
ChipsPerSemiWeighted = data['ChipsPerSemiWeighted']
# @Parameter TotalProductionHours @Def: Total production hours available per day @Shape: [] 
TotalProductionHours = data['TotalProductionHours']
# @Parameter ProductionTimePerKeyboard @Def: Production time required to manufacture one keyboard @Shape: [] 
ProductionTimePerKeyboard = data['ProductionTimePerKeyboard']

# Variables 
# @Variable QuantityFullWeighted @Def: The quantity of FullWeighted keyboards @Shape: [] 
QuantityFullWeighted = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityFullWeighted"")
# @Variable QuantitySemiWeighted @Def: The quantity of SemiWeighted keyboards @Shape: [] 
QuantitySemiWeighted = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantitySemiWeighted"")

# Constraints 
# @Constraint Constr_1 @Def: The total oscillator chips used, calculated as ChipsPerFullWeighted multiplied by the quantity of FullWeighted keyboards plus ChipsPerSemiWeighted multiplied by the quantity of SemiWeighted keyboards, must not exceed TotalChipsAvailable.
model.addConstr(ChipsPerFullWeighted * QuantityFullWeighted + ChipsPerSemiWeighted * QuantitySemiWeighted <= TotalChipsAvailable)
# @Constraint Constr_2 @Def: The total production time, calculated as ProductionTimePerKeyboard multiplied by the sum of the quantities of FullWeighted and SemiWeighted keyboards, must not exceed TotalProductionHours.
model.addConstr(ProductionTimePerKeyboard * (QuantityFullWeighted + QuantitySemiWeighted) <= TotalProductionHours)

# Objective 
# @Objective Objective @Def: Total revenue is calculated as PriceFullWeighted multiplied by the quantity of FullWeighted keyboards plus PriceSemiWeighted multiplied by the quantity of SemiWeighted keyboards. The objective is to maximize total revenue.
model.setObjective(PriceFullWeighted * QuantityFullWeighted + PriceSemiWeighted * QuantitySemiWeighted, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityFullWeighted'] = QuantityFullWeighted.x
variables['QuantitySemiWeighted'] = QuantitySemiWeighted.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Platinum Database sells two types of subscription software packages: a personal license and a commercial license which will cost $550 and $2000 to generate respectively. The marketing department estimates that they can sell at most 300 licenses for both versions combined a month. The profit per personal license is $450 and the profit per commercial version is $1200. If the company does not want to spend more than $400000, how many of each software package should they produce to maximize the profits.","{""variables"": {""NumberOfPersonalLicenses"": 138.0, ""NumberOfCommercialLicenses"": 162.0}, ""objective"": 256500.0}","{""parametrized_description"": ""A company offers two types of subscription licenses: a personal license and a commercial license. The cost to generate each personal license is CostPersonalLicense, and the cost to generate each commercial license is CostCommercialLicense. The marketing department estimates that the total number of licenses sold per month cannot exceed MaxTotalLicenses. The profit earned from each personal license is ProfitPersonalLicense, and the profit earned from each commercial license is ProfitCommercialLicense. Additionally, the company aims to ensure that the total expenditure does not surpass MaxTotalExpenditure. The objective is to determine the number of personal and commercial licenses to produce in order to maximize profits."", ""keywords"": [""N.A.""], ""parameters"": {""CostPersonalLicense"": {""description"": ""Cost to generate a personal license"", ""shape"": []}, ""CostCommercialLicense"": {""description"": ""Cost to generate a commercial license"", ""shape"": []}, ""ProfitPersonalLicense"": {""description"": ""Profit per personal license"", ""shape"": []}, ""ProfitCommercialLicense"": {""description"": ""Profit per commercial license"", ""shape"": []}, ""MaxTotalLicenses"": {""description"": ""Maximum total licenses that can be sold per month"", ""shape"": []}, ""MaxTotalExpenditure"": {""description"": ""Maximum total expenditure allowed by the company"", ""shape"": []}}, ""variables"": {""NumberOfPersonalLicenses"": {""description"": ""The number of personal licenses sold per month"", ""type"": ""continuous"", ""shape"": [""NonNegativeInteger""]}, ""NumberOfCommercialLicenses"": {""description"": ""The number of commercial licenses sold per month"", ""type"": ""continuous"", ""shape"": [""NonNegativeInteger""]}}, ""constraints"": [{""description"": ""The total number of licenses sold per month cannot exceed MaxTotalLicenses."", ""formulation"": ""NumberOfPersonalLicenses + NumberOfCommercialLicenses \\leq MaxTotalLicenses"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfPersonalLicenses + NumberOfCommercialLicenses <= MaxTotalLicenses)""}}, {""description"": ""The total expenditure does not surpass MaxTotalExpenditure."", ""formulation"": ""CostPersonalLicense \\cdot NumberOfPersonalLicenses + CostCommercialLicense \\cdot NumberOfCommercialLicenses \\leq MaxTotalExpenditure"", ""code"": {""gurobipy"": ""model.addConstr(CostPersonalLicense * NumberOfPersonalLicenses + CostCommercialLicense * NumberOfCommercialLicenses <= MaxTotalExpenditure)""}}], ""objective"": {""description"": ""Total profit is calculated as (ProfitPersonalLicense \u00d7 number of personal licenses) + (ProfitCommercialLicense \u00d7 number of commercial licenses). The objective is to maximize the total profit."", ""formulation"": ""Max \\ ProfitPersonalLicense \\times NumberOfPersonalLicenses + ProfitCommercialLicense \\times NumberOfCommercialLicenses"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPersonalLicense * NumberOfPersonalLicenses + ProfitCommercialLicense * NumberOfCommercialLicenses, GRB.MAXIMIZE)""}}}","{""CostPersonalLicense"": 550, ""CostCommercialLicense"": 2000, ""ProfitPersonalLicense"": 450, ""ProfitCommercialLicense"": 1200, ""MaxTotalLicenses"": 300, ""MaxTotalExpenditure"": 400000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company offers two types of subscription licenses: a personal license and a
commercial license. The cost to generate each personal license is
CostPersonalLicense, and the cost to generate each commercial license is
CostCommercialLicense. The marketing department estimates that the total number
of licenses sold per month cannot exceed MaxTotalLicenses. The profit earned
from each personal license is ProfitPersonalLicense, and the profit earned from
each commercial license is ProfitCommercialLicense. Additionally, the company
aims to ensure that the total expenditure does not surpass MaxTotalExpenditure.
The objective is to determine the number of personal and commercial licenses to
produce in order to maximize profits.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/211/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CostPersonalLicense @Def: Cost to generate a personal license @Shape: [] 
CostPersonalLicense = data['CostPersonalLicense']
# @Parameter CostCommercialLicense @Def: Cost to generate a commercial license @Shape: [] 
CostCommercialLicense = data['CostCommercialLicense']
# @Parameter ProfitPersonalLicense @Def: Profit per personal license @Shape: [] 
ProfitPersonalLicense = data['ProfitPersonalLicense']
# @Parameter ProfitCommercialLicense @Def: Profit per commercial license @Shape: [] 
ProfitCommercialLicense = data['ProfitCommercialLicense']
# @Parameter MaxTotalLicenses @Def: Maximum total licenses that can be sold per month @Shape: [] 
MaxTotalLicenses = data['MaxTotalLicenses']
# @Parameter MaxTotalExpenditure @Def: Maximum total expenditure allowed by the company @Shape: [] 
MaxTotalExpenditure = data['MaxTotalExpenditure']

# Variables 
# @Variable NumberOfPersonalLicenses @Def: The number of personal licenses sold per month @Shape: ['NonNegativeInteger'] 
NumberOfPersonalLicenses = model.addVar(vtype=GRB.INTEGER, lb=0, name=""NumberOfPersonalLicenses"")
# @Variable NumberOfCommercialLicenses @Def: The number of commercial licenses sold per month @Shape: ['NonNegativeInteger'] 
NumberOfCommercialLicenses = model.addVar(vtype=GRB.INTEGER, lb=0, name=""NumberOfCommercialLicenses"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of licenses sold per month cannot exceed MaxTotalLicenses.
model.addConstr(NumberOfPersonalLicenses + NumberOfCommercialLicenses <= MaxTotalLicenses)
# @Constraint Constr_2 @Def: The total expenditure does not surpass MaxTotalExpenditure.
model.addConstr(CostPersonalLicense * NumberOfPersonalLicenses + CostCommercialLicense * NumberOfCommercialLicenses <= MaxTotalExpenditure)

# Objective 
# @Objective Objective @Def: Total profit is calculated as (ProfitPersonalLicense × number of personal licenses) + (ProfitCommercialLicense × number of commercial licenses). The objective is to maximize the total profit.
model.setObjective(ProfitPersonalLicense * NumberOfPersonalLicenses + ProfitCommercialLicense * NumberOfCommercialLicenses, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfPersonalLicenses'] = NumberOfPersonalLicenses.x
variables['NumberOfCommercialLicenses'] = NumberOfCommercialLicenses.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Zeta Bakery sells two types of cookies. They sell a strawberry cookie and a sugar cookie. Let's say they make x1 strawberry cookies, at a profit of $5.5 each, and x2 sugar cookies, at a profit of $12 each (x1 and x2 are unknowns both greater than or equal to 0). The daily demand for these cookies is at most 100 strawberry cookies and at most 80 sugar cookies. The bakery is short staffed and can make a maximum of 100 cookies of either type per day. How much of each cookie should the bakery make in order to maximize profit?","{""variables"": {""NumStrawberryCookies"": 20.0, ""NumSugarCookies"": 80.0}, ""objective"": 1070.0}","{""parametrized_description"": ""The bakery produces x\u2081 strawberry cookies and x\u2082 sugar cookies, where each strawberry cookie yields ProfitPerStrawberryCookie profit and each sugar cookie yields ProfitPerSugarCookie profit. The daily demand for strawberry cookies is limited by MaxDailyDemandStrawberry and for sugar cookies by MaxDailyDemandSugar. The total number of cookies produced per day cannot exceed MaxTotalCookiesPerDay. The objective is to maximize the total profit."", ""keywords"": [""N.A.""], ""parameters"": {""ProfitPerStrawberryCookie"": {""description"": ""Profit per strawberry cookie"", ""shape"": []}, ""ProfitPerSugarCookie"": {""description"": ""Profit per sugar cookie"", ""shape"": []}, ""MaxDailyDemandStrawberry"": {""description"": ""Maximum daily demand for strawberry cookies"", ""shape"": []}, ""MaxDailyDemandSugar"": {""description"": ""Maximum daily demand for sugar cookies"", ""shape"": []}, ""MaxTotalCookiesPerDay"": {""description"": ""Maximum total cookies that can be made per day"", ""shape"": []}}, ""variables"": {""NumStrawberryCookies"": {""description"": ""The number of strawberry cookies produced"", ""type"": ""continuous"", ""shape"": []}, ""NumSugarCookies"": {""description"": ""The number of sugar cookies produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of strawberry cookies produced cannot exceed MaxDailyDemandStrawberry."", ""formulation"": ""NumStrawberryCookies \\leq MaxDailyDemandStrawberry"", ""code"": {""gurobipy"": ""model.addConstr(NumStrawberryCookies <= MaxDailyDemandStrawberry)""}}, {""description"": ""The number of sugar cookies produced cannot exceed MaxDailyDemandSugar."", ""formulation"": ""NumSugarCookies \\leq MaxDailyDemandSugar"", ""code"": {""gurobipy"": ""model.addConstr(NumSugarCookies <= MaxDailyDemandSugar)""}}, {""description"": ""The total number of cookies produced per day cannot exceed MaxTotalCookiesPerDay."", ""formulation"": ""NumStrawberryCookies + NumSugarCookies \\leq MaxTotalCookiesPerDay"", ""code"": {""gurobipy"": ""model.addConstr(NumStrawberryCookies + NumSugarCookies <= MaxTotalCookiesPerDay)""}}], ""objective"": {""description"": ""Total profit is the sum of the profits from strawberry and sugar cookies. The objective is to maximize the total profit."", ""formulation"": ""Max ProfitPerStrawberryCookie \\times NumStrawberryCookies + ProfitPerSugarCookie \\times NumSugarCookies"", ""code"": {""gurobipy"": ""model.setObjective(ProfitPerStrawberryCookie * NumStrawberryCookies + ProfitPerSugarCookie * NumSugarCookies, GRB.MAXIMIZE)""}}}","{""ProfitPerStrawberryCookie"": 5.5, ""ProfitPerSugarCookie"": 12, ""MaxDailyDemandStrawberry"": 100, ""MaxDailyDemandSugar"": 80, ""MaxTotalCookiesPerDay"": 100}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
The bakery produces x₁ strawberry cookies and x₂ sugar cookies, where each
strawberry cookie yields ProfitPerStrawberryCookie profit and each sugar cookie
yields ProfitPerSugarCookie profit. The daily demand for strawberry cookies is
limited by MaxDailyDemandStrawberry and for sugar cookies by
MaxDailyDemandSugar. The total number of cookies produced per day cannot exceed
MaxTotalCookiesPerDay. The objective is to maximize the total profit.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/212/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProfitPerStrawberryCookie @Def: Profit per strawberry cookie @Shape: [] 
ProfitPerStrawberryCookie = data['ProfitPerStrawberryCookie']
# @Parameter ProfitPerSugarCookie @Def: Profit per sugar cookie @Shape: [] 
ProfitPerSugarCookie = data['ProfitPerSugarCookie']
# @Parameter MaxDailyDemandStrawberry @Def: Maximum daily demand for strawberry cookies @Shape: [] 
MaxDailyDemandStrawberry = data['MaxDailyDemandStrawberry']
# @Parameter MaxDailyDemandSugar @Def: Maximum daily demand for sugar cookies @Shape: [] 
MaxDailyDemandSugar = data['MaxDailyDemandSugar']
# @Parameter MaxTotalCookiesPerDay @Def: Maximum total cookies that can be made per day @Shape: [] 
MaxTotalCookiesPerDay = data['MaxTotalCookiesPerDay']

# Variables 
# @Variable NumStrawberryCookies @Def: The number of strawberry cookies produced @Shape: [] 
NumStrawberryCookies = model.addVar(vtype=GRB.CONTINUOUS, name=""NumStrawberryCookies"")
# @Variable NumSugarCookies @Def: The number of sugar cookies produced @Shape: [] 
NumSugarCookies = model.addVar(vtype=GRB.CONTINUOUS, name=""NumSugarCookies"")

# Constraints 
# @Constraint Constr_1 @Def: The number of strawberry cookies produced cannot exceed MaxDailyDemandStrawberry.
model.addConstr(NumStrawberryCookies <= MaxDailyDemandStrawberry)
# @Constraint Constr_2 @Def: The number of sugar cookies produced cannot exceed MaxDailyDemandSugar.
model.addConstr(NumSugarCookies <= MaxDailyDemandSugar)
# @Constraint Constr_3 @Def: The total number of cookies produced per day cannot exceed MaxTotalCookiesPerDay.
model.addConstr(NumStrawberryCookies + NumSugarCookies <= MaxTotalCookiesPerDay)

# Objective 
# @Objective Objective @Def: Total profit is the sum of the profits from strawberry and sugar cookies. The objective is to maximize the total profit.
model.setObjective(ProfitPerStrawberryCookie * NumStrawberryCookies + ProfitPerSugarCookie * NumSugarCookies, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumStrawberryCookies'] = NumStrawberryCookies.x
variables['NumSugarCookies'] = NumSugarCookies.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A food company would like to run its commercials on three streaming platforms: Pi TV, Beta Video and Gamma Live. The cost for a commercial as well as the expected audience reach is given. On Pi TV, a commercial costs $1200 and attracts 2000 viewers. On Beta Video, a commercial costs $2000 and attracts 5000 viewers. On Gamma Live, a commercial costs $4000 and attracts 9000 viewers. Beta Video limits the number of commercials from a single company to 8. In order to attract a wide range of people, at most a third of all commercials should occur on Gamma Live and a minimum of 20% should occur on Pi TV. If the weekly budget is $20000, how many commercials should be run in each of the three possible choices in order to maximize audience?","{""variables"": {""NumberPiTV"": 3.0, ""NumberBetaVideo"": 8.0, ""NumberGammaLive"": 0.0}, ""objective"": 46000.0}","{""parametrized_description"": ""A food company aims to determine the number of commercials to run on Pi TV, Beta Video, and Gamma Live to maximize the total audience. The total cost, calculated using CostPiTV, CostBetaVideo, and CostGammaLive, must not exceed TotalBudget. Additionally, the number of commercials on Beta Video must not exceed MaxCommercialsBetaVideo, the proportion of commercials on Gamma Live must not exceed MaxGammaProportion, and the proportion of commercials on Pi TV must be at least MinPiTVProportion."", ""keywords"": [""N.A.""], ""parameters"": {""CostPiTV"": {""description"": ""Cost per commercial on Pi TV"", ""shape"": []}, ""CostBetaVideo"": {""description"": ""Cost per commercial on Beta Video"", ""shape"": []}, ""CostGammaLive"": {""description"": ""Cost per commercial on Gamma Live"", ""shape"": []}, ""AudiencePiTV"": {""description"": ""Audience per commercial on Pi TV"", ""shape"": []}, ""AudienceBetaVideo"": {""description"": ""Audience per commercial on Beta Video"", ""shape"": []}, ""AudienceGammaLive"": {""description"": ""Audience per commercial on Gamma Live"", ""shape"": []}, ""MaxCommercialsBetaVideo"": {""description"": ""Maximum number of commercials on Beta Video"", ""shape"": []}, ""TotalBudget"": {""description"": ""Total weekly budget"", ""shape"": []}, ""MaxGammaProportion"": {""description"": ""Maximum proportion of all commercials on Gamma Live"", ""shape"": []}, ""MinPiTVProportion"": {""description"": ""Minimum proportion of all commercials on Pi TV"", ""shape"": []}}, ""variables"": {""NumberPiTV"": {""description"": ""The number of commercials on Pi TV"", ""type"": ""continuous"", ""shape"": []}, ""NumberBetaVideo"": {""description"": ""The number of commercials on Beta Video"", ""type"": ""continuous"", ""shape"": []}, ""NumberGammaLive"": {""description"": ""The number of commercials on Gamma Live"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total cost, calculated as (CostPiTV * NumberPiTV) + (CostBetaVideo * NumberBetaVideo) + (CostGammaLive * NumberGammaLive), must not exceed TotalBudget."", ""formulation"": ""CostPiTV \\times NumberPiTV + CostBetaVideo \\times NumberBetaVideo + CostGammaLive \\times NumberGammaLive \\leq TotalBudget"", ""code"": {""gurobipy"": ""model.addConstr(CostPiTV * NumberPiTV + CostBetaVideo * NumberBetaVideo + CostGammaLive * NumberGammaLive <= TotalBudget)""}}, {""description"": ""The number of commercials on Beta Video must not exceed MaxCommercialsBetaVideo."", ""formulation"": ""NumberBetaVideo \\leq MaxCommercialsBetaVideo"", ""code"": {""gurobipy"": ""model.addConstr(NumberBetaVideo <= MaxCommercialsBetaVideo)""}}, {""description"": ""The proportion of all commercials on Gamma Live must not exceed MaxGammaProportion."", ""formulation"": ""NumberGammaLive \\leq MaxGammaProportion \\times (NumberPiTV + NumberBetaVideo + NumberGammaLive)"", ""code"": {""gurobipy"": ""model.addConstr(NumberGammaLive <= MaxGammaProportion * (NumberPiTV + NumberBetaVideo + NumberGammaLive))""}}, {""description"": ""The proportion of all commercials on Pi TV must be at least MinPiTVProportion."", ""formulation"": ""NumberPiTV \\geq MinPiTVProportion \\times (NumberPiTV + NumberBetaVideo + NumberGammaLive)"", ""code"": {""gurobipy"": ""model.addConstr(NumberPiTV >= MinPiTVProportion * (NumberPiTV + NumberBetaVideo + NumberGammaLive))""}}], ""objective"": {""description"": ""Maximize the total audience, which is the sum of (AudiencePiTV * NumberPiTV) + (AudienceBetaVideo * NumberBetaVideo) + (AudienceGammaLive * NumberGammaLive), while adhering to the budget and placement constraints."", ""formulation"": ""Max \\,(AudiencePiTV \\times NumberPiTV + AudienceBetaVideo \\times NumberBetaVideo + AudienceGammaLive \\times NumberGammaLive)"", ""code"": {""gurobipy"": ""model.setObjective(AudiencePiTV * NumberPiTV + AudienceBetaVideo * NumberBetaVideo + AudienceGammaLive * NumberGammaLive, GRB.MAXIMIZE)""}}}","{""CostPiTV"": 1200, ""CostBetaVideo"": 2000, ""CostGammaLive"": 4000, ""AudiencePiTV"": 2000, ""AudienceBetaVideo"": 5000, ""AudienceGammaLive"": 9000, ""MaxCommercialsBetaVideo"": 8, ""TotalBudget"": 20000, ""MaxGammaProportion"": 0.333333, ""MinPiTVProportion"": 0.2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A food company aims to determine the number of commercials to run on Pi TV, Beta
Video, and Gamma Live to maximize the total audience. The total cost, calculated
using CostPiTV, CostBetaVideo, and CostGammaLive, must not exceed TotalBudget.
Additionally, the number of commercials on Beta Video must not exceed
MaxCommercialsBetaVideo, the proportion of commercials on Gamma Live must not
exceed MaxGammaProportion, and the proportion of commercials on Pi TV must be at
least MinPiTVProportion.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/213/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CostPiTV @Def: Cost per commercial on Pi TV @Shape: [] 
CostPiTV = data['CostPiTV']
# @Parameter CostBetaVideo @Def: Cost per commercial on Beta Video @Shape: [] 
CostBetaVideo = data['CostBetaVideo']
# @Parameter CostGammaLive @Def: Cost per commercial on Gamma Live @Shape: [] 
CostGammaLive = data['CostGammaLive']
# @Parameter AudiencePiTV @Def: Audience per commercial on Pi TV @Shape: [] 
AudiencePiTV = data['AudiencePiTV']
# @Parameter AudienceBetaVideo @Def: Audience per commercial on Beta Video @Shape: [] 
AudienceBetaVideo = data['AudienceBetaVideo']
# @Parameter AudienceGammaLive @Def: Audience per commercial on Gamma Live @Shape: [] 
AudienceGammaLive = data['AudienceGammaLive']
# @Parameter MaxCommercialsBetaVideo @Def: Maximum number of commercials on Beta Video @Shape: [] 
MaxCommercialsBetaVideo = data['MaxCommercialsBetaVideo']
# @Parameter TotalBudget @Def: Total weekly budget @Shape: [] 
TotalBudget = data['TotalBudget']
# @Parameter MaxGammaProportion @Def: Maximum proportion of all commercials on Gamma Live @Shape: [] 
MaxGammaProportion = data['MaxGammaProportion']
# @Parameter MinPiTVProportion @Def: Minimum proportion of all commercials on Pi TV @Shape: [] 
MinPiTVProportion = data['MinPiTVProportion']

# Variables 
# @Variable NumberPiTV @Def: The number of commercials on Pi TV @Shape: [] 
NumberPiTV = model.addVar(vtype=GRB.INTEGER, name=""NumberPiTV"")
# @Variable NumberBetaVideo @Def: The number of commercials on Beta Video @Shape: [] 
NumberBetaVideo = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxCommercialsBetaVideo, name=""NumberBetaVideo"")
# @Variable NumberGammaLive @Def: The number of commercials on Gamma Live @Shape: [] 
NumberGammaLive = model.addVar(vtype=GRB.INTEGER, name=""NumberGammaLive"")

# Constraints 
# @Constraint Constr_1 @Def: The total cost, calculated as (CostPiTV * NumberPiTV) + (CostBetaVideo * NumberBetaVideo) + (CostGammaLive * NumberGammaLive), must not exceed TotalBudget.
model.addConstr(CostPiTV * NumberPiTV + CostBetaVideo * NumberBetaVideo + CostGammaLive * NumberGammaLive <= TotalBudget)
# @Constraint Constr_2 @Def: The number of commercials on Beta Video must not exceed MaxCommercialsBetaVideo.
model.addConstr(NumberBetaVideo <= MaxCommercialsBetaVideo)
# @Constraint Constr_3 @Def: The proportion of all commercials on Gamma Live must not exceed MaxGammaProportion.
model.addConstr(NumberGammaLive <= MaxGammaProportion * (NumberPiTV + NumberBetaVideo + NumberGammaLive))
# @Constraint Constr_4 @Def: The proportion of all commercials on Pi TV must be at least MinPiTVProportion.
model.addConstr(NumberPiTV >= MinPiTVProportion * (NumberPiTV + NumberBetaVideo + NumberGammaLive))

# Objective 
# @Objective Objective @Def: Maximize the total audience, which is the sum of (AudiencePiTV * NumberPiTV) + (AudienceBetaVideo * NumberBetaVideo) + (AudienceGammaLive * NumberGammaLive), while adhering to the budget and placement constraints.
model.setObjective(AudiencePiTV * NumberPiTV + AudienceBetaVideo * NumberBetaVideo + AudienceGammaLive * NumberGammaLive, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberPiTV'] = NumberPiTV.x
variables['NumberBetaVideo'] = NumberBetaVideo.x
variables['NumberGammaLive'] = NumberGammaLive.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A disease testing station is conducting a temperature check and/or a blood test on each patient. A temperature check takes 2 minutes while a blood test takes 10 minutes. The disease testing station must conduct at least 45 blood tests. Since the temperature check is recommended to be performed on most people, the testing station requires that the temperature check is performed at least 5 times as many as the blood test. If the disease testing station only has a total of 22000 staff minutes, how many of each test or check should be done to maximize the number of patients seen?","{""variables"": {""TemperatureChecks"": 10775.0, ""BloodTests"": 45.0, ""PatientsSeen"": 10820.0}, ""objective"": 10820.0}","{""parametrized_description"": ""A disease testing station conducts a temperature check and/or a blood test on each patient. A temperature check takes TimeTemperatureCheck minutes while a blood test takes TimeBloodTest minutes. The testing station must conduct at least MinBloodTests blood tests. The temperature check is required to be performed at least TempToBloodRatio times as many as the blood tests. If the testing station has a total of TotalStaffMinutes staff minutes, how many of each test or check should be done to maximize the number of patients seen?"", ""keywords"": [""N.A.""], ""parameters"": {""TimeTemperatureCheck"": {""description"": ""Time taken to perform a temperature check"", ""shape"": []}, ""TimeBloodTest"": {""description"": ""Time taken to perform a blood test"", ""shape"": []}, ""MinBloodTests"": {""description"": ""Minimum number of blood tests required"", ""shape"": []}, ""TempToBloodRatio"": {""description"": ""Minimum ratio of temperature checks to blood tests"", ""shape"": []}, ""TotalStaffMinutes"": {""description"": ""Total staff minutes available"", ""shape"": []}}, ""variables"": {""TemperatureChecks"": {""description"": ""The number of temperature checks"", ""type"": ""continuous"", ""shape"": []}, ""BloodTests"": {""description"": ""The number of blood tests"", ""type"": ""continuous"", ""shape"": []}, ""PatientsSeen"": {""description"": ""The number of patients seen"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total time allocated for temperature checks and blood tests cannot exceed TotalStaffMinutes minutes."", ""formulation"": ""TimeTemperatureCheck \\cdot TemperatureChecks + TimeBloodTest \\cdot BloodTests \\leq TotalStaffMinutes"", ""code"": {""gurobipy"": ""model.addConstr(TimeTemperatureCheck * TemperatureChecks + TimeBloodTest * BloodTests <= TotalStaffMinutes)""}}, {""description"": ""At least MinBloodTests blood tests must be conducted."", ""formulation"": ""BloodTests \\geq MinBloodTests"", ""code"": {""gurobipy"": ""model.addConstr(BloodTests >= MinBloodTests)""}}, {""description"": ""The number of temperature checks must be at least TempToBloodRatio times the number of blood tests."", ""formulation"": ""TemperatureChecks \\geq TempToBloodRatio \\times BloodTests"", ""code"": {""gurobipy"": ""model.addConstr(TemperatureChecks >= TempToBloodRatio * BloodTests)""}}], ""objective"": {""description"": ""Maximize the number of patients seen by conducting temperature checks and blood tests."", ""formulation"": ""Max\\ PatientsSeen \\n PatientsSeen \\leq TemperatureChecks \\n PatientsSeen \\leq BloodTests \\n TimeTemperatureCheck \\cdot TemperatureChecks + TimeBloodTest \\cdot BloodTests \\leq TotalStaffMinutes \\n BloodTests \\geq MinBloodTests \\n TemperatureChecks \\geq TempToBloodRatio \\cdot BloodTests"", ""code"": {""gurobipy"": ""model.setObjective(PatientsSeen, GRB.MAXIMIZE)""}}}","{""TimeTemperatureCheck"": 2, ""TimeBloodTest"": 10, ""MinBloodTests"": 45, ""TempToBloodRatio"": 5, ""TotalStaffMinutes"": 22000}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A disease testing station conducts a temperature check and/or a blood test on
each patient. A temperature check takes TimeTemperatureCheck minutes while a
blood test takes TimeBloodTest minutes. The testing station must conduct at
least MinBloodTests blood tests. The temperature check is required to be
performed at least TempToBloodRatio times as many as the blood tests. If the
testing station has a total of TotalStaffMinutes staff minutes, how many of each
 test or check should be done to maximize the number of patients seen?
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/214/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter TimeTemperatureCheck @Def: Time taken to perform a temperature check @Shape: [] 
TimeTemperatureCheck = data['TimeTemperatureCheck']
# @Parameter TimeBloodTest @Def: Time taken to perform a blood test @Shape: [] 
TimeBloodTest = data['TimeBloodTest']
# @Parameter MinBloodTests @Def: Minimum number of blood tests required @Shape: [] 
MinBloodTests = data['MinBloodTests']
# @Parameter TempToBloodRatio @Def: Minimum ratio of temperature checks to blood tests @Shape: [] 
TempToBloodRatio = data['TempToBloodRatio']
# @Parameter TotalStaffMinutes @Def: Total staff minutes available @Shape: [] 
TotalStaffMinutes = data['TotalStaffMinutes']

# Variables 
# @Variable TemperatureChecks @Def: The number of temperature checks @Shape: [] 
TemperatureChecks = model.addVar(vtype=GRB.CONTINUOUS, name=""TemperatureChecks"")
# @Variable BloodTests @Def: The number of blood tests @Shape: [] 
BloodTests = model.addVar(vtype=GRB.CONTINUOUS, name=""BloodTests"")
# @Variable PatientsSeen @Def: The number of patients seen @Shape: [] 
PatientsSeen = model.addVar(vtype=GRB.CONTINUOUS, name=""PatientsSeen"")

# Constraints 
# @Constraint Constr_1 @Def: The total time allocated for temperature checks and blood tests cannot exceed TotalStaffMinutes minutes.
model.addConstr(TimeTemperatureCheck * TemperatureChecks + TimeBloodTest * BloodTests <= TotalStaffMinutes)
# @Constraint Constr_2 @Def: At least MinBloodTests blood tests must be conducted.
model.addConstr(BloodTests >= MinBloodTests)
# @Constraint Constr_3 @Def: The number of temperature checks must be at least TempToBloodRatio times the number of blood tests.
model.addConstr(TemperatureChecks >= TempToBloodRatio * BloodTests)
# @Constraint Constr_4 @Def: The number of patients seen cannot exceed the total tests conducted.
model.addConstr(PatientsSeen <= TemperatureChecks + BloodTests)

# Objective 
# @Objective Objective @Def: Maximize the number of patients seen by conducting temperature checks and blood tests.
model.setObjective(PatientsSeen, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['TemperatureChecks'] = TemperatureChecks.x
variables['BloodTests'] = BloodTests.x
variables['PatientsSeen'] = PatientsSeen.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"The government is reworking the pipes to transport water to houses in the area. The water can be transported through wide pipes or narrow pipes. Wide pipes can transport 25 units of water per minute and narrow pipes can transport 15 units of water per minute. Due to logistics, the number of wide pipes can be at most a third the number of narrow pipes. If there needs to be at least 900 units of water transported every minute, and at least 5 wide pipes must be used, minimize the total number of pipes required.","{""variables"": {""WidePipes"": 12.0, ""NarrowPipes"": 40.0}, ""objective"": 52.0}","{""parametrized_description"": ""The government uses wide pipes and narrow pipes to transport water. Each wide pipe can carry WidePipeCapacity units of water per minute, and each narrow pipe can carry NarrowPipeCapacity units of water per minute. The number of wide pipes is restricted to at most MaxWideToNarrowRatio times the number of narrow pipes. The system must transport at least MinTransportRequired units of water every minute, and at least MinWidePipes wide pipes must be utilized. The objective is to minimize the total number of pipes required."", ""keywords"": [""N.A.""], ""parameters"": {""WidePipeCapacity"": {""description"": ""Water transport capacity of a wide pipe (units per minute)"", ""shape"": []}, ""NarrowPipeCapacity"": {""description"": ""Water transport capacity of a narrow pipe (units per minute)"", ""shape"": []}, ""MaxWideToNarrowRatio"": {""description"": ""Maximum ratio of wide pipes to narrow pipes"", ""shape"": []}, ""MinTransportRequired"": {""description"": ""Minimum required water transported per minute"", ""shape"": []}, ""MinWidePipes"": {""description"": ""Minimum number of wide pipes required"", ""shape"": []}}, ""variables"": {""WidePipes"": {""description"": ""The number of wide pipes"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NarrowPipes"": {""description"": ""The number of narrow pipes"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""WidePipeCapacity * WidePipes + NarrowPipeCapacity * NarrowPipes >= MinTransportRequired"", ""formulation"": ""WidePipeCapacity \\cdot WidePipes + NarrowPipeCapacity \\cdot NarrowPipes \\geq MinTransportRequired"", ""code"": {""gurobipy"": ""model.addConstr(WidePipeCapacity * WidePipes + NarrowPipeCapacity * NarrowPipes >= MinTransportRequired)""}}, {""description"": ""WidePipes <= MaxWideToNarrowRatio * NarrowPipes"", ""formulation"": ""WidePipes \\leq MaxWideToNarrowRatio \\times NarrowPipes"", ""code"": {""gurobipy"": ""model.addConstr(WidePipes <= MaxWideToNarrowRatio * NarrowPipes)""}}, {""description"": ""WidePipes >= MinWidePipes"", ""formulation"": ""WidePipes \\geq MinWidePipes"", ""code"": {""gurobipy"": ""model.addConstr(WidePipes >= MinWidePipes)""}}], ""objective"": {""description"": ""Minimize the total number of pipes required, which is WidePipes plus NarrowPipes."", ""formulation"": ""Min\\ (WidePipes + NarrowPipes)"", ""code"": {""gurobipy"": ""model.setObjective(WidePipes + NarrowPipes, GRB.MINIMIZE)""}}}","{""WidePipeCapacity"": 25, ""NarrowPipeCapacity"": 15, ""MaxWideToNarrowRatio"": 0.333333, ""MinTransportRequired"": 900, ""MinWidePipes"": 5}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
The government uses wide pipes and narrow pipes to transport water. Each wide
pipe can carry WidePipeCapacity units of water per minute, and each narrow pipe
can carry NarrowPipeCapacity units of water per minute. The number of wide pipes
is restricted to at most MaxWideToNarrowRatio times the number of narrow pipes.
The system must transport at least MinTransportRequired units of water every
minute, and at least MinWidePipes wide pipes must be utilized. The objective is
to minimize the total number of pipes required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/215/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter WidePipeCapacity @Def: Water transport capacity of a wide pipe (units per minute) @Shape: [] 
WidePipeCapacity = data['WidePipeCapacity']
# @Parameter NarrowPipeCapacity @Def: Water transport capacity of a narrow pipe (units per minute) @Shape: [] 
NarrowPipeCapacity = data['NarrowPipeCapacity']
# @Parameter MaxWideToNarrowRatio @Def: Maximum ratio of wide pipes to narrow pipes @Shape: [] 
MaxWideToNarrowRatio = data['MaxWideToNarrowRatio']
# @Parameter MinTransportRequired @Def: Minimum required water transported per minute @Shape: [] 
MinTransportRequired = data['MinTransportRequired']
# @Parameter MinWidePipes @Def: Minimum number of wide pipes required @Shape: [] 
MinWidePipes = data['MinWidePipes']

# Variables 
# @Variable WidePipes @Def: The number of wide pipes @Shape: ['Integer'] 
WidePipes = model.addVar(vtype=GRB.INTEGER, name=""WidePipes"")
# @Variable NarrowPipes @Def: The number of narrow pipes @Shape: ['Integer'] 
NarrowPipes = model.addVar(vtype=GRB.INTEGER, name=""NarrowPipes"")

# Constraints 
# @Constraint Constr_1 @Def: WidePipeCapacity * WidePipes + NarrowPipeCapacity * NarrowPipes >= MinTransportRequired
model.addConstr(WidePipeCapacity * WidePipes + NarrowPipeCapacity * NarrowPipes >= MinTransportRequired)
# @Constraint Constr_2 @Def: WidePipes <= MaxWideToNarrowRatio * NarrowPipes
model.addConstr(WidePipes <= MaxWideToNarrowRatio * NarrowPipes)
# @Constraint Constr_3 @Def: WidePipes >= MinWidePipes
model.addConstr(WidePipes >= MinWidePipes)

# Objective 
# @Objective Objective @Def: Minimize the total number of pipes required, which is WidePipes plus NarrowPipes.
model.setObjective(WidePipes + NarrowPipes, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['WidePipes'] = WidePipes.x
variables['NarrowPipes'] = NarrowPipes.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A concert organizer has to transport equipment using carts or trolleys. Carts can transport 5 kg/min of equipment and requires 2 workers. Trolleys can transport 7 kg/min of equipment and requires 4 workers. There must be at least 12 trolleys to be used. Additionally, only a maximum of 40% of the transportation can be using trolleys. The organizer has to deliver at a rate of 100 kg/min of equipment. How many of each transportation method should be used to minimize the total number of workers?","{""variables"": {""NumberOfCarts"": 4.0, ""NumberOfTrolleys"": 12.0}, ""objective"": 56.0}","{""parametrized_description"": ""A concert organizer must determine the optimal number of carts and trolleys to minimize the total number of workers. Each cart transports equipment at a rate of CartTransportRate kilograms per minute and requires CartWorkersRequired workers. Each trolley transports equipment at a rate of TrolleyTransportRate kilograms per minute and requires TrolleyWorkersRequired workers. The total transportation must meet or exceed the DeliveryRate kilograms per minute. Additionally, the number of trolleys used must be at least MinTrolleys, and the transportation rate using trolleys must not exceed MaxTrolleyTransportPercentage of the total transportation rate."", ""keywords"": [""N.A.""], ""parameters"": {""CartTransportRate"": {""description"": ""Equipment transport rate of carts in kilograms per minute"", ""shape"": []}, ""CartWorkersRequired"": {""description"": ""Number of workers required per cart"", ""shape"": []}, ""TrolleyTransportRate"": {""description"": ""Equipment transport rate of trolleys in kilograms per minute"", ""shape"": []}, ""TrolleyWorkersRequired"": {""description"": ""Number of workers required per trolley"", ""shape"": []}, ""MinTrolleys"": {""description"": ""Minimum number of trolleys to be used"", ""shape"": []}, ""MaxTrolleyTransportPercentage"": {""description"": ""Maximum percentage of transportation that can use trolleys"", ""shape"": []}, ""DeliveryRate"": {""description"": ""Delivery rate of equipment in kilograms per minute"", ""shape"": []}}, ""variables"": {""NumberOfCarts"": {""description"": ""The number of carts used"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfTrolleys"": {""description"": ""The number of trolleys used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total transportation rate must be at least DeliveryRate kilograms per minute."", ""formulation"": ""NumberOfCarts \\times CartTransportRate + NumberOfTrolleys \\times TrolleyTransportRate \\geq DeliveryRate"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfCarts * CartTransportRate + NumberOfTrolleys * TrolleyTransportRate >= DeliveryRate)""}}, {""description"": ""The number of trolleys used must be at least MinTrolleys."", ""formulation"": ""NumberOfTrolleys \\geq MinTrolleys"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfTrolleys >= MinTrolleys)""}}, {""description"": ""The transportation rate using trolleys must not exceed MaxTrolleyTransportPercentage of the total transportation rate."", ""formulation"": ""NumberOfTrolleys \\times TrolleyTransportRate \\leq MaxTrolleyTransportPercentage \\times (NumberOfCarts \\times CartTransportRate + NumberOfTrolleys \\times TrolleyTransportRate)"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfTrolleys * TrolleyTransportRate <= MaxTrolleyTransportPercentage * (NumberOfCarts * CartTransportRate + NumberOfTrolleys * TrolleyTransportRate))""}}], ""objective"": {""description"": ""Minimize the total number of workers, which is the sum of CartWorkersRequired workers for each cart and TrolleyWorkersRequired workers for each trolley."", ""formulation"": ""Min CartWorkersRequired \\cdot NumberOfCarts + TrolleyWorkersRequired \\cdot NumberOfTrolleys"", ""code"": {""gurobipy"": ""model.setObjective(CartWorkersRequired * NumberOfCarts + TrolleyWorkersRequired * NumberOfTrolleys, GRB.MINIMIZE)""}}}","{""CartTransportRate"": 5, ""CartWorkersRequired"": 2, ""TrolleyTransportRate"": 7, ""TrolleyWorkersRequired"": 4, ""MinTrolleys"": 12, ""MaxTrolleyTransportPercentage"": 40, ""DeliveryRate"": 100}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A concert organizer must determine the optimal number of carts and trolleys to
minimize the total number of workers. Each cart transports equipment at a rate
of CartTransportRate kilograms per minute and requires CartWorkersRequired
workers. Each trolley transports equipment at a rate of TrolleyTransportRate
kilograms per minute and requires TrolleyWorkersRequired workers. The total
transportation must meet or exceed the DeliveryRate kilograms per minute.
Additionally, the number of trolleys used must be at least MinTrolleys, and the
transportation rate using trolleys must not exceed MaxTrolleyTransportPercentage
of the total transportation rate.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/216/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CartTransportRate @Def: Equipment transport rate of carts in kilograms per minute @Shape: [] 
CartTransportRate = data['CartTransportRate']
# @Parameter CartWorkersRequired @Def: Number of workers required per cart @Shape: [] 
CartWorkersRequired = data['CartWorkersRequired']
# @Parameter TrolleyTransportRate @Def: Equipment transport rate of trolleys in kilograms per minute @Shape: [] 
TrolleyTransportRate = data['TrolleyTransportRate']
# @Parameter TrolleyWorkersRequired @Def: Number of workers required per trolley @Shape: [] 
TrolleyWorkersRequired = data['TrolleyWorkersRequired']
# @Parameter MinTrolleys @Def: Minimum number of trolleys to be used @Shape: [] 
MinTrolleys = data['MinTrolleys']
# @Parameter MaxTrolleyTransportPercentage @Def: Maximum percentage of transportation that can use trolleys @Shape: [] 
MaxTrolleyTransportPercentage = data['MaxTrolleyTransportPercentage']
# @Parameter DeliveryRate @Def: Delivery rate of equipment in kilograms per minute @Shape: [] 
DeliveryRate = data['DeliveryRate']

# Variables 
# @Variable NumberOfCarts @Def: The number of carts used @Shape: [] 
NumberOfCarts = model.addVar(vtype=GRB.INTEGER, name=""NumberOfCarts"")
# @Variable NumberOfTrolleys @Def: The number of trolleys used @Shape: [] 
NumberOfTrolleys = model.addVar(vtype=GRB.INTEGER, name=""NumberOfTrolleys"")

# Constraints 
# @Constraint Constr_1 @Def: The total transportation rate must be at least DeliveryRate kilograms per minute.
model.addConstr(NumberOfCarts * CartTransportRate + NumberOfTrolleys * TrolleyTransportRate >= DeliveryRate)
# @Constraint Constr_2 @Def: The number of trolleys used must be at least MinTrolleys.
model.addConstr(NumberOfTrolleys >= MinTrolleys)
# @Constraint Constr_3 @Def: The transportation rate using trolleys must not exceed MaxTrolleyTransportPercentage of the total transportation rate.
model.addConstr(NumberOfTrolleys * TrolleyTransportRate <= MaxTrolleyTransportPercentage * (NumberOfCarts * CartTransportRate + NumberOfTrolleys * TrolleyTransportRate))

# Objective 
# @Objective Objective @Def: Minimize the total number of workers, which is the sum of CartWorkersRequired workers for each cart and TrolleyWorkersRequired workers for each trolley.
model.setObjective(CartWorkersRequired * NumberOfCarts + TrolleyWorkersRequired * NumberOfTrolleys, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfCarts'] = NumberOfCarts.x
variables['NumberOfTrolleys'] = NumberOfTrolleys.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Both subsoil and topsoil need to be added to a garden bed. One bag of subsoil requires 10 units of water to hydrate while one bag of topsoil requires 6 units of water to hydrate every day. The truck used to transport the dirt has limited capacity and therefore, the farmer has available 150 bags of topsoil and subsoil combined. In addition, at least 10 bags of topsoil must be used. Since the topsoil is more expensive, at most 30% of all bags of soil can be topsoil. How many bags of each should be bought to minimize the total amount of water required to hydrate the garden bed?","{""variables"": {""SubsoilBags"": 24.0, ""TopsoilBags"": 10.0}, ""objective"": 300.0}","{""parametrized_description"": ""Both subsoil and topsoil need to be added to a garden bed. The objective is to minimize the total amount of water required to hydrate the garden bed, where each bag of subsoil requires WaterSubsoil units of water per day and each bag of topsoil requires WaterTopsoil units of water per day. The total number of bags of subsoil and topsoil combined must not exceed MaxTotalBags. Additionally, at least MinTopsoilBags bags of topsoil must be used, and the proportion of topsoil bags must not exceed MaxTopsoilProportion of all bags."", ""keywords"": [""N.A.""], ""parameters"": {""WaterSubsoil"": {""description"": ""Amount of water required to hydrate one bag of subsoil per day"", ""shape"": []}, ""WaterTopsoil"": {""description"": ""Amount of water required to hydrate one bag of topsoil per day"", ""shape"": []}, ""MaxTotalBags"": {""description"": ""Maximum number of bags of topsoil and subsoil combined"", ""shape"": []}, ""MinTopsoilBags"": {""description"": ""Minimum number of topsoil bags to be used"", ""shape"": []}, ""MaxTopsoilProportion"": {""description"": ""Maximum proportion of bags that can be topsoil"", ""shape"": []}}, ""variables"": {""SubsoilBags"": {""description"": ""The number of subsoil bags"", ""type"": ""continuous"", ""shape"": []}, ""TopsoilBags"": {""description"": ""The number of topsoil bags"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of subsoil and topsoil bags combined must not exceed MaxTotalBags."", ""formulation"": ""SubsoilBags + TopsoilBags \\leq MaxTotalBags"", ""code"": {""gurobipy"": ""model.addConstr(SubsoilBags + TopsoilBags <= MaxTotalBags)""}}, {""description"": ""At least MinTopsoilBags bags of topsoil must be used."", ""formulation"": ""TopsoilBags \\geq MinTopsoilBags"", ""code"": {""gurobipy"": ""model.addConstr(TopsoilBags >= MinTopsoilBags)""}}, {""description"": ""The proportion of topsoil bags must not exceed MaxTopsoilProportion of all bags."", ""formulation"": ""TopsoilBags \\leq MaxTopsoilProportion \\times ( TopsoilBags + SubsoilBags )"", ""code"": {""gurobipy"": ""model.addConstr(TopsoilBags <= MaxTopsoilProportion * (TopsoilBags + SubsoilBags))""}}], ""objective"": {""description"": ""Total water required is the sum of (WaterSubsoil * number of subsoil bags) and (WaterTopsoil * number of topsoil bags). The objective is to minimize the total water required."", ""formulation"": ""Min \\left( WaterSubsoil \\times SubsoilBags + WaterTopsoil \\times TopsoilBags \\right )"", ""code"": {""gurobipy"": ""model.setObjective(WaterSubsoil * SubsoilBags + WaterTopsoil * TopsoilBags, GRB.MINIMIZE)""}}}","{""WaterSubsoil"": 10, ""WaterTopsoil"": 6, ""MaxTotalBags"": 150, ""MinTopsoilBags"": 10, ""MaxTopsoilProportion"": 0.3}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Both subsoil and topsoil need to be added to a garden bed. The objective is to
minimize the total amount of water required to hydrate the garden bed, where
each bag of subsoil requires WaterSubsoil units of water per day and each bag of
topsoil requires WaterTopsoil units of water per day. The total number of bags
of subsoil and topsoil combined must not exceed MaxTotalBags. Additionally, at
least MinTopsoilBags bags of topsoil must be used, and the proportion of topsoil
bags must not exceed MaxTopsoilProportion of all bags.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/217/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter WaterSubsoil @Def: Amount of water required to hydrate one bag of subsoil per day @Shape: [] 
WaterSubsoil = data['WaterSubsoil']
# @Parameter WaterTopsoil @Def: Amount of water required to hydrate one bag of topsoil per day @Shape: [] 
WaterTopsoil = data['WaterTopsoil']
# @Parameter MaxTotalBags @Def: Maximum number of bags of topsoil and subsoil combined @Shape: [] 
MaxTotalBags = data['MaxTotalBags']
# @Parameter MinTopsoilBags @Def: Minimum number of topsoil bags to be used @Shape: [] 
MinTopsoilBags = data['MinTopsoilBags']
# @Parameter MaxTopsoilProportion @Def: Maximum proportion of bags that can be topsoil @Shape: [] 
MaxTopsoilProportion = data['MaxTopsoilProportion']

# Variables 
# @Variable SubsoilBags @Def: The number of subsoil bags @Shape: [] 
SubsoilBags = model.addVar(vtype=GRB.INTEGER, name=""SubsoilBags"")
# @Variable TopsoilBags @Def: The number of topsoil bags @Shape: [] 
TopsoilBags = model.addVar(vtype=GRB.INTEGER, name=""TopsoilBags"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of subsoil and topsoil bags combined must not exceed MaxTotalBags.
model.addConstr(SubsoilBags + TopsoilBags <= MaxTotalBags)
# @Constraint Constr_2 @Def: At least MinTopsoilBags bags of topsoil must be used.
model.addConstr(TopsoilBags >= MinTopsoilBags)
# @Constraint Constr_3 @Def: The proportion of topsoil bags must not exceed MaxTopsoilProportion of all bags.
model.addConstr(TopsoilBags <= MaxTopsoilProportion * (TopsoilBags + SubsoilBags))

# Objective 
# @Objective Objective @Def: Total water required is the sum of (WaterSubsoil * number of subsoil bags) and (WaterTopsoil * number of topsoil bags). The objective is to minimize the total water required.
model.setObjective(WaterSubsoil * SubsoilBags + WaterTopsoil * TopsoilBags, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SubsoilBags'] = SubsoilBags.x
variables['TopsoilBags'] = TopsoilBags.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An extremely large ski resort is looking into purchasing two types of ski lifts, a densely-seated one and a loosely-seated one. The densely-seated ski lift is able to bring 45 guests up the slopes every minute whereas the loosely-seated ski lift can transport 20 guests every minute.  The densely-seated ski lift uses 30 units of electricity and the loosely-seated lift uses 22 units of electricity. There must be at least five loosely-seated ski lifts because they move slower and are friendlier for beginners. The ski resort needs at least 1000 guests every minute to make a profit and has available 940 units of electricity. How many of each type of ski lifts should they plan to install to minimize the total number of ski lifts needed?","{""variables"": {""LooselySeatedLift"": 5.0, ""DenselySeatedLift"": 20.0}, ""objective"": 25.0}","{""parametrized_description"": ""A ski resort needs to install two types of ski lifts: densely-seated lifts and loosely-seated lifts. The densely-seated ski lift transports GuestsPerMinuteDenselySeatedLift guests per minute and consumes ElectricityPerDenselySeatedLift units of electricity. The loosely-seated ski lift transports GuestsPerMinuteLooselySeatedLift guests per minute and consumes ElectricityPerLooselySeatedLift units of electricity. The resort must install at least MinimumLooselySeatedLifts loosely-seated ski lifts. To achieve a minimum of MinimumGuestsPerMinute guests per minute while not exceeding TotalElectricityAvailable units of electricity, determine the number of each type of ski lift to install in order to minimize the total number of ski lifts."", ""keywords"": [""N.A.""], ""parameters"": {""GuestsPerMinuteDenselySeatedLift"": {""description"": ""Number of guests transported per minute by a densely-seated ski lift"", ""shape"": []}, ""GuestsPerMinuteLooselySeatedLift"": {""description"": ""Number of guests transported per minute by a loosely-seated ski lift"", ""shape"": []}, ""ElectricityPerDenselySeatedLift"": {""description"": ""Electricity units used by a densely-seated ski lift"", ""shape"": []}, ""ElectricityPerLooselySeatedLift"": {""description"": ""Electricity units used by a loosely-seated ski lift"", ""shape"": []}, ""MinimumLooselySeatedLifts"": {""description"": ""Minimum number of loosely-seated ski lifts required"", ""shape"": []}, ""MinimumGuestsPerMinute"": {""description"": ""Minimum number of guests per minute required for profit"", ""shape"": []}, ""TotalElectricityAvailable"": {""description"": ""Total electricity units available"", ""shape"": []}}, ""variables"": {""LooselySeatedLift"": {""description"": ""The number of loosely-seated ski lifts"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""DenselySeatedLift"": {""description"": ""The number of densely-seated ski lifts"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""At least MinimumLooselySeatedLifts loosely-seated ski lifts must be installed."", ""formulation"": ""LooselySeatedLift \\geq MinimumLooselySeatedLifts"", ""code"": {""gurobipy"": ""model.addConstr(LooselySeatedLift >= MinimumLooselySeatedLifts)""}}, {""description"": ""The total number of guests per minute must be at least MinimumGuestsPerMinute."", ""formulation"": ""GuestsPerMinuteDenselySeatedLift \\times DenselySeatedLift + GuestsPerMinuteLooselySeatedLift \\times LooselySeatedLift \\geq MinimumGuestsPerMinute"", ""code"": {""gurobipy"": ""model.addConstr(\n    GuestsPerMinuteDenselySeatedLift * DenselySeatedLift +\n    GuestsPerMinuteLooselySeatedLift * LooselySeatedLift >= MinimumGuestsPerMinute\n)""}}, {""description"": ""The total electricity consumption must not exceed TotalElectricityAvailable units."", ""formulation"": ""DenselySeatedLift \\cdot ElectricityPerDenselySeatedLift + LooselySeatedLift \\cdot ElectricityPerLooselySeatedLift \\leq TotalElectricityAvailable"", ""code"": {""gurobipy"": ""model.addConstr(DenselySeatedLift * ElectricityPerDenselySeatedLift + LooselySeatedLift * ElectricityPerLooselySeatedLift <= TotalElectricityAvailable)""}}], ""objective"": {""description"": ""Minimize the total number of ski lifts installed."", ""formulation"": ""Min \\left( LooselySeatedLift + DenselySeatedLift \\right)"", ""code"": {""gurobipy"": ""model.setObjective(LooselySeatedLift + DenselySeatedLift, GRB.MINIMIZE)""}}}","{""GuestsPerMinuteDenselySeatedLift"": 45, ""GuestsPerMinuteLooselySeatedLift"": 20, ""ElectricityPerDenselySeatedLift"": 30, ""ElectricityPerLooselySeatedLift"": 22, ""MinimumLooselySeatedLifts"": 5, ""MinimumGuestsPerMinute"": 1000, ""TotalElectricityAvailable"": 940}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A ski resort needs to install two types of ski lifts: densely-seated lifts and
loosely-seated lifts. The densely-seated ski lift transports
GuestsPerMinuteDenselySeatedLift guests per minute and consumes
ElectricityPerDenselySeatedLift units of electricity. The loosely-seated ski
lift transports GuestsPerMinuteLooselySeatedLift guests per minute and consumes
ElectricityPerLooselySeatedLift units of electricity. The resort must install at
least MinimumLooselySeatedLifts loosely-seated ski lifts. To achieve a minimum
of MinimumGuestsPerMinute guests per minute while not exceeding
TotalElectricityAvailable units of electricity, determine the number of each
type of ski lift to install in order to minimize the total number of ski lifts.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/218/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter GuestsPerMinuteDenselySeatedLift @Def: Number of guests transported per minute by a densely-seated ski lift @Shape: [] 
GuestsPerMinuteDenselySeatedLift = data['GuestsPerMinuteDenselySeatedLift']
# @Parameter GuestsPerMinuteLooselySeatedLift @Def: Number of guests transported per minute by a loosely-seated ski lift @Shape: [] 
GuestsPerMinuteLooselySeatedLift = data['GuestsPerMinuteLooselySeatedLift']
# @Parameter ElectricityPerDenselySeatedLift @Def: Electricity units used by a densely-seated ski lift @Shape: [] 
ElectricityPerDenselySeatedLift = data['ElectricityPerDenselySeatedLift']
# @Parameter ElectricityPerLooselySeatedLift @Def: Electricity units used by a loosely-seated ski lift @Shape: [] 
ElectricityPerLooselySeatedLift = data['ElectricityPerLooselySeatedLift']
# @Parameter MinimumLooselySeatedLifts @Def: Minimum number of loosely-seated ski lifts required @Shape: [] 
MinimumLooselySeatedLifts = data['MinimumLooselySeatedLifts']
# @Parameter MinimumGuestsPerMinute @Def: Minimum number of guests per minute required for profit @Shape: [] 
MinimumGuestsPerMinute = data['MinimumGuestsPerMinute']
# @Parameter TotalElectricityAvailable @Def: Total electricity units available @Shape: [] 
TotalElectricityAvailable = data['TotalElectricityAvailable']

# Variables 
# @Variable LooselySeatedLift @Def: The number of loosely-seated ski lifts @Shape: ['Integer'] 
LooselySeatedLift = model.addVar(vtype=GRB.INTEGER, lb=MinimumLooselySeatedLifts, name=""LooselySeatedLift"")
# @Variable DenselySeatedLift @Def: The number of densely-seated ski lifts @Shape: ['Integer'] 
DenselySeatedLift = model.addVar(vtype=GRB.INTEGER, name=""DenselySeatedLift"")

# Constraints 
# @Constraint Constr_1 @Def: At least MinimumLooselySeatedLifts loosely-seated ski lifts must be installed.
model.addConstr(LooselySeatedLift >= MinimumLooselySeatedLifts)
# @Constraint Constr_2 @Def: The total number of guests per minute must be at least MinimumGuestsPerMinute.
model.addConstr(
    GuestsPerMinuteDenselySeatedLift * DenselySeatedLift +
    GuestsPerMinuteLooselySeatedLift * LooselySeatedLift >= MinimumGuestsPerMinute
)
# @Constraint Constr_3 @Def: The total electricity consumption must not exceed TotalElectricityAvailable units.
model.addConstr(DenselySeatedLift * ElectricityPerDenselySeatedLift + LooselySeatedLift * ElectricityPerLooselySeatedLift <= TotalElectricityAvailable)

# Objective 
# @Objective Objective @Def: Minimize the total number of ski lifts installed.
model.setObjective(LooselySeatedLift + DenselySeatedLift, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['LooselySeatedLift'] = LooselySeatedLift.x
variables['DenselySeatedLift'] = DenselySeatedLift.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A strata-management company is looking into purchasing two types of air conditioners, a low-power and a high-power model. A low-powered air conditioner can cool down 12 housing units and uses 150 units of electricity every day. A high-power model can cool down 17 housing units and uses 250 units of electricity every day. Since the low-powered model is not good for the aesthetics, the strata decided to limit the number of low-powered models to only 30% and at least 7 high-powered models must be used. If the apartment needs to condition at least 250 housing units and has 3400 units of electricity available, how many of each air conditioner should the strata company buy to minimize the total number of air conditioners?",{},"{""parametrized_description"": ""A strata-management company aims to purchase a combination of low-powered and high-powered air conditioners. Each low-powered air conditioner provides LowPowerCoolingCapacity and consumes LowPowerElectricityUsage units of electricity daily. Each high-powered air conditioner provides HighPowerCoolingCapacity and consumes HighPowerElectricityUsage units of electricity daily. The number of low-powered air conditioners is restricted to MaxLowPowerPercentage of the total air conditioners. Additionally, the company must acquire at least MinHighPowerModels high-powered air conditioners. The total cooling requirement is TotalCoolingRequired housing units, and the available electricity is TotalElectricityAvailable units. The objective is to minimize the total number of air conditioners purchased."", ""keywords"": [""N.A.""], ""parameters"": {""LowPowerCoolingCapacity"": {""description"": ""Cooling capacity of a low-powered air conditioner (number of housing units it can cool)"", ""shape"": []}, ""LowPowerElectricityUsage"": {""description"": ""Electricity usage of a low-powered air conditioner (units per day)"", ""shape"": []}, ""HighPowerCoolingCapacity"": {""description"": ""Cooling capacity of a high-powered air conditioner (number of housing units it can cool)"", ""shape"": []}, ""HighPowerElectricityUsage"": {""description"": ""Electricity usage of a high-powered air conditioner (units per day)"", ""shape"": []}, ""MaxLowPowerPercentage"": {""description"": ""Maximum percentage of low-powered air conditioners allowed"", ""shape"": []}, ""MinHighPowerModels"": {""description"": ""Minimum number of high-powered air conditioners required"", ""shape"": []}, ""TotalCoolingRequired"": {""description"": ""Total number of housing units to be cooled"", ""shape"": []}, ""TotalElectricityAvailable"": {""description"": ""Total units of electricity available"", ""shape"": []}}, ""variables"": {""LowPowerUnits"": {""description"": ""The number of low-powered air conditioners"", ""type"": ""continuous"", ""shape"": []}, ""HighPowerUnits"": {""description"": ""The number of high-powered air conditioners"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total cooling capacity provided by low-powered and high-powered air conditioners must meet or exceed the total cooling requirement of TotalCoolingRequired housing units."", ""formulation"": ""LowPowerCoolingCapacity \\times LowPowerUnits + HighPowerCoolingCapacity \\times HighPowerUnits \\geq TotalCoolingRequired"", ""code"": {""gurobipy"": ""model.addConstr(LowPowerCoolingCapacity * LowPowerUnits + HighPowerCoolingCapacity * HighPowerUnits >= TotalCoolingRequired)""}}, {""description"": ""The total electricity consumption of all air conditioners must not exceed the available electricity of TotalElectricityAvailable units."", ""formulation"": ""LowPowerUnits \\times LowPowerElectricityUsage + HighPowerUnits \\times HighPowerElectricityUsage \\leq TotalElectricityAvailable"", ""code"": {""gurobipy"": ""model.addConstr(LowPowerElectricityUsage * LowPowerUnits + HighPowerElectricityUsage * HighPowerUnits <= TotalElectricityAvailable)""}}, {""description"": ""The number of low-powered air conditioners must not exceed MaxLowPowerPercentage of the total number of air conditioners purchased."", ""formulation"": ""LowPowerUnits \\leq MaxLowPowerPercentage \\cdot \\left( LowPowerUnits + HighPowerUnits \\right )"", ""code"": {""gurobipy"": ""model.addConstr(LowPowerUnits <= MaxLowPowerPercentage * (LowPowerUnits + HighPowerUnits))""}}, {""description"": ""At least MinHighPowerModels high-powered air conditioners must be acquired."", ""formulation"": ""HighPowerUnits \\geq MinHighPowerModels"", ""code"": {""gurobipy"": ""model.addConstr(HighPowerUnits >= MinHighPowerModels)""}}], ""objective"": {""description"": ""Minimize the total number of air conditioners purchased."", ""formulation"": ""Min \\ LowPowerUnits + HighPowerUnits"", ""code"": {""gurobipy"": ""model.setObjective(LowPowerUnits + HighPowerUnits, GRB.MINIMIZE)""}}}","{""LowPowerCoolingCapacity"": 12, ""LowPowerElectricityUsage"": 150, ""HighPowerCoolingCapacity"": 17, ""HighPowerElectricityUsage"": 250, ""MaxLowPowerPercentage"": 0.3, ""MinHighPowerModels"": 7, ""TotalCoolingRequired"": 250, ""TotalElectricityAvailable"": 3400}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A strata-management company aims to purchase a combination of low-powered and
high-powered air conditioners. Each low-powered air conditioner provides
LowPowerCoolingCapacity and consumes LowPowerElectricityUsage units of
electricity daily. Each high-powered air conditioner provides
HighPowerCoolingCapacity and consumes HighPowerElectricityUsage units of
electricity daily. The number of low-powered air conditioners is restricted to
MaxLowPowerPercentage of the total air conditioners. Additionally, the company
must acquire at least MinHighPowerModels high-powered air conditioners. The
total cooling requirement is TotalCoolingRequired housing units, and the
available electricity is TotalElectricityAvailable units. The objective is to
minimize the total number of air conditioners purchased.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/219/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter LowPowerCoolingCapacity @Def: Cooling capacity of a low-powered air conditioner (number of housing units it can cool) @Shape: [] 
LowPowerCoolingCapacity = data['LowPowerCoolingCapacity']
# @Parameter LowPowerElectricityUsage @Def: Electricity usage of a low-powered air conditioner (units per day) @Shape: [] 
LowPowerElectricityUsage = data['LowPowerElectricityUsage']
# @Parameter HighPowerCoolingCapacity @Def: Cooling capacity of a high-powered air conditioner (number of housing units it can cool) @Shape: [] 
HighPowerCoolingCapacity = data['HighPowerCoolingCapacity']
# @Parameter HighPowerElectricityUsage @Def: Electricity usage of a high-powered air conditioner (units per day) @Shape: [] 
HighPowerElectricityUsage = data['HighPowerElectricityUsage']
# @Parameter MaxLowPowerPercentage @Def: Maximum percentage of low-powered air conditioners allowed @Shape: [] 
MaxLowPowerPercentage = data['MaxLowPowerPercentage']
# @Parameter MinHighPowerModels @Def: Minimum number of high-powered air conditioners required @Shape: [] 
MinHighPowerModels = data['MinHighPowerModels']
# @Parameter TotalCoolingRequired @Def: Total number of housing units to be cooled @Shape: [] 
TotalCoolingRequired = data['TotalCoolingRequired']
# @Parameter TotalElectricityAvailable @Def: Total units of electricity available @Shape: [] 
TotalElectricityAvailable = data['TotalElectricityAvailable']

# Variables 
# @Variable LowPowerUnits @Def: The number of low-powered air conditioners @Shape: [] 
LowPowerUnits = model.addVar(vtype=GRB.INTEGER, name=""LowPowerUnits"")
# @Variable HighPowerUnits @Def: The number of high-powered air conditioners @Shape: [] 
HighPowerUnits = model.addVar(vtype=GRB.INTEGER, name=""HighPowerUnits"")

# Constraints 
# @Constraint Constr_1 @Def: The total cooling capacity provided by low-powered and high-powered air conditioners must meet or exceed the total cooling requirement of TotalCoolingRequired housing units.
model.addConstr(LowPowerCoolingCapacity * LowPowerUnits + HighPowerCoolingCapacity * HighPowerUnits >= TotalCoolingRequired)
# @Constraint Constr_2 @Def: The total electricity consumption of all air conditioners must not exceed the available electricity of TotalElectricityAvailable units.
model.addConstr(LowPowerElectricityUsage * LowPowerUnits + HighPowerElectricityUsage * HighPowerUnits <= TotalElectricityAvailable)
# @Constraint Constr_3 @Def: The number of low-powered air conditioners must not exceed MaxLowPowerPercentage of the total number of air conditioners purchased.
model.addConstr(LowPowerUnits <= MaxLowPowerPercentage * (LowPowerUnits + HighPowerUnits))
# @Constraint Constr_4 @Def: At least MinHighPowerModels high-powered air conditioners must be acquired.
model.addConstr(HighPowerUnits >= MinHighPowerModels)

# Objective 
# @Objective Objective @Def: Minimize the total number of air conditioners purchased.
model.setObjective(LowPowerUnits + HighPowerUnits, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['LowPowerUnits'] = LowPowerUnits.x
variables['HighPowerUnits'] = HighPowerUnits.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A student takes calcium pills and vitamin D pills one after the other. Each calcium pill takes 5 minutes to be effective while each vitamin D pill takes 6 minutes to be effective. Over a month, the student must take at least 130 pills of medication and at least 40 should be vitamin D pills because they enhance the absorption of calcium in the body. Since vitamin D is complimentary to calcium, the student must take more calcium pills than vitamin D pills. How many pills of each should the student take to minimize the total time it takes for the medication to be effective?","{""variables"": {""NumberCalciumPills"": 2000000000.0, ""NumberVitaminDPills"": 40.0, ""TotalTime"": 0.0, ""IsCalciumTaken"": 1.0, ""IsVitaminDTaken"": 1.0}, ""objective"": 0.0}","{""parametrized_description"": ""A student consumes calcium and vitamin D pills sequentially. Each calcium pill requires TimeToEffectCalcium time to become effective, and each vitamin D pill requires TimeToEffectVitaminD time to become effective. Over a month, the student must ingest at least MinTotalPills pills in total, with a minimum of MinVitaminDPills being vitamin D pills. Additionally, the number of calcium pills taken must exceed the number of vitamin D pills. The objective is to minimize the total time for the medication to become effective."", ""keywords"": [""N.A.""], ""parameters"": {""TimeToEffectCalcium"": {""description"": ""Time it takes for a calcium pill to be effective"", ""shape"": []}, ""TimeToEffectVitaminD"": {""description"": ""Time it takes for a vitamin D pill to be effective"", ""shape"": []}, ""MinTotalPills"": {""description"": ""Minimum total number of pills to be taken in a month"", ""shape"": []}, ""MinVitaminDPills"": {""description"": ""Minimum number of vitamin D pills to be taken in a month"", ""shape"": []}}, ""variables"": {""NumberCalciumPills"": {""description"": ""The number of Calcium pills taken in a month"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberVitaminDPills"": {""description"": ""The number of Vitamin D pills taken in a month"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""TotalTime"": {""description"": ""The total time for the medications to become effective."", ""type"": ""continuous"", ""shape"": [""Continuous""]}, ""IsCalciumTaken"": {""description"": ""Binary variable indicating whether any Calcium pills are taken."", ""type"": ""continuous"", ""shape"": [""Binary""]}, ""IsVitaminDTaken"": {""description"": ""Binary variable indicating whether any Vitamin D pills are taken."", ""type"": ""continuous"", ""shape"": [""Binary""]}}, ""constraints"": [{""description"": ""The total number of pills ingested in a month must be at least MinTotalPills."", ""formulation"": ""NumberCalciumPills + NumberVitaminDPills \\geq MinTotalPills"", ""code"": {""gurobipy"": ""model.addConstr(NumberCalciumPills + NumberVitaminDPills >= MinTotalPills)""}}, {""description"": ""At least MinVitaminDPills of the pills ingested in a month must be vitamin D pills."", ""formulation"": ""NumberVitaminDPills \\geq MinVitaminDPills"", ""code"": {""gurobipy"": ""model.addConstr(NumberVitaminDPills >= MinVitaminDPills)""}}, {""description"": ""The number of calcium pills taken must exceed the number of vitamin D pills."", ""formulation"": ""NumberCalciumPills \\geq NumberVitaminDPills + 1"", ""code"": {""gurobipy"": ""model.addConstr(NumberCalciumPills >= NumberVitaminDPills + 1)""}}], ""objective"": {""description"": ""Minimize the total time for the medications to become effective."", ""formulation"": ""Min \\ TotalTime \\n TotalTime \\geq TimeToEffectCalcium \\times IsCalciumTaken \\n TotalTime \\geq TimeToEffectVitaminD \\times IsVitaminDTaken \\n NumberCalciumPills \\geq IsCalciumTaken \\n NumberVitaminDPills \\geq IsVitaminDTaken"", ""code"": {""gurobipy"": ""model.setObjective(TotalTime, GRB.MINIMIZE)""}}}","{""TimeToEffectCalcium"": 5, ""TimeToEffectVitaminD"": 6, ""MinTotalPills"": 130, ""MinVitaminDPills"": 40}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A student consumes calcium and vitamin D pills sequentially. Each calcium pill
requires TimeToEffectCalcium time to become effective, and each vitamin D pill
requires TimeToEffectVitaminD time to become effective. Over a month, the
student must ingest at least MinTotalPills pills in total, with a minimum of
MinVitaminDPills being vitamin D pills. Additionally, the number of calcium
pills taken must exceed the number of vitamin D pills. The objective is to
minimize the total time for the medication to become effective.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/220/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TimeToEffectCalcium @Def: Time it takes for a calcium pill to be effective @Shape: [] 
TimeToEffectCalcium = data['TimeToEffectCalcium']
# @Parameter TimeToEffectVitaminD @Def: Time it takes for a vitamin D pill to be effective @Shape: [] 
TimeToEffectVitaminD = data['TimeToEffectVitaminD']
# @Parameter MinTotalPills @Def: Minimum total number of pills to be taken in a month @Shape: [] 
MinTotalPills = data['MinTotalPills']
# @Parameter MinVitaminDPills @Def: Minimum number of vitamin D pills to be taken in a month @Shape: [] 
MinVitaminDPills = data['MinVitaminDPills']

# Variables 
# @Variable NumberCalciumPills @Def: The number of Calcium pills taken in a month @Shape: ['Integer'] 
NumberCalciumPills = model.addVar(vtype=GRB.INTEGER, name=""NumberCalciumPills"")
# @Variable NumberVitaminDPills @Def: The number of Vitamin D pills taken in a month @Shape: ['Integer'] 
NumberVitaminDPills = model.addVar(vtype=GRB.INTEGER, lb=MinVitaminDPills, name=""NumberVitaminDPills"")
# @Variable TotalTime @Def: The total time for the medications to become effective. @Shape: ['Continuous'] 
TotalTime = model.addVar(vtype=GRB.CONTINUOUS, name=""TotalTime"")
# @Variable IsCalciumTaken @Def: Binary variable indicating whether any Calcium pills are taken. @Shape: ['Binary'] 
IsCalciumTaken = model.addVar(vtype=GRB.BINARY, name=""IsCalciumTaken"")
# @Variable IsVitaminDTaken @Def: Binary variable indicating whether any Vitamin D pills are taken. @Shape: ['Binary'] 
IsVitaminDTaken = model.addVar(vtype=GRB.BINARY, name=""IsVitaminDTaken"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of pills ingested in a month must be at least MinTotalPills.
model.addConstr(NumberCalciumPills + NumberVitaminDPills >= MinTotalPills)
# @Constraint Constr_2 @Def: At least MinVitaminDPills of the pills ingested in a month must be vitamin D pills.
model.addConstr(NumberVitaminDPills >= MinVitaminDPills)
# @Constraint Constr_3 @Def: The number of calcium pills taken must exceed the number of vitamin D pills.
model.addConstr(NumberCalciumPills >= NumberVitaminDPills + 1)

# Objective 
# @Objective Objective @Def: Minimize the total time for the medications to become effective.
model.setObjective(TotalTime, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberCalciumPills'] = NumberCalciumPills.x
variables['NumberVitaminDPills'] = NumberVitaminDPills.x
variables['TotalTime'] = TotalTime.x
variables['IsCalciumTaken'] = IsCalciumTaken.x
variables['IsVitaminDTaken'] = IsVitaminDTaken.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An amusement park has two types of games: throwing and climbing games. Throwing games attract 15 customers every hour and climbing games attract 8 customers every hour. Throwing games costs the amusement park $2 in prizes per hour whereas climbing games cost $3 in prizes per hour. Since throwing games yield the most profit, there must be at least twice as many throwing games as climbing games. However, at least 5 games must be climbing. If the amusement park can have at most $100 in prizes every hour, maximize the total number of customers attracted every hour.","{""variables"": {""ThrowingGames"": 42.0, ""ClimbingGames"": 5.0}, ""objective"": 670.0}","{""parametrized_description"": ""An amusement park operates throwing and climbing games. Each throwing game attracts CustomersPerThrowingGame customers per hour and incurs a PrizeCostPerThrowingGame cost per hour. Each climbing game attracts CustomersPerClimbingGame customers per hour and incurs a PrizeCostPerClimbingGame cost per hour. The number of throwing games must be at least MinRatioThrowingClimbing times the number of climbing games. At least MinClimbingGames climbing games must be operated. The total prize cost per hour must not exceed MaxPrizeCostPerHour. The objective is to maximize the total number of customers attracted per hour."", ""keywords"": [""N.A.""], ""parameters"": {""CustomersPerThrowingGame"": {""description"": ""Number of customers attracted per hour by throwing games"", ""shape"": []}, ""CustomersPerClimbingGame"": {""description"": ""Number of customers attracted per hour by climbing games"", ""shape"": []}, ""PrizeCostPerThrowingGame"": {""description"": ""Cost in prizes per hour for throwing games"", ""shape"": []}, ""PrizeCostPerClimbingGame"": {""description"": ""Cost in prizes per hour for climbing games"", ""shape"": []}, ""MinRatioThrowingClimbing"": {""description"": ""Minimum ratio of throwing games to climbing games"", ""shape"": []}, ""MinClimbingGames"": {""description"": ""Minimum number of climbing games required"", ""shape"": []}, ""MaxPrizeCostPerHour"": {""description"": ""Maximum total prize cost per hour"", ""shape"": []}}, ""variables"": {""ThrowingGames"": {""description"": ""The number of throwing games"", ""type"": ""continuous"", ""shape"": []}, ""ClimbingGames"": {""description"": ""The number of climbing games"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of throwing games must be at least MinRatioThrowingClimbing times the number of climbing games."", ""formulation"": ""ThrowingGames \\geq MinRatioThrowingClimbing \\times ClimbingGames"", ""code"": {""gurobipy"": ""model.addConstr(ThrowingGames >= MinRatioThrowingClimbing * ClimbingGames)""}}, {""description"": ""At least MinClimbingGames climbing games must be operated."", ""formulation"": ""ClimbingGames \\geq MinClimbingGames"", ""code"": {""gurobipy"": ""model.addConstr(ClimbingGames >= MinClimbingGames)""}}, {""description"": ""The total prize cost per hour must not exceed MaxPrizeCostPerHour."", ""formulation"": ""PrizeCostPerThrowingGame \\times ThrowingGames + PrizeCostPerClimbingGame \\times ClimbingGames \\leq MaxPrizeCostPerHour"", ""code"": {""gurobipy"": ""model.addConstr(PrizeCostPerThrowingGame * ThrowingGames + PrizeCostPerClimbingGame * ClimbingGames <= MaxPrizeCostPerHour)""}}], ""objective"": {""description"": ""Maximize the total number of customers attracted per hour, which is the sum of CustomersPerThrowingGame multiplied by the number of throwing games and CustomersPerClimbingGame multiplied by the number of climbing games."", ""formulation"": ""Max CustomersPerThrowingGame \\times ThrowingGames + CustomersPerClimbingGame \\times ClimbingGames"", ""code"": {""gurobipy"": ""model.setObjective(CustomersPerThrowingGame * ThrowingGames + CustomersPerClimbingGame * ClimbingGames, GRB.MAXIMIZE)""}}}","{""CustomersPerThrowingGame"": 15, ""CustomersPerClimbingGame"": 8, ""PrizeCostPerThrowingGame"": 2, ""PrizeCostPerClimbingGame"": 3, ""MinRatioThrowingClimbing"": 2, ""MinClimbingGames"": 5, ""MaxPrizeCostPerHour"": 100}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
An amusement park operates throwing and climbing games. Each throwing game
attracts CustomersPerThrowingGame customers per hour and incurs a
PrizeCostPerThrowingGame cost per hour. Each climbing game attracts
CustomersPerClimbingGame customers per hour and incurs a
PrizeCostPerClimbingGame cost per hour. The number of throwing games must be at
least MinRatioThrowingClimbing times the number of climbing games. At least
MinClimbingGames climbing games must be operated. The total prize cost per hour
must not exceed MaxPrizeCostPerHour. The objective is to maximize the total
number of customers attracted per hour.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/221/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CustomersPerThrowingGame @Def: Number of customers attracted per hour by throwing games @Shape: [] 
CustomersPerThrowingGame = data['CustomersPerThrowingGame']
# @Parameter CustomersPerClimbingGame @Def: Number of customers attracted per hour by climbing games @Shape: [] 
CustomersPerClimbingGame = data['CustomersPerClimbingGame']
# @Parameter PrizeCostPerThrowingGame @Def: Cost in prizes per hour for throwing games @Shape: [] 
PrizeCostPerThrowingGame = data['PrizeCostPerThrowingGame']
# @Parameter PrizeCostPerClimbingGame @Def: Cost in prizes per hour for climbing games @Shape: [] 
PrizeCostPerClimbingGame = data['PrizeCostPerClimbingGame']
# @Parameter MinRatioThrowingClimbing @Def: Minimum ratio of throwing games to climbing games @Shape: [] 
MinRatioThrowingClimbing = data['MinRatioThrowingClimbing']
# @Parameter MinClimbingGames @Def: Minimum number of climbing games required @Shape: [] 
MinClimbingGames = data['MinClimbingGames']
# @Parameter MaxPrizeCostPerHour @Def: Maximum total prize cost per hour @Shape: [] 
MaxPrizeCostPerHour = data['MaxPrizeCostPerHour']

# Variables 
# @Variable ThrowingGames @Def: The number of throwing games @Shape: [] 
ThrowingGames = model.addVar(vtype=GRB.INTEGER, name=""ThrowingGames"")
# @Variable ClimbingGames @Def: The number of climbing games @Shape: [] 
ClimbingGames = model.addVar(vtype=GRB.INTEGER, name=""ClimbingGames"")

# Constraints 
# @Constraint Constr_1 @Def: The number of throwing games must be at least MinRatioThrowingClimbing times the number of climbing games.
model.addConstr(ThrowingGames >= MinRatioThrowingClimbing * ClimbingGames)
# @Constraint Constr_2 @Def: At least MinClimbingGames climbing games must be operated.
model.addConstr(ClimbingGames >= MinClimbingGames)
# @Constraint Constr_3 @Def: The total prize cost per hour must not exceed MaxPrizeCostPerHour.
model.addConstr(PrizeCostPerThrowingGame * ThrowingGames + PrizeCostPerClimbingGame * ClimbingGames <= MaxPrizeCostPerHour)

# Objective 
# @Objective Objective @Def: Maximize the total number of customers attracted per hour, which is the sum of CustomersPerThrowingGame multiplied by the number of throwing games and CustomersPerClimbingGame multiplied by the number of climbing games.
model.setObjective(CustomersPerThrowingGame * ThrowingGames + CustomersPerClimbingGame * ClimbingGames, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ThrowingGames'] = ThrowingGames.x
variables['ClimbingGames'] = ClimbingGames.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"In a science fair, there are two types of tables that can be used to display the children’s science experiments. At the circular tables, 4 poster boards and 5 participants can fit around the table to cater to 8 guests. At the rectangular tables, 4 poster boards and 4 participants can fit around the table to cater to 12 guests. However, each circular table takes up 15 units of space while each rectangular table takes up 20 units of space. The science fair has must be able to fit at least 500 participants and 300 poster boards. If the science fair has available 1900 units of space, how many of each type of table should be set up to maximize the number of catered guests?","{""variables"": {""CircularTables"": 60.0, ""RectangularTables"": 50.0}, ""objective"": 1080.0}","{""parametrized_description"": ""Determine the number of circular tables and rectangular tables to set up, where each circular table accommodates PosterBoardsPerCircularTable poster boards and ParticipantsPerCircularTable participants, thereby catering to GuestsPerCircularTable guests, and occupies SpacePerCircularTable space units. Each rectangular table accommodates PosterBoardsPerRectangularTable poster boards and ParticipantsPerRectangularTable participants, thereby catering to GuestsPerRectangularTable guests, and occupies SpacePerRectangularTable space units. The total number of participants must be at least MinimumParticipants, the total number of poster boards must be at least MinimumPosterBoards, and the total space used must not exceed AvailableSpace. The objective is to maximize the number of catered guests."", ""keywords"": [""N.A.""], ""parameters"": {""PosterBoardsPerCircularTable"": {""description"": ""Number of poster boards per circular table"", ""shape"": []}, ""ParticipantsPerCircularTable"": {""description"": ""Number of participants per circular table"", ""shape"": []}, ""GuestsPerCircularTable"": {""description"": ""Number of guests catered per circular table"", ""shape"": []}, ""SpacePerCircularTable"": {""description"": ""Space units taken by one circular table"", ""shape"": []}, ""PosterBoardsPerRectangularTable"": {""description"": ""Number of poster boards per rectangular table"", ""shape"": []}, ""ParticipantsPerRectangularTable"": {""description"": ""Number of participants per rectangular table"", ""shape"": []}, ""GuestsPerRectangularTable"": {""description"": ""Number of guests catered per rectangular table"", ""shape"": []}, ""SpacePerRectangularTable"": {""description"": ""Space units taken by one rectangular table"", ""shape"": []}, ""MinimumParticipants"": {""description"": ""Minimum number of participants to be accommodated"", ""shape"": []}, ""MinimumPosterBoards"": {""description"": ""Minimum number of poster boards to be accommodated"", ""shape"": []}, ""AvailableSpace"": {""description"": ""Total available space units"", ""shape"": []}}, ""variables"": {""CircularTables"": {""description"": ""The number of circular tables"", ""type"": ""continuous"", ""shape"": [""integer""]}, ""RectangularTables"": {""description"": ""The number of rectangular tables"", ""type"": ""continuous"", ""shape"": [""integer""]}}, ""constraints"": [{""description"": ""The total number of participants from circular and rectangular tables must be at least MinimumParticipants."", ""formulation"": ""ParticipantsPerCircularTable \\cdot CircularTables + ParticipantsPerRectangularTable \\cdot RectangularTables \\geq MinimumParticipants"", ""code"": {""gurobipy"": ""model.addConstr(ParticipantsPerCircularTable * CircularTables + ParticipantsPerRectangularTable * RectangularTables >= MinimumParticipants)""}}, {""description"": ""The total number of poster boards from circular and rectangular tables must be at least MinimumPosterBoards."", ""formulation"": ""PosterBoardsPerCircularTable \\cdot CircularTables + PosterBoardsPerRectangularTable \\cdot RectangularTables \\geq MinimumPosterBoards"", ""code"": {""gurobipy"": ""model.addConstr(PosterBoardsPerCircularTable * CircularTables + PosterBoardsPerRectangularTable * RectangularTables >= MinimumPosterBoards)""}}, {""description"": ""The total space used by circular and rectangular tables must not exceed AvailableSpace."", ""formulation"": ""SpacePerCircularTable \\cdot CircularTables + SpacePerRectangularTable \\cdot RectangularTables \\leq AvailableSpace"", ""code"": {""gurobipy"": ""model.addConstr(SpacePerCircularTable * CircularTables + SpacePerRectangularTable * RectangularTables <= AvailableSpace)""}}], ""objective"": {""description"": ""The total number of catered guests is the sum of guests from circular and rectangular tables. The objective is to maximize the number of catered guests."", ""formulation"": ""Max \\ GuestsPerCircularTable \\times CircularTables + GuestsPerRectangularTable \\times RectangularTables"", ""code"": {""gurobipy"": ""model.setObjective(GuestsPerCircularTable * CircularTables + GuestsPerRectangularTable * RectangularTables, GRB.MAXIMIZE)""}}}","{""PosterBoardsPerCircularTable"": 4, ""ParticipantsPerCircularTable"": 5, ""GuestsPerCircularTable"": 8, ""SpacePerCircularTable"": 15, ""PosterBoardsPerRectangularTable"": 4, ""ParticipantsPerRectangularTable"": 4, ""GuestsPerRectangularTable"": 12, ""SpacePerRectangularTable"": 20, ""MinimumParticipants"": 500, ""MinimumPosterBoards"": 300, ""AvailableSpace"": 1900}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Determine the number of circular tables and rectangular tables to set up, where
each circular table accommodates PosterBoardsPerCircularTable poster boards and
ParticipantsPerCircularTable participants, thereby catering to
GuestsPerCircularTable guests, and occupies SpacePerCircularTable space units.
Each rectangular table accommodates PosterBoardsPerRectangularTable poster
boards and ParticipantsPerRectangularTable participants, thereby catering to
GuestsPerRectangularTable guests, and occupies SpacePerRectangularTable space
units. The total number of participants must be at least MinimumParticipants,
the total number of poster boards must be at least MinimumPosterBoards, and the
total space used must not exceed AvailableSpace. The objective is to maximize
the number of catered guests.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/222/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter PosterBoardsPerCircularTable @Def: Number of poster boards per circular table @Shape: [] 
PosterBoardsPerCircularTable = data['PosterBoardsPerCircularTable']
# @Parameter ParticipantsPerCircularTable @Def: Number of participants per circular table @Shape: [] 
ParticipantsPerCircularTable = data['ParticipantsPerCircularTable']
# @Parameter GuestsPerCircularTable @Def: Number of guests catered per circular table @Shape: [] 
GuestsPerCircularTable = data['GuestsPerCircularTable']
# @Parameter SpacePerCircularTable @Def: Space units taken by one circular table @Shape: [] 
SpacePerCircularTable = data['SpacePerCircularTable']
# @Parameter PosterBoardsPerRectangularTable @Def: Number of poster boards per rectangular table @Shape: [] 
PosterBoardsPerRectangularTable = data['PosterBoardsPerRectangularTable']
# @Parameter ParticipantsPerRectangularTable @Def: Number of participants per rectangular table @Shape: [] 
ParticipantsPerRectangularTable = data['ParticipantsPerRectangularTable']
# @Parameter GuestsPerRectangularTable @Def: Number of guests catered per rectangular table @Shape: [] 
GuestsPerRectangularTable = data['GuestsPerRectangularTable']
# @Parameter SpacePerRectangularTable @Def: Space units taken by one rectangular table @Shape: [] 
SpacePerRectangularTable = data['SpacePerRectangularTable']
# @Parameter MinimumParticipants @Def: Minimum number of participants to be accommodated @Shape: [] 
MinimumParticipants = data['MinimumParticipants']
# @Parameter MinimumPosterBoards @Def: Minimum number of poster boards to be accommodated @Shape: [] 
MinimumPosterBoards = data['MinimumPosterBoards']
# @Parameter AvailableSpace @Def: Total available space units @Shape: [] 
AvailableSpace = data['AvailableSpace']

# Variables 
# @Variable CircularTables @Def: The number of circular tables @Shape: ['integer'] 
CircularTables = model.addVar(vtype=GRB.INTEGER, name=""CircularTables"")
# @Variable RectangularTables @Def: The number of rectangular tables @Shape: ['integer'] 
RectangularTables = model.addVar(vtype=GRB.INTEGER, name=""RectangularTables"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of participants from circular and rectangular tables must be at least MinimumParticipants.
model.addConstr(ParticipantsPerCircularTable * CircularTables + ParticipantsPerRectangularTable * RectangularTables >= MinimumParticipants)
# @Constraint Constr_2 @Def: The total number of poster boards from circular and rectangular tables must be at least MinimumPosterBoards.
model.addConstr(PosterBoardsPerCircularTable * CircularTables + PosterBoardsPerRectangularTable * RectangularTables >= MinimumPosterBoards)
# @Constraint Constr_3 @Def: The total space used by circular and rectangular tables must not exceed AvailableSpace.
model.addConstr(SpacePerCircularTable * CircularTables + SpacePerRectangularTable * RectangularTables <= AvailableSpace)

# Objective 
# @Objective Objective @Def: The total number of catered guests is the sum of guests from circular and rectangular tables. The objective is to maximize the number of catered guests.
model.setObjective(GuestsPerCircularTable * CircularTables + GuestsPerRectangularTable * RectangularTables, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['CircularTables'] = CircularTables.x
variables['RectangularTables'] = RectangularTables.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An oil and gas company has two types of pipes, a high-volume and a low-volume one. Every day, the high-volume pipe allows 10000 US gallons and it is recommended that 12 technicians closely monitor the pipes to ensure that it is functioning properly. Each day, the low-volume pipe allows 5000 US gallons and 5 technicians should closely monitor for safety reasons. Every day, the oil and gas company needs to meet the demands of at least 150000 US gallons of gas and they have 160 technicians that are on their staff. Since the high-volume pipe has a higher risk of environmental damage, at most 35 percent of the pipes can be high-volume ones. Additionally, there must be a minimum of 8 low-volume pipes. How many of each pipe types should be used to reduce the total number of pipes required?","{""variables"": {""HighVolumePipes"": 5.0, ""LowVolumePipes"": 20.0}, ""objective"": 25.0}","{""parametrized_description"": ""A company must determine the number of HighVolumePipes and LowVolumePipes to ensure that the combined daily capacity meets or exceeds the DailyGasDemand. The total number of technicians required to monitor these pipes must not exceed the TotalTechnicians available. Additionally, the proportion of HighVolumePipes used should not surpass the MaxHighVolumeProportion of all pipes, and there must be at least MinLowVolumePipes LowVolumePipes. The objective is to minimize the total number of pipes employed."", ""keywords"": [""N.A.""], ""parameters"": {""HighVolumeCapacity"": {""description"": ""The daily capacity of a high-volume pipe in US gallons"", ""shape"": []}, ""LowVolumeCapacity"": {""description"": ""The daily capacity of a low-volume pipe in US gallons"", ""shape"": []}, ""TechniciansPerHighVolumePipe"": {""description"": ""Number of technicians required to monitor each high-volume pipe daily"", ""shape"": []}, ""TechniciansPerLowVolumePipe"": {""description"": ""Number of technicians required to monitor each low-volume pipe daily"", ""shape"": []}, ""DailyGasDemand"": {""description"": ""Minimum daily US gallons of gas that need to be met"", ""shape"": []}, ""TotalTechnicians"": {""description"": ""Total number of technicians available daily"", ""shape"": []}, ""MaxHighVolumeProportion"": {""description"": ""Maximum allowed proportion of high-volume pipes"", ""shape"": []}, ""MinLowVolumePipes"": {""description"": ""Minimum number of low-volume pipes required"", ""shape"": []}}, ""variables"": {""HighVolumePipes"": {""description"": ""The number of high-volume pipes"", ""type"": ""continuous"", ""shape"": []}, ""LowVolumePipes"": {""description"": ""The number of low-volume pipes"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The combined daily capacity of HighVolumePipes and LowVolumePipes must be at least DailyGasDemand."", ""formulation"": ""HighVolumePipes \\cdot HighVolumeCapacity + LowVolumePipes \\cdot LowVolumeCapacity \\geq DailyGasDemand"", ""code"": {""gurobipy"": ""model.addConstr(HighVolumeCapacity * HighVolumePipes + LowVolumeCapacity * LowVolumePipes >= DailyGasDemand)""}}, {""description"": ""The total number of technicians required to monitor HighVolumePipes and LowVolumePipes must not exceed TotalTechnicians available."", ""formulation"": ""TechniciansPerHighVolumePipe \\cdot HighVolumePipes + TechniciansPerLowVolumePipe \\cdot LowVolumePipes \\leq TotalTechnicians"", ""code"": {""gurobipy"": ""model.addConstr(TechniciansPerHighVolumePipe * HighVolumePipes + TechniciansPerLowVolumePipe * LowVolumePipes <= TotalTechnicians)""}}, {""description"": ""The proportion of HighVolumePipes relative to the total number of pipes must not exceed MaxHighVolumeProportion."", ""formulation"": ""HighVolumePipes \\leq MaxHighVolumeProportion \\times (HighVolumePipes + LowVolumePipes)"", ""code"": {""gurobipy"": ""model.addConstr(HighVolumePipes <= MaxHighVolumeProportion * (HighVolumePipes + LowVolumePipes))""}}, {""description"": ""At least MinLowVolumePipes LowVolumePipes must be employed."", ""formulation"": ""LowVolumePipes \\geq MinLowVolumePipes"", ""code"": {""gurobipy"": ""model.addConstr(LowVolumePipes >= MinLowVolumePipes)""}}], ""objective"": {""description"": ""Minimize the total number of pipes employed."", ""formulation"": ""Min \\ HighVolumePipes + LowVolumePipes"", ""code"": {""gurobipy"": ""model.setObjective(HighVolumePipes + LowVolumePipes, GRB.MINIMIZE)""}}}","{""HighVolumeCapacity"": 10000, ""LowVolumeCapacity"": 5000, ""TechniciansPerHighVolumePipe"": 12, ""TechniciansPerLowVolumePipe"": 5, ""DailyGasDemand"": 150000, ""TotalTechnicians"": 160, ""MaxHighVolumeProportion"": 0.35, ""MinLowVolumePipes"": 8}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company must determine the number of HighVolumePipes and LowVolumePipes to
ensure that the combined daily capacity meets or exceeds the DailyGasDemand. The
total number of technicians required to monitor these pipes must not exceed the
TotalTechnicians available. Additionally, the proportion of HighVolumePipes used
should not surpass the MaxHighVolumeProportion of all pipes, and there must be
at least MinLowVolumePipes LowVolumePipes. The objective is to minimize the
total number of pipes employed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/223/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter HighVolumeCapacity @Def: The daily capacity of a high-volume pipe in US gallons @Shape: [] 
HighVolumeCapacity = data['HighVolumeCapacity']
# @Parameter LowVolumeCapacity @Def: The daily capacity of a low-volume pipe in US gallons @Shape: [] 
LowVolumeCapacity = data['LowVolumeCapacity']
# @Parameter TechniciansPerHighVolumePipe @Def: Number of technicians required to monitor each high-volume pipe daily @Shape: [] 
TechniciansPerHighVolumePipe = data['TechniciansPerHighVolumePipe']
# @Parameter TechniciansPerLowVolumePipe @Def: Number of technicians required to monitor each low-volume pipe daily @Shape: [] 
TechniciansPerLowVolumePipe = data['TechniciansPerLowVolumePipe']
# @Parameter DailyGasDemand @Def: Minimum daily US gallons of gas that need to be met @Shape: [] 
DailyGasDemand = data['DailyGasDemand']
# @Parameter TotalTechnicians @Def: Total number of technicians available daily @Shape: [] 
TotalTechnicians = data['TotalTechnicians']
# @Parameter MaxHighVolumeProportion @Def: Maximum allowed proportion of high-volume pipes @Shape: [] 
MaxHighVolumeProportion = data['MaxHighVolumeProportion']
# @Parameter MinLowVolumePipes @Def: Minimum number of low-volume pipes required @Shape: [] 
MinLowVolumePipes = data['MinLowVolumePipes']

# Variables 
# @Variable HighVolumePipes @Def: The number of high-volume pipes @Shape: [] 
HighVolumePipes = model.addVar(vtype=GRB.INTEGER, name=""HighVolumePipes"")
# @Variable LowVolumePipes @Def: The number of low-volume pipes @Shape: [] 
LowVolumePipes = model.addVar(vtype=GRB.INTEGER, name=""LowVolumePipes"")

# Constraints 
# @Constraint Constr_1 @Def: The combined daily capacity of HighVolumePipes and LowVolumePipes must be at least DailyGasDemand.
model.addConstr(HighVolumeCapacity * HighVolumePipes + LowVolumeCapacity * LowVolumePipes >= DailyGasDemand)
# @Constraint Constr_2 @Def: The total number of technicians required to monitor HighVolumePipes and LowVolumePipes must not exceed TotalTechnicians available.
model.addConstr(TechniciansPerHighVolumePipe * HighVolumePipes + TechniciansPerLowVolumePipe * LowVolumePipes <= TotalTechnicians)
# @Constraint Constr_3 @Def: The proportion of HighVolumePipes relative to the total number of pipes must not exceed MaxHighVolumeProportion.
model.addConstr(HighVolumePipes <= MaxHighVolumeProportion * (HighVolumePipes + LowVolumePipes))
# @Constraint Constr_4 @Def: At least MinLowVolumePipes LowVolumePipes must be employed.
model.addConstr(LowVolumePipes >= MinLowVolumePipes)

# Objective 
# @Objective Objective @Def: Minimize the total number of pipes employed.
model.setObjective(HighVolumePipes + LowVolumePipes, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['HighVolumePipes'] = HighVolumePipes.x
variables['LowVolumePipes'] = LowVolumePipes.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A hospital hires ultrasound technicians and graduate researchers to image patients. An ultrasound technician works 8 hours per shift while a graduate researcher works 5 hours per shift. Ultrasound technicians are paid $300 per shift while graduate researchers are paid $100 per shift. However, due to regulations, there must be twice as many ultrasound technician shifts than graduate researcher shifts. Currently, the hospital needs 500 hours of ultrasound services to meet needs. If the hospital has a budget of $14000, how many of each worker certified to use the ultrasound should be scheduled to reduce the total number of workers?",{},"{""parametrized_description"": ""A hospital hires UltrasoundTechnician and GraduateResearcher to image patients. An UltrasoundTechnician works UltrasoundTechnicianShiftHours per shift while a GraduateResearcher works GraduateResearcherShiftHours per shift. UltrasoundTechnicians are paid UltrasoundTechnicianPayment per shift while GraduateResearchers are paid GraduateResearcherPayment per shift. Due to regulations, there must be ShiftRatio times as many UltrasoundTechnician shifts as GraduateResearcher shifts. Currently, the hospital needs RequiredUltrasoundServiceHours of ultrasound services to meet needs. If the hospital has a budget of TotalBudget, how many of each worker certified to use the ultrasound should be scheduled to reduce the total number of workers?"", ""keywords"": [""N.A.""], ""parameters"": {""UltrasoundTechnicianShiftHours"": {""description"": ""The number of hours an ultrasound technician works per shift"", ""shape"": []}, ""GraduateResearcherShiftHours"": {""description"": ""The number of hours a graduate researcher works per shift"", ""shape"": []}, ""UltrasoundTechnicianPayment"": {""description"": ""The payment an ultrasound technician receives per shift"", ""shape"": []}, ""GraduateResearcherPayment"": {""description"": ""The payment a graduate researcher receives per shift"", ""shape"": []}, ""ShiftRatio"": {""description"": ""The required ratio of ultrasound technician shifts to graduate researcher shifts"", ""shape"": []}, ""RequiredUltrasoundServiceHours"": {""description"": ""The total number of ultrasound service hours required"", ""shape"": []}, ""TotalBudget"": {""description"": ""The total budget available for workers' payments"", ""shape"": []}}, ""variables"": {""NumberOfUltrasoundTechnicianShifts"": {""description"": ""The number of shifts for ultrasound technicians"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfGraduateResearcherShifts"": {""description"": ""The number of shifts for graduate researchers"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""There must be ShiftRatio times as many UltrasoundTechnician shifts as GraduateResearcher shifts."", ""formulation"": ""NumberOfUltrasoundTechnicianShifts = ShiftRatio \\times NumberOfGraduateResearcherShifts"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfUltrasoundTechnicianShifts == ShiftRatio * NumberOfGraduateResearcherShifts)""}}, {""description"": ""The total ultrasound service hours provided by UltrasoundTechnicians and GraduateResearchers must be at least RequiredUltrasoundServiceHours."", ""formulation"": ""NumberOfUltrasoundTechnicianShifts \\times UltrasoundTechnicianShiftHours + NumberOfGraduateResearcherShifts \\times GraduateResearcherShiftHours \\geq RequiredUltrasoundServiceHours"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfUltrasoundTechnicianShifts * UltrasoundTechnicianShiftHours + NumberOfGraduateResearcherShifts * GraduateResearcherShiftHours >= RequiredUltrasoundServiceHours)""}}, {""description"": ""The total payment for UltrasoundTechnicians and GraduateResearchers must not exceed TotalBudget."", ""formulation"": ""UltrasoundTechnicianPayment \\cdot NumberOfUltrasoundTechnicianShifts + GraduateResearcherPayment \\cdot NumberOfGraduateResearcherShifts \\leq TotalBudget"", ""code"": {""gurobipy"": ""model.addConstr(UltrasoundTechnicianPayment * NumberOfUltrasoundTechnicianShifts + GraduateResearcherPayment * NumberOfGraduateResearcherShifts <= TotalBudget)""}}], ""objective"": {""description"": ""Total number of workers is the sum of UltrasoundTechnician shifts and GraduateResearcher shifts. The objective is to minimize the total number of workers."", ""formulation"": ""\\text{Min} \\ NumberOfUltrasoundTechnicianShifts + NumberOfGraduateResearcherShifts"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfUltrasoundTechnicianShifts + NumberOfGraduateResearcherShifts, GRB.MINIMIZE)""}}}","{""UltrasoundTechnicianShiftHours"": 8, ""GraduateResearcherShiftHours"": 5, ""UltrasoundTechnicianPayment"": 300, ""GraduateResearcherPayment"": 100, ""ShiftRatio"": 2, ""RequiredUltrasoundServiceHours"": 500, ""TotalBudget"": 14000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A hospital hires UltrasoundTechnician and GraduateResearcher to image patients.
An UltrasoundTechnician works UltrasoundTechnicianShiftHours per shift while a
GraduateResearcher works GraduateResearcherShiftHours per shift.
UltrasoundTechnicians are paid UltrasoundTechnicianPayment per shift while
GraduateResearchers are paid GraduateResearcherPayment per shift. Due to
regulations, there must be ShiftRatio times as many UltrasoundTechnician shifts
as GraduateResearcher shifts. Currently, the hospital needs
RequiredUltrasoundServiceHours of ultrasound services to meet needs. If the
hospital has a budget of TotalBudget, how many of each worker certified to use
the ultrasound should be scheduled to reduce the total number of workers?
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/224/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter UltrasoundTechnicianShiftHours @Def: The number of hours an ultrasound technician works per shift @Shape: [] 
UltrasoundTechnicianShiftHours = data['UltrasoundTechnicianShiftHours']
# @Parameter GraduateResearcherShiftHours @Def: The number of hours a graduate researcher works per shift @Shape: [] 
GraduateResearcherShiftHours = data['GraduateResearcherShiftHours']
# @Parameter UltrasoundTechnicianPayment @Def: The payment an ultrasound technician receives per shift @Shape: [] 
UltrasoundTechnicianPayment = data['UltrasoundTechnicianPayment']
# @Parameter GraduateResearcherPayment @Def: The payment a graduate researcher receives per shift @Shape: [] 
GraduateResearcherPayment = data['GraduateResearcherPayment']
# @Parameter ShiftRatio @Def: The required ratio of ultrasound technician shifts to graduate researcher shifts @Shape: [] 
ShiftRatio = data['ShiftRatio']
# @Parameter RequiredUltrasoundServiceHours @Def: The total number of ultrasound service hours required @Shape: [] 
RequiredUltrasoundServiceHours = data['RequiredUltrasoundServiceHours']
# @Parameter TotalBudget @Def: The total budget available for workers' payments @Shape: [] 
TotalBudget = data['TotalBudget']

# Variables 
# @Variable NumberOfUltrasoundTechnicianShifts @Def: The number of shifts for ultrasound technicians @Shape: [] 
NumberOfUltrasoundTechnicianShifts = model.addVar(vtype=GRB.INTEGER, name=""NumberOfUltrasoundTechnicianShifts"")
# @Variable NumberOfGraduateResearcherShifts @Def: The number of shifts for graduate researchers @Shape: [] 
NumberOfGraduateResearcherShifts = model.addVar(vtype=GRB.INTEGER, name=""NumberOfGraduateResearcherShifts"")

# Constraints 
# @Constraint Constr_1 @Def: There must be ShiftRatio times as many UltrasoundTechnician shifts as GraduateResearcher shifts.
model.addConstr(NumberOfUltrasoundTechnicianShifts == ShiftRatio * NumberOfGraduateResearcherShifts)
# @Constraint Constr_2 @Def: The total ultrasound service hours provided by UltrasoundTechnicians and GraduateResearchers must be at least RequiredUltrasoundServiceHours.
model.addConstr(NumberOfUltrasoundTechnicianShifts * UltrasoundTechnicianShiftHours + NumberOfGraduateResearcherShifts * GraduateResearcherShiftHours >= RequiredUltrasoundServiceHours)
# @Constraint Constr_3 @Def: The total payment for UltrasoundTechnicians and GraduateResearchers must not exceed TotalBudget.
model.addConstr(UltrasoundTechnicianPayment * NumberOfUltrasoundTechnicianShifts + GraduateResearcherPayment * NumberOfGraduateResearcherShifts <= TotalBudget)

# Objective 
# @Objective Objective @Def: Total number of workers is the sum of UltrasoundTechnician shifts and GraduateResearcher shifts. The objective is to minimize the total number of workers.
model.setObjective(NumberOfUltrasoundTechnicianShifts + NumberOfGraduateResearcherShifts, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfUltrasoundTechnicianShifts'] = NumberOfUltrasoundTechnicianShifts.x
variables['NumberOfGraduateResearcherShifts'] = NumberOfGraduateResearcherShifts.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A dentist has 3000 units of resin to fill cavities in both molars and canines. Molars require 20 units of resin and 3 units of pain killer. Canines require 15 units of resin and 2.3 units of pain killer. Since this dentist sees more cavities in canines, at least 60% of cavities filled must be in canines. In addition, the dentist must reserve materials to fill at least 45 molars. How many of each type of teeth should the dentist schedule to fill to minimize the amount of pain killer needed?","{""variables"": {""NumberMolars"": 45.0, ""NumberCanines"": 68.0}, ""objective"": 291.4}","{""parametrized_description"": ""A dentist must determine the number of molars and canines to fill, ensuring that ResinPerMolar multiplied by the number of molars plus ResinPerCanine multiplied by the number of canines does not exceed TotalResin. Additionally, the number of canines must be at least MinPercentageCanines times the total number of cavities filled, and the number of molars must be at least MinNumMolars. The objective is to minimize the total pain killer used, which is PainKillerPerMolar multiplied by the number of molars plus PainKillerPerCanine multiplied by the number of canines."", ""keywords"": [""N.A.""], ""parameters"": {""TotalResin"": {""description"": ""Total amount of resin available for filling cavities"", ""shape"": []}, ""ResinPerMolar"": {""description"": ""Units of resin required to fill one molar"", ""shape"": []}, ""ResinPerCanine"": {""description"": ""Units of resin required to fill one canine"", ""shape"": []}, ""PainKillerPerMolar"": {""description"": ""Units of pain killer required to fill one molar"", ""shape"": []}, ""PainKillerPerCanine"": {""description"": ""Units of pain killer required to fill one canine"", ""shape"": []}, ""MinPercentageCanines"": {""description"": ""Minimum fraction of cavities filled that must be canines"", ""shape"": []}, ""MinNumMolars"": {""description"": ""Minimum number of molars that must be filled"", ""shape"": []}}, ""variables"": {""NumberMolars"": {""description"": ""The number of molars to be filled"", ""type"": ""continuous"", ""shape"": []}, ""NumberCanines"": {""description"": ""The number of canines to be filled"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total resin used for filling molars and canines must not exceed the total available resin. This is represented by ResinPerMolar multiplied by the number of molars plus ResinPerCanine multiplied by the number of canines being less than or equal to TotalResin."", ""formulation"": ""ResinPerMolar \\times NumberMolars + ResinPerCanine \\times NumberCanines \\leq TotalResin"", ""code"": {""gurobipy"": ""model.addConstr(ResinPerMolar * NumberMolars + ResinPerCanine * NumberCanines <= TotalResin)""}}, {""description"": ""The number of canines filled must be at least MinPercentageCanines times the total number of cavities filled. This means that the number of canines is at least MinPercentageCanines multiplied by the sum of the number of molars and canines."", ""formulation"": ""NumberCanines \\geq MinPercentageCanines \\times (NumberCanines + NumberMolars)"", ""code"": {""gurobipy"": ""model.addConstr(NumberCanines >= MinPercentageCanines * (NumberCanines + NumberMolars))""}}, {""description"": ""The number of molars filled must be at least MinNumMolars."", ""formulation"": ""NumberMolars \\geq MinNumMolars"", ""code"": {""gurobipy"": ""model.addConstr(NumberMolars >= MinNumMolars)""}}], ""objective"": {""description"": ""Minimize the total pain killer used, which is PainKillerPerMolar multiplied by the number of molars plus PainKillerPerCanine multiplied by the number of canines."", ""formulation"": ""Min \\ PainKillerPerMolar \\times NumberMolars + PainKillerPerCanine \\times NumberCanines"", ""code"": {""gurobipy"": ""model.setObjective(PainKillerPerMolar * NumberMolars + PainKillerPerCanine * NumberCanines, GRB.MINIMIZE)""}}}","{""TotalResin"": 3000, ""ResinPerMolar"": 20, ""ResinPerCanine"": 15, ""PainKillerPerMolar"": 3, ""PainKillerPerCanine"": 2.3, ""MinPercentageCanines"": 0.6, ""MinNumMolars"": 45}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A dentist must determine the number of molars and canines to fill, ensuring that
ResinPerMolar multiplied by the number of molars plus ResinPerCanine multiplied
by the number of canines does not exceed TotalResin. Additionally, the number of
canines must be at least MinPercentageCanines times the total number of cavities
filled, and the number of molars must be at least MinNumMolars. The objective is
to minimize the total pain killer used, which is PainKillerPerMolar multiplied
by the number of molars plus PainKillerPerCanine multiplied by the number of
canines.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/225/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalResin @Def: Total amount of resin available for filling cavities @Shape: [] 
TotalResin = data['TotalResin']
# @Parameter ResinPerMolar @Def: Units of resin required to fill one molar @Shape: [] 
ResinPerMolar = data['ResinPerMolar']
# @Parameter ResinPerCanine @Def: Units of resin required to fill one canine @Shape: [] 
ResinPerCanine = data['ResinPerCanine']
# @Parameter PainKillerPerMolar @Def: Units of pain killer required to fill one molar @Shape: [] 
PainKillerPerMolar = data['PainKillerPerMolar']
# @Parameter PainKillerPerCanine @Def: Units of pain killer required to fill one canine @Shape: [] 
PainKillerPerCanine = data['PainKillerPerCanine']
# @Parameter MinPercentageCanines @Def: Minimum fraction of cavities filled that must be canines @Shape: [] 
MinPercentageCanines = data['MinPercentageCanines']
# @Parameter MinNumMolars @Def: Minimum number of molars that must be filled @Shape: [] 
MinNumMolars = data['MinNumMolars']

# Variables 
# @Variable NumberMolars @Def: The number of molars to be filled @Shape: [] 
NumberMolars = model.addVar(vtype=GRB.INTEGER, name=""NumberMolars"")
# @Variable NumberCanines @Def: The number of canines to be filled @Shape: [] 
NumberCanines = model.addVar(vtype=GRB.INTEGER, name=""NumberCanines"")

# Constraints 
# @Constraint Constr_1 @Def: The total resin used for filling molars and canines must not exceed the total available resin. This is represented by ResinPerMolar multiplied by the number of molars plus ResinPerCanine multiplied by the number of canines being less than or equal to TotalResin.
model.addConstr(ResinPerMolar * NumberMolars + ResinPerCanine * NumberCanines <= TotalResin)
# @Constraint Constr_2 @Def: The number of canines filled must be at least MinPercentageCanines times the total number of cavities filled. This means that the number of canines is at least MinPercentageCanines multiplied by the sum of the number of molars and canines.
model.addConstr(NumberCanines >= MinPercentageCanines * (NumberCanines + NumberMolars))
# @Constraint Constr_3 @Def: The number of molars filled must be at least MinNumMolars.
model.addConstr(NumberMolars >= MinNumMolars)

# Objective 
# @Objective Objective @Def: Minimize the total pain killer used, which is PainKillerPerMolar multiplied by the number of molars plus PainKillerPerCanine multiplied by the number of canines.
model.setObjective(PainKillerPerMolar * NumberMolars + PainKillerPerCanine * NumberCanines, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberMolars'] = NumberMolars.x
variables['NumberCanines'] = NumberCanines.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A food delivery person can either have shifts on bikes or scooters. A shift on a bike can deliver 10 orders, takes 5 units of energy, and brings in $50 on tips because it is faster. A shift on a scooter can deliver 7 orders, takes 6 units of energy, and brings in $43 on tips.  The delivery person has available 40 shifts a month and has 230 units of energy and must bring at least 320 orders. He must have at least 5 shifts on a scooter because bikes are harder to get. How many shifts on each type of transportation should the delivery person schedule to maximize tips received?","{""variables"": {""BikeShifts"": 35.0, ""ScooterShifts"": 5.0}, ""objective"": 1965.0}","{""parametrized_description"": ""A delivery person can schedule shifts on either bike or scooter. Each bike shift delivers OrdersPerBikeShift orders, consumes EnergyPerBikeShift units of energy, and receives TipsPerBikeShift in tips. Each scooter shift delivers OrdersPerScooterShift orders, consumes EnergyPerScooterShift units of energy, and receives TipsPerScooterShift in tips. The delivery person has TotalShifts available per month, TotalEnergy units of energy, must deliver at least MinOrders orders, and must schedule at least MinShiftsScooter shifts on a scooter. The goal is to maximize the total tips received."", ""keywords"": [""N.A.""], ""parameters"": {""TotalShifts"": {""description"": ""Total number of shifts available per month"", ""shape"": []}, ""TotalEnergy"": {""description"": ""Total units of energy available per month"", ""shape"": []}, ""MinOrders"": {""description"": ""Minimum number of orders to deliver"", ""shape"": []}, ""MinShiftsScooter"": {""description"": ""Minimum number of shifts on a scooter"", ""shape"": []}, ""OrdersPerBikeShift"": {""description"": ""Number of orders delivered per bike shift"", ""shape"": []}, ""EnergyPerBikeShift"": {""description"": ""Units of energy consumed per bike shift"", ""shape"": []}, ""TipsPerBikeShift"": {""description"": ""Tips received per bike shift"", ""shape"": []}, ""OrdersPerScooterShift"": {""description"": ""Number of orders delivered per scooter shift"", ""shape"": []}, ""EnergyPerScooterShift"": {""description"": ""Units of energy consumed per scooter shift"", ""shape"": []}, ""TipsPerScooterShift"": {""description"": ""Tips received per scooter shift"", ""shape"": []}}, ""variables"": {""BikeShifts"": {""description"": ""The number of bike shifts scheduled"", ""type"": ""continuous"", ""shape"": []}, ""ScooterShifts"": {""description"": ""The number of scooter shifts scheduled"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of bike and scooter shifts scheduled cannot exceed the TotalShifts available per month."", ""formulation"": ""BikeShifts + ScooterShifts \\leq TotalShifts"", ""code"": {""gurobipy"": ""model.addConstr(BikeShifts + ScooterShifts <= TotalShifts)""}}, {""description"": ""The total energy consumed by all shifts cannot exceed TotalEnergy units."", ""formulation"": ""EnergyPerBikeShift \\cdot BikeShifts + EnergyPerScooterShift \\cdot ScooterShifts \\leq TotalEnergy"", ""code"": {""gurobipy"": ""model.addConstr(EnergyPerBikeShift * BikeShifts + EnergyPerScooterShift * ScooterShifts <= TotalEnergy)""}}, {""description"": ""The total number of orders delivered must be at least MinOrders."", ""formulation"": ""BikeShifts \\cdot OrdersPerBikeShift + ScooterShifts \\cdot OrdersPerScooterShift \\geq MinOrders"", ""code"": {""gurobipy"": ""model.addConstr(BikeShifts * OrdersPerBikeShift + ScooterShifts * OrdersPerScooterShift >= MinOrders)""}}, {""description"": ""At least MinShiftsScooter shifts must be scheduled on a scooter."", ""formulation"": ""ScooterShifts \\geq MinShiftsScooter"", ""code"": {""gurobipy"": ""model.addConstr(ScooterShifts >= MinShiftsScooter)""}}], ""objective"": {""description"": ""The total tips received is the sum of the tips from all bike and scooter shifts. The objective is to maximize the total tips received."", ""formulation"": ""Max \\ TipsPerBikeShift \\times BikeShifts + TipsPerScooterShift \\times ScooterShifts"", ""code"": {""gurobipy"": ""model.setObjective(TipsPerBikeShift * BikeShifts + TipsPerScooterShift * ScooterShifts, GRB.MAXIMIZE)""}}}","{""TotalShifts"": 40, ""TotalEnergy"": 230, ""MinOrders"": 320, ""MinShiftsScooter"": 5, ""OrdersPerBikeShift"": 10, ""EnergyPerBikeShift"": 5, ""TipsPerBikeShift"": 50, ""OrdersPerScooterShift"": 7, ""EnergyPerScooterShift"": 6, ""TipsPerScooterShift"": 43}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A delivery person can schedule shifts on either bike or scooter. Each bike shift
delivers OrdersPerBikeShift orders, consumes EnergyPerBikeShift units of energy,
and receives TipsPerBikeShift in tips. Each scooter shift delivers
OrdersPerScooterShift orders, consumes EnergyPerScooterShift units of energy,
and receives TipsPerScooterShift in tips. The delivery person has TotalShifts
available per month, TotalEnergy units of energy, must deliver at least
MinOrders orders, and must schedule at least MinShiftsScooter shifts on a
scooter. The goal is to maximize the total tips received.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/226/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalShifts @Def: Total number of shifts available per month @Shape: [] 
TotalShifts = data['TotalShifts']
# @Parameter TotalEnergy @Def: Total units of energy available per month @Shape: [] 
TotalEnergy = data['TotalEnergy']
# @Parameter MinOrders @Def: Minimum number of orders to deliver @Shape: [] 
MinOrders = data['MinOrders']
# @Parameter MinShiftsScooter @Def: Minimum number of shifts on a scooter @Shape: [] 
MinShiftsScooter = data['MinShiftsScooter']
# @Parameter OrdersPerBikeShift @Def: Number of orders delivered per bike shift @Shape: [] 
OrdersPerBikeShift = data['OrdersPerBikeShift']
# @Parameter EnergyPerBikeShift @Def: Units of energy consumed per bike shift @Shape: [] 
EnergyPerBikeShift = data['EnergyPerBikeShift']
# @Parameter TipsPerBikeShift @Def: Tips received per bike shift @Shape: [] 
TipsPerBikeShift = data['TipsPerBikeShift']
# @Parameter OrdersPerScooterShift @Def: Number of orders delivered per scooter shift @Shape: [] 
OrdersPerScooterShift = data['OrdersPerScooterShift']
# @Parameter EnergyPerScooterShift @Def: Units of energy consumed per scooter shift @Shape: [] 
EnergyPerScooterShift = data['EnergyPerScooterShift']
# @Parameter TipsPerScooterShift @Def: Tips received per scooter shift @Shape: [] 
TipsPerScooterShift = data['TipsPerScooterShift']

# Variables 
# @Variable BikeShifts @Def: The number of bike shifts scheduled @Shape: [] 
BikeShifts = model.addVar(vtype=GRB.INTEGER, name=""BikeShifts"")
# @Variable ScooterShifts @Def: The number of scooter shifts scheduled @Shape: [] 
ScooterShifts = model.addVar(vtype=GRB.INTEGER, name=""ScooterShifts"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of bike and scooter shifts scheduled cannot exceed the TotalShifts available per month.
model.addConstr(BikeShifts + ScooterShifts <= TotalShifts)
# @Constraint Constr_2 @Def: The total energy consumed by all shifts cannot exceed TotalEnergy units.
model.addConstr(EnergyPerBikeShift * BikeShifts + EnergyPerScooterShift * ScooterShifts <= TotalEnergy)
# @Constraint Constr_3 @Def: The total number of orders delivered must be at least MinOrders.
model.addConstr(BikeShifts * OrdersPerBikeShift + ScooterShifts * OrdersPerScooterShift >= MinOrders)
# @Constraint Constr_4 @Def: At least MinShiftsScooter shifts must be scheduled on a scooter.
model.addConstr(ScooterShifts >= MinShiftsScooter)

# Objective 
# @Objective Objective @Def: The total tips received is the sum of the tips from all bike and scooter shifts. The objective is to maximize the total tips received.
model.setObjective(TipsPerBikeShift * BikeShifts + TipsPerScooterShift * ScooterShifts, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['BikeShifts'] = BikeShifts.x
variables['ScooterShifts'] = ScooterShifts.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A singer has two types of concerts he can hold, pop and R&B. Each pop concert will bring in 100 audience members and take 2 days of practice. Every R&B concert brings in 240 audience members and takes 4 days of practice. The singer must bring in at least 10000 audience members and only has available 180 days for practice. If he can at most perform 40% of his concerts as R&B because he likes pop songs more, how many of each type of concert should be created to minimize the total number of concerts?","{""variables"": {""NumPopConcerts"": 40.0, ""NumRnBConcerts"": 25.0}, ""objective"": 65.0}","{""parametrized_description"": ""A singer plans to hold pop and R&B concerts. Each pop concert attracts AudiencePop audience members and requires PracticeDaysPop practice days. Each R&B concert attracts AudienceRnB audience members and requires PracticeDaysRnB practice days. The singer must attract at least MinAudience audience members and has TotalPracticeDays available for practice. Additionally, no more than MaxRnBProportion proportion of the total concerts can be R&B. The objective is to determine the number of pop and R&B concerts that minimizes the total number of concerts."", ""keywords"": [""N.A.""], ""parameters"": {""AudiencePop"": {""description"": ""Audience members brought in by one pop concert"", ""shape"": []}, ""AudienceRnB"": {""description"": ""Audience members brought in by one R&B concert"", ""shape"": []}, ""PracticeDaysPop"": {""description"": ""Number of practice days required for one pop concert"", ""shape"": []}, ""PracticeDaysRnB"": {""description"": ""Number of practice days required for one R&B concert"", ""shape"": []}, ""MinAudience"": {""description"": ""Minimum required audience members"", ""shape"": []}, ""TotalPracticeDays"": {""description"": ""Total available practice days"", ""shape"": []}, ""MaxRnBProportion"": {""description"": ""Maximum proportion of concerts that can be R&B"", ""shape"": []}}, ""variables"": {""NumPopConcerts"": {""description"": ""The number of pop concerts"", ""type"": ""continuous"", ""shape"": []}, ""NumRnBConcerts"": {""description"": ""The number of R&B concerts"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total audience attracted by pop and R&B concerts must be at least MinAudience."", ""formulation"": ""AudiencePop \\cdot NumPopConcerts + AudienceRnB \\cdot NumRnBConcerts \\geq MinAudience"", ""code"": {""gurobipy"": ""model.addConstr(AudiencePop * NumPopConcerts + AudienceRnB * NumRnBConcerts >= MinAudience, \""AudienceConstraint\"")""}}, {""description"": ""The total practice days required for pop and R&B concerts must not exceed TotalPracticeDays."", ""formulation"": ""NumPopConcerts \\cdot PracticeDaysPop + NumRnBConcerts \\cdot PracticeDaysRnB \\leq TotalPracticeDays"", ""code"": {""gurobipy"": ""model.addConstr(NumPopConcerts * PracticeDaysPop + NumRnBConcerts * PracticeDaysRnB <= TotalPracticeDays)""}}, {""description"": ""R&B concerts must not exceed MaxRnBProportion of the total number of concerts."", ""formulation"": ""NumRnBConcerts \\leq MaxRnBProportion \\times (NumPopConcerts + NumRnBConcerts)"", ""code"": {""gurobipy"": ""model.addConstr(NumRnBConcerts <= MaxRnBProportion * (NumPopConcerts + NumRnBConcerts))""}}], ""objective"": {""description"": ""Minimize the total number of pop and R&B concerts."", ""formulation"": ""Min \\ NumPopConcerts + NumRnBConcerts"", ""code"": {""gurobipy"": ""model.setObjective(NumPopConcerts + NumRnBConcerts, GRB.MINIMIZE)""}}}","{""AudiencePop"": 100, ""AudienceRnB"": 240, ""PracticeDaysPop"": 2, ""PracticeDaysRnB"": 4, ""MinAudience"": 10000, ""TotalPracticeDays"": 180, ""MaxRnBProportion"": 0.4}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A singer plans to hold pop and R&B concerts. Each pop concert attracts
AudiencePop audience members and requires PracticeDaysPop practice days. Each
R&B concert attracts AudienceRnB audience members and requires PracticeDaysRnB
practice days. The singer must attract at least MinAudience audience members and
has TotalPracticeDays available for practice. Additionally, no more than
MaxRnBProportion proportion of the total concerts can be R&B. The objective is
to determine the number of pop and R&B concerts that minimizes the total number
of concerts.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/227/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter AudiencePop @Def: Audience members brought in by one pop concert @Shape: [] 
AudiencePop = data['AudiencePop']
# @Parameter AudienceRnB @Def: Audience members brought in by one R&B concert @Shape: [] 
AudienceRnB = data['AudienceRnB']
# @Parameter PracticeDaysPop @Def: Number of practice days required for one pop concert @Shape: [] 
PracticeDaysPop = data['PracticeDaysPop']
# @Parameter PracticeDaysRnB @Def: Number of practice days required for one R&B concert @Shape: [] 
PracticeDaysRnB = data['PracticeDaysRnB']
# @Parameter MinAudience @Def: Minimum required audience members @Shape: [] 
MinAudience = data['MinAudience']
# @Parameter TotalPracticeDays @Def: Total available practice days @Shape: [] 
TotalPracticeDays = data['TotalPracticeDays']
# @Parameter MaxRnBProportion @Def: Maximum proportion of concerts that can be R&B @Shape: [] 
MaxRnBProportion = data['MaxRnBProportion']

# Variables 
# @Variable NumPopConcerts @Def: The number of pop concerts @Shape: [] 
NumPopConcerts = model.addVar(vtype=GRB.INTEGER, name=""NumPopConcerts"")
# @Variable NumRnBConcerts @Def: The number of R&B concerts @Shape: [] 
NumRnBConcerts = model.addVar(vtype=GRB.INTEGER, name=""NumRnBConcerts"")

# Constraints 
# @Constraint Constr_1 @Def: The total audience attracted by pop and R&B concerts must be at least MinAudience.
model.addConstr(AudiencePop * NumPopConcerts + AudienceRnB * NumRnBConcerts >= MinAudience, ""AudienceConstraint"")
# @Constraint Constr_2 @Def: The total practice days required for pop and R&B concerts must not exceed TotalPracticeDays.
model.addConstr(NumPopConcerts * PracticeDaysPop + NumRnBConcerts * PracticeDaysRnB <= TotalPracticeDays)
# @Constraint Constr_3 @Def: R&B concerts must not exceed MaxRnBProportion of the total number of concerts.
model.addConstr(NumRnBConcerts <= MaxRnBProportion * (NumPopConcerts + NumRnBConcerts))

# Objective 
# @Objective Objective @Def: Minimize the total number of pop and R&B concerts.
model.setObjective(NumPopConcerts + NumRnBConcerts, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumPopConcerts'] = NumPopConcerts.x
variables['NumRnBConcerts'] = NumRnBConcerts.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A neighbourhood pizza restaurant has opened and sells pizzas in two sizes; large pizza and medium pizza. Large pizzas require 12 units of dough, and 5 units of toppings. Medium pizzas require 8 units of dough, and 4 units of toppings. While large pizzas take 12 minutes to bake, medium pizzas require 8 minutes to bake. The neighbourhood pizza restaurant must use at least 10000 units of dough and 4400 units of toppings. Medium pizzas are popular due to a promotion, therefore, at least 200 medium pizzas must be made. There are regulars that prefer large pizzas and at least two times as many large pizzas should be made than medium pizzas. How many of each size of pizzas should the neighbourhood pizza restaurant make to reduce time spent baking?","{""variables"": {""NumberLargePizzas"": 629.0, ""NumberMediumPizzas"": 314.0}, ""objective"": 10060.0}","{""parametrized_description"": ""A neighbourhood pizza restaurant produces large and medium pizzas. Each large pizza requires DoughLarge units of dough and ToppingsLarge units of toppings and takes BakingTimeLarge minutes to bake. Each medium pizza requires DoughMedium units of dough and ToppingsMedium units of toppings and takes BakingTimeMedium minutes to bake. The restaurant must use at least MinDough units of dough and MinToppings units of toppings. At least MinMediumPizzas medium pizzas must be made, and the number of large pizzas must be at least MinRatioLargeToMedium times the number of medium pizzas. The objective is to minimize the total baking time."", ""keywords"": [""N.A.""], ""parameters"": {""DoughLarge"": {""description"": ""Units of dough required per large pizza"", ""shape"": []}, ""DoughMedium"": {""description"": ""Units of dough required per medium pizza"", ""shape"": []}, ""ToppingsLarge"": {""description"": ""Units of toppings required per large pizza"", ""shape"": []}, ""ToppingsMedium"": {""description"": ""Units of toppings required per medium pizza"", ""shape"": []}, ""BakingTimeLarge"": {""description"": ""Baking time per large pizza in minutes"", ""shape"": []}, ""BakingTimeMedium"": {""description"": ""Baking time per medium pizza in minutes"", ""shape"": []}, ""MinDough"": {""description"": ""Minimum units of dough required"", ""shape"": []}, ""MinToppings"": {""description"": ""Minimum units of toppings required"", ""shape"": []}, ""MinMediumPizzas"": {""description"": ""Minimum number of medium pizzas to be made"", ""shape"": []}, ""MinRatioLargeToMedium"": {""description"": ""Minimum ratio of large pizzas to medium pizzas"", ""shape"": []}}, ""variables"": {""NumberLargePizzas"": {""description"": ""The number of large pizzas to be made"", ""type"": ""continuous"", ""shape"": [""Integer"", ""NonNegative""]}, ""NumberMediumPizzas"": {""description"": ""The number of medium pizzas to be made"", ""type"": ""continuous"", ""shape"": [""Integer"", ""NonNegative""]}}, ""constraints"": [{""description"": ""Each large pizza requires DoughLarge units of dough and each medium pizza requires DoughMedium units of dough. The total dough used must be at least MinDough units."", ""formulation"": ""DoughLarge \\cdot NumberLargePizzas + DoughMedium \\cdot NumberMediumPizzas \\geq MinDough"", ""code"": {""gurobipy"": ""model.addConstr(DoughLarge * NumberLargePizzas + DoughMedium * NumberMediumPizzas >= MinDough)""}}, {""description"": ""Each large pizza requires ToppingsLarge units of toppings and each medium pizza requires ToppingsMedium units of toppings. The total toppings used must be at least MinToppings units."", ""formulation"": ""ToppingsLarge \\cdot NumberLargePizzas + ToppingsMedium \\cdot NumberMediumPizzas \\geq MinToppings"", ""code"": {""gurobipy"": ""model.addConstr(ToppingsLarge * NumberLargePizzas + ToppingsMedium * NumberMediumPizzas >= MinToppings)""}}, {""description"": ""At least MinMediumPizzas medium pizzas must be made."", ""formulation"": ""NumberMediumPizzas \\geq MinMediumPizzas"", ""code"": {""gurobipy"": ""model.addConstr(NumberMediumPizzas >= MinMediumPizzas)""}}, {""description"": ""The number of large pizzas must be at least MinRatioLargeToMedium times the number of medium pizzas."", ""formulation"": ""NumberLargePizzas \\geq MinRatioLargeToMedium \\times NumberMediumPizzas"", ""code"": {""gurobipy"": ""model.addConstr(NumberLargePizzas >= MinRatioLargeToMedium * NumberMediumPizzas)""}}], ""objective"": {""description"": ""Minimize the total baking time, which is the sum of the baking times for all large and medium pizzas."", ""formulation"": ""Min \\ NumberLargePizzas \\times BakingTimeLarge + NumberMediumPizzas \\times BakingTimeMedium"", ""code"": {""gurobipy"": ""model.setObjective(NumberLargePizzas * BakingTimeLarge + NumberMediumPizzas * BakingTimeMedium, GRB.MINIMIZE)""}}}","{""DoughLarge"": 12, ""DoughMedium"": 8, ""ToppingsLarge"": 5, ""ToppingsMedium"": 4, ""BakingTimeLarge"": 12, ""BakingTimeMedium"": 8, ""MinDough"": 10000, ""MinToppings"": 4400, ""MinMediumPizzas"": 200, ""MinRatioLargeToMedium"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A neighbourhood pizza restaurant produces large and medium pizzas. Each large
pizza requires DoughLarge units of dough and ToppingsLarge units of toppings and
takes BakingTimeLarge minutes to bake. Each medium pizza requires DoughMedium
units of dough and ToppingsMedium units of toppings and takes BakingTimeMedium
minutes to bake. The restaurant must use at least MinDough units of dough and
MinToppings units of toppings. At least MinMediumPizzas medium pizzas must be
made, and the number of large pizzas must be at least MinRatioLargeToMedium
times the number of medium pizzas. The objective is to minimize the total baking
time.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/228/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter DoughLarge @Def: Units of dough required per large pizza @Shape: [] 
DoughLarge = data['DoughLarge']
# @Parameter DoughMedium @Def: Units of dough required per medium pizza @Shape: [] 
DoughMedium = data['DoughMedium']
# @Parameter ToppingsLarge @Def: Units of toppings required per large pizza @Shape: [] 
ToppingsLarge = data['ToppingsLarge']
# @Parameter ToppingsMedium @Def: Units of toppings required per medium pizza @Shape: [] 
ToppingsMedium = data['ToppingsMedium']
# @Parameter BakingTimeLarge @Def: Baking time per large pizza in minutes @Shape: [] 
BakingTimeLarge = data['BakingTimeLarge']
# @Parameter BakingTimeMedium @Def: Baking time per medium pizza in minutes @Shape: [] 
BakingTimeMedium = data['BakingTimeMedium']
# @Parameter MinDough @Def: Minimum units of dough required @Shape: [] 
MinDough = data['MinDough']
# @Parameter MinToppings @Def: Minimum units of toppings required @Shape: [] 
MinToppings = data['MinToppings']
# @Parameter MinMediumPizzas @Def: Minimum number of medium pizzas to be made @Shape: [] 
MinMediumPizzas = data['MinMediumPizzas']
# @Parameter MinRatioLargeToMedium @Def: Minimum ratio of large pizzas to medium pizzas @Shape: [] 
MinRatioLargeToMedium = data['MinRatioLargeToMedium']

# Variables 
# @Variable NumberLargePizzas @Def: The number of large pizzas to be made @Shape: ['Integer', 'NonNegative'] 
NumberLargePizzas = model.addVar(vtype=GRB.INTEGER, lb=0, name=""NumberLargePizzas"")
# @Variable NumberMediumPizzas @Def: The number of medium pizzas to be made @Shape: ['Integer', 'NonNegative'] 
NumberMediumPizzas = model.addVar(vtype=GRB.INTEGER, name=""NumberMediumPizzas"")

# Constraints 
# @Constraint Constr_1 @Def: Each large pizza requires DoughLarge units of dough and each medium pizza requires DoughMedium units of dough. The total dough used must be at least MinDough units.
model.addConstr(DoughLarge * NumberLargePizzas + DoughMedium * NumberMediumPizzas >= MinDough)
# @Constraint Constr_2 @Def: Each large pizza requires ToppingsLarge units of toppings and each medium pizza requires ToppingsMedium units of toppings. The total toppings used must be at least MinToppings units.
model.addConstr(ToppingsLarge * NumberLargePizzas + ToppingsMedium * NumberMediumPizzas >= MinToppings)
# @Constraint Constr_3 @Def: At least MinMediumPizzas medium pizzas must be made.
model.addConstr(NumberMediumPizzas >= MinMediumPizzas)
# @Constraint Constr_4 @Def: The number of large pizzas must be at least MinRatioLargeToMedium times the number of medium pizzas.
model.addConstr(NumberLargePizzas >= MinRatioLargeToMedium * NumberMediumPizzas)

# Objective 
# @Objective Objective @Def: Minimize the total baking time, which is the sum of the baking times for all large and medium pizzas.
model.setObjective(NumberLargePizzas * BakingTimeLarge + NumberMediumPizzas * BakingTimeMedium, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberLargePizzas'] = NumberLargePizzas.x
variables['NumberMediumPizzas'] = NumberMediumPizzas.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A party organizer needs to transport party goers either by limousine or bus. Limousines can carry 12 people and buses can carry 18 people. They need to transport at least 400 people. Because limousines are more attractive, at least 70% of the vehicles must be limousines. How many of each type of vehicle should be used to minimize the total number of limousines and buses used?","{""variables"": {""NumLimousines"": 22.0, ""PeopleLimousines"": 264.0, ""NumBuses"": 8.0, ""PeopleBuses"": 144.0}, ""objective"": 30.0}","{""parametrized_description"": ""A party organizer needs to transport at least MinPeople people using limousines and buses. Each limousine can carry LimousineCapacity people and each bus can carry BusCapacity people. At least MinLimousineFraction of the vehicles used must be limousines. The objective is to minimize the total number of limousines and buses used."", ""keywords"": [""N.A.""], ""parameters"": {""LimousineCapacity"": {""description"": ""Number of people a limousine can carry"", ""shape"": []}, ""BusCapacity"": {""description"": ""Number of people a bus can carry"", ""shape"": []}, ""MinPeople"": {""description"": ""Minimum number of people to transport"", ""shape"": []}, ""MinLimousineFraction"": {""description"": ""Minimum fraction of vehicles that must be limousines"", ""shape"": []}}, ""variables"": {""NumLimousines"": {""description"": ""The number of limousines used"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""PeopleLimousines"": {""description"": ""The number of people assigned to limousines"", ""type"": ""continuous"", ""shape"": [""Continuous""]}, ""NumBuses"": {""description"": ""The number of buses used"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""PeopleBuses"": {""description"": ""The number of people assigned to buses"", ""type"": ""continuous"", ""shape"": [""Continuous""]}}, ""constraints"": [{""description"": ""Each limousine can carry LimousineCapacity people."", ""formulation"": ""PeopleLimousines \\leq LimousineCapacity \\times NumLimousines"", ""code"": {""gurobipy"": ""model.addConstr(PeopleLimousines <= LimousineCapacity * NumLimousines)""}}, {""description"": ""Each bus can carry BusCapacity people."", ""formulation"": ""PeopleBuses \\leq NumBuses \\times BusCapacity"", ""code"": {""gurobipy"": ""model.addConstr(PeopleBuses <= NumBuses * BusCapacity)""}}, {""description"": ""The total number of people transported by limousines and buses must be at least MinPeople."", ""formulation"": ""PeopleLimousines + PeopleBuses \\geq MinPeople"", ""code"": {""gurobipy"": ""model.addConstr(PeopleLimousines + PeopleBuses >= MinPeople)""}}, {""description"": ""At least MinLimousineFraction of the vehicles used must be limousines."", ""formulation"": ""NumLimousines \\geq MinLimousineFraction \\times (NumLimousines + NumBuses)"", ""code"": {""gurobipy"": ""model.addConstr(NumLimousines >= MinLimousineFraction * (NumLimousines + NumBuses))""}}], ""objective"": {""description"": ""Minimize the total number of limousines and buses used."", ""formulation"": ""Min\\ (NumLimousines + NumBuses)"", ""code"": {""gurobipy"": ""model.setObjective(NumLimousines + NumBuses, GRB.MINIMIZE)""}}}","{""LimousineCapacity"": 12, ""BusCapacity"": 18, ""MinPeople"": 400, ""MinLimousineFraction"": 0.7}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A party organizer needs to transport at least MinPeople people using limousines
and buses. Each limousine can carry LimousineCapacity people and each bus can
carry BusCapacity people. At least MinLimousineFraction of the vehicles used
must be limousines. The objective is to minimize the total number of limousines
and buses used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/229/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter LimousineCapacity @Def: Number of people a limousine can carry @Shape: [] 
LimousineCapacity = data['LimousineCapacity']
# @Parameter BusCapacity @Def: Number of people a bus can carry @Shape: [] 
BusCapacity = data['BusCapacity']
# @Parameter MinPeople @Def: Minimum number of people to transport @Shape: [] 
MinPeople = data['MinPeople']
# @Parameter MinLimousineFraction @Def: Minimum fraction of vehicles that must be limousines @Shape: [] 
MinLimousineFraction = data['MinLimousineFraction']

# Variables 
# @Variable NumLimousines @Def: The number of limousines used @Shape: ['Integer'] 
NumLimousines = model.addVar(vtype=GRB.INTEGER, name=""NumLimousines"")
# @Variable PeopleLimousines @Def: The number of people assigned to limousines @Shape: ['Continuous'] 
PeopleLimousines = model.addVar(vtype=GRB.CONTINUOUS, name=""PeopleLimousines"")
# @Variable NumBuses @Def: The number of buses used @Shape: ['Integer'] 
NumBuses = model.addVar(vtype=GRB.INTEGER, name=""NumBuses"")
# @Variable PeopleBuses @Def: The number of people assigned to buses @Shape: ['Continuous'] 
PeopleBuses = model.addVar(vtype=GRB.CONTINUOUS, name=""PeopleBuses"")

# Constraints 
# @Constraint Constr_1 @Def: Each limousine can carry LimousineCapacity people.
model.addConstr(PeopleLimousines <= LimousineCapacity * NumLimousines)
# @Constraint Constr_2 @Def: Each bus can carry BusCapacity people.
model.addConstr(PeopleBuses <= NumBuses * BusCapacity)
# @Constraint Constr_3 @Def: The total number of people transported by limousines and buses must be at least MinPeople.
model.addConstr(PeopleLimousines + PeopleBuses >= MinPeople)
# @Constraint Constr_4 @Def: At least MinLimousineFraction of the vehicles used must be limousines.
model.addConstr(NumLimousines >= MinLimousineFraction * (NumLimousines + NumBuses))

# Objective 
# @Objective Objective @Def: Minimize the total number of limousines and buses used.
model.setObjective(NumLimousines + NumBuses, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumLimousines'] = NumLimousines.x
variables['PeopleLimousines'] = PeopleLimousines.x
variables['NumBuses'] = NumBuses.x
variables['PeopleBuses'] = PeopleBuses.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A hospital purchases two pills available for the patients to take one at a time. One pill is taken as a prevention and another is taken for treatment. The prevention pill takes 15 dollars to make while the treatment pill takes 25 dollars to make. Since the prevention pill is in higher demand, the hospital must purchase at least two times as many prevention pills as treatment pills. In addition, the hospital must purchase at least 50 treatment pills. If the clinic only has a budget of 10000 dollars, maximize the number of patients that can be treated.","{""variables"": {""NumPreventionPills"": 362.0, ""NumTreatmentPills"": 181.0}, ""objective"": 181.0}","{""parametrized_description"": ""A hospital purchases two types of pills: prevention pills and treatment pills. Each prevention pill costs PreventionPillCost to make, while each treatment pill costs TreatmentPillCost to make. The hospital must purchase at least PreventionToTreatmentRatio times as many prevention pills as treatment pills and must purchase at least MinimumTreatmentPills treatment pills. With a total budget of Budget, the objective is to maximize the number of patients that can be treated."", ""keywords"": [""N.A.""], ""parameters"": {""PreventionPillCost"": {""description"": ""Cost to make one prevention pill"", ""shape"": []}, ""TreatmentPillCost"": {""description"": ""Cost to make one treatment pill"", ""shape"": []}, ""PreventionToTreatmentRatio"": {""description"": ""Minimum ratio of prevention pills to treatment pills"", ""shape"": []}, ""MinimumTreatmentPills"": {""description"": ""Minimum number of treatment pills to purchase"", ""shape"": []}, ""Budget"": {""description"": ""Total budget available for purchasing pills"", ""shape"": []}}, ""variables"": {""NumPreventionPills"": {""description"": ""The number of prevention pills to purchase"", ""type"": ""continuous"", ""shape"": []}, ""NumTreatmentPills"": {""description"": ""The number of treatment pills to purchase"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total cost of prevention and treatment pills cannot exceed the budget."", ""formulation"": ""PreventionPillCost \\cdot NumPreventionPills + TreatmentPillCost \\cdot NumTreatmentPills \\leq Budget"", ""code"": {""gurobipy"": ""model.addConstr(PreventionPillCost * NumPreventionPills + TreatmentPillCost * NumTreatmentPills <= Budget)""}}, {""description"": ""The number of prevention pills purchased must be at least PreventionToTreatmentRatio times the number of treatment pills purchased."", ""formulation"": ""NumPreventionPills \\geq PreventionToTreatmentRatio \\times NumTreatmentPills"", ""code"": {""gurobipy"": ""model.addConstr(NumPreventionPills >= PreventionToTreatmentRatio * NumTreatmentPills)""}}, {""description"": ""At least MinimumTreatmentPills treatment pills must be purchased."", ""formulation"": ""NumTreatmentPills \\geq MinimumTreatmentPills"", ""code"": {""gurobipy"": ""model.addConstr(NumTreatmentPills >= MinimumTreatmentPills)""}}], ""objective"": {""description"": ""The objective is to maximize the number of patients that can be treated without exceeding the budget and while satisfying the purchase ratios and minimum treatment pill requirements."", ""formulation"": ""Max \\ NumTreatmentPills"", ""code"": {""gurobipy"": ""model.setObjective(NumTreatmentPills, GRB.MAXIMIZE)""}}}","{""PreventionPillCost"": 15, ""TreatmentPillCost"": 25, ""PreventionToTreatmentRatio"": 2, ""MinimumTreatmentPills"": 50, ""Budget"": 10000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A hospital purchases two types of pills: prevention pills and treatment pills.
Each prevention pill costs PreventionPillCost to make, while each treatment pill
costs TreatmentPillCost to make. The hospital must purchase at least
PreventionToTreatmentRatio times as many prevention pills as treatment pills and
must purchase at least MinimumTreatmentPills treatment pills. With a total
budget of Budget, the objective is to maximize the number of patients that can
be treated.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/230/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter PreventionPillCost @Def: Cost to make one prevention pill @Shape: [] 
PreventionPillCost = data['PreventionPillCost']
# @Parameter TreatmentPillCost @Def: Cost to make one treatment pill @Shape: [] 
TreatmentPillCost = data['TreatmentPillCost']
# @Parameter PreventionToTreatmentRatio @Def: Minimum ratio of prevention pills to treatment pills @Shape: [] 
PreventionToTreatmentRatio = data['PreventionToTreatmentRatio']
# @Parameter MinimumTreatmentPills @Def: Minimum number of treatment pills to purchase @Shape: [] 
MinimumTreatmentPills = data['MinimumTreatmentPills']
# @Parameter Budget @Def: Total budget available for purchasing pills @Shape: [] 
Budget = data['Budget']

# Variables 
# @Variable NumPreventionPills @Def: The number of prevention pills to purchase @Shape: [] 
NumPreventionPills = model.addVar(vtype=GRB.INTEGER, name=""NumPreventionPills"")
# @Variable NumTreatmentPills @Def: The number of treatment pills to purchase @Shape: [] 
NumTreatmentPills = model.addVar(vtype=GRB.INTEGER, name=""NumTreatmentPills"")

# Constraints 
# @Constraint Constr_1 @Def: The total cost of prevention and treatment pills cannot exceed the budget.
model.addConstr(PreventionPillCost * NumPreventionPills + TreatmentPillCost * NumTreatmentPills <= Budget)
# @Constraint Constr_2 @Def: The number of prevention pills purchased must be at least PreventionToTreatmentRatio times the number of treatment pills purchased.
model.addConstr(NumPreventionPills >= PreventionToTreatmentRatio * NumTreatmentPills)
# @Constraint Constr_3 @Def: At least MinimumTreatmentPills treatment pills must be purchased.
model.addConstr(NumTreatmentPills >= MinimumTreatmentPills)

# Objective 
# @Objective Objective @Def: The objective is to maximize the number of patients that can be treated without exceeding the budget and while satisfying the purchase ratios and minimum treatment pill requirements.
model.setObjective(NumTreatmentPills, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumPreventionPills'] = NumPreventionPills.x
variables['NumTreatmentPills'] = NumTreatmentPills.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A dim sum restaurant can deliver their food by cart or by hand. Servers can deliver by cart and have 70 customer interactions and will have to refill food five times an hour. They can also deliver more food by hand, due to the increased mobility, and have 85 customer interactions while refilling food twenty times an hour. However, the customers get more options when delivering by cart, therefore at least 70% of delivery shifts must be by cart. There must be at least 3 servers delivering by hand for their direct customer service. If the restaurant wants to have 4000 customer interactions per hour, how many of each form of delivery should the dim sum restaurant schedule to minimize the total number of refills per hour?","{""variables"": {""NumberOfCartDeliveryServers"": 54.0, ""NumberOfHandDeliveryServers"": 3.0}, ""objective"": 330.0}","{""parametrized_description"": ""Determine the number of cart delivery servers and hand delivery servers such that CustomerInteractionsCart multiplied by the number of cart delivery servers plus CustomerInteractionsHand multiplied by the number of hand delivery servers meets or exceeds TargetCustomerInteractions. Ensure that at least MinFractionCart fraction of delivery shifts are by cart and that the number of hand delivery servers is at least MinServersHand. The objective is to minimize the total number of refills per hour, calculated as RefillsCart multiplied by the number of cart delivery servers plus RefillsHand multiplied by the number of hand delivery servers."", ""keywords"": [""N.A.""], ""parameters"": {""CustomerInteractionsCart"": {""description"": ""Customer interactions per cart delivery server per hour"", ""shape"": []}, ""CustomerInteractionsHand"": {""description"": ""Customer interactions per hand delivery server per hour"", ""shape"": []}, ""RefillsCart"": {""description"": ""Number of refills per cart delivery server per hour"", ""shape"": []}, ""RefillsHand"": {""description"": ""Number of refills per hand delivery server per hour"", ""shape"": []}, ""MinFractionCart"": {""description"": ""Minimum fraction of delivery shifts that must be by cart"", ""shape"": []}, ""MinServersHand"": {""description"": ""Minimum number of servers delivering by hand"", ""shape"": []}, ""TargetCustomerInteractions"": {""description"": ""Target total number of customer interactions per hour"", ""shape"": []}}, ""variables"": {""NumberOfCartDeliveryServers"": {""description"": ""The number of cart delivery servers"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfHandDeliveryServers"": {""description"": ""The number of hand delivery servers"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""CustomerInteractionsCart multiplied by the number of cart delivery servers plus CustomerInteractionsHand multiplied by the number of hand delivery servers must be greater than or equal to TargetCustomerInteractions."", ""formulation"": ""CustomerInteractionsCart \\cdot NumberOfCartDeliveryServers + CustomerInteractionsHand \\cdot NumberOfHandDeliveryServers \\geq TargetCustomerInteractions"", ""code"": {""gurobipy"": ""model.addConstr(CustomerInteractionsCart * NumberOfCartDeliveryServers + CustomerInteractionsHand * NumberOfHandDeliveryServers >= TargetCustomerInteractions)""}}, {""description"": ""At least MinFractionCart fraction of delivery shifts must be by cart."", ""formulation"": ""NumberOfCartDeliveryServers \\geq MinFractionCart \\cdot (NumberOfCartDeliveryServers + NumberOfHandDeliveryServers)"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfCartDeliveryServers >= MinFractionCart * (NumberOfCartDeliveryServers + NumberOfHandDeliveryServers))""}}, {""description"": ""The number of hand delivery servers must be at least MinServersHand."", ""formulation"": ""NumberOfHandDeliveryServers \\geq MinServersHand"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfHandDeliveryServers >= MinServersHand)""}}], ""objective"": {""description"": ""Minimize the total number of refills per hour, calculated as RefillsCart multiplied by the number of cart delivery servers plus RefillsHand multiplied by the number of hand delivery servers."", ""formulation"": ""Min RefillsCart \\times NumberOfCartDeliveryServers + RefillsHand \\times NumberOfHandDeliveryServers"", ""code"": {""gurobipy"": ""model.setObjective(RefillsCart * NumberOfCartDeliveryServers + RefillsHand * NumberOfHandDeliveryServers, GRB.MINIMIZE)""}}}","{""CustomerInteractionsCart"": 70, ""CustomerInteractionsHand"": 85, ""RefillsCart"": 5, ""RefillsHand"": 20, ""MinFractionCart"": 0.7, ""MinServersHand"": 3, ""TargetCustomerInteractions"": 4000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Determine the number of cart delivery servers and hand delivery servers such
that CustomerInteractionsCart multiplied by the number of cart delivery servers
plus CustomerInteractionsHand multiplied by the number of hand delivery servers
meets or exceeds TargetCustomerInteractions. Ensure that at least
MinFractionCart fraction of delivery shifts are by cart and that the number of
hand delivery servers is at least MinServersHand. The objective is to minimize
the total number of refills per hour, calculated as RefillsCart multiplied by
the number of cart delivery servers plus RefillsHand multiplied by the number of
hand delivery servers.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/231/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CustomerInteractionsCart @Def: Customer interactions per cart delivery server per hour @Shape: [] 
CustomerInteractionsCart = data['CustomerInteractionsCart']
# @Parameter CustomerInteractionsHand @Def: Customer interactions per hand delivery server per hour @Shape: [] 
CustomerInteractionsHand = data['CustomerInteractionsHand']
# @Parameter RefillsCart @Def: Number of refills per cart delivery server per hour @Shape: [] 
RefillsCart = data['RefillsCart']
# @Parameter RefillsHand @Def: Number of refills per hand delivery server per hour @Shape: [] 
RefillsHand = data['RefillsHand']
# @Parameter MinFractionCart @Def: Minimum fraction of delivery shifts that must be by cart @Shape: [] 
MinFractionCart = data['MinFractionCart']
# @Parameter MinServersHand @Def: Minimum number of servers delivering by hand @Shape: [] 
MinServersHand = data['MinServersHand']
# @Parameter TargetCustomerInteractions @Def: Target total number of customer interactions per hour @Shape: [] 
TargetCustomerInteractions = data['TargetCustomerInteractions']

# Variables 
# @Variable NumberOfCartDeliveryServers @Def: The number of cart delivery servers @Shape: [] 
NumberOfCartDeliveryServers = model.addVar(vtype=GRB.INTEGER, name=""NumberOfCartDeliveryServers"")
# @Variable NumberOfHandDeliveryServers @Def: The number of hand delivery servers @Shape: [] 
NumberOfHandDeliveryServers = model.addVar(lb=MinServersHand, vtype=GRB.INTEGER, name=""NumberOfHandDeliveryServers"")

# Constraints 
# @Constraint Constr_1 @Def: CustomerInteractionsCart multiplied by the number of cart delivery servers plus CustomerInteractionsHand multiplied by the number of hand delivery servers must be greater than or equal to TargetCustomerInteractions.
model.addConstr(CustomerInteractionsCart * NumberOfCartDeliveryServers + CustomerInteractionsHand * NumberOfHandDeliveryServers >= TargetCustomerInteractions)
# @Constraint Constr_2 @Def: At least MinFractionCart fraction of delivery shifts must be by cart.
model.addConstr(NumberOfCartDeliveryServers >= MinFractionCart * (NumberOfCartDeliveryServers + NumberOfHandDeliveryServers))
# @Constraint Constr_3 @Def: The number of hand delivery servers must be at least MinServersHand.
model.addConstr(NumberOfHandDeliveryServers >= MinServersHand)

# Objective 
# @Objective Objective @Def: Minimize the total number of refills per hour, calculated as RefillsCart multiplied by the number of cart delivery servers plus RefillsHand multiplied by the number of hand delivery servers.
model.setObjective(RefillsCart * NumberOfCartDeliveryServers + RefillsHand * NumberOfHandDeliveryServers, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfCartDeliveryServers'] = NumberOfCartDeliveryServers.x
variables['NumberOfHandDeliveryServers'] = NumberOfHandDeliveryServers.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A macro-counting fitness guru only eats salmon and eggs. Each bowl of salmon contains 300 calories, 15 grams of protein, and 80 mg of sodium. Each bowl of eggs contains 200 calories, 8 grams of protein, and 20 mg of sodium. Since the fitness guru has a limit to how many eggs he would like to eat, at most 40% of his meals can be eggs. The fitness guru needs to eat at least 2000 calories and 90 grams of protein. How many of each type of meal should he eat to minimize his sodium intake?","{""variables"": {""NumMealsPerFoodType"": {""0"": 0.0, ""1"": 12.0}}, ""objective"": 240.0}","{""parametrized_description"": ""A fitness guru consumes NumFoodTypes different types of meals. Each bowl of the i-th meal contains CaloriePerBowl[i] calories, ProteinPerBowl[i] grams of protein, and SodiumPerBowl[i] mg of sodium. No more than MaxMealProportionEggs proportion of the meals can be eggs. The fitness guru needs to consume at least MinCalories total calories and at least MinProtein total grams of protein. The objective is to determine the number of bowls of each meal type to minimize total sodium intake."", ""keywords"": [""N.A.""], ""parameters"": {""NumFoodTypes"": {""description"": ""Number of food types"", ""shape"": []}, ""CaloriePerBowl"": {""description"": ""Calorie content per bowl for each food type"", ""shape"": [""NumFoodTypes""]}, ""ProteinPerBowl"": {""description"": ""Protein content per bowl for each food type"", ""shape"": [""NumFoodTypes""]}, ""SodiumPerBowl"": {""description"": ""Sodium content per bowl for each food type"", ""shape"": [""NumFoodTypes""]}, ""MaxMealProportionEggs"": {""description"": ""Maximum proportion of meals that can be eggs"", ""shape"": []}, ""MinCalories"": {""description"": ""Minimum total calories required"", ""shape"": []}, ""MinProtein"": {""description"": ""Minimum total protein required"", ""shape"": []}}, ""variables"": {""NumMealsPerFoodType"": {""description"": ""The number of meals for each food type"", ""type"": ""continuous"", ""shape"": [""NumFoodTypes""]}}, ""constraints"": [{""description"": ""No more than MaxMealProportionEggs proportion of the meals can be eggs."", ""formulation"": ""NumMealsPerFoodType_{1} \\leq MaxMealProportionEggs \\cdot \\sum_{i=1}^{NumFoodTypes} NumMealsPerFoodType_i"", ""code"": {""gurobipy"": ""model.addConstr(NumMealsPerFoodType[0] <= MaxMealProportionEggs * quicksum(NumMealsPerFoodType[i] for i in range(NumFoodTypes)))""}}, {""description"": ""The total caloric intake must be at least MinCalories."", ""formulation"": ""\\sum_{i=1}^{NumFoodTypes} NumMealsPerFoodType_i \\times CaloriePerBowl_i \\geq MinCalories"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(NumMealsPerFoodType[i] * CaloriePerBowl[i] for i in range(NumFoodTypes)) >= MinCalories)""}}, {""description"": ""The total protein intake must be at least MinProtein."", ""formulation"": ""\\sum_{i=1}^{\\text{NumFoodTypes}} ProteinPerBowl_i \\times NumMealsPerFoodType_i \\geq MinProtein"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ProteinPerBowl[i] * NumMealsPerFoodType[i] for i in range(NumFoodTypes)) >= MinProtein)""}}], ""objective"": {""description"": ""Minimize the total sodium intake."", ""formulation"": ""Min \\sum_{i=1}^{NumFoodTypes} SodiumPerBowl_i \\times NumMealsPerFoodType_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(SodiumPerBowl[i] * NumMealsPerFoodType[i] for i in range(NumFoodTypes)), GRB.MINIMIZE)""}}}","{""NumFoodTypes"": 2, ""CaloriePerBowl"": [300, 200], ""ProteinPerBowl"": [15, 8], ""SodiumPerBowl"": [80, 20], ""MaxMealProportionEggs"": 0.4, ""MinCalories"": 2000, ""MinProtein"": 90}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A fitness guru consumes NumFoodTypes different types of meals. Each bowl of the
i-th meal contains CaloriePerBowl[i] calories, ProteinPerBowl[i] grams of
protein, and SodiumPerBowl[i] mg of sodium. No more than MaxMealProportionEggs
proportion of the meals can be eggs. The fitness guru needs to consume at least
MinCalories total calories and at least MinProtein total grams of protein. The
objective is to determine the number of bowls of each meal type to minimize
total sodium intake.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/232/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
            
# Parameters 
# @Parameter NumFoodTypes @Def: Number of food types @Shape: [] 
NumFoodTypes = data['NumFoodTypes']
# @Parameter CaloriePerBowl @Def: Calorie content per bowl for each food type @Shape: ['NumFoodTypes'] 
CaloriePerBowl = data['CaloriePerBowl']
# @Parameter ProteinPerBowl @Def: Protein content per bowl for each food type @Shape: ['NumFoodTypes'] 
ProteinPerBowl = data['ProteinPerBowl']
# @Parameter SodiumPerBowl @Def: Sodium content per bowl for each food type @Shape: ['NumFoodTypes'] 
SodiumPerBowl = data['SodiumPerBowl']
# @Parameter MaxMealProportionEggs @Def: Maximum proportion of meals that can be eggs @Shape: [] 
MaxMealProportionEggs = data['MaxMealProportionEggs']
# @Parameter MinCalories @Def: Minimum total calories required @Shape: [] 
MinCalories = data['MinCalories']
# @Parameter MinProtein @Def: Minimum total protein required @Shape: [] 
MinProtein = data['MinProtein']

# Variables 
# @Variable NumMealsPerFoodType @Def: The number of meals for each food type @Shape: ['NumFoodTypes'] 
NumMealsPerFoodType = model.addVars(NumFoodTypes, vtype=GRB.INTEGER, name=""NumMealsPerFoodType"")

# Constraints 
# @Constraint Constr_1 @Def: No more than MaxMealProportionEggs proportion of the meals can be eggs.
model.addConstr(NumMealsPerFoodType[0] <= MaxMealProportionEggs * quicksum(NumMealsPerFoodType[i] for i in range(NumFoodTypes)))
# @Constraint Constr_2 @Def: The total caloric intake must be at least MinCalories.
model.addConstr(quicksum(NumMealsPerFoodType[i] * CaloriePerBowl[i] for i in range(NumFoodTypes)) >= MinCalories)
# @Constraint Constr_3 @Def: The total protein intake must be at least MinProtein.
model.addConstr(quicksum(ProteinPerBowl[i] * NumMealsPerFoodType[i] for i in range(NumFoodTypes)) >= MinProtein)

# Objective 
# @Objective Objective @Def: Minimize the total sodium intake.
model.setObjective(quicksum(SodiumPerBowl[i] * NumMealsPerFoodType[i] for i in range(NumFoodTypes)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumMealsPerFoodType'] = {i: var.x for i, var in NumMealsPerFoodType.items()}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A restaurant has two combos available to their customers, an original and an experimental meal. The original meal typically generates 20 units of food waste and 45 units of wrapping waste and takes 10 minutes to cook. In comparison, the experimental meal generates 25 units of food waste and 35 units of wrapping waste and takes 15 minutes to cook. The restaurant can have at most 900 units of wrapping waste and can have at most 800 units of food waste as regulated by the government. How many of each combo should be pushed for by the waiting staff to minimize the cooking time?","{""variables"": {""OriginalMeals"": -0.0, ""ExperimentalMeals"": -0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A restaurant offers two types of meals: Original and Experimental. The Original meal generates OriginalFoodWaste units of food waste and OriginalWrappingWaste units of wrapping waste, and requires OriginalCookingTime minutes to prepare. The Experimental meal generates ExperimentalFoodWaste units of food waste and ExperimentalWrappingWaste units of wrapping waste, and requires ExperimentalCookingTime minutes to prepare. The total wrapping waste must not exceed MaxWrappingWaste, and the total food waste must not exceed MaxFoodWaste. Determine the number of Original and Experimental meals to minimize the total cooking time."", ""keywords"": [""N.A.""], ""parameters"": {""OriginalFoodWaste"": {""description"": ""Food waste generated by the original meal"", ""shape"": []}, ""OriginalWrappingWaste"": {""description"": ""Wrapping waste generated by the original meal"", ""shape"": []}, ""OriginalCookingTime"": {""description"": ""Cooking time for the original meal"", ""shape"": []}, ""ExperimentalFoodWaste"": {""description"": ""Food waste generated by the experimental meal"", ""shape"": []}, ""ExperimentalWrappingWaste"": {""description"": ""Wrapping waste generated by the experimental meal"", ""shape"": []}, ""ExperimentalCookingTime"": {""description"": ""Cooking time for the experimental meal"", ""shape"": []}, ""MaxWrappingWaste"": {""description"": ""Maximum allowed wrapping waste"", ""shape"": []}, ""MaxFoodWaste"": {""description"": ""Maximum allowed food waste"", ""shape"": []}}, ""variables"": {""OriginalMeals"": {""description"": ""The number of Original meals"", ""type"": ""continuous"", ""shape"": []}, ""ExperimentalMeals"": {""description"": ""The number of Experimental meals"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total wrapping waste generated by Original and Experimental meals must not exceed MaxWrappingWaste."", ""formulation"": ""OriginalWrappingWaste \\times OriginalMeals + ExperimentalWrappingWaste \\times ExperimentalMeals \\leq MaxWrappingWaste"", ""code"": {""gurobipy"": ""model.addConstr(OriginalWrappingWaste * OriginalMeals + ExperimentalWrappingWaste * ExperimentalMeals <= MaxWrappingWaste)""}}, {""description"": ""The total food waste generated by Original and Experimental meals must not exceed MaxFoodWaste."", ""formulation"": ""OriginalMeals \\times OriginalFoodWaste + ExperimentalMeals \\times ExperimentalFoodWaste \\leq MaxFoodWaste"", ""code"": {""gurobipy"": ""model.addConstr(OriginalMeals * OriginalFoodWaste + ExperimentalMeals * ExperimentalFoodWaste <= MaxFoodWaste)""}}], ""objective"": {""description"": ""The total cooking time is the sum of the cooking times required for Original and Experimental meals. The objective is to minimize the total cooking time."", ""formulation"": ""Min OriginalCookingTime \\times OriginalMeals + ExperimentalCookingTime \\times ExperimentalMeals"", ""code"": {""gurobipy"": ""model.setObjective(OriginalCookingTime * OriginalMeals + ExperimentalCookingTime * ExperimentalMeals, GRB.MINIMIZE)""}}}","{""OriginalFoodWaste"": 20, ""OriginalWrappingWaste"": 45, ""OriginalCookingTime"": 10, ""ExperimentalFoodWaste"": 25, ""ExperimentalWrappingWaste"": 35, ""ExperimentalCookingTime"": 15, ""MaxWrappingWaste"": 900, ""MaxFoodWaste"": 800}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A restaurant offers two types of meals: Original and Experimental. The Original
meal generates OriginalFoodWaste units of food waste and OriginalWrappingWaste
units of wrapping waste, and requires OriginalCookingTime minutes to prepare.
The Experimental meal generates ExperimentalFoodWaste units of food waste and
ExperimentalWrappingWaste units of wrapping waste, and requires
ExperimentalCookingTime minutes to prepare. The total wrapping waste must not
exceed MaxWrappingWaste, and the total food waste must not exceed MaxFoodWaste.
Determine the number of Original and Experimental meals to minimize the total
cooking time.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/233/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter OriginalFoodWaste @Def: Food waste generated by the original meal @Shape: [] 
OriginalFoodWaste = data['OriginalFoodWaste']
# @Parameter OriginalWrappingWaste @Def: Wrapping waste generated by the original meal @Shape: [] 
OriginalWrappingWaste = data['OriginalWrappingWaste']
# @Parameter OriginalCookingTime @Def: Cooking time for the original meal @Shape: [] 
OriginalCookingTime = data['OriginalCookingTime']
# @Parameter ExperimentalFoodWaste @Def: Food waste generated by the experimental meal @Shape: [] 
ExperimentalFoodWaste = data['ExperimentalFoodWaste']
# @Parameter ExperimentalWrappingWaste @Def: Wrapping waste generated by the experimental meal @Shape: [] 
ExperimentalWrappingWaste = data['ExperimentalWrappingWaste']
# @Parameter ExperimentalCookingTime @Def: Cooking time for the experimental meal @Shape: [] 
ExperimentalCookingTime = data['ExperimentalCookingTime']
# @Parameter MaxWrappingWaste @Def: Maximum allowed wrapping waste @Shape: [] 
MaxWrappingWaste = data['MaxWrappingWaste']
# @Parameter MaxFoodWaste @Def: Maximum allowed food waste @Shape: [] 
MaxFoodWaste = data['MaxFoodWaste']

# Variables 
# @Variable OriginalMeals @Def: The number of Original meals @Shape: [] 
OriginalMeals = model.addVar(vtype=GRB.INTEGER, name=""OriginalMeals"")
# @Variable ExperimentalMeals @Def: The number of Experimental meals @Shape: [] 
ExperimentalMeals = model.addVar(vtype=GRB.INTEGER, name=""ExperimentalMeals"")

# Constraints 
# @Constraint Constr_1 @Def: The total wrapping waste generated by Original and Experimental meals must not exceed MaxWrappingWaste.
model.addConstr(OriginalWrappingWaste * OriginalMeals + ExperimentalWrappingWaste * ExperimentalMeals <= MaxWrappingWaste)
# @Constraint Constr_2 @Def: The total food waste generated by Original and Experimental meals must not exceed MaxFoodWaste.
model.addConstr(OriginalMeals * OriginalFoodWaste + ExperimentalMeals * ExperimentalFoodWaste <= MaxFoodWaste)

# Objective 
# @Objective Objective @Def: The total cooking time is the sum of the cooking times required for Original and Experimental meals. The objective is to minimize the total cooking time.
model.setObjective(OriginalCookingTime * OriginalMeals + ExperimentalCookingTime * ExperimentalMeals, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['OriginalMeals'] = OriginalMeals.x
variables['ExperimentalMeals'] = ExperimentalMeals.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A metal-working shop has access to two types of metal-working equipment, a chop saw and a steel cutter. A chop saw can work 25 pounds of steel and generates 25 units of waste every day. A steel cutter can only cut 5 pounds of steel and generates 3 units of waste every day.  The metal-working shop is expecting an increase in demand and must cut 520 pounds of metal every day. However, there is a waste limitation due to the fines that may be in place if too much heavy metal is discarded and they may at most produce 400 units of waste every day. How should the metal-working shop purchase their metal-working equipment to decrease the total number of metal-working equipment needed?","{""variables"": {""NumberOfChopSaws"": 8.0, ""NumberOfSteelCutters"": 64.0}, ""objective"": 72.0}","{""parametrized_description"": ""A metal-working shop has access to two types of metal-working equipment, a ChopSaw and a SteelCutter. A ChopSaw can cut ChopSawCuttingCapacity pounds of steel and generates ChopSawWaste units of waste per day. A SteelCutter can cut SteelCutterCuttingCapacity pounds of steel and generates SteelCutterWaste units of waste per day. The metal-working shop must cut TotalCuttingRequirement pounds of metal every day. The waste generated must not exceed WasteLimit units per day. How should the metal-working shop purchase their metal-working equipment to minimize the total number of metal-working equipment needed?"", ""keywords"": [""N.A.""], ""parameters"": {""ChopSawCuttingCapacity"": {""description"": ""Cutting capacity of a chop saw in pounds per day"", ""shape"": []}, ""ChopSawWaste"": {""description"": ""Waste generated by a chop saw per day"", ""shape"": []}, ""SteelCutterCuttingCapacity"": {""description"": ""Cutting capacity of a steel cutter in pounds per day"", ""shape"": []}, ""SteelCutterWaste"": {""description"": ""Waste generated by a steel cutter per day"", ""shape"": []}, ""TotalCuttingRequirement"": {""description"": ""Total metal cutting requirement per day in pounds"", ""shape"": []}, ""WasteLimit"": {""description"": ""Maximum allowable waste per day in units"", ""shape"": []}}, ""variables"": {""NumberOfChopSaws"": {""description"": ""The number of chop saws used"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberOfSteelCutters"": {""description"": ""The number of steel cutters used"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total metal cutting capacity of ChopSaws and SteelCutters must be at least 520 pounds per day."", ""formulation"": ""ChopSawCuttingCapacity \\times NumberOfChopSaws + SteelCutterCuttingCapacity \\times NumberOfSteelCutters \\geq TotalCuttingRequirement"", ""code"": {""gurobipy"": ""model.addConstr(ChopSawCuttingCapacity * NumberOfChopSaws + SteelCutterCuttingCapacity * NumberOfSteelCutters >= TotalCuttingRequirement)""}}, {""description"": ""The total waste generated by ChopSaws and SteelCutters must not exceed 400 units per day."", ""formulation"": ""NumberOfChopSaws \\times ChopSawWaste + NumberOfSteelCutters \\times SteelCutterWaste \\leq WasteLimit"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfChopSaws * ChopSawWaste + NumberOfSteelCutters * SteelCutterWaste <= WasteLimit)""}}], ""objective"": {""description"": ""Minimize the total number of metal-working equipment (ChopSaws and SteelCutters) needed to meet the daily cutting and waste requirements."", ""formulation"": ""Min \\left( NumberOfChopSaws + NumberOfSteelCutters \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfChopSaws + NumberOfSteelCutters, GRB.MINIMIZE)""}}}","{""ChopSawCuttingCapacity"": 25, ""ChopSawWaste"": 25, ""SteelCutterCuttingCapacity"": 5, ""SteelCutterWaste"": 3, ""TotalCuttingRequirement"": 520, ""WasteLimit"": 400}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A metal-working shop has access to two types of metal-working equipment, a
ChopSaw and a SteelCutter. A ChopSaw can cut ChopSawCuttingCapacity pounds of
steel and generates ChopSawWaste units of waste per day. A SteelCutter can cut
SteelCutterCuttingCapacity pounds of steel and generates SteelCutterWaste units
of waste per day. The metal-working shop must cut TotalCuttingRequirement pounds
of metal every day. The waste generated must not exceed WasteLimit units per
day. How should the metal-working shop purchase their metal-working equipment to
minimize the total number of metal-working equipment needed?
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/234/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ChopSawCuttingCapacity @Def: Cutting capacity of a chop saw in pounds per day @Shape: [] 
ChopSawCuttingCapacity = data['ChopSawCuttingCapacity']
# @Parameter ChopSawWaste @Def: Waste generated by a chop saw per day @Shape: [] 
ChopSawWaste = data['ChopSawWaste']
# @Parameter SteelCutterCuttingCapacity @Def: Cutting capacity of a steel cutter in pounds per day @Shape: [] 
SteelCutterCuttingCapacity = data['SteelCutterCuttingCapacity']
# @Parameter SteelCutterWaste @Def: Waste generated by a steel cutter per day @Shape: [] 
SteelCutterWaste = data['SteelCutterWaste']
# @Parameter TotalCuttingRequirement @Def: Total metal cutting requirement per day in pounds @Shape: [] 
TotalCuttingRequirement = data['TotalCuttingRequirement']
# @Parameter WasteLimit @Def: Maximum allowable waste per day in units @Shape: [] 
WasteLimit = data['WasteLimit']

# Variables 
# @Variable NumberOfChopSaws @Def: The number of chop saws used @Shape: ['Integer'] 
NumberOfChopSaws = model.addVar(vtype=GRB.INTEGER, name=""NumberOfChopSaws"")
# @Variable NumberOfSteelCutters @Def: The number of steel cutters used @Shape: ['Integer'] 
NumberOfSteelCutters = model.addVar(vtype=GRB.INTEGER, name=""NumberOfSteelCutters"")

# Constraints 
# @Constraint Constr_1 @Def: The total metal cutting capacity of ChopSaws and SteelCutters must be at least 520 pounds per day.
model.addConstr(ChopSawCuttingCapacity * NumberOfChopSaws + SteelCutterCuttingCapacity * NumberOfSteelCutters >= TotalCuttingRequirement)
# @Constraint Constr_2 @Def: The total waste generated by ChopSaws and SteelCutters must not exceed 400 units per day.
model.addConstr(NumberOfChopSaws * ChopSawWaste + NumberOfSteelCutters * SteelCutterWaste <= WasteLimit)

# Objective 
# @Objective Objective @Def: Minimize the total number of metal-working equipment (ChopSaws and SteelCutters) needed to meet the daily cutting and waste requirements.
model.setObjective(NumberOfChopSaws + NumberOfSteelCutters, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfChopSaws'] = NumberOfChopSaws.x
variables['NumberOfSteelCutters'] = NumberOfSteelCutters.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A cruise company can either have two types of trips, a large cruise ship or a small cruise ship. A large cruise ship trip can carry 2000 customers and produces 20 units of pollution. A small cruise ship trip can carry 800 customers and produces 15 units of pollution. There can be at most 7 large cruise ship trips and at least 40% of the total trips must be made by small cruise ships. If the cruise company aims to transport at least 20000 customers, how many of each size of cruise ships should the company use to minimize the total amount of pollution produced?","{""variables"": {""NumberLargeTrips"": 7.0, ""NumberSmallTrips"": 8.0}, ""objective"": 260.0}","{""parametrized_description"": ""The company selects the number of large and small cruise ship trips to minimize (PollutionLarge \u00d7 LargeTrips + PollutionSmall \u00d7 SmallTrips) subject to LargeTrips \u2264 MaxLargeTrips, SmallTrips \u2265 MinSmallTripsPercentage \u00d7 (LargeTrips + SmallTrips), and (CapacityLarge \u00d7 LargeTrips + CapacitySmall \u00d7 SmallTrips) \u2265 RequiredCustomers."", ""keywords"": [""N.A.""], ""parameters"": {""CapacityLarge"": {""description"": ""Capacity of a large cruise ship in number of customers"", ""shape"": []}, ""CapacitySmall"": {""description"": ""Capacity of a small cruise ship in number of customers"", ""shape"": []}, ""PollutionLarge"": {""description"": ""Pollution produced by a large cruise ship trip"", ""shape"": []}, ""PollutionSmall"": {""description"": ""Pollution produced by a small cruise ship trip"", ""shape"": []}, ""MaxLargeTrips"": {""description"": ""Maximum number of large cruise ship trips"", ""shape"": []}, ""MinSmallTripsPercentage"": {""description"": ""Minimum proportion of total trips made by small cruise ships"", ""shape"": []}, ""RequiredCustomers"": {""description"": ""Required number of customers to transport"", ""shape"": []}}, ""variables"": {""NumberLargeTrips"": {""description"": ""The number of large cruise ship trips"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberSmallTrips"": {""description"": ""The number of small cruise ship trips"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The number of large trips must not exceed MaxLargeTrips."", ""formulation"": ""NumberLargeTrips \\leq MaxLargeTrips"", ""code"": {""gurobipy"": ""model.addConstr(NumberLargeTrips <= MaxLargeTrips)""}}, {""description"": ""The number of small trips must be at least MinSmallTripsPercentage times the total number of trips (LargeTrips + SmallTrips)."", ""formulation"": ""NumberSmallTrips \\geq MinSmallTripsPercentage \\times (NumberLargeTrips + NumberSmallTrips)"", ""code"": {""gurobipy"": ""model.addConstr(NumberSmallTrips >= MinSmallTripsPercentage * (NumberLargeTrips + NumberSmallTrips))""}}, {""description"": ""The combined capacity of large and small trips must be at least RequiredCustomers (CapacityLarge \u00d7 LargeTrips + CapacitySmall \u00d7 SmallTrips \u2265 RequiredCustomers)."", ""formulation"": ""CapacityLarge \\times NumberLargeTrips + CapacitySmall \\times NumberSmallTrips \\geq RequiredCustomers"", ""code"": {""gurobipy"": ""model.addConstr(CapacityLarge * NumberLargeTrips + CapacitySmall * NumberSmallTrips >= RequiredCustomers)""}}], ""objective"": {""description"": ""Minimize the total pollution, calculated as PollutionLarge \u00d7 LargeTrips + PollutionSmall \u00d7 SmallTrips."", ""formulation"": ""Min PollutionLarge \\times NumberLargeTrips + PollutionSmall \\times NumberSmallTrips"", ""code"": {""gurobipy"": ""model.setObjective(PollutionLarge * NumberLargeTrips + PollutionSmall * NumberSmallTrips, GRB.MINIMIZE)""}}}","{""CapacityLarge"": 2000, ""CapacitySmall"": 800, ""PollutionLarge"": 20, ""PollutionSmall"": 15, ""MaxLargeTrips"": 7, ""MinSmallTripsPercentage"": 0.4, ""RequiredCustomers"": 20000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
The company selects the number of large and small cruise ship trips to minimize
(PollutionLarge × LargeTrips + PollutionSmall × SmallTrips) subject to
LargeTrips ≤ MaxLargeTrips, SmallTrips ≥ MinSmallTripsPercentage × (LargeTrips +
SmallTrips), and (CapacityLarge × LargeTrips + CapacitySmall × SmallTrips) ≥
RequiredCustomers.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/235/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CapacityLarge @Def: Capacity of a large cruise ship in number of customers @Shape: [] 
CapacityLarge = data['CapacityLarge']
# @Parameter CapacitySmall @Def: Capacity of a small cruise ship in number of customers @Shape: [] 
CapacitySmall = data['CapacitySmall']
# @Parameter PollutionLarge @Def: Pollution produced by a large cruise ship trip @Shape: [] 
PollutionLarge = data['PollutionLarge']
# @Parameter PollutionSmall @Def: Pollution produced by a small cruise ship trip @Shape: [] 
PollutionSmall = data['PollutionSmall']
# @Parameter MaxLargeTrips @Def: Maximum number of large cruise ship trips @Shape: [] 
MaxLargeTrips = data['MaxLargeTrips']
# @Parameter MinSmallTripsPercentage @Def: Minimum proportion of total trips made by small cruise ships @Shape: [] 
MinSmallTripsPercentage = data['MinSmallTripsPercentage']
# @Parameter RequiredCustomers @Def: Required number of customers to transport @Shape: [] 
RequiredCustomers = data['RequiredCustomers']

# Variables 
# @Variable NumberLargeTrips @Def: The number of large cruise ship trips @Shape: ['Integer'] 
NumberLargeTrips = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxLargeTrips, name=""NumberLargeTrips"")
# @Variable NumberSmallTrips @Def: The number of small cruise ship trips @Shape: ['Integer'] 
NumberSmallTrips = model.addVar(vtype=GRB.INTEGER, name=""NumberSmallTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The number of large trips must not exceed MaxLargeTrips.
model.addConstr(NumberLargeTrips <= MaxLargeTrips)
# @Constraint Constr_2 @Def: The number of small trips must be at least MinSmallTripsPercentage times the total number of trips (LargeTrips + SmallTrips).
model.addConstr(NumberSmallTrips >= MinSmallTripsPercentage * (NumberLargeTrips + NumberSmallTrips))
# @Constraint Constr_3 @Def: The combined capacity of large and small trips must be at least RequiredCustomers (CapacityLarge × LargeTrips + CapacitySmall × SmallTrips ≥ RequiredCustomers).
model.addConstr(CapacityLarge * NumberLargeTrips + CapacitySmall * NumberSmallTrips >= RequiredCustomers)

# Objective 
# @Objective Objective @Def: Minimize the total pollution, calculated as PollutionLarge × LargeTrips + PollutionSmall × SmallTrips.
model.setObjective(PollutionLarge * NumberLargeTrips + PollutionSmall * NumberSmallTrips, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberLargeTrips'] = NumberLargeTrips.x
variables['NumberSmallTrips'] = NumberSmallTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A lighting company has access to two types of lights to provide their customers, an LED fixture, and a fluorescence lamp. The LED light uses 5 units of electricity per hour and needs to be changed 3 times a decade. Conversely, the fluorescence lamp uses 8 units of electricity per hour and needs to be changed 4 times a decade. Due to previous installations, at least 30% implemented lights must be fluorescence lamps. If the customer requires at least 300 light fixtures and can use at most 2000 units of electricity, how many of each light should be installed to reduce the total number of light changes?","{""variables"": {""NumFixtures"": {""0"": 0.0, ""1"": 0.0}, ""NumFluorescenceFixtures"": 2000000000.0}, ""objective"": 0.0}","{""parametrized_description"": ""A lighting company has access to NumTypes types of lights to provide their customers. Each type uses ElectricityUsage[i] units of electricity per hour and needs to be changed ChangesPerDecade[i] times per decade. Due to previous installations, at least MinPercentageFluorescence fraction of implemented lights must be fluorescence lamps. If the customer requires at least MinNumFixtures light fixtures and can use at most MaxElectricity units of electricity, determine the number of each type of light to install to minimize the total number of light changes."", ""keywords"": [""N.A.""], ""parameters"": {""NumTypes"": {""description"": ""Number of types of lights available"", ""shape"": []}, ""ElectricityUsage"": {""description"": ""Electricity units used per hour by each type of light"", ""shape"": [""NumTypes""]}, ""ChangesPerDecade"": {""description"": ""Number of times each type of light needs to be changed per decade"", ""shape"": [""NumTypes""]}, ""MinPercentageFluorescence"": {""description"": ""Minimum fraction of implemented light fixtures that must be fluorescence lamps"", ""shape"": []}, ""MinNumFixtures"": {""description"": ""Minimum number of light fixtures required"", ""shape"": []}, ""MaxElectricity"": {""description"": ""Maximum number of electricity units that can be used"", ""shape"": []}}, ""variables"": {""NumFixtures"": {""description"": ""The number of fixtures for each type of light"", ""type"": ""continuous"", ""shape"": [""NumTypes""]}, ""NumFluorescenceFixtures"": {""description"": ""The number of fluorescence light fixtures"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""At least MinPercentageFluorescence fraction of the implemented light fixtures must be fluorescence lamps."", ""formulation"": ""NumFluorescenceFixtures \\geq MinPercentageFluorescence \\cdot \\sum_{i=1}^{NumTypes} NumFixtures_i"", ""code"": {""gurobipy"": ""model.addConstr(NumFluorescenceFixtures >= MinPercentageFluorescence * quicksum(NumFixtures[i] for i in range(NumTypes)))""}}, {""description"": ""The total number of light fixtures installed must be at least MinNumFixtures."", ""formulation"": ""\\sum_{t=1}^{NumTypes} NumFixtures_{t} + NumFluorescenceFixtures \\geq MinNumFixtures"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(NumFixtures[t] for t in range(NumTypes)) + NumFluorescenceFixtures >= MinNumFixtures)""}}, {""description"": ""The total electricity usage of all installed lights must not exceed MaxElectricity units."", ""formulation"": ""\\sum_{t=1}^{NumTypes} ElectricityUsage_t \\cdot NumFixtures_t \\leq MaxElectricity"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(ElectricityUsage[t] * NumFixtures[t] for t in range(NumTypes)) <= MaxElectricity)""}}], ""objective"": {""description"": ""Minimize the total number of light changes, calculated as the sum of ChangesPerDecade[i] multiplied by the number of each type of light installed."", ""formulation"": ""Min \\sum_{i=1}^{NumTypes} ChangesPerDecade_{i} \\cdot NumFixtures_{i}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ChangesPerDecade[i] * NumFixtures[i] for i in range(NumTypes)), GRB.MINIMIZE)""}}}","{""NumTypes"": 2, ""ElectricityUsage"": [5, 8], ""ChangesPerDecade"": [3, 4], ""MinPercentageFluorescence"": 0.3, ""MinNumFixtures"": 300, ""MaxElectricity"": 2000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A lighting company has access to NumTypes types of lights to provide their
customers. Each type uses ElectricityUsage[i] units of electricity per hour and
needs to be changed ChangesPerDecade[i] times per decade. Due to previous
installations, at least MinPercentageFluorescence fraction of implemented lights
must be fluorescence lamps. If the customer requires at least MinNumFixtures
light fixtures and can use at most MaxElectricity units of electricity,
determine the number of each type of light to install to minimize the total
number of light changes.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/236/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target            
        
# Parameters 
# @Parameter NumTypes @Def: Number of types of lights available @Shape: [] 
NumTypes = data['NumTypes']
# @Parameter ElectricityUsage @Def: Electricity units used per hour by each type of light @Shape: ['NumTypes'] 
ElectricityUsage = data['ElectricityUsage']
# @Parameter ChangesPerDecade @Def: Number of times each type of light needs to be changed per decade @Shape: ['NumTypes'] 
ChangesPerDecade = data['ChangesPerDecade']
# @Parameter MinPercentageFluorescence @Def: Minimum fraction of implemented light fixtures that must be fluorescence lamps @Shape: [] 
MinPercentageFluorescence = data['MinPercentageFluorescence']
# @Parameter MinNumFixtures @Def: Minimum number of light fixtures required @Shape: [] 
MinNumFixtures = data['MinNumFixtures']
# @Parameter MaxElectricity @Def: Maximum number of electricity units that can be used @Shape: [] 
MaxElectricity = data['MaxElectricity']

# Variables 
# @Variable NumFixtures @Def: The number of fixtures for each type of light @Shape: ['NumTypes'] 
NumFixtures = model.addVars(NumTypes, vtype=GRB.INTEGER, name=""NumFixtures"")
# @Variable NumFluorescenceFixtures @Def: The number of fluorescence light fixtures @Shape: [] 
NumFluorescenceFixtures = model.addVar(vtype=GRB.INTEGER, name=""NumFluorescenceFixtures"")

# Constraints 
# @Constraint Constr_1 @Def: At least MinPercentageFluorescence fraction of the implemented light fixtures must be fluorescence lamps.
model.addConstr(NumFluorescenceFixtures >= MinPercentageFluorescence * quicksum(NumFixtures[i] for i in range(NumTypes)))
# @Constraint Constr_2 @Def: The total number of light fixtures installed must be at least MinNumFixtures.
model.addConstr(quicksum(NumFixtures[t] for t in range(NumTypes)) + NumFluorescenceFixtures >= MinNumFixtures)
# @Constraint Constr_3 @Def: The total electricity usage of all installed lights must not exceed MaxElectricity units.
model.addConstr(quicksum(ElectricityUsage[t] * NumFixtures[t] for t in range(NumTypes)) <= MaxElectricity)

# Objective 
# @Objective Objective @Def: Minimize the total number of light changes, calculated as the sum of ChangesPerDecade[i] multiplied by the number of each type of light installed.
model.setObjective(quicksum(ChangesPerDecade[i] * NumFixtures[i] for i in range(NumTypes)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumFixtures'] = {i: NumFixtures[i].x for i in range(NumTypes)}
variables['NumFluorescenceFixtures'] = NumFluorescenceFixtures.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"A market owner wants to start a jam business. He can either sell one unit of jam to customers in a set of small packets or jugs. A set of small packets can hold 1000 ml of jam while a jug can hold 1250 ml of jam. Since a set of small packets are more expensive to make, at least three times as many jugs must be used than sets of small packets. On the other hand, at least 35 sets of small packets should be filled. If the market owner has 65000 ml of jam, how many sets of small packets or jugs should be selected to maximize the total number of units that he can sell to his customers?",{},"{""parametrized_description"": ""A market owner wants to start a jam business. He can either sell sets of small packets or jugs. Each set of small packets has a capacity of SmallPacketCapacity milliliters and each jug has a capacity of JugCapacity milliliters. At least MinJugRatio times as many jugs must be used as sets of small packets. At least MinSmallPackets sets of small packets must be filled. The market owner has TotalJam milliliters of jam. The owner aims to maximize the total number of units sold to customers."", ""keywords"": [""N.A.""], ""parameters"": {""SmallPacketCapacity"": {""description"": ""Capacity of one set of small packets in milliliters"", ""shape"": []}, ""JugCapacity"": {""description"": ""Capacity of one jug in milliliters"", ""shape"": []}, ""MinJugRatio"": {""description"": ""Minimum ratio of jugs to sets of small packets"", ""shape"": []}, ""MinSmallPackets"": {""description"": ""Minimum number of sets of small packets to be filled"", ""shape"": []}, ""TotalJam"": {""description"": ""Total available milliliters of jam"", ""shape"": []}}, ""variables"": {""NumberOfSmallPacketSets"": {""description"": ""The number of sets of small packets"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfJugs"": {""description"": ""The number of jugs"", ""type"": ""continuous"", ""shape"": []}, ""TotalJamUsedSmall"": {""description"": ""The total milliliters of jam used by small packet sets"", ""type"": ""continuous"", ""shape"": []}, ""TotalJamUsedJugs"": {""description"": ""The total milliliters of jam used by jugs"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total jam used for small packets and jugs cannot exceed the total available jam (TotalJam)."", ""formulation"": ""NumberOfSmallPacketSets \\times SmallPacketCapacity + NumberOfJugs \\times JugCapacity \\leq TotalJam"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfSmallPacketSets * SmallPacketCapacity + NumberOfJugs * JugCapacity <= TotalJam)""}}, {""description"": ""Each set of small packets sold uses SmallPacketCapacity milliliters of jam."", ""formulation"": ""TotalJamUsedSmall = NumberOfSmallPacketSets \\times SmallPacketCapacity"", ""code"": {""gurobipy"": ""model.addConstr(TotalJamUsedSmall == NumberOfSmallPacketSets * SmallPacketCapacity)""}}, {""description"": ""Each jug sold uses JugCapacity milliliters of jam."", ""formulation"": ""TotalJamUsedJugs = NumberOfJugs \\times JugCapacity"", ""code"": {""gurobipy"": ""model.addConstr(TotalJamUsedJugs == JugCapacity * NumberOfJugs)""}}, {""description"": ""The number of jugs sold must be at least MinJugRatio times the number of sets of small packets sold."", ""formulation"": ""NumberOfJugs \\geq MinJugRatio \\times NumberOfSmallPacketSets"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfJugs >= MinJugRatio * NumberOfSmallPacketSets)""}}, {""description"": ""At least MinSmallPackets sets of small packets must be filled."", ""formulation"": ""NumberOfSmallPacketSets \\geq MinSmallPackets"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfSmallPacketSets >= MinSmallPackets)""}}], ""objective"": {""description"": ""The objective is to maximize the total number of units sold to customers, where total units sold are the sum of sets of small packets and jugs sold."", ""formulation"": ""Max \\left( NumberOfSmallPacketSets + NumberOfJugs \\right )"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfSmallPacketSets + NumberOfJugs, GRB.MAXIMIZE)""}}}","{""SmallPacketCapacity"": 1000, ""JugCapacity"": 1250, ""MinJugRatio"": 3, ""MinSmallPackets"": 35, ""TotalJam"": 65000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A market owner wants to start a jam business. He can either sell sets of small
packets or jugs. Each set of small packets has a capacity of SmallPacketCapacity
milliliters and each jug has a capacity of JugCapacity milliliters. At least
MinJugRatio times as many jugs must be used as sets of small packets. At least
MinSmallPackets sets of small packets must be filled. The market owner has
TotalJam milliliters of jam. The owner aims to maximize the total number of
units sold to customers.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/237/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SmallPacketCapacity @Def: Capacity of one set of small packets in milliliters @Shape: [] 
SmallPacketCapacity = data['SmallPacketCapacity']
# @Parameter JugCapacity @Def: Capacity of one jug in milliliters @Shape: [] 
JugCapacity = data['JugCapacity']
# @Parameter MinJugRatio @Def: Minimum ratio of jugs to sets of small packets @Shape: [] 
MinJugRatio = data['MinJugRatio']
# @Parameter MinSmallPackets @Def: Minimum number of sets of small packets to be filled @Shape: [] 
MinSmallPackets = data['MinSmallPackets']
# @Parameter TotalJam @Def: Total available milliliters of jam @Shape: [] 
TotalJam = data['TotalJam']

# Variables 
# @Variable NumberOfSmallPacketSets @Def: The number of sets of small packets @Shape: [] 
NumberOfSmallPacketSets = model.addVar(vtype=GRB.INTEGER, name=""NumberOfSmallPacketSets"")
# @Variable NumberOfJugs @Def: The number of jugs @Shape: [] 
NumberOfJugs = model.addVar(vtype=GRB.INTEGER, name=""NumberOfJugs"")
# @Variable TotalJamUsedSmall @Def: The total milliliters of jam used by small packet sets @Shape: [] 
TotalJamUsedSmall = model.addVar(vtype=GRB.CONTINUOUS, name=""TotalJamUsedSmall"")
# @Variable TotalJamUsedJugs @Def: The total milliliters of jam used by jugs @Shape: [] 
TotalJamUsedJugs = model.addVar(vtype=GRB.CONTINUOUS, name=""TotalJamUsedJugs"")

# Constraints 
# @Constraint Constr_1 @Def: The total jam used for small packets and jugs cannot exceed the total available jam (TotalJam).
model.addConstr(NumberOfSmallPacketSets * SmallPacketCapacity + NumberOfJugs * JugCapacity <= TotalJam)
# @Constraint Constr_2 @Def: Each set of small packets sold uses SmallPacketCapacity milliliters of jam.
model.addConstr(TotalJamUsedSmall == NumberOfSmallPacketSets * SmallPacketCapacity)
# @Constraint Constr_3 @Def: Each jug sold uses JugCapacity milliliters of jam.
model.addConstr(TotalJamUsedJugs == JugCapacity * NumberOfJugs)
# @Constraint Constr_4 @Def: The number of jugs sold must be at least MinJugRatio times the number of sets of small packets sold.
model.addConstr(NumberOfJugs >= MinJugRatio * NumberOfSmallPacketSets)
# @Constraint Constr_5 @Def: At least MinSmallPackets sets of small packets must be filled.
model.addConstr(NumberOfSmallPacketSets >= MinSmallPackets)

# Objective 
# @Objective Objective @Def: The objective is to maximize the total number of units sold to customers, where total units sold are the sum of sets of small packets and jugs sold.
model.setObjective(NumberOfSmallPacketSets + NumberOfJugs, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfSmallPacketSets'] = NumberOfSmallPacketSets.x
variables['NumberOfJugs'] = NumberOfJugs.x
variables['TotalJamUsedSmall'] = TotalJamUsedSmall.x
variables['TotalJamUsedJugs'] = TotalJamUsedJugs.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A navy ship is stocking food onto their submarine and their staff can eat either a salad or fruit bowl for their fibre and vitamin intake. The nutritionist in charge of this voyage needs to ensure that their staff gets at least 90 units of vitamin and 110 units of fibre each. Each salad contains 7 units of vitamins and 12 units of fibre. Each fruit bowl contains 15 units of vitamin and 3 units of fibre. In addition, since fruit bowls take longer to prepare, at most 30% of their meals should be fruit bowls. If each salad contains 2 units of potassium and each fruit bowl contains 8 units of potassium, how many of each should they prepare for each staff to maximize their potassium intake?",{},"{""parametrized_description"": ""A navy ship is preparing salads and fruit bowls for their staff. Each salad provides VitaminsPerSalad units of vitamins, FiberPerSalad units of fiber, and PotassiumPerSalad units of potassium. Each fruit bowl provides VitaminsPerFruitBowl units of vitamins, FiberPerFruitBowl units of fiber, and PotassiumPerFruitBowl units of potassium. The nutritionist must ensure that each staff member receives at least MinVitamins units of vitamins and at least MinFiber units of fiber. Additionally, at most MaxFruitBowlFraction fraction of the meals can be fruit bowls. The objective is to determine the number of salads and fruit bowls to maximize potassium intake."", ""keywords"": [""N.A.""], ""parameters"": {""MinVitamins"": {""description"": ""Minimum required units of vitamins per staff"", ""shape"": []}, ""MinFiber"": {""description"": ""Minimum required units of fiber per staff"", ""shape"": []}, ""VitaminsPerSalad"": {""description"": ""Units of vitamins per salad"", ""shape"": []}, ""VitaminsPerFruitBowl"": {""description"": ""Units of vitamins per fruit bowl"", ""shape"": []}, ""FiberPerSalad"": {""description"": ""Units of fiber per salad"", ""shape"": []}, ""FiberPerFruitBowl"": {""description"": ""Units of fiber per fruit bowl"", ""shape"": []}, ""PotassiumPerSalad"": {""description"": ""Units of potassium per salad"", ""shape"": []}, ""PotassiumPerFruitBowl"": {""description"": ""Units of potassium per fruit bowl"", ""shape"": []}, ""MaxFruitBowlFraction"": {""description"": ""Maximum fraction of meals that can be fruit bowls"", ""shape"": []}}, ""variables"": {""QuantitySalads"": {""description"": ""The quantity of salads"", ""type"": ""continuous"", ""shape"": []}, ""QuantityFruitBowls"": {""description"": ""The quantity of fruit bowls"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total vitamins provided by the salads and fruit bowls must be at least MinVitamins units."", ""formulation"": ""VitaminsPerSalad * QuantitySalads + VitaminsPerFruitBowl * QuantityFruitBowls \\geq MinVitamins"", ""code"": {""gurobipy"": ""model.addConstr(VitaminsPerSalad * QuantitySalads + VitaminsPerFruitBowl * QuantityFruitBowls >= MinVitamins)""}}, {""description"": ""The total fiber provided by the salads and fruit bowls must be at least MinFiber units."", ""formulation"": ""FiberPerSalad \\times QuantitySalads + FiberPerFruitBowl \\times QuantityFruitBowls \\geq MinFiber"", ""code"": {""gurobipy"": ""model.addConstr(FiberPerSalad * QuantitySalads + FiberPerFruitBowl * QuantityFruitBowls >= MinFiber)""}}, {""description"": ""At most MaxFruitBowlFraction fraction of the meals can be fruit bowls."", ""formulation"": ""QuantityFruitBowls \\leq MaxFruitBowlFraction \\times (QuantitySalads + QuantityFruitBowls)"", ""code"": {""gurobipy"": ""model.addConstr(QuantityFruitBowls <= MaxFruitBowlFraction * (QuantitySalads + QuantityFruitBowls))""}}], ""objective"": {""description"": ""Maximize the total potassium intake, calculated as PotassiumPerSalad multiplied by the number of salads plus PotassiumPerFruitBowl multiplied by the number of fruit bowls."", ""formulation"": ""Max PotassiumPerSalad \\times QuantitySalads + PotassiumPerFruitBowl \\times QuantityFruitBowls"", ""code"": {""gurobipy"": ""model.setObjective(PotassiumPerSalad * QuantitySalads + PotassiumPerFruitBowl * QuantityFruitBowls, GRB.MAXIMIZE)""}}}","{""MinVitamins"": 90, ""MinFiber"": 110, ""VitaminsPerSalad"": 7, ""VitaminsPerFruitBowl"": 15, ""FiberPerSalad"": 12, ""FiberPerFruitBowl"": 3, ""PotassiumPerSalad"": 2, ""PotassiumPerFruitBowl"": 8, ""MaxFruitBowlFraction"": 0.3}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A navy ship is preparing salads and fruit bowls for their staff. Each salad
provides VitaminsPerSalad units of vitamins, FiberPerSalad units of fiber, and
PotassiumPerSalad units of potassium. Each fruit bowl provides
VitaminsPerFruitBowl units of vitamins, FiberPerFruitBowl units of fiber, and
PotassiumPerFruitBowl units of potassium. The nutritionist must ensure that each
staff member receives at least MinVitamins units of vitamins and at least
MinFiber units of fiber. Additionally, at most MaxFruitBowlFraction fraction of
the meals can be fruit bowls. The objective is to determine the number of salads
and fruit bowls to maximize potassium intake.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/238/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MinVitamins @Def: Minimum required units of vitamins per staff @Shape: [] 
MinVitamins = data['MinVitamins']
# @Parameter MinFiber @Def: Minimum required units of fiber per staff @Shape: [] 
MinFiber = data['MinFiber']
# @Parameter VitaminsPerSalad @Def: Units of vitamins per salad @Shape: [] 
VitaminsPerSalad = data['VitaminsPerSalad']
# @Parameter VitaminsPerFruitBowl @Def: Units of vitamins per fruit bowl @Shape: [] 
VitaminsPerFruitBowl = data['VitaminsPerFruitBowl']
# @Parameter FiberPerSalad @Def: Units of fiber per salad @Shape: [] 
FiberPerSalad = data['FiberPerSalad']
# @Parameter FiberPerFruitBowl @Def: Units of fiber per fruit bowl @Shape: [] 
FiberPerFruitBowl = data['FiberPerFruitBowl']
# @Parameter PotassiumPerSalad @Def: Units of potassium per salad @Shape: [] 
PotassiumPerSalad = data['PotassiumPerSalad']
# @Parameter PotassiumPerFruitBowl @Def: Units of potassium per fruit bowl @Shape: [] 
PotassiumPerFruitBowl = data['PotassiumPerFruitBowl']
# @Parameter MaxFruitBowlFraction @Def: Maximum fraction of meals that can be fruit bowls @Shape: [] 
MaxFruitBowlFraction = data['MaxFruitBowlFraction']

# Variables 
# @Variable QuantitySalads @Def: The quantity of salads @Shape: [] 
QuantitySalads = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantitySalads"")
# @Variable QuantityFruitBowls @Def: The quantity of fruit bowls @Shape: [] 
QuantityFruitBowls = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityFruitBowls"")

# Constraints 
# @Constraint Constr_1 @Def: The total vitamins provided by the salads and fruit bowls must be at least MinVitamins units.
model.addConstr(VitaminsPerSalad * QuantitySalads + VitaminsPerFruitBowl * QuantityFruitBowls >= MinVitamins)
# @Constraint Constr_2 @Def: The total fiber provided by the salads and fruit bowls must be at least MinFiber units.
model.addConstr(FiberPerSalad * QuantitySalads + FiberPerFruitBowl * QuantityFruitBowls >= MinFiber)
# @Constraint Constr_3 @Def: At most MaxFruitBowlFraction fraction of the meals can be fruit bowls.
model.addConstr(QuantityFruitBowls <= MaxFruitBowlFraction * (QuantitySalads + QuantityFruitBowls))

# Objective 
# @Objective Objective @Def: Maximize the total potassium intake, calculated as PotassiumPerSalad multiplied by the number of salads plus PotassiumPerFruitBowl multiplied by the number of fruit bowls.
model.setObjective(PotassiumPerSalad * QuantitySalads + PotassiumPerFruitBowl * QuantityFruitBowls, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantitySalads'] = QuantitySalads.x
variables['QuantityFruitBowls'] = QuantityFruitBowls.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A clothing company can sell their product in two types of stores, a retail store and a factory outlet. A retail store brings in 200 customers every day and requires 6 employees to operate. A factory outlet brings in 80 customers every day and due to the lower traffic and being in more remote areas, requires 4 employees to run. Company executives decided that there must be at least 1200 customers every day, and can make available 50 employees. How should the company distribute their product to the two types of store to reduce the number of stores that must be open?","{""variables"": {""NumberRetailStores"": 6.0, ""NumberFactoryOutlets"": -0.0}, ""objective"": 6.0}","{""parametrized_description"": ""A clothing company can sell their product in two types of stores: a retail store and a factory outlet. A retail store brings in CustomersPerRetailStore customers every day and requires EmployeesPerRetailStore employees to operate. A factory outlet brings in CustomersPerFactoryOutlet customers every day and requires EmployeesPerFactoryOutlet employees to run. Company executives decided that there must be at least MinTotalCustomers customers every day and can make available MaxTotalEmployees employees. The company aims to minimize the number of stores that must be open."", ""keywords"": [""N.A.""], ""parameters"": {""CustomersPerRetailStore"": {""description"": ""Number of customers served per retail store each day"", ""shape"": []}, ""EmployeesPerRetailStore"": {""description"": ""Number of employees required to operate a retail store"", ""shape"": []}, ""CustomersPerFactoryOutlet"": {""description"": ""Number of customers served per factory outlet each day"", ""shape"": []}, ""EmployeesPerFactoryOutlet"": {""description"": ""Number of employees required to operate a factory outlet"", ""shape"": []}, ""MinTotalCustomers"": {""description"": ""Minimum total number of customers required each day"", ""shape"": []}, ""MaxTotalEmployees"": {""description"": ""Maximum number of employees available"", ""shape"": []}}, ""variables"": {""NumberRetailStores"": {""description"": ""The number of retail stores to open"", ""type"": ""continuous"", ""shape"": [""integer""]}, ""NumberFactoryOutlets"": {""description"": ""The number of factory outlets to open"", ""type"": ""continuous"", ""shape"": [""integer""]}}, ""constraints"": [{""description"": ""The total number of customers served each day must be at least MinTotalCustomers."", ""formulation"": ""CustomersPerRetailStore \\cdot NumberRetailStores + CustomersPerFactoryOutlet \\cdot NumberFactoryOutlets \\geq MinTotalCustomers"", ""code"": {""gurobipy"": ""model.addConstr(CustomersPerRetailStore * NumberRetailStores + CustomersPerFactoryOutlet * NumberFactoryOutlets >= MinTotalCustomers)""}}, {""description"": ""The total number of employees used to operate the stores must not exceed MaxTotalEmployees."", ""formulation"": ""EmployeesPerRetailStore \\cdot NumberRetailStores + EmployeesPerFactoryOutlet \\cdot NumberFactoryOutlets \\leq MaxTotalEmployees"", ""code"": {""gurobipy"": ""model.addConstr(EmployeesPerRetailStore * NumberRetailStores + EmployeesPerFactoryOutlet * NumberFactoryOutlets <= MaxTotalEmployees)""}}], ""objective"": {""description"": ""Minimize the total number of stores (retail stores and factory outlets) that must be open."", ""formulation"": ""Min \\ NumberRetailStores + NumberFactoryOutlets"", ""code"": {""gurobipy"": ""model.setObjective(NumberRetailStores + NumberFactoryOutlets, GRB.MINIMIZE)""}}}","{""CustomersPerRetailStore"": 200, ""EmployeesPerRetailStore"": 6, ""CustomersPerFactoryOutlet"": 80, ""EmployeesPerFactoryOutlet"": 4, ""MinTotalCustomers"": 1200, ""MaxTotalEmployees"": 50}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A clothing company can sell their product in two types of stores: a retail store
and a factory outlet. A retail store brings in CustomersPerRetailStore customers
every day and requires EmployeesPerRetailStore employees to operate. A factory
outlet brings in CustomersPerFactoryOutlet customers every day and requires
EmployeesPerFactoryOutlet employees to run. Company executives decided that
there must be at least MinTotalCustomers customers every day and can make
available MaxTotalEmployees employees. The company aims to minimize the number
of stores that must be open.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/239/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CustomersPerRetailStore @Def: Number of customers served per retail store each day @Shape: [] 
CustomersPerRetailStore = data['CustomersPerRetailStore']
# @Parameter EmployeesPerRetailStore @Def: Number of employees required to operate a retail store @Shape: [] 
EmployeesPerRetailStore = data['EmployeesPerRetailStore']
# @Parameter CustomersPerFactoryOutlet @Def: Number of customers served per factory outlet each day @Shape: [] 
CustomersPerFactoryOutlet = data['CustomersPerFactoryOutlet']
# @Parameter EmployeesPerFactoryOutlet @Def: Number of employees required to operate a factory outlet @Shape: [] 
EmployeesPerFactoryOutlet = data['EmployeesPerFactoryOutlet']
# @Parameter MinTotalCustomers @Def: Minimum total number of customers required each day @Shape: [] 
MinTotalCustomers = data['MinTotalCustomers']
# @Parameter MaxTotalEmployees @Def: Maximum number of employees available @Shape: [] 
MaxTotalEmployees = data['MaxTotalEmployees']

# Variables 
# @Variable NumberRetailStores @Def: The number of retail stores to open @Shape: ['integer'] 
NumberRetailStores = model.addVar(vtype=GRB.INTEGER, name=""NumberRetailStores"")
# @Variable NumberFactoryOutlets @Def: The number of factory outlets to open @Shape: ['integer'] 
NumberFactoryOutlets = model.addVar(vtype=GRB.INTEGER, name=""NumberFactoryOutlets"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of customers served each day must be at least MinTotalCustomers.
model.addConstr(CustomersPerRetailStore * NumberRetailStores + CustomersPerFactoryOutlet * NumberFactoryOutlets >= MinTotalCustomers)
# @Constraint Constr_2 @Def: The total number of employees used to operate the stores must not exceed MaxTotalEmployees.
model.addConstr(EmployeesPerRetailStore * NumberRetailStores + EmployeesPerFactoryOutlet * NumberFactoryOutlets <= MaxTotalEmployees)

# Objective 
# @Objective Objective @Def: Minimize the total number of stores (retail stores and factory outlets) that must be open.
model.setObjective(NumberRetailStores + NumberFactoryOutlets, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberRetailStores'] = NumberRetailStores.x
variables['NumberFactoryOutlets'] = NumberFactoryOutlets.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A soda company sells soda in two types of containers: cans and glass bottles. A can holds 250 ml of soda whereas a bottle holds 1000 ml of soda. The soda company needs to bottle at least 1000000 ml of soda every day and due to the ability to sell soda cans as packs, there must be at least three times more cans than glass bottles. However, because of previous contracts with gas stations, there must be at least 100 glass bottles made. How many of each should be made to maximize the total number of units produced?",{},"{""parametrized_description"": ""A company produces two types of containers: cans and glass bottles. Each can holds CapacityCan milliliters and each glass bottle holds CapacityBottle milliliters. The company must bottle at least MinimumTotalVolume milliliters per day. The number of cans produced must be at least RatioCansToBottles times the number of glass bottles produced. Additionally, at least MinimumGlassBottles glass bottles must be produced each day. The objective is to maximize the total number of containers produced."", ""keywords"": [""N.A.""], ""parameters"": {""CapacityCan"": {""description"": ""The amount of soda that one can container holds, in milliliters."", ""shape"": []}, ""CapacityBottle"": {""description"": ""The amount of soda that one glass bottle container holds, in milliliters."", ""shape"": []}, ""MinimumTotalVolume"": {""description"": ""The minimum total volume of soda that needs to be bottled each day, in milliliters."", ""shape"": []}, ""RatioCansToBottles"": {""description"": ""The minimum ratio of number of cans to number of glass bottles."", ""shape"": []}, ""MinimumGlassBottles"": {""description"": ""The minimum number of glass bottles that must be produced."", ""shape"": []}}, ""variables"": {""NumberOfBottles"": {""description"": ""The number of glass bottle containers to produce"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfCans"": {""description"": ""The number of cans to produce"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total volume bottled per day must be at least MinimumTotalVolume milliliters."", ""formulation"": ""CapacityBottle \\times NumberOfBottles \\geq MinimumTotalVolume"", ""code"": {""gurobipy"": ""model.addConstr(CapacityBottle * NumberOfBottles >= MinimumTotalVolume)""}}, {""description"": ""The number of cans produced must be at least RatioCansToBottles times the number of glass bottles produced."", ""formulation"": ""NumberOfCans \\geq RatioCansToBottles \\times NumberOfBottles"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfCans >= RatioCansToBottles * NumberOfBottles)""}}, {""description"": ""At least MinimumGlassBottles glass bottles must be produced each day."", ""formulation"": ""NumberOfBottles \\geq MinimumGlassBottles"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfBottles >= MinimumGlassBottles)""}}], ""objective"": {""description"": ""The total number of containers produced is the sum of the number of cans and the number of glass bottles. The objective is to maximize the total number of containers produced."", ""formulation"": ""Max \\ NumberOfCans + NumberOfBottles"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfCans + NumberOfBottles, GRB.MAXIMIZE)""}}}","{""CapacityCan"": 250, ""CapacityBottle"": 1000, ""MinimumTotalVolume"": 1000000, ""RatioCansToBottles"": 3, ""MinimumGlassBottles"": 100}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company produces two types of containers: cans and glass bottles. Each can
holds CapacityCan milliliters and each glass bottle holds CapacityBottle
milliliters. The company must bottle at least MinimumTotalVolume milliliters per
day. The number of cans produced must be at least RatioCansToBottles times the
number of glass bottles produced. Additionally, at least MinimumGlassBottles
glass bottles must be produced each day. The objective is to maximize the total
number of containers produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/240/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CapacityCan @Def: The amount of soda that one can container holds, in milliliters. @Shape: [] 
CapacityCan = data['CapacityCan']
# @Parameter CapacityBottle @Def: The amount of soda that one glass bottle container holds, in milliliters. @Shape: [] 
CapacityBottle = data['CapacityBottle']
# @Parameter MinimumTotalVolume @Def: The minimum total volume of soda that needs to be bottled each day, in milliliters. @Shape: [] 
MinimumTotalVolume = data['MinimumTotalVolume']
# @Parameter RatioCansToBottles @Def: The minimum ratio of number of cans to number of glass bottles. @Shape: [] 
RatioCansToBottles = data['RatioCansToBottles']
# @Parameter MinimumGlassBottles @Def: The minimum number of glass bottles that must be produced. @Shape: [] 
MinimumGlassBottles = data['MinimumGlassBottles']

# Variables 
# @Variable NumberOfBottles @Def: The number of glass bottle containers to produce @Shape: [] 
NumberOfBottles = model.addVar(vtype=GRB.INTEGER, name=""NumberOfBottles"")
# @Variable NumberOfCans @Def: The number of cans to produce @Shape: [] 
NumberOfCans = model.addVar(vtype=GRB.INTEGER, name=""NumberOfCans"")

# Constraints 
# @Constraint Constr_1 @Def: The total volume bottled per day must be at least MinimumTotalVolume milliliters.
model.addConstr(CapacityBottle * NumberOfBottles >= MinimumTotalVolume)
# @Constraint Constr_2 @Def: The number of cans produced must be at least RatioCansToBottles times the number of glass bottles produced.
model.addConstr(NumberOfCans >= RatioCansToBottles * NumberOfBottles)
# @Constraint Constr_3 @Def: At least MinimumGlassBottles glass bottles must be produced each day.
model.addConstr(NumberOfBottles >= MinimumGlassBottles)

# Objective 
# @Objective Objective @Def: The total number of containers produced is the sum of the number of cans and the number of glass bottles. The objective is to maximize the total number of containers produced.
model.setObjective(NumberOfCans + NumberOfBottles, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfBottles'] = NumberOfBottles.x
variables['NumberOfCans'] = NumberOfCans.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A candle-making company can move their inventory of candles using freight and air. Freight can transport 5 tons per trip while using air can transport 3 tons per trip. Since freight take longer, the cost for each freight trip is $300 while the cost over air for each trip is $550. The company needs to transport at least 200 tons of candles and they have a budget of $20000. Additionally, due to some urgent orders, at least 30% of tons of candles must be transported through air. There must also be at least 5 trips through freight. How many of trip by each should be scheduled to minimize the total number of trips?","{""variables"": {""FreightTrips"": 28.0, ""AirTrips"": 20.0}, ""objective"": 48.0}","{""parametrized_description"": ""A candle-making company can transport candles using freight and air. Freight can transport FreightCapacityPerTrip tons per trip, while air can transport AirCapacityPerTrip tons per trip. Each freight trip costs FreightCostPerTrip dollars, and each air trip costs AirCostPerTrip dollars. The company needs to transport at least MinimumTotalTons of candles and has a transportation budget of Budget dollars. Additionally, at least MinimumAirProportion proportion of the total tons must be transported via air. There must also be at least MinimumFreightTrips freight trips. The objective is to determine the number of freight and air trips to minimize the total number of trips."", ""keywords"": [""N.A.""], ""parameters"": {""FreightCapacityPerTrip"": {""description"": ""Amount of tons freight can transport per trip"", ""shape"": []}, ""AirCapacityPerTrip"": {""description"": ""Amount of tons air can transport per trip"", ""shape"": []}, ""FreightCostPerTrip"": {""description"": ""Cost per freight trip in dollars"", ""shape"": []}, ""AirCostPerTrip"": {""description"": ""Cost per air trip in dollars"", ""shape"": []}, ""MinimumTotalTons"": {""description"": ""Minimum total tons to transport"", ""shape"": []}, ""Budget"": {""description"": ""Budget for transportation in dollars"", ""shape"": []}, ""MinimumAirProportion"": {""description"": ""Minimum proportion of tons to transport via air"", ""shape"": []}, ""MinimumFreightTrips"": {""description"": ""Minimum number of freight trips"", ""shape"": []}}, ""variables"": {""FreightTrips"": {""description"": ""The number of freight trips"", ""type"": ""continuous"", ""shape"": []}, ""AirTrips"": {""description"": ""The number of air trips"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The company needs to transport at least MinimumTotalTons of candles."", ""formulation"": ""FreightTrips \\times FreightCapacityPerTrip + AirTrips \\times AirCapacityPerTrip \\geq MinimumTotalTons"", ""code"": {""gurobipy"": ""model.addConstr(FreightTrips * FreightCapacityPerTrip + AirTrips * AirCapacityPerTrip >= MinimumTotalTons)""}}, {""description"": ""The transportation budget is limited to Budget dollars."", ""formulation"": ""FreightTrips \\cdot FreightCostPerTrip + AirTrips \\cdot AirCostPerTrip \\leq Budget"", ""code"": {""gurobipy"": ""model.addConstr(FreightTrips * FreightCostPerTrip + AirTrips * AirCostPerTrip <= Budget)""}}, {""description"": ""At least MinimumAirProportion proportion of the total tons must be transported via air."", ""formulation"": ""AirTrips \\times AirCapacityPerTrip \\geq MinimumAirProportion \\times \\left(FreightTrips \\times FreightCapacityPerTrip + AirTrips \\times AirCapacityPerTrip\\right)"", ""code"": {""gurobipy"": ""model.addConstr(AirTrips * AirCapacityPerTrip >= MinimumAirProportion * (FreightTrips * FreightCapacityPerTrip + AirTrips * AirCapacityPerTrip))""}}, {""description"": ""There must be at least MinimumFreightTrips freight trips."", ""formulation"": ""FreightTrips \\geq MinimumFreightTrips"", ""code"": {""gurobipy"": ""model.addConstr(FreightTrips >= MinimumFreightTrips)""}}], ""objective"": {""description"": ""Determine the number of freight and air trips to minimize the total number of trips."", ""formulation"": ""Min \\ FreightTrips + AirTrips"", ""code"": {""gurobipy"": ""model.setObjective(FreightTrips + AirTrips, GRB.MINIMIZE)""}}}","{""FreightCapacityPerTrip"": 5, ""AirCapacityPerTrip"": 3, ""FreightCostPerTrip"": 300, ""AirCostPerTrip"": 550, ""MinimumTotalTons"": 200, ""Budget"": 20000, ""MinimumAirProportion"": 0.3, ""MinimumFreightTrips"": 5}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A candle-making company can transport candles using freight and air. Freight can
transport FreightCapacityPerTrip tons per trip, while air can transport
AirCapacityPerTrip tons per trip. Each freight trip costs FreightCostPerTrip
dollars, and each air trip costs AirCostPerTrip dollars. The company needs to
transport at least MinimumTotalTons of candles and has a transportation budget
of Budget dollars. Additionally, at least MinimumAirProportion proportion of the
total tons must be transported via air. There must also be at least
MinimumFreightTrips freight trips. The objective is to determine the number of
freight and air trips to minimize the total number of trips.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/241/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter FreightCapacityPerTrip @Def: Amount of tons freight can transport per trip @Shape: [] 
FreightCapacityPerTrip = data['FreightCapacityPerTrip']
# @Parameter AirCapacityPerTrip @Def: Amount of tons air can transport per trip @Shape: [] 
AirCapacityPerTrip = data['AirCapacityPerTrip']
# @Parameter FreightCostPerTrip @Def: Cost per freight trip in dollars @Shape: [] 
FreightCostPerTrip = data['FreightCostPerTrip']
# @Parameter AirCostPerTrip @Def: Cost per air trip in dollars @Shape: [] 
AirCostPerTrip = data['AirCostPerTrip']
# @Parameter MinimumTotalTons @Def: Minimum total tons to transport @Shape: [] 
MinimumTotalTons = data['MinimumTotalTons']
# @Parameter Budget @Def: Budget for transportation in dollars @Shape: [] 
Budget = data['Budget']
# @Parameter MinimumAirProportion @Def: Minimum proportion of tons to transport via air @Shape: [] 
MinimumAirProportion = data['MinimumAirProportion']
# @Parameter MinimumFreightTrips @Def: Minimum number of freight trips @Shape: [] 
MinimumFreightTrips = data['MinimumFreightTrips']

# Variables 
# @Variable FreightTrips @Def: The number of freight trips @Shape: [] 
FreightTrips = model.addVar(vtype=GRB.INTEGER, name=""FreightTrips"")
# @Variable AirTrips @Def: The number of air trips @Shape: [] 
AirTrips = model.addVar(vtype=GRB.INTEGER, name=""AirTrips"")

# Constraints 
# @Constraint Constr_1 @Def: The company needs to transport at least MinimumTotalTons of candles.
model.addConstr(FreightTrips * FreightCapacityPerTrip + AirTrips * AirCapacityPerTrip >= MinimumTotalTons)
# @Constraint Constr_2 @Def: The transportation budget is limited to Budget dollars.
model.addConstr(FreightTrips * FreightCostPerTrip + AirTrips * AirCostPerTrip <= Budget)
# @Constraint Constr_3 @Def: At least MinimumAirProportion proportion of the total tons must be transported via air.
model.addConstr(AirTrips * AirCapacityPerTrip >= MinimumAirProportion * (FreightTrips * FreightCapacityPerTrip + AirTrips * AirCapacityPerTrip))
# @Constraint Constr_4 @Def: There must be at least MinimumFreightTrips freight trips.
model.addConstr(FreightTrips >= MinimumFreightTrips)

# Objective 
# @Objective Objective @Def: Determine the number of freight and air trips to minimize the total number of trips.
model.setObjective(FreightTrips + AirTrips, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['FreightTrips'] = FreightTrips.x
variables['AirTrips'] = AirTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A production company needs to transport their equipment and staff for a movie they are shooting using large mobile production units or small mobile production units. Large mobile production units can hold 6 people and takes up 2 parking spots whereas small mobile production units can hold only 2 people and takes up 1 parking spot. Movie stars prefer to have their small mobile production unit to share with a close staff, therefore at least 5 units must be small mobile units. However, due to logistic limitations, large mobile production units are more space efficient per spot, they must make up at least 75% of all vehicles. If the movie needs to transport 80 people, minimize the total number of parking spots required by this production.","{""variables"": {""NumberLargeUnits"": 15.0, ""NumberSmallUnits"": 5.0}, ""objective"": 35.0}","{""parametrized_description"": ""The production company needs to transport TotalPeople using large mobile production units and small mobile production units. Each large unit can hold CapacityLargeUnit people and occupies ParkingLargeUnit parking spots. Each small unit can hold CapacitySmallUnit people and occupies ParkingSmallUnit parking spots. At least MinSmallUnits small mobile production units must be used. The number of large mobile production units must be at least MinLargeUnitProportion of all mobile production units. The objective is to minimize the total number of parking spots required."", ""keywords"": [""N.A.""], ""parameters"": {""CapacityLargeUnit"": {""description"": ""Number of people that one large mobile production unit can hold"", ""shape"": []}, ""ParkingLargeUnit"": {""description"": ""Number of parking spots occupied by one large mobile production unit"", ""shape"": []}, ""CapacitySmallUnit"": {""description"": ""Number of people that one small mobile production unit can hold"", ""shape"": []}, ""ParkingSmallUnit"": {""description"": ""Number of parking spots occupied by one small mobile production unit"", ""shape"": []}, ""MinSmallUnits"": {""description"": ""Minimum number of small mobile production units required"", ""shape"": []}, ""MinLargeUnitProportion"": {""description"": ""Minimum proportion of large mobile production units relative to total vehicles"", ""shape"": []}, ""TotalPeople"": {""description"": ""Total number of people that need to be transported"", ""shape"": []}}, ""variables"": {""NumberLargeUnits"": {""description"": ""The number of large mobile production units used"", ""type"": ""continuous"", ""shape"": []}, ""NumberSmallUnits"": {""description"": ""The number of small mobile production units used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of people transported using large and small mobile production units must be at least TotalPeople. Each large unit holds CapacityLargeUnit people and each small unit holds CapacitySmallUnit people."", ""formulation"": ""CapacityLargeUnit \\times NumberLargeUnits + CapacitySmallUnit \\times NumberSmallUnits \\geq TotalPeople"", ""code"": {""gurobipy"": ""model.addConstr(CapacityLargeUnit * NumberLargeUnits + CapacitySmallUnit * NumberSmallUnits >= TotalPeople)""}}, {""description"": ""At least MinSmallUnits small mobile production units must be used."", ""formulation"": ""NumberSmallUnits \\geq MinSmallUnits"", ""code"": {""gurobipy"": ""model.addConstr(NumberSmallUnits >= MinSmallUnits)""}}, {""description"": ""The number of large mobile production units must be at least MinLargeUnitProportion of all mobile production units."", ""formulation"": ""NumberLargeUnits \\geq MinLargeUnitProportion \\times (NumberLargeUnits + NumberSmallUnits)"", ""code"": {""gurobipy"": ""model.addConstr(NumberLargeUnits >= MinLargeUnitProportion * (NumberLargeUnits + NumberSmallUnits))""}}], ""objective"": {""description"": ""Minimize the total number of parking spots required. The total parking spots are calculated by summing the parking spots occupied by large and small mobile production units, where each large unit occupies ParkingLargeUnit spots and each small unit occupies ParkingSmallUnit spots."", ""formulation"": ""Min NumberLargeUnits \\times ParkingLargeUnit + NumberSmallUnits \\times ParkingSmallUnit"", ""code"": {""gurobipy"": ""model.setObjective(NumberLargeUnits * ParkingLargeUnit + NumberSmallUnits * ParkingSmallUnit, GRB.MINIMIZE)""}}}","{""CapacityLargeUnit"": 6, ""ParkingLargeUnit"": 2, ""CapacitySmallUnit"": 2, ""ParkingSmallUnit"": 1, ""MinSmallUnits"": 5, ""MinLargeUnitProportion"": 0.75, ""TotalPeople"": 80}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
The production company needs to transport TotalPeople using large mobile
production units and small mobile production units. Each large unit can hold
CapacityLargeUnit people and occupies ParkingLargeUnit parking spots. Each small
unit can hold CapacitySmallUnit people and occupies ParkingSmallUnit parking
spots. At least MinSmallUnits small mobile production units must be used. The
number of large mobile production units must be at least MinLargeUnitProportion
of all mobile production units. The objective is to minimize the total number of
parking spots required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/242/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CapacityLargeUnit @Def: Number of people that one large mobile production unit can hold @Shape: [] 
CapacityLargeUnit = data['CapacityLargeUnit']
# @Parameter ParkingLargeUnit @Def: Number of parking spots occupied by one large mobile production unit @Shape: [] 
ParkingLargeUnit = data['ParkingLargeUnit']
# @Parameter CapacitySmallUnit @Def: Number of people that one small mobile production unit can hold @Shape: [] 
CapacitySmallUnit = data['CapacitySmallUnit']
# @Parameter ParkingSmallUnit @Def: Number of parking spots occupied by one small mobile production unit @Shape: [] 
ParkingSmallUnit = data['ParkingSmallUnit']
# @Parameter MinSmallUnits @Def: Minimum number of small mobile production units required @Shape: [] 
MinSmallUnits = data['MinSmallUnits']
# @Parameter MinLargeUnitProportion @Def: Minimum proportion of large mobile production units relative to total vehicles @Shape: [] 
MinLargeUnitProportion = data['MinLargeUnitProportion']
# @Parameter TotalPeople @Def: Total number of people that need to be transported @Shape: [] 
TotalPeople = data['TotalPeople']

# Variables 
# @Variable NumberLargeUnits @Def: The number of large mobile production units used @Shape: [] 
NumberLargeUnits = model.addVar(vtype=GRB.INTEGER, name=""NumberLargeUnits"")
# @Variable NumberSmallUnits @Def: The number of small mobile production units used @Shape: [] 
NumberSmallUnits = model.addVar(vtype=GRB.INTEGER, lb=MinSmallUnits, name=""NumberSmallUnits"")

# Constraints 
# @Constraint Constr_1 @Def: The number of people transported using large and small mobile production units must be at least TotalPeople. Each large unit holds CapacityLargeUnit people and each small unit holds CapacitySmallUnit people.
model.addConstr(CapacityLargeUnit * NumberLargeUnits + CapacitySmallUnit * NumberSmallUnits >= TotalPeople)
# @Constraint Constr_2 @Def: At least MinSmallUnits small mobile production units must be used.
model.addConstr(NumberSmallUnits >= MinSmallUnits)
# @Constraint Constr_3 @Def: The number of large mobile production units must be at least MinLargeUnitProportion of all mobile production units.
model.addConstr(NumberLargeUnits >= MinLargeUnitProportion * (NumberLargeUnits + NumberSmallUnits))

# Objective 
# @Objective Objective @Def: Minimize the total number of parking spots required. The total parking spots are calculated by summing the parking spots occupied by large and small mobile production units, where each large unit occupies ParkingLargeUnit spots and each small unit occupies ParkingSmallUnit spots.
model.setObjective(NumberLargeUnits * ParkingLargeUnit + NumberSmallUnits * ParkingSmallUnit, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberLargeUnits'] = NumberLargeUnits.x
variables['NumberSmallUnits'] = NumberSmallUnits.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A mask making company ships masks to their retail stores using small boxes and large boxes. A small box holds 25 masks whereas a large box holds 45 masks. Since small boxes are easier to stack and will be used first to stock stores, there must be at least three times as many small boxes as large boxes. Additionally, at least 5 large boxes must be used. If at least 750 masks are required to be distributed, how many of each size of box should be used to minimize the total number of boxes needed?","{""variables"": {""NumberSmallBoxes"": 21.0, ""NumberLargeBoxes"": 5.0}, ""objective"": 26.0}","{""parametrized_description"": ""A company distributes masks using small boxes and large boxes. Each small box holds MasksPerSmallBox masks, and each large box holds MasksPerLargeBox masks. The number of small boxes must be at least MinRatioSmallToLarge times the number of large boxes. At least MinLargeBoxes large boxes must be used. The total number of masks distributed must be at least TotalMasksRequired. The objective is to minimize the total number of boxes used."", ""keywords"": [""N.A.""], ""parameters"": {""MasksPerSmallBox"": {""description"": ""Number of masks that fit in a small box"", ""shape"": []}, ""MasksPerLargeBox"": {""description"": ""Number of masks that fit in a large box"", ""shape"": []}, ""MinRatioSmallToLarge"": {""description"": ""Minimum ratio of small boxes to large boxes"", ""shape"": []}, ""MinLargeBoxes"": {""description"": ""Minimum number of large boxes required"", ""shape"": []}, ""TotalMasksRequired"": {""description"": ""Minimum number of masks to distribute"", ""shape"": []}}, ""variables"": {""NumberSmallBoxes"": {""description"": ""The number of small boxes"", ""type"": ""continuous"", ""shape"": []}, ""NumberLargeBoxes"": {""description"": ""The number of large boxes"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of small boxes must be at least MinRatioSmallToLarge times the number of large boxes."", ""formulation"": ""NumberSmallBoxes \\geq MinRatioSmallToLarge \\times NumberLargeBoxes"", ""code"": {""gurobipy"": ""model.addConstr(NumberSmallBoxes >= MinRatioSmallToLarge * NumberLargeBoxes)""}}, {""description"": ""At least MinLargeBoxes large boxes must be used."", ""formulation"": ""NumberLargeBoxes \\geq MinLargeBoxes"", ""code"": {""gurobipy"": ""model.addConstr(NumberLargeBoxes >= MinLargeBoxes)""}}, {""description"": ""The total number of masks distributed must be at least TotalMasksRequired."", ""formulation"": ""MasksPerSmallBox \\times NumberSmallBoxes + MasksPerLargeBox \\times NumberLargeBoxes \\geq TotalMasksRequired"", ""code"": {""gurobipy"": ""model.addConstr(MasksPerSmallBox * NumberSmallBoxes + MasksPerLargeBox * NumberLargeBoxes >= TotalMasksRequired)""}}], ""objective"": {""description"": ""The total number of boxes used is the sum of small and large boxes. The objective is to minimize the total number of boxes used."", ""formulation"": ""Min NumberSmallBoxes + NumberLargeBoxes"", ""code"": {""gurobipy"": ""model.setObjective(NumberSmallBoxes + NumberLargeBoxes, GRB.MINIMIZE)""}}}","{""MasksPerSmallBox"": 25, ""MasksPerLargeBox"": 45, ""MinRatioSmallToLarge"": 3, ""MinLargeBoxes"": 5, ""TotalMasksRequired"": 750}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company distributes masks using small boxes and large boxes. Each small box
holds MasksPerSmallBox masks, and each large box holds MasksPerLargeBox masks.
The number of small boxes must be at least MinRatioSmallToLarge times the number
of large boxes. At least MinLargeBoxes large boxes must be used. The total
number of masks distributed must be at least TotalMasksRequired. The objective
is to minimize the total number of boxes used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/243/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MasksPerSmallBox @Def: Number of masks that fit in a small box @Shape: [] 
MasksPerSmallBox = data['MasksPerSmallBox']
# @Parameter MasksPerLargeBox @Def: Number of masks that fit in a large box @Shape: [] 
MasksPerLargeBox = data['MasksPerLargeBox']
# @Parameter MinRatioSmallToLarge @Def: Minimum ratio of small boxes to large boxes @Shape: [] 
MinRatioSmallToLarge = data['MinRatioSmallToLarge']
# @Parameter MinLargeBoxes @Def: Minimum number of large boxes required @Shape: [] 
MinLargeBoxes = data['MinLargeBoxes']
# @Parameter TotalMasksRequired @Def: Minimum number of masks to distribute @Shape: [] 
TotalMasksRequired = data['TotalMasksRequired']

# Variables 
# @Variable NumberSmallBoxes @Def: The number of small boxes @Shape: [] 
NumberSmallBoxes = model.addVar(vtype=GRB.INTEGER, name=""NumberSmallBoxes"")
# @Variable NumberLargeBoxes @Def: The number of large boxes @Shape: [] 
NumberLargeBoxes = model.addVar(vtype=GRB.INTEGER, lb=MinLargeBoxes, name=""NumberLargeBoxes"")

# Constraints 
# @Constraint Constr_1 @Def: The number of small boxes must be at least MinRatioSmallToLarge times the number of large boxes.
model.addConstr(NumberSmallBoxes >= MinRatioSmallToLarge * NumberLargeBoxes)
# @Constraint Constr_2 @Def: At least MinLargeBoxes large boxes must be used.
model.addConstr(NumberLargeBoxes >= MinLargeBoxes)
# @Constraint Constr_3 @Def: The total number of masks distributed must be at least TotalMasksRequired.
model.addConstr(MasksPerSmallBox * NumberSmallBoxes + MasksPerLargeBox * NumberLargeBoxes >= TotalMasksRequired)

# Objective 
# @Objective Objective @Def: The total number of boxes used is the sum of small and large boxes. The objective is to minimize the total number of boxes used.
model.setObjective(NumberSmallBoxes + NumberLargeBoxes, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberSmallBoxes'] = NumberSmallBoxes.x
variables['NumberLargeBoxes'] = NumberLargeBoxes.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Grain is transported from a farm to local grocery stores in either large bags or tiny bags. Large bags can hold 25 kg of grain and requires 4 units of energy to transport. Tiny bags can hold 6 kg of grain and requires 1.5 units of energy to transport. The distribution process has access to 110 units of energy. Because of popularity of buying in bulk, there must be twice as many large bags as tiny bags of rice. Additionally, there must be at least 20 tiny bags of rice. How many of each size of rice bags should be used to maximize the total amount of grain in weight?",{},"{""parametrized_description"": ""Determine the number of large bags (L) and tiny bags (T) such that LargeBagEnergy * L + TinyBagEnergy * T \u2264 TotalEnergy, L = RatioLargeToTiny * T, and T \u2265 MinTinyBags. The goal is to maximize the total grain weight, which is LargeBagCapacity * L + TinyBagCapacity * T."", ""keywords"": [""N.A.""], ""parameters"": {""LargeBagCapacity"": {""description"": ""The capacity of a large bag in kilograms"", ""shape"": []}, ""LargeBagEnergy"": {""description"": ""The energy required to transport a large bag"", ""shape"": []}, ""TinyBagCapacity"": {""description"": ""The capacity of a tiny bag in kilograms"", ""shape"": []}, ""TinyBagEnergy"": {""description"": ""The energy required to transport a tiny bag"", ""shape"": []}, ""TotalEnergy"": {""description"": ""Total available energy for distribution"", ""shape"": []}, ""RatioLargeToTiny"": {""description"": ""The ratio of large bags to tiny bags"", ""shape"": []}, ""MinTinyBags"": {""description"": ""Minimum number of tiny bags required"", ""shape"": []}}, ""variables"": {""LargeBags"": {""description"": ""The number of large bags to transport"", ""type"": ""continuous"", ""shape"": []}, ""TinyBags"": {""description"": ""The number of tiny bags to transport"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""LargeBagEnergy * L + TinyBagEnergy * T must be less than or equal to TotalEnergy."", ""formulation"": ""LargeBagEnergy \\cdot LargeBags + TinyBagEnergy \\cdot TinyBags \\leq TotalEnergy"", ""code"": {""gurobipy"": ""model.addConstr(LargeBagEnergy * LargeBags + TinyBagEnergy * TinyBags <= TotalEnergy)""}}, {""description"": ""L must be equal to RatioLargeToTiny multiplied by T."", ""formulation"": ""LargeBags = RatioLargeToTiny \\times TinyBags"", ""code"": {""gurobipy"": ""model.addConstr(LargeBags == RatioLargeToTiny * TinyBags)""}}, {""description"": ""T must be greater than or equal to MinTinyBags."", ""formulation"": ""TinyBags \\geq MinTinyBags"", ""code"": {""gurobipy"": ""model.addConstr(TinyBags >= MinTinyBags)""}}], ""objective"": {""description"": ""Maximize the total grain weight, which is LargeBagCapacity * L + TinyBagCapacity * T."", ""formulation"": ""Max LargeBagCapacity \\times LargeBags + TinyBagCapacity \\times TinyBags"", ""code"": {""gurobipy"": ""model.setObjective(LargeBagCapacity * LargeBags + TinyBagCapacity * TinyBags, GRB.MAXIMIZE)""}}}","{""LargeBagCapacity"": 25, ""LargeBagEnergy"": 4, ""TinyBagCapacity"": 6, ""TinyBagEnergy"": 1.5, ""TotalEnergy"": 110, ""RatioLargeToTiny"": 2, ""MinTinyBags"": 20}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
Determine the number of large bags (L) and tiny bags (T) such that
LargeBagEnergy * L + TinyBagEnergy * T ≤ TotalEnergy, L = RatioLargeToTiny * T,
and T ≥ MinTinyBags. The goal is to maximize the total grain weight, which is
LargeBagCapacity * L + TinyBagCapacity * T.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/244/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter LargeBagCapacity @Def: The capacity of a large bag in kilograms @Shape: [] 
LargeBagCapacity = data['LargeBagCapacity']
# @Parameter LargeBagEnergy @Def: The energy required to transport a large bag @Shape: [] 
LargeBagEnergy = data['LargeBagEnergy']
# @Parameter TinyBagCapacity @Def: The capacity of a tiny bag in kilograms @Shape: [] 
TinyBagCapacity = data['TinyBagCapacity']
# @Parameter TinyBagEnergy @Def: The energy required to transport a tiny bag @Shape: [] 
TinyBagEnergy = data['TinyBagEnergy']
# @Parameter TotalEnergy @Def: Total available energy for distribution @Shape: [] 
TotalEnergy = data['TotalEnergy']
# @Parameter RatioLargeToTiny @Def: The ratio of large bags to tiny bags @Shape: [] 
RatioLargeToTiny = data['RatioLargeToTiny']
# @Parameter MinTinyBags @Def: Minimum number of tiny bags required @Shape: [] 
MinTinyBags = data['MinTinyBags']

# Variables 
# @Variable LargeBags @Def: The number of large bags to transport @Shape: [] 
LargeBags = model.addVar(vtype=GRB.INTEGER, name=""LargeBags"")
# @Variable TinyBags @Def: The number of tiny bags to transport @Shape: [] 
TinyBags = model.addVar(vtype=GRB.INTEGER, name=""TinyBags"")

# Constraints 
# @Constraint Constr_1 @Def: LargeBagEnergy * L + TinyBagEnergy * T must be less than or equal to TotalEnergy.
model.addConstr(LargeBagEnergy * LargeBags + TinyBagEnergy * TinyBags <= TotalEnergy)
# @Constraint Constr_2 @Def: L must be equal to RatioLargeToTiny multiplied by T.
model.addConstr(LargeBags == RatioLargeToTiny * TinyBags)
# @Constraint Constr_3 @Def: T must be greater than or equal to MinTinyBags.
model.addConstr(TinyBags >= MinTinyBags)

# Objective 
# @Objective Objective @Def: Maximize the total grain weight, which is LargeBagCapacity * L + TinyBagCapacity * T.
model.setObjective(LargeBagCapacity * LargeBags + TinyBagCapacity * TinyBags, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['LargeBags'] = LargeBags.x
variables['TinyBags'] = TinyBags.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"An autobody shop needs to purchase two types of car jacks, an automatic electric one, or a gas-powered one. The automatic electric one can process 5 cars every hour and uses 6 units of electricity whereas the gas-powered one can process 4 cars each hour using 7 units of gas. Since there is a limit to how many automatic electric ones there can be due to the limited number of power outlets, the shop must use less than 15 automatic electric ones. The shop can use at most 50 units of electricity and 80 units of gas. How many of each type of jack should the shop purchase to maximize the amount of cars processed every hour?","{""variables"": {""AutoElectricJacksUsed"": 8.0, ""GasPoweredJacksUsed"": 11.0}, ""objective"": 84.0}","{""parametrized_description"": ""An autobody shop needs to purchase AutoElectricJacks and GasPoweredJacks. Each AutoElectricJack can process AutoElectricProcessingRate cars per hour and uses AutoElectricElectricityUsage units of electricity per hour. Each GasPoweredJack can process GasPoweredProcessingRate cars per hour and uses GasPoweredGasUsage units of gas per hour. The shop must use fewer than MaxAutoElectricJacks AutoElectricJacks. Additionally, the shop can use at most MaxElectricityUnits units of electricity and MaxGasUnits units of gas. The objective is to maximize the number of cars processed every hour."", ""keywords"": [""N.A.""], ""parameters"": {""AutoElectricProcessingRate"": {""description"": ""The number of cars processed per hour by one automatic electric jack."", ""shape"": []}, ""AutoElectricElectricityUsage"": {""description"": ""Units of electricity used per hour by one automatic electric jack."", ""shape"": []}, ""GasPoweredProcessingRate"": {""description"": ""The number of cars processed per hour by one gas-powered jack."", ""shape"": []}, ""GasPoweredGasUsage"": {""description"": ""Units of gas used per hour by one gas-powered jack."", ""shape"": []}, ""MaxAutoElectricJacks"": {""description"": ""The maximum number of automatic electric jacks that can be used."", ""shape"": []}, ""MaxElectricityUnits"": {""description"": ""The maximum units of electricity available."", ""shape"": []}, ""MaxGasUnits"": {""description"": ""The maximum units of gas available."", ""shape"": []}}, ""variables"": {""AutoElectricJacksUsed"": {""description"": ""The number of automatic electric jacks used"", ""type"": ""continuous"", ""shape"": []}, ""GasPoweredJacksUsed"": {""description"": ""The number of gas-powered jacks used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of AutoElectricJacks used must be fewer than MaxAutoElectricJacks."", ""formulation"": ""AutoElectricJacksUsed \\leq MaxAutoElectricJacks - 1"", ""code"": {""gurobipy"": ""model.addConstr(AutoElectricJacksUsed <= MaxAutoElectricJacks - 1)""}}, {""description"": ""The total electricity usage by AutoElectricJacks must not exceed MaxElectricityUnits."", ""formulation"": ""AutoElectricElectricityUsage \\cdot AutoElectricJacksUsed \\leq MaxElectricityUnits"", ""code"": {""gurobipy"": ""model.addConstr(AutoElectricElectricityUsage * AutoElectricJacksUsed <= MaxElectricityUnits)""}}, {""description"": ""The total gas usage by GasPoweredJacks must not exceed MaxGasUnits."", ""formulation"": ""GasPoweredGasUsage \\times GasPoweredJacksUsed \\leq MaxGasUnits"", ""code"": {""gurobipy"": ""model.addConstr(GasPoweredGasUsage * GasPoweredJacksUsed <= MaxGasUnits)""}}], ""objective"": {""description"": ""Maximize the number of cars processed every hour."", ""formulation"": ""Max AutoElectricJacksUsed \\times AutoElectricProcessingRate + GasPoweredJacksUsed \\times GasPoweredProcessingRate"", ""code"": {""gurobipy"": ""model.setObjective(AutoElectricJacksUsed * AutoElectricProcessingRate + GasPoweredJacksUsed * GasPoweredProcessingRate, GRB.MAXIMIZE)""}}}","{""AutoElectricProcessingRate"": 5, ""AutoElectricElectricityUsage"": 6, ""GasPoweredProcessingRate"": 4, ""GasPoweredGasUsage"": 7, ""MaxAutoElectricJacks"": 15, ""MaxElectricityUnits"": 50, ""MaxGasUnits"": 80}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
An autobody shop needs to purchase AutoElectricJacks and GasPoweredJacks. Each
AutoElectricJack can process AutoElectricProcessingRate cars per hour and uses
AutoElectricElectricityUsage units of electricity per hour. Each GasPoweredJack
can process GasPoweredProcessingRate cars per hour and uses GasPoweredGasUsage
units of gas per hour. The shop must use fewer than MaxAutoElectricJacks
AutoElectricJacks. Additionally, the shop can use at most MaxElectricityUnits
units of electricity and MaxGasUnits units of gas. The objective is to maximize
the number of cars processed every hour.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/245/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter AutoElectricProcessingRate @Def: The number of cars processed per hour by one automatic electric jack. @Shape: [] 
AutoElectricProcessingRate = data['AutoElectricProcessingRate']
# @Parameter AutoElectricElectricityUsage @Def: Units of electricity used per hour by one automatic electric jack. @Shape: [] 
AutoElectricElectricityUsage = data['AutoElectricElectricityUsage']
# @Parameter GasPoweredProcessingRate @Def: The number of cars processed per hour by one gas-powered jack. @Shape: [] 
GasPoweredProcessingRate = data['GasPoweredProcessingRate']
# @Parameter GasPoweredGasUsage @Def: Units of gas used per hour by one gas-powered jack. @Shape: [] 
GasPoweredGasUsage = data['GasPoweredGasUsage']
# @Parameter MaxAutoElectricJacks @Def: The maximum number of automatic electric jacks that can be used. @Shape: [] 
MaxAutoElectricJacks = data['MaxAutoElectricJacks']
# @Parameter MaxElectricityUnits @Def: The maximum units of electricity available. @Shape: [] 
MaxElectricityUnits = data['MaxElectricityUnits']
# @Parameter MaxGasUnits @Def: The maximum units of gas available. @Shape: [] 
MaxGasUnits = data['MaxGasUnits']

# Variables 
# @Variable AutoElectricJacksUsed @Def: The number of automatic electric jacks used @Shape: [] 
AutoElectricJacksUsed = model.addVar(vtype=GRB.INTEGER, name=""AutoElectricJacksUsed"", ub=MaxAutoElectricJacks)
# @Variable GasPoweredJacksUsed @Def: The number of gas-powered jacks used @Shape: [] 
GasPoweredJacksUsed = model.addVar(vtype=GRB.INTEGER, name=""GasPoweredJacksUsed"")

# Constraints 
# @Constraint Constr_1 @Def: The number of AutoElectricJacks used must be fewer than MaxAutoElectricJacks.
model.addConstr(AutoElectricJacksUsed <= MaxAutoElectricJacks - 1)
# @Constraint Constr_2 @Def: The total electricity usage by AutoElectricJacks must not exceed MaxElectricityUnits.
model.addConstr(AutoElectricElectricityUsage * AutoElectricJacksUsed <= MaxElectricityUnits)
# @Constraint Constr_3 @Def: The total gas usage by GasPoweredJacks must not exceed MaxGasUnits.
model.addConstr(GasPoweredGasUsage * GasPoweredJacksUsed <= MaxGasUnits)

# Objective 
# @Objective Objective @Def: Maximize the number of cars processed every hour.
model.setObjective(AutoElectricJacksUsed * AutoElectricProcessingRate + GasPoweredJacksUsed * GasPoweredProcessingRate, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['AutoElectricJacksUsed'] = AutoElectricJacksUsed.x
variables['GasPoweredJacksUsed'] = GasPoweredJacksUsed.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A railway company is planning the infrastructure for the city and is considering two types of transportation, trains and trams. Each train can transport 120 people per hour comfortably and each tram can transport 30 people per hour comfortably. Since trains take longer to build, the number of trams must be at least twice the number of trains. If the railway company wants to transport at least 600 people per hour, minimize the total number of transportation units required.","{""variables"": {""NumberOfTrams"": 8.0, ""NumberOfTrains"": 3.0}, ""objective"": 11.0}","{""parametrized_description"": ""A railway company is planning the infrastructure for the city and is considering two types of transportation, trains and trams. Each train can transport TrainCapacity people per hour comfortably and each tram can transport TramCapacity people per hour comfortably. Since trains take longer to build, the number of trams must be at least MinTramsToTrainsRatio times the number of trains. If the railway company wants to transport at least MinPeoplePerHour people per hour, minimize the total number of transportation units required."", ""keywords"": [""N.A.""], ""parameters"": {""TrainCapacity"": {""description"": ""Number of people transported per train per hour"", ""shape"": []}, ""TramCapacity"": {""description"": ""Number of people transported per tram per hour"", ""shape"": []}, ""MinTramsToTrainsRatio"": {""description"": ""Minimum ratio of trams to trains"", ""shape"": []}, ""MinPeoplePerHour"": {""description"": ""Minimum number of people to transport per hour"", ""shape"": []}}, ""variables"": {""NumberOfTrams"": {""description"": ""The number of trams"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberOfTrains"": {""description"": ""The number of trains"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The number of trams must be at least MinTramsToTrainsRatio times the number of trains."", ""formulation"": ""NumberOfTrams \\geq MinTramsToTrainsRatio \\times NumberOfTrains"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfTrams >= MinTramsToTrainsRatio * NumberOfTrains)""}}, {""description"": ""The total number of people transported per hour by trains and trams must be at least MinPeoplePerHour."", ""formulation"": ""NumberOfTrains \\times TrainCapacity + NumberOfTrams \\times TramCapacity \\geq MinPeoplePerHour"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfTrains * TrainCapacity + NumberOfTrams * TramCapacity >= MinPeoplePerHour)""}}], ""objective"": {""description"": ""Minimize the total number of transportation units required."", ""formulation"": ""\\min NumberOfTrams + NumberOfTrains"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfTrams + NumberOfTrains, GRB.MINIMIZE)""}}}","{""TrainCapacity"": 120, ""TramCapacity"": 30, ""MinTramsToTrainsRatio"": 2, ""MinPeoplePerHour"": 600}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A railway company is planning the infrastructure for the city and is considering
two types of transportation, trains and trams. Each train can transport
TrainCapacity people per hour comfortably and each tram can transport
TramCapacity people per hour comfortably. Since trains take longer to build, the
number of trams must be at least MinTramsToTrainsRatio times the number of
trains. If the railway company wants to transport at least MinPeoplePerHour
people per hour, minimize the total number of transportation units required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/246/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TrainCapacity @Def: Number of people transported per train per hour @Shape: [] 
TrainCapacity = data['TrainCapacity']
# @Parameter TramCapacity @Def: Number of people transported per tram per hour @Shape: [] 
TramCapacity = data['TramCapacity']
# @Parameter MinTramsToTrainsRatio @Def: Minimum ratio of trams to trains @Shape: [] 
MinTramsToTrainsRatio = data['MinTramsToTrainsRatio']
# @Parameter MinPeoplePerHour @Def: Minimum number of people to transport per hour @Shape: [] 
MinPeoplePerHour = data['MinPeoplePerHour']

# Variables 
# @Variable NumberOfTrams @Def: The number of trams @Shape: ['Integer'] 
NumberOfTrams = model.addVar(vtype=GRB.INTEGER, name=""NumberOfTrams"")
# @Variable NumberOfTrains @Def: The number of trains @Shape: ['Integer'] 
NumberOfTrains = model.addVar(vtype=GRB.INTEGER, name=""NumberOfTrains"")

# Constraints 
# @Constraint Constr_1 @Def: The number of trams must be at least MinTramsToTrainsRatio times the number of trains.
model.addConstr(NumberOfTrams >= MinTramsToTrainsRatio * NumberOfTrains)
# @Constraint Constr_2 @Def: The total number of people transported per hour by trains and trams must be at least MinPeoplePerHour.
model.addConstr(NumberOfTrains * TrainCapacity + NumberOfTrams * TramCapacity >= MinPeoplePerHour)

# Objective 
# @Objective Objective @Def: Minimize the total number of transportation units required.
model.setObjective(NumberOfTrams + NumberOfTrains, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfTrams'] = NumberOfTrams.x
variables['NumberOfTrains'] = NumberOfTrains.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Platinum in combination with palladium has been used as a catalyst in cars and it changes carbon monoxide, which is toxic, into carbon dioxide. An automotive company is comparing two different catalysts, a palladium-heavy catalyst and a platinum-heavy catalyst. The process with a palladium-heavy catalyst requires 15 units of platinum and 25 units of palladium and can perform the conversion to carbon dioxide at a rate of 5 units per second. A platinum-heavy catalyst requires 20 units of platinum and 14 units of palladium and converts to carbon dioxide at a rate of 4 units per second. There are 450 units of platinum and 390 units of palladium available. How many of each catalyst should be used to maximize the amount converted into carbon dioxide?","{""variables"": {""CatalystUsage"": {""0"": 5.172413793103448, ""1"": 18.620689655172413}}, ""objective"": 100.34482758620689}","{""parametrized_description"": ""An automotive company is comparing NumCatalysts different catalysts. Each catalyst requires amounts of resources as specified by ResourceRequirement and has a conversion rate defined by ConversionRate. Given the TotalResource available for each resource, determine the number of each catalyst to use to maximize the total conversion rate without exceeding the available resources."", ""keywords"": [""N.A.""], ""parameters"": {""NumCatalysts"": {""description"": ""Number of catalyst types"", ""shape"": []}, ""NumResources"": {""description"": ""Number of resources"", ""shape"": []}, ""ResourceRequirement"": {""description"": ""Amount of resource r required per unit of catalyst c"", ""shape"": [""NumResources"", ""NumCatalysts""]}, ""ConversionRate"": {""description"": ""Conversion rate per unit of catalyst c"", ""shape"": [""NumCatalysts""]}, ""TotalResource"": {""description"": ""Total amount of resource r available"", ""shape"": [""NumResources""]}}, ""variables"": {""CatalystUsage"": {""description"": ""The amount of catalyst c to use"", ""type"": ""continuous"", ""shape"": [""NumCatalysts""]}}, ""constraints"": [{""description"": ""For each resource, the total amount consumed by all catalysts must not exceed the available TotalResource."", ""formulation"": ""\\sum_{c=1}^{\\text{NumCatalysts}} ResourceRequirement_{r,c} \\cdot CatalystUsage_{c} \\leq TotalResource_{r} \\quad \\forall r \\in \\{1, \\dots, \\text{NumResources}\\}"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(ResourceRequirement[r][c] * CatalystUsage[c] for c in range(NumCatalysts)) <= TotalResource[r] for r in range(NumResources)), name=\""ResourceConstraint\"")""}}], ""objective"": {""description"": ""Maximize the total conversion rate, calculated as the sum of ConversionRate multiplied by the number of each catalyst used."", ""formulation"": ""Max \\sum_{c=1}^{NumCatalysts} ConversionRate_{c} \\times CatalystUsage_{c}"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ConversionRate[c] * CatalystUsage[c] for c in range(NumCatalysts)), GRB.MAXIMIZE)""}}}","{""NumCatalysts"": 2, ""NumResources"": 2, ""ResourceRequirement"": [[15, 20], [25, 14]], ""ConversionRate"": [5, 4], ""TotalResource"": [450, 390]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
An automotive company is comparing NumCatalysts different catalysts. Each
catalyst requires amounts of resources as specified by ResourceRequirement and
has a conversion rate defined by ConversionRate. Given the TotalResource
available for each resource, determine the number of each catalyst to use to
maximize the total conversion rate without exceeding the available resources.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/247/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumCatalysts @Def: Number of catalyst types @Shape: [] 
NumCatalysts = data['NumCatalysts']
# @Parameter NumResources @Def: Number of resources @Shape: [] 
NumResources = data['NumResources']
# @Parameter ResourceRequirement @Def: Amount of resource r required per unit of catalyst c @Shape: ['NumResources', 'NumCatalysts'] 
ResourceRequirement = data['ResourceRequirement']
# @Parameter ConversionRate @Def: Conversion rate per unit of catalyst c @Shape: ['NumCatalysts'] 
ConversionRate = data['ConversionRate']
# @Parameter TotalResource @Def: Total amount of resource r available @Shape: ['NumResources'] 
TotalResource = data['TotalResource']

# Variables 
# @Variable CatalystUsage @Def: The amount of catalyst c to use @Shape: ['NumCatalysts'] 
CatalystUsage = model.addVars(NumCatalysts, vtype=GRB.CONTINUOUS, name=""CatalystUsage"")

# Constraints 
# @Constraint Constr_1 @Def: For each resource, the total amount consumed by all catalysts must not exceed the available TotalResource.
model.addConstrs((quicksum(ResourceRequirement[r][c] * CatalystUsage[c] for c in range(NumCatalysts)) <= TotalResource[r] for r in range(NumResources)), name=""ResourceConstraint"")

# Objective 
# @Objective Objective @Def: Maximize the total conversion rate, calculated as the sum of ConversionRate multiplied by the number of each catalyst used.
model.setObjective(quicksum(ConversionRate[c] * CatalystUsage[c] for c in range(NumCatalysts)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['CatalystUsage'] = {c: CatalystUsage[c].X for c in range(NumCatalysts)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
There are two ways to extract a metal from mined ores. The first way is to use process J and the second is process P. Process J can extract 5 units of metal using 8 units of water and produces 3 units of pollution. Process P can extract 9 units of metal using 6 units of water and produces 5 units of pollution. There can be at most 1500 units of water 1350 units of pollution. How many of each type of processes should be performed to maximize the amount of metal extracted?,"{""variables"": {""ProcessUnit"": {""0"": 0.0, ""1"": 250.0}}, ""objective"": 2250.0}","{""parametrized_description"": ""Determine the number of each process to perform in order to maximize the total MetalExtraction, subject to the constraints that the total WaterUsage does not exceed MaxWater and the total PollutionProduction does not exceed MaxPollution."", ""keywords"": [""N.A.""], ""parameters"": {""MaxWater"": {""description"": ""Maximum units of water available"", ""shape"": []}, ""MaxPollution"": {""description"": ""Maximum units of pollution allowed"", ""shape"": []}, ""MetalExtraction"": {""description"": ""Amount of metal extracted per unit of process"", ""shape"": [""NumProcesses""]}, ""WaterUsage"": {""description"": ""Amount of water used per unit of process"", ""shape"": [""NumProcesses""]}, ""PollutionProduction"": {""description"": ""Amount of pollution produced per unit of process"", ""shape"": [""NumProcesses""]}}, ""variables"": {""ProcessUnit"": {""description"": ""The number of units for each process"", ""type"": ""continuous"", ""shape"": [""NumProcesses""]}}, ""constraints"": [{""description"": ""The total WaterUsage does not exceed MaxWater."", ""formulation"": ""\\sum_{i \\in \\text{NumProcesses}} \\text{WaterUsage}_i \\times \\text{ProcessUnit}_i \\leq \\text{MaxWater}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(WaterUsage[i] * ProcessUnit[i] for i in range(NumProcesses)) <= MaxWater)""}}, {""description"": ""The total PollutionProduction does not exceed MaxPollution."", ""formulation"": ""\\sum_{p=1}^{NumProcesses} PollutionProduction_p \\cdot ProcessUnit_p \\leq MaxPollution"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(PollutionProduction[p] * ProcessUnit[p] for p in range(NumProcesses)) <= MaxPollution)""}}], ""objective"": {""description"": ""Maximize the total MetalExtraction."", ""formulation"": ""Max \\sum_{i=1}^{\\text{NumProcesses}} MetalExtraction_i \\cdot ProcessUnit_i"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(MetalExtraction[i] * ProcessUnit[i] for i in range(NumProcesses)), GRB.MAXIMIZE)""}}}","{""MaxWater"": 1500, ""MaxPollution"": 1350, ""MetalExtraction"": [5, 9], ""WaterUsage"": [8, 6], ""PollutionProduction"": [3, 5]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Determine the number of each process to perform in order to maximize the total
MetalExtraction, subject to the constraints that the total WaterUsage does not
exceed MaxWater and the total PollutionProduction does not exceed MaxPollution.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/248/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter MaxWater @Def: Maximum units of water available @Shape: [] 
MaxWater = data['MaxWater']
# @Parameter MaxPollution @Def: Maximum units of pollution allowed @Shape: [] 
MaxPollution = data['MaxPollution']
# @Parameter MetalExtraction @Def: Amount of metal extracted per unit of process @Shape: ['NumProcesses'] 
MetalExtraction = data['MetalExtraction']
# @Parameter WaterUsage @Def: Amount of water used per unit of process @Shape: ['NumProcesses'] 
WaterUsage = data['WaterUsage']
# @Parameter PollutionProduction @Def: Amount of pollution produced per unit of process @Shape: ['NumProcesses'] 
PollutionProduction = data['PollutionProduction']

# Define the number of processes
NumProcesses = len(MetalExtraction)
    
# Variables 
# @Variable ProcessUnit @Def: The number of units for each process @Shape: ['NumProcesses'] 
ProcessUnit = model.addVars(NumProcesses, vtype=GRB.CONTINUOUS, name=""ProcessUnit"")
    
# Constraints 
# @Constraint Constr_1 @Def: The total WaterUsage does not exceed MaxWater.
model.addConstr(quicksum(WaterUsage[i] * ProcessUnit[i] for i in range(NumProcesses)) <= MaxWater)
# @Constraint Constr_2 @Def: The total PollutionProduction does not exceed MaxPollution.
model.addConstr(quicksum(PollutionProduction[i] * ProcessUnit[i] for i in range(NumProcesses)) <= MaxPollution)
    
# Objective 
# @Objective Objective @Def: Maximize the total MetalExtraction.
model.setObjective(quicksum(MetalExtraction[i] * ProcessUnit[i] for i in range(NumProcesses)), GRB.MAXIMIZE)
    
# Solve 
model.optimize()
    
# Extract solution 
solution = {}
variables = {}
objective = []
variables['ProcessUnit'] = {i: ProcessUnit[i].X for i in range(NumProcesses)}
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)"
"An airport can either install escalators or elevators. Escalators can transport 20 people every minute whereas elevators can transport 8 people every minute. Escalators take up 5 units of space while elevators take 2 units of space. The airport needs to have enough capacity to transport at least 400 people every minute. Additionally, there must be at least three times more escalators than elevators and at least 2 elevators must be used. How many of each type should the airport install to minimize the total units of space taken?","{""variables"": {""NumberEscalators"": 18.0, ""NumberElevators"": 5.0}, ""objective"": 100.0}","{""parametrized_description"": ""The airport can install escalators and elevators. Each escalator transports TransportRateEscalator people per minute and requires SpaceEscalator units of space. Each elevator transports TransportRateElevator people per minute and requires SpaceElevator units of space. The airport must have a total transport capacity of at least MinPeopleTransport people per minute. Additionally, the number of escalators must be at least RatioEscalatorsToElevators times the number of elevators, and at least MinElevators elevators must be installed. The objective is to minimize the total space used."", ""keywords"": [""N.A.""], ""parameters"": {""TransportRateEscalator"": {""description"": ""Transport rate of an escalator in people per minute"", ""shape"": []}, ""TransportRateElevator"": {""description"": ""Transport rate of an elevator in people per minute"", ""shape"": []}, ""SpaceEscalator"": {""description"": ""Space taken by an escalator in units"", ""shape"": []}, ""SpaceElevator"": {""description"": ""Space taken by an elevator in units"", ""shape"": []}, ""MinPeopleTransport"": {""description"": ""Minimum number of people to transport per minute"", ""shape"": []}, ""RatioEscalatorsToElevators"": {""description"": ""Minimum ratio of escalators to elevators"", ""shape"": []}, ""MinElevators"": {""description"": ""Minimum number of elevators to be installed"", ""shape"": []}}, ""variables"": {""NumberEscalators"": {""description"": ""The number of escalators to install"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberElevators"": {""description"": ""The number of elevators to install"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total transport capacity from escalators and elevators must be at least MinPeopleTransport people per minute."", ""formulation"": ""TransportRateEscalator \\times NumberEscalators + TransportRateElevator \\times NumberElevators \\geq MinPeopleTransport"", ""code"": {""gurobipy"": ""model.addConstr(TransportRateEscalator * NumberEscalators + TransportRateElevator * NumberElevators >= MinPeopleTransport)""}}, {""description"": ""The number of escalators must be at least RatioEscalatorsToElevators times the number of elevators."", ""formulation"": ""NumberEscalators \\geq RatioEscalatorsToElevators \\times NumberElevators"", ""code"": {""gurobipy"": ""model.addConstr(NumberEscalators >= RatioEscalatorsToElevators * NumberElevators)""}}, {""description"": ""At least MinElevators elevators must be installed."", ""formulation"": ""NumberElevators \\geq MinElevators"", ""code"": {""gurobipy"": ""model.addConstr(NumberElevators >= MinElevators)""}}], ""objective"": {""description"": ""The total space used is the sum of the spaces required for all escalators and elevators. The objective is to minimize the total space used."", ""formulation"": ""Min NumberEscalators \\times SpaceEscalator + NumberElevators \\times SpaceElevator"", ""code"": {""gurobipy"": ""model.setObjective(NumberEscalators * SpaceEscalator + NumberElevators * SpaceElevator, GRB.MINIMIZE)""}}}","{""TransportRateEscalator"": 20, ""TransportRateElevator"": 8, ""SpaceEscalator"": 5, ""SpaceElevator"": 2, ""MinPeopleTransport"": 400, ""RatioEscalatorsToElevators"": 3, ""MinElevators"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
The airport can install escalators and elevators. Each escalator transports
TransportRateEscalator people per minute and requires SpaceEscalator units of
space. Each elevator transports TransportRateElevator people per minute and
requires SpaceElevator units of space. The airport must have a total transport
capacity of at least MinPeopleTransport people per minute. Additionally, the
number of escalators must be at least RatioEscalatorsToElevators times the
number of elevators, and at least MinElevators elevators must be installed. The
objective is to minimize the total space used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/249/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TransportRateEscalator @Def: Transport rate of an escalator in people per minute @Shape: [] 
TransportRateEscalator = data['TransportRateEscalator']
# @Parameter TransportRateElevator @Def: Transport rate of an elevator in people per minute @Shape: [] 
TransportRateElevator = data['TransportRateElevator']
# @Parameter SpaceEscalator @Def: Space taken by an escalator in units @Shape: [] 
SpaceEscalator = data['SpaceEscalator']
# @Parameter SpaceElevator @Def: Space taken by an elevator in units @Shape: [] 
SpaceElevator = data['SpaceElevator']
# @Parameter MinPeopleTransport @Def: Minimum number of people to transport per minute @Shape: [] 
MinPeopleTransport = data['MinPeopleTransport']
# @Parameter RatioEscalatorsToElevators @Def: Minimum ratio of escalators to elevators @Shape: [] 
RatioEscalatorsToElevators = data['RatioEscalatorsToElevators']
# @Parameter MinElevators @Def: Minimum number of elevators to be installed @Shape: [] 
MinElevators = data['MinElevators']

# Variables 
# @Variable NumberEscalators @Def: The number of escalators to install @Shape: ['Integer'] 
NumberEscalators = model.addVar(vtype=GRB.INTEGER, name=""NumberEscalators"")
# @Variable NumberElevators @Def: The number of elevators to install @Shape: ['Integer'] 
NumberElevators = model.addVar(vtype=GRB.INTEGER, name=""NumberElevators"", lb=MinElevators)

# Constraints 
# @Constraint Constr_1 @Def: The total transport capacity from escalators and elevators must be at least MinPeopleTransport people per minute.
model.addConstr(TransportRateEscalator * NumberEscalators + TransportRateElevator * NumberElevators >= MinPeopleTransport)
# @Constraint Constr_2 @Def: The number of escalators must be at least RatioEscalatorsToElevators times the number of elevators.
model.addConstr(NumberEscalators >= RatioEscalatorsToElevators * NumberElevators)
# @Constraint Constr_3 @Def: At least MinElevators elevators must be installed.
model.addConstr(NumberElevators >= MinElevators)

# Objective 
# @Objective Objective @Def: The total space used is the sum of the spaces required for all escalators and elevators. The objective is to minimize the total space used.
model.setObjective(NumberEscalators * SpaceEscalator + NumberElevators * SpaceElevator, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberEscalators'] = NumberEscalators.x
variables['NumberElevators'] = NumberElevators.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A research group is making fabric and plastic using two methods, method A and method B. Method A produces 25 units of fabric and 14 units of plastic per hour. Method B produces 45 units of fabric and 25 units of plastic per hour. Method A requires 60 units of a special element while method B requires 65 units of the same special element. The research group has available 3500 units of the special element and must make at least 1400 units of fabric and 1000 units of plastic. How many of each method should be executed to minimize the total time needed?","{""variables"": {""OperationTime"": {""0"": 0.0, ""1"": 53.84615384615385}, ""TotalTime"": 0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A research group is producing NumProducts different products using NumMethods production methods. Each method has a ProductionRate for each product and consumes SpecialElementConsumption units of a special element per hour. The research group has TotalSpecialElement units of the special element available and must produce at least MinRequired units for each product. The objective is to minimize the total time needed."", ""keywords"": [""N.A.""], ""parameters"": {""NumMethods"": {""description"": ""The number of production methods available"", ""shape"": []}, ""NumProducts"": {""description"": ""The number of different products being produced"", ""shape"": []}, ""ProductionRate"": {""description"": ""Units of each product produced per hour by each method"", ""shape"": [""NumProducts"", ""NumMethods""]}, ""SpecialElementConsumption"": {""description"": ""Units of the special element required per hour by each method"", ""shape"": [""NumMethods""]}, ""TotalSpecialElement"": {""description"": ""Total units of the special element available"", ""shape"": []}, ""MinRequired"": {""description"": ""Minimum number of units required for each product"", ""shape"": [""NumProducts""]}}, ""variables"": {""OperationTime"": {""description"": ""The number of hours each production method is operated"", ""type"": ""continuous"", ""shape"": [""NumMethods""]}, ""TotalTime"": {""description"": ""The total time to produce all required products"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total consumption of the special element by all production methods cannot exceed TotalSpecialElement units."", ""formulation"": ""\\sum_{m=1}^{\\text{NumMethods}} \\text{SpecialElementConsumption}_m \\times \\text{OperationTime}_m \\leq \\text{TotalSpecialElement}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(SpecialElementConsumption[m] * OperationTime[m] for m in range(NumMethods)) <= TotalSpecialElement)""}}, {""description"": ""For each product, the total number of units produced by all production methods must be at least MinRequired units."", ""formulation"": ""\\sum_{m=1}^{NumMethods} ProductionRate_{p,m} \\cdot OperationTime_{m} \\geq MinRequired_{p} \\quad \\forall p \\in \\{1, \\dots, NumProducts\\}"", ""code"": {""gurobipy"": ""model.addConstrs((quicksum(ProductionRate[p][m] * OperationTime[m] for m in range(NumMethods)) >= MinRequired[p] for p in range(NumProducts)), name=\""MinRequiredProduction\"")""}}], ""objective"": {""description"": ""The objective is to minimize the total time needed to produce all required products while satisfying the resource and production constraints."", ""formulation"": ""Min \\text{TotalTime}"", ""code"": {""gurobipy"": ""model.setObjective(TotalTime, GRB.MINIMIZE)""}}}","{""NumMethods"": 2, ""NumProducts"": 2, ""ProductionRate"": [[25, 45], [14, 25]], ""SpecialElementConsumption"": [60, 65], ""TotalSpecialElement"": 3500, ""MinRequired"": [1400, 1000]}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A research group is producing NumProducts different products using NumMethods
production methods. Each method has a ProductionRate for each product and
consumes SpecialElementConsumption units of a special element per hour. The
research group has TotalSpecialElement units of the special element available
and must produce at least MinRequired units for each product. The objective is
to minimize the total time needed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/250/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumMethods @Def: The number of production methods available @Shape: [] 
NumMethods = data['NumMethods']
# @Parameter NumProducts @Def: The number of different products being produced @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter ProductionRate @Def: Units of each product produced per hour by each method @Shape: ['NumProducts', 'NumMethods'] 
ProductionRate = data['ProductionRate']
# @Parameter SpecialElementConsumption @Def: Units of the special element required per hour by each method @Shape: ['NumMethods'] 
SpecialElementConsumption = data['SpecialElementConsumption']
# @Parameter TotalSpecialElement @Def: Total units of the special element available @Shape: [] 
TotalSpecialElement = data['TotalSpecialElement']
# @Parameter MinRequired @Def: Minimum number of units required for each product @Shape: ['NumProducts'] 
MinRequired = data['MinRequired']

# Variables 
# @Variable OperationTime @Def: The number of hours each production method is operated @Shape: ['NumMethods'] 
OperationTime = model.addVars(NumMethods, vtype=GRB.CONTINUOUS, name=""OperationTime"")
# @Variable TotalTime @Def: The total time to produce all required products @Shape: [] 
TotalTime = model.addVar(vtype=GRB.CONTINUOUS, name=""TotalTime"")

# Constraints 
# @Constraint Constr_1 @Def: The total consumption of the special element by all production methods cannot exceed TotalSpecialElement units.
model.addConstr(quicksum(SpecialElementConsumption[m] * OperationTime[m] for m in range(NumMethods)) <= TotalSpecialElement)
# @Constraint Constr_2 @Def: For each product, the total number of units produced by all production methods must be at least MinRequired units.
model.addConstrs((quicksum(ProductionRate[p][m] * OperationTime[m] for m in range(NumMethods)) >= MinRequired[p] for p in range(NumProducts)), name=""MinRequiredProduction"")

# Objective 
# @Objective Objective @Def: The objective is to minimize the total time needed to produce all required products while satisfying the resource and production constraints.
model.setObjective(TotalTime, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['OperationTime'] = {m: OperationTime[m].x for m in range(NumMethods)}
variables['TotalTime'] = TotalTime.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A taxi company will purchase vehicles to rent to their drivers. They are interested in purchasing either motorcycles or sedans. A motorcycle can transport 30 people, produces 4 units of pollution, and earns the taxi company $100 per shift. A sedan can transport 70 people, produces 15 units of pollution and earns the company $225 per shift. Because not every customer is comfortable with a motorcycle, at most 25% of vehicles can be motorcycles. Additionally, the company has committed to producing less than 200 units of pollution. The company needs to transport at least 1200 people every shift. How many of each type of vehicle should be used to maximize the total earnings for the taxi company per shift?",{},"{""parametrized_description"": ""A taxi company selects quantities of NumVehicleTypes different vehicle types to maximize the total Earnings per shift, subject to the total Pollution being below PollutionCap, the total TransportCapacity being at least MinTransportCapacity, and each vehicle type not exceeding its MaxVehiclePercentage of the total number of vehicles."", ""keywords"": [""N.A.""], ""parameters"": {""NumVehicleTypes"": {""description"": ""Number of different vehicle types."", ""shape"": []}, ""TransportCapacity"": {""description"": ""The number of people each vehicle type can transport per shift."", ""shape"": [""NumVehicleTypes""]}, ""Pollution"": {""description"": ""The units of pollution each vehicle type produces per shift."", ""shape"": [""NumVehicleTypes""]}, ""Earnings"": {""description"": ""The earnings the company makes per shift from each vehicle type."", ""shape"": [""NumVehicleTypes""]}, ""MaxVehiclePercentage"": {""description"": ""The maximum proportion of the total number of vehicles that can be of each vehicle type."", ""shape"": [""NumVehicleTypes""]}, ""PollutionCap"": {""description"": ""The maximum total units of pollution allowed per shift."", ""shape"": []}, ""MinTransportCapacity"": {""description"": ""The minimum number of people that need to be transported per shift."", ""shape"": []}}, ""variables"": {""NumVehicles"": {""description"": ""The number of vehicles of each type used per shift"", ""type"": ""continuous"", ""shape"": [""NumVehicleTypes""]}}, ""constraints"": [{""description"": ""The total Pollution is below PollutionCap."", ""formulation"": ""\\sum_{i=1}^{NumVehicleTypes} Pollution_{i} \\cdot NumVehicles_{i} \\leq PollutionCap"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(Pollution[i] * NumVehicles[i] for i in range(NumVehicleTypes)) <= PollutionCap)""}}, {""description"": ""The total TransportCapacity is at least MinTransportCapacity."", ""formulation"": ""\\sum_{i=1}^{NumVehicleTypes} NumVehicles_i \\times TransportCapacity_i \\geq MinTransportCapacity"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(NumVehicles[i] * TransportCapacity[i] for i in range(NumVehicleTypes)) >= MinTransportCapacity)""}}, {""description"": ""Each vehicle type does not exceed its MaxVehiclePercentage of the total number of vehicles."", ""formulation"": ""NumVehicles_i \\leq MaxVehiclePercentage_i \\cdot \\sum_{j=1}^{NumVehicleTypes} NumVehicles_j, \\quad \\forall i \\in \\{1, \\dots, NumVehicleTypes\\}"", ""code"": {""gurobipy"": ""model.addConstrs(NumVehicles[i] <= MaxVehiclePercentage[i] * quicksum(NumVehicles[j] for j in range(NumVehicleTypes)) for i in range(NumVehicleTypes))""}}], ""objective"": {""description"": ""Maximize the total Earnings per shift."", ""formulation"": ""Max \\sum_{t=1}^{\\text{NumVehicleTypes}} \\text{Earnings}_t \\times \\text{NumVehicles}_t"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(Earnings[t] * NumVehicles[t] for t in range(NumVehicleTypes)), GRB.MAXIMIZE)""}}}","{""NumVehicleTypes"": 2, ""TransportCapacity"": [30, 70], ""Pollution"": [4, 15], ""Earnings"": [100, 225], ""MaxVehiclePercentage"": [0.25, 1.0], ""PollutionCap"": 200, ""MinTransportCapacity"": 1200}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A taxi company selects quantities of NumVehicleTypes different vehicle types to
maximize the total Earnings per shift, subject to the total Pollution being
below PollutionCap, the total TransportCapacity being at least
MinTransportCapacity, and each vehicle type not exceeding its
MaxVehiclePercentage of the total number of vehicles.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/251/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumVehicleTypes @Def: Number of different vehicle types. @Shape: [] 
NumVehicleTypes = data['NumVehicleTypes']
# @Parameter TransportCapacity @Def: The number of people each vehicle type can transport per shift. @Shape: ['NumVehicleTypes'] 
TransportCapacity = data['TransportCapacity']
# @Parameter Pollution @Def: The units of pollution each vehicle type produces per shift. @Shape: ['NumVehicleTypes'] 
Pollution = data['Pollution']
# @Parameter Earnings @Def: The earnings the company makes per shift from each vehicle type. @Shape: ['NumVehicleTypes'] 
Earnings = data['Earnings']
# @Parameter MaxVehiclePercentage @Def: The maximum proportion of the total number of vehicles that can be of each vehicle type. @Shape: ['NumVehicleTypes'] 
MaxVehiclePercentage = data['MaxVehiclePercentage']
# @Parameter PollutionCap @Def: The maximum total units of pollution allowed per shift. @Shape: [] 
PollutionCap = data['PollutionCap']
# @Parameter MinTransportCapacity @Def: The minimum number of people that need to be transported per shift. @Shape: [] 
MinTransportCapacity = data['MinTransportCapacity']

# Variables 
# @Variable NumVehicles @Def: The number of vehicles of each type used per shift @Shape: ['NumVehicleTypes'] 
NumVehicles = model.addVars(NumVehicleTypes, vtype=GRB.INTEGER, name=""NumVehicles"")

# Constraints 
# @Constraint Constr_1 @Def: The total Pollution is below PollutionCap.
model.addConstr(quicksum(Pollution[i] * NumVehicles[i] for i in range(NumVehicleTypes)) <= PollutionCap)
# @Constraint Constr_2 @Def: The total TransportCapacity is at least MinTransportCapacity.
model.addConstr(quicksum(NumVehicles[i] * TransportCapacity[i] for i in range(NumVehicleTypes)) >= MinTransportCapacity)
# @Constraint Constr_3 @Def: Each vehicle type does not exceed its MaxVehiclePercentage of the total number of vehicles.
model.addConstrs(NumVehicles[i] <= MaxVehiclePercentage[i] * quicksum(NumVehicles[j] for j in range(NumVehicleTypes)) for i in range(NumVehicleTypes))

# Objective 
# @Objective Objective @Def: Maximize the total Earnings per shift.
model.setObjective(quicksum(Earnings[t] * NumVehicles[t] for t in range(NumVehicleTypes)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumVehicles'] = model.getAttr(""X"", NumVehicles)
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Due to an accident, at least 550 locals must be moved across a lake. They can either be transported over the lake by a kayak or a motorboat. Kayaks can transport 4 people every trip and motorboats can transport 5 people every trip. Kayaks take 5 minutes per trip whereas motorboats take 3 minutes per trip. Due to the limited number of motorboats available to the locals, there can be at most 25 motorboat trips and at least 75% of the trips should be by kayak. How many of each transportation method should be used to minimize the total amount of time needed to transport all the locals?","{""variables"": {""KayakTrips"": 107.0, ""MotorboatTrips"": 25.0}, ""objective"": 610.0}","{""parametrized_description"": ""At least MinLocals locals must be transported across a lake using kayaks and motorboats. Kayaks can transport KayakCapacity people per trip and take KayakTime minutes per trip, while motorboats can transport MotorboatCapacity people per trip and take MotorboatTime minutes per trip. The number of motorboat trips is limited to at most MaxMotorboatTrips, and at least MinKayakTripPercentage of the total trips must be by kayak. The objective is to minimize the total transportation time."", ""keywords"": [""N.A.""], ""parameters"": {""MinLocals"": {""description"": ""Minimum number of locals to transport"", ""shape"": []}, ""KayakCapacity"": {""description"": ""Number of people a kayak can transport per trip"", ""shape"": []}, ""MotorboatCapacity"": {""description"": ""Number of people a motorboat can transport per trip"", ""shape"": []}, ""KayakTime"": {""description"": ""Time in minutes a kayak takes per trip"", ""shape"": []}, ""MotorboatTime"": {""description"": ""Time in minutes a motorboat takes per trip"", ""shape"": []}, ""MaxMotorboatTrips"": {""description"": ""Maximum number of motorboat trips allowed"", ""shape"": []}, ""MinKayakTripPercentage"": {""description"": ""Minimum percentage of trips that must be by kayak"", ""shape"": []}}, ""variables"": {""KayakTrips"": {""description"": ""The number of kayak trips"", ""type"": ""continuous"", ""shape"": [""integer""]}, ""MotorboatTrips"": {""description"": ""The number of motorboat trips"", ""type"": ""continuous"", ""shape"": [""integer""]}}, ""constraints"": [{""description"": ""Ensure that at least MinLocals individuals are transported across the lake using kayaks and motorboats."", ""formulation"": ""KayakCapacity \\times KayakTrips + MotorboatCapacity \\times MotorboatTrips \\geq MinLocals"", ""code"": {""gurobipy"": ""model.addConstr(KayakCapacity * KayakTrips + MotorboatCapacity * MotorboatTrips >= MinLocals)""}}, {""description"": ""The number of motorboat trips must not exceed MaxMotorboatTrips."", ""formulation"": ""MotorboatTrips \\leq MaxMotorboatTrips"", ""code"": {""gurobipy"": ""model.addConstr(MotorboatTrips <= MaxMotorboatTrips)""}}, {""description"": ""At least MinKayakTripPercentage of the total trips must be conducted by kayak."", ""formulation"": ""KayakTrips \\geq MinKayakTripPercentage \\times \\left(KayakTrips + MotorboatTrips\\right)"", ""code"": {""gurobipy"": ""model.addConstr(KayakTrips >= MinKayakTripPercentage * (KayakTrips + MotorboatTrips))""}}], ""objective"": {""description"": ""Minimize the total transportation time, which is the sum of the time taken by all kayak trips and motorboat trips."", ""formulation"": ""Min \\left( KayakTime \\times KayakTrips + MotorboatTime \\times MotorboatTrips \\right)"", ""code"": {""gurobipy"": ""model.setObjective(KayakTime * KayakTrips + MotorboatTime * MotorboatTrips, GRB.MINIMIZE)""}}}","{""MinLocals"": 550, ""KayakCapacity"": 4, ""MotorboatCapacity"": 5, ""KayakTime"": 5, ""MotorboatTime"": 3, ""MaxMotorboatTrips"": 25, ""MinKayakTripPercentage"": 0.75}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
At least MinLocals locals must be transported across a lake using kayaks and
motorboats. Kayaks can transport KayakCapacity people per trip and take
KayakTime minutes per trip, while motorboats can transport MotorboatCapacity
people per trip and take MotorboatTime minutes per trip. The number of motorboat
trips is limited to at most MaxMotorboatTrips, and at least
MinKayakTripPercentage of the total trips must be by kayak. The objective is to
minimize the total transportation time.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/252/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter MinLocals @Def: Minimum number of locals to transport @Shape: [] 
MinLocals = data['MinLocals']
# @Parameter KayakCapacity @Def: Number of people a kayak can transport per trip @Shape: [] 
KayakCapacity = data['KayakCapacity']
# @Parameter MotorboatCapacity @Def: Number of people a motorboat can transport per trip @Shape: [] 
MotorboatCapacity = data['MotorboatCapacity']
# @Parameter KayakTime @Def: Time in minutes a kayak takes per trip @Shape: [] 
KayakTime = data['KayakTime']
# @Parameter MotorboatTime @Def: Time in minutes a motorboat takes per trip @Shape: [] 
MotorboatTime = data['MotorboatTime']
# @Parameter MaxMotorboatTrips @Def: Maximum number of motorboat trips allowed @Shape: [] 
MaxMotorboatTrips = data['MaxMotorboatTrips']
# @Parameter MinKayakTripPercentage @Def: Minimum percentage of trips that must be by kayak @Shape: [] 
MinKayakTripPercentage = data['MinKayakTripPercentage']

# Variables 
# @Variable KayakTrips @Def: The number of kayak trips @Shape: ['integer'] 
KayakTrips = model.addVar(vtype=GRB.INTEGER, name=""KayakTrips"")
# @Variable MotorboatTrips @Def: The number of motorboat trips @Shape: ['integer'] 
MotorboatTrips = model.addVar(vtype=GRB.INTEGER, lb=0, ub=MaxMotorboatTrips, name=""MotorboatTrips"")

# Constraints 
# @Constraint Constr_1 @Def: Ensure that at least MinLocals individuals are transported across the lake using kayaks and motorboats.
model.addConstr(KayakCapacity * KayakTrips + MotorboatCapacity * MotorboatTrips >= MinLocals)
# @Constraint Constr_2 @Def: The number of motorboat trips must not exceed MaxMotorboatTrips.
model.addConstr(MotorboatTrips <= MaxMotorboatTrips)
# @Constraint Constr_3 @Def: At least MinKayakTripPercentage of the total trips must be conducted by kayak.
model.addConstr(KayakTrips >= MinKayakTripPercentage * (KayakTrips + MotorboatTrips))

# Objective 
# @Objective Objective @Def: Minimize the total transportation time, which is the sum of the time taken by all kayak trips and motorboat trips.
model.setObjective(KayakTime * KayakTrips + MotorboatTime * MotorboatTrips, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['KayakTrips'] = KayakTrips.x
variables['MotorboatTrips'] = MotorboatTrips.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A drop-in clinic is performing a test either through the ear or blood. A blood test takes 30 minutes to perform while an ear test takes 5 minutes to perform. Since the blood test is more accurate, at least three times as many blood tests should be performed as ear tests. However, at least 12 ear tests must be administered. If the drop-in clinic operates for 7525 minutes, maximize the number of tests that can be performed.","{""variables"": {""NumberOfBloodTests"": 237.0, ""NumberOfEarTests"": 79.0}, ""objective"": 316.0}","{""parametrized_description"": ""A drop-in clinic is performing tests either through the ear or blood. Each blood test takes TimePerBloodTest minutes to perform while each ear test takes TimePerEarTest minutes. Since the blood test is more accurate, at least BloodToEarTestRatio times as many blood tests should be performed as ear tests. However, at least MinEarTests ear tests must be administered. If the drop-in clinic operates for TotalOperatingTime minutes, maximize the number of tests that can be performed."", ""keywords"": [""N.A.""], ""parameters"": {""TimePerBloodTest"": {""description"": ""Time required to perform a blood test in minutes"", ""shape"": []}, ""TimePerEarTest"": {""description"": ""Time required to perform an ear test in minutes"", ""shape"": []}, ""BloodToEarTestRatio"": {""description"": ""Minimum ratio of blood tests to ear tests"", ""shape"": []}, ""MinEarTests"": {""description"": ""Minimum number of ear tests to be administered"", ""shape"": []}, ""TotalOperatingTime"": {""description"": ""Total operating time of the clinic in minutes"", ""shape"": []}}, ""variables"": {""NumberOfBloodTests"": {""description"": ""The number of blood tests to be administered"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfEarTests"": {""description"": ""The number of ear tests to be administered"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total time required for blood tests plus ear tests does not exceed TotalOperatingTime minutes."", ""formulation"": ""TimePerBloodTest \\times NumberOfBloodTests + TimePerEarTest \\times NumberOfEarTests \\leq TotalOperatingTime"", ""code"": {""gurobipy"": ""model.addConstr(TimePerBloodTest * NumberOfBloodTests + TimePerEarTest * NumberOfEarTests <= TotalOperatingTime)""}}, {""description"": ""The number of blood tests is at least BloodToEarTestRatio times the number of ear tests."", ""formulation"": ""NumberOfBloodTests \\geq BloodToEarTestRatio \\times NumberOfEarTests"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfBloodTests >= BloodToEarTestRatio * NumberOfEarTests)""}}, {""description"": ""At least MinEarTests ear tests must be administered."", ""formulation"": ""NumberOfEarTests \\geq MinEarTests"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfEarTests >= MinEarTests)""}}], ""objective"": {""description"": ""Maximize the total number of tests performed (blood tests plus ear tests)."", ""formulation"": ""Max \\left( NumberOfBloodTests + NumberOfEarTests \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfBloodTests + NumberOfEarTests, GRB.MAXIMIZE)""}}}","{""TimePerBloodTest"": 30, ""TimePerEarTest"": 5, ""BloodToEarTestRatio"": 3, ""MinEarTests"": 12, ""TotalOperatingTime"": 7525}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A drop-in clinic is performing tests either through the ear or blood. Each blood
test takes TimePerBloodTest minutes to perform while each ear test takes
TimePerEarTest minutes. Since the blood test is more accurate, at least
BloodToEarTestRatio times as many blood tests should be performed as ear tests.
However, at least MinEarTests ear tests must be administered. If the drop-in
clinic operates for TotalOperatingTime minutes, maximize the number of tests
that can be performed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/253/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TimePerBloodTest @Def: Time required to perform a blood test in minutes @Shape: [] 
TimePerBloodTest = data['TimePerBloodTest']
# @Parameter TimePerEarTest @Def: Time required to perform an ear test in minutes @Shape: [] 
TimePerEarTest = data['TimePerEarTest']
# @Parameter BloodToEarTestRatio @Def: Minimum ratio of blood tests to ear tests @Shape: [] 
BloodToEarTestRatio = data['BloodToEarTestRatio']
# @Parameter MinEarTests @Def: Minimum number of ear tests to be administered @Shape: [] 
MinEarTests = data['MinEarTests']
# @Parameter TotalOperatingTime @Def: Total operating time of the clinic in minutes @Shape: [] 
TotalOperatingTime = data['TotalOperatingTime']

# Variables 
# @Variable NumberOfBloodTests @Def: The number of blood tests to be administered @Shape: [] 
NumberOfBloodTests = model.addVar(vtype=GRB.INTEGER, name=""NumberOfBloodTests"")
# @Variable NumberOfEarTests @Def: The number of ear tests to be administered @Shape: [] 
NumberOfEarTests = model.addVar(vtype=GRB.INTEGER, name=""NumberOfEarTests"")

# Constraints 
# @Constraint Constr_1 @Def: The total time required for blood tests plus ear tests does not exceed TotalOperatingTime minutes.
model.addConstr(TimePerBloodTest * NumberOfBloodTests + TimePerEarTest * NumberOfEarTests <= TotalOperatingTime)
# @Constraint Constr_2 @Def: The number of blood tests is at least BloodToEarTestRatio times the number of ear tests.
model.addConstr(NumberOfBloodTests >= BloodToEarTestRatio * NumberOfEarTests)
# @Constraint Constr_3 @Def: At least MinEarTests ear tests must be administered.
model.addConstr(NumberOfEarTests >= MinEarTests)

# Objective 
# @Objective Objective @Def: Maximize the total number of tests performed (blood tests plus ear tests).
model.setObjective(NumberOfBloodTests + NumberOfEarTests, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfBloodTests'] = NumberOfBloodTests.x
variables['NumberOfEarTests'] = NumberOfEarTests.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A researcher is outsourcing annotations and has two options: a specialized third-party or a common third-party annotation company. The specialized company can annotate at a rate of 60 images per hour whereas the common company can annotate at a rate of 40 images per hour. However, the specialized company charges $100 per hour and the common company charges $72 per hour. The researcher has deadlines to meet and must complete a dataset of at least 10,000 images. They also have some special images that only the specialized company can annotate. Therefore, at least a third of work must be allocated to the specialized company. How should the researcher distribute the annotations to the two companies to minimize the cost of annotating the whole dataset?","{""variables"": {""SpecializedHours"": 166.66666666666666, ""CommonHours"": 0.0}, ""objective"": 16666.666666666664}","{""parametrized_description"": ""A researcher must annotate at least MinTotalImages images by distributing the work between a specialized company and a common company. The specialized company annotates at a rate of SpecializedAnnotRate images per hour and charges SpecializedCostPerHour per hour. The common company annotates at a rate of CommonAnnotRate images per hour and charges CommonCostPerHour per hour. At least MinSpecializedFraction of the work must be allocated to the specialized company. The objective is to minimize the total annotation cost."", ""keywords"": [""N.A.""], ""parameters"": {""SpecializedAnnotRate"": {""description"": ""Annotation rate of the specialized company (images per hour)"", ""shape"": []}, ""CommonAnnotRate"": {""description"": ""Annotation rate of the common company (images per hour)"", ""shape"": []}, ""SpecializedCostPerHour"": {""description"": ""Cost per hour of the specialized company"", ""shape"": []}, ""CommonCostPerHour"": {""description"": ""Cost per hour of the common company"", ""shape"": []}, ""MinTotalImages"": {""description"": ""Minimum number of images to annotate"", ""shape"": []}, ""MinSpecializedFraction"": {""description"": ""Minimum fraction of work allocated to the specialized company"", ""shape"": []}}, ""variables"": {""SpecializedHours"": {""description"": ""The number of hours the specialized company works"", ""type"": ""continuous"", ""shape"": []}, ""CommonHours"": {""description"": ""The number of hours the common company works"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total number of images annotated by the specialized company and the common company must be at least MinTotalImages."", ""formulation"": ""SpecializedAnnotRate \\times SpecializedHours + CommonAnnotRate \\times CommonHours \\geq MinTotalImages"", ""code"": {""gurobipy"": ""model.addConstr(SpecializedAnnotRate * SpecializedHours + CommonAnnotRate * CommonHours >= MinTotalImages)""}}, {""description"": ""The number of images annotated by the specialized company must be at least MinSpecializedFraction of the total number of annotated images."", ""formulation"": ""SpecializedAnnotRate \\times SpecializedHours \\geq MinSpecializedFraction \\times \\left( SpecializedAnnotRate \\times SpecializedHours + CommonAnnotRate \\times CommonHours \\right )"", ""code"": {""gurobipy"": ""model.addConstr(SpecializedAnnotRate * SpecializedHours >= MinSpecializedFraction * (SpecializedAnnotRate * SpecializedHours + CommonAnnotRate * CommonHours))""}}], ""objective"": {""description"": ""Minimize the total annotation cost, which is the sum of the costs of the specialized and common companies."", ""formulation"": ""Min \\ SpecializedCostPerHour \\cdot SpecializedHours + CommonCostPerHour \\cdot CommonHours"", ""code"": {""gurobipy"": ""model.setObjective(SpecializedCostPerHour * SpecializedHours + CommonCostPerHour * CommonHours, GRB.MINIMIZE)""}}}","{""SpecializedAnnotRate"": 60, ""CommonAnnotRate"": 40, ""SpecializedCostPerHour"": 100, ""CommonCostPerHour"": 72, ""MinTotalImages"": 10000, ""MinSpecializedFraction"": 0.3333333333333333}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A researcher must annotate at least MinTotalImages images by distributing the
work between a specialized company and a common company. The specialized company
annotates at a rate of SpecializedAnnotRate images per hour and charges
SpecializedCostPerHour per hour. The common company annotates at a rate of
CommonAnnotRate images per hour and charges CommonCostPerHour per hour. At least
MinSpecializedFraction of the work must be allocated to the specialized company.
The objective is to minimize the total annotation cost.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/254/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SpecializedAnnotRate @Def: Annotation rate of the specialized company (images per hour) @Shape: [] 
SpecializedAnnotRate = data['SpecializedAnnotRate']
# @Parameter CommonAnnotRate @Def: Annotation rate of the common company (images per hour) @Shape: [] 
CommonAnnotRate = data['CommonAnnotRate']
# @Parameter SpecializedCostPerHour @Def: Cost per hour of the specialized company @Shape: [] 
SpecializedCostPerHour = data['SpecializedCostPerHour']
# @Parameter CommonCostPerHour @Def: Cost per hour of the common company @Shape: [] 
CommonCostPerHour = data['CommonCostPerHour']
# @Parameter MinTotalImages @Def: Minimum number of images to annotate @Shape: [] 
MinTotalImages = data['MinTotalImages']
# @Parameter MinSpecializedFraction @Def: Minimum fraction of work allocated to the specialized company @Shape: [] 
MinSpecializedFraction = data['MinSpecializedFraction']

# Variables 
# @Variable SpecializedHours @Def: The number of hours the specialized company works @Shape: [] 
SpecializedHours = model.addVar(vtype=GRB.CONTINUOUS, name=""SpecializedHours"")
# @Variable CommonHours @Def: The number of hours the common company works @Shape: [] 
CommonHours = model.addVar(vtype=GRB.CONTINUOUS, name=""CommonHours"")

# Constraints 
# @Constraint Constr_1 @Def: The total number of images annotated by the specialized company and the common company must be at least MinTotalImages.
model.addConstr(SpecializedAnnotRate * SpecializedHours + CommonAnnotRate * CommonHours >= MinTotalImages)
# @Constraint Constr_2 @Def: The number of images annotated by the specialized company must be at least MinSpecializedFraction of the total number of annotated images.
model.addConstr(SpecializedAnnotRate * SpecializedHours >= MinSpecializedFraction * (SpecializedAnnotRate * SpecializedHours + CommonAnnotRate * CommonHours))

# Objective 
# @Objective Objective @Def: Minimize the total annotation cost, which is the sum of the costs of the specialized and common companies.
model.setObjective(SpecializedCostPerHour * SpecializedHours + CommonCostPerHour * CommonHours, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['SpecializedHours'] = SpecializedHours.x
variables['CommonHours'] = CommonHours.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A golf course is hosting an event and can transport guests using either golf carts or pull carts. A golf cart can take 4 guests while a pull cart can take 1 guest. Since golf carts take up a lot of space, at most 60% of carts can be golf carts. If the golf course needs to transport at least 80 guests, how many of each cart should be used to minimize the total number of carts needed?","{""variables"": {""NumGolfCarts"": 17.0, ""NumPullCarts"": 12.0}, ""objective"": 29.0}","{""parametrized_description"": ""A venue needs to transport guests using two types of carts: golf carts and pull carts. Each golf cart has a capacity of GolfCartCapacity guests, and each pull cart has a capacity of PullCartCapacity guests. Due to space constraints, no more than MaxGolfCartPercentage of the total carts can be golf carts. The venue must transport at least MinGuests guests. The goal is to determine the number of golf carts and pull carts to use in order to minimize the total number of carts required."", ""keywords"": [""N.A.""], ""parameters"": {""GolfCartCapacity"": {""description"": ""Capacity of a golf cart"", ""shape"": []}, ""PullCartCapacity"": {""description"": ""Capacity of a pull cart"", ""shape"": []}, ""MaxGolfCartPercentage"": {""description"": ""Maximum percentage of carts that can be golf carts"", ""shape"": []}, ""MinGuests"": {""description"": ""Minimum number of guests to transport"", ""shape"": []}}, ""variables"": {""NumGolfCarts"": {""description"": ""The number of golf carts"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumPullCarts"": {""description"": ""The number of pull carts"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""Each golf cart can transport GolfCartCapacity guests and each pull cart can transport PullCartCapacity guests. The total number of guests transported must be at least MinGuests."", ""formulation"": ""GolfCartCapacity \\times NumGolfCarts + PullCartCapacity \\times NumPullCarts \\geq MinGuests"", ""code"": {""gurobipy"": ""model.addConstr(GolfCartCapacity * NumGolfCarts + PullCartCapacity * NumPullCarts >= MinGuests)""}}, {""description"": ""No more than MaxGolfCartPercentage of the total number of carts can be golf carts."", ""formulation"": ""NumGolfCarts \\leq MaxGolfCartPercentage \\times (NumGolfCarts + NumPullCarts)"", ""code"": {""gurobipy"": ""model.addConstr(NumGolfCarts <= MaxGolfCartPercentage * (NumGolfCarts + NumPullCarts))""}}], ""objective"": {""description"": ""Minimize the total number of carts required."", ""formulation"": ""Min\\ NumGolfCarts + NumPullCarts"", ""code"": {""gurobipy"": ""model.setObjective(NumGolfCarts + NumPullCarts, GRB.MINIMIZE)""}}}","{""GolfCartCapacity"": 4, ""PullCartCapacity"": 1, ""MaxGolfCartPercentage"": 0.6, ""MinGuests"": 80}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A venue needs to transport guests using two types of carts: golf carts and pull
carts. Each golf cart has a capacity of GolfCartCapacity guests, and each pull
cart has a capacity of PullCartCapacity guests. Due to space constraints, no
more than MaxGolfCartPercentage of the total carts can be golf carts. The venue
must transport at least MinGuests guests. The goal is to determine the number of
golf carts and pull carts to use in order to minimize the total number of carts
required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/255/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter GolfCartCapacity @Def: Capacity of a golf cart @Shape: [] 
GolfCartCapacity = data['GolfCartCapacity']
# @Parameter PullCartCapacity @Def: Capacity of a pull cart @Shape: [] 
PullCartCapacity = data['PullCartCapacity']
# @Parameter MaxGolfCartPercentage @Def: Maximum percentage of carts that can be golf carts @Shape: [] 
MaxGolfCartPercentage = data['MaxGolfCartPercentage']
# @Parameter MinGuests @Def: Minimum number of guests to transport @Shape: [] 
MinGuests = data['MinGuests']

# Variables 
# @Variable NumGolfCarts @Def: The number of golf carts @Shape: ['Integer'] 
NumGolfCarts = model.addVar(vtype=GRB.INTEGER, name=""NumGolfCarts"")
# @Variable NumPullCarts @Def: The number of pull carts @Shape: ['Integer'] 
NumPullCarts = model.addVar(vtype=GRB.INTEGER, name=""NumPullCarts"")

# Constraints 
# @Constraint Constr_1 @Def: Each golf cart can transport GolfCartCapacity guests and each pull cart can transport PullCartCapacity guests. The total number of guests transported must be at least MinGuests.
model.addConstr(GolfCartCapacity * NumGolfCarts + PullCartCapacity * NumPullCarts >= MinGuests)
# @Constraint Constr_2 @Def: No more than MaxGolfCartPercentage of the total number of carts can be golf carts.
model.addConstr(NumGolfCarts <= MaxGolfCartPercentage * (NumGolfCarts + NumPullCarts))

# Objective 
# @Objective Objective @Def: Minimize the total number of carts required.
model.setObjective(NumGolfCarts + NumPullCarts, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumGolfCarts'] = NumGolfCarts.x
variables['NumPullCarts'] = NumPullCarts.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A smoothie shop has a promotion for their two smoothies; an acai berry smoothie and a banana chocolate smoothie. It takes 7 units of acai berries and 3 units of water to make the acai berry smoothie. It takes 6 units of banana chocolate and 4 units of water to make the banana chocolate smoothie. Banana chocolate smoothies are more popular and thus the number of banana chocolate smoothies made must be more than the number of acai berry smoothies made. However, the acai berry smoothies have a loyal customer base, and at least 35% of the smoothies made must be acai berry smoothies. If the smoothie shop has 3500 units of acai berries and 3200 units of banana chocolate, to reduce the total amount of water, how many of each smoothie type should be made?","{""variables"": {""AcaiSmoothies"": 0.0, ""BananaSmoothies"": 0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A smoothie shop produces AcaiSmoothies and BananaSmoothies. Each AcaiSmoothie requires AcaiBerriesPerAcaiSmoothie units of acai berries and WaterPerAcaiSmoothie units of water. Each BananaSmoothie requires BananaChocolatePerBananaSmoothie units of banana chocolate and WaterPerBananaSmoothie units of water. The number of BananaSmoothies produced must be greater than the number of AcaiSmoothies produced. At least MinAcaiProportion proportion of the total smoothies made must be AcaiSmoothies. The shop has AcaiBerriesAvailable units of acai berries and BananaChocolateAvailable units of banana chocolate available. The objective is to minimize the total amount of water used."", ""keywords"": [""N.A.""], ""parameters"": {""AcaiBerriesAvailable"": {""description"": ""Total units of acai berries available"", ""shape"": []}, ""BananaChocolateAvailable"": {""description"": ""Total units of banana chocolate available"", ""shape"": []}, ""AcaiBerriesPerAcaiSmoothie"": {""description"": ""Units of acai berries required per acai berry smoothie"", ""shape"": []}, ""WaterPerAcaiSmoothie"": {""description"": ""Units of water required per acai berry smoothie"", ""shape"": []}, ""BananaChocolatePerBananaSmoothie"": {""description"": ""Units of banana chocolate required per banana chocolate smoothie"", ""shape"": []}, ""WaterPerBananaSmoothie"": {""description"": ""Units of water required per banana chocolate smoothie"", ""shape"": []}, ""MinAcaiProportion"": {""description"": ""Minimum proportion of smoothies that must be acai berry smoothies"", ""shape"": []}}, ""variables"": {""AcaiSmoothies"": {""description"": ""The number of AcaiSmoothies produced"", ""type"": ""continuous"", ""shape"": []}, ""BananaSmoothies"": {""description"": ""The number of BananaSmoothies produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total units of acai berries used for AcaiSmoothies cannot exceed AcaiBerriesAvailable."", ""formulation"": ""AcaiBerriesPerAcaiSmoothie \\times AcaiSmoothies \\leq AcaiBerriesAvailable"", ""code"": {""gurobipy"": ""model.addConstr(AcaiBerriesPerAcaiSmoothie * AcaiSmoothies <= AcaiBerriesAvailable)""}}, {""description"": ""The total units of banana chocolate used for BananaSmoothies cannot exceed BananaChocolateAvailable."", ""formulation"": ""BananaChocolatePerBananaSmoothie \\times BananaSmoothies \\leq BananaChocolateAvailable"", ""code"": {""gurobipy"": ""model.addConstr(BananaChocolatePerBananaSmoothie * BananaSmoothies <= BananaChocolateAvailable)""}}, {""description"": ""The number of BananaSmoothies produced must be greater than the number of AcaiSmoothies produced."", ""formulation"": ""BananaSmoothies - AcaiSmoothies \\geq 0"", ""code"": {""gurobipy"": ""model.addConstr(BananaSmoothies - AcaiSmoothies >= 0)""}}, {""description"": ""At least MinAcaiProportion proportion of the total smoothies made must be AcaiSmoothies."", ""formulation"": ""AcaiSmoothies \\geq MinAcaiProportion \\left( AcaiSmoothies + BananaSmoothies \\right)"", ""code"": {""gurobipy"": ""model.addConstr(AcaiSmoothies >= MinAcaiProportion * (AcaiSmoothies + BananaSmoothies))""}}], ""objective"": {""description"": ""Minimize the total amount of water used, which is the sum of the water used by AcaiSmoothies and BananaSmoothies."", ""formulation"": ""Min \\left( WaterPerAcaiSmoothie \\times AcaiSmoothies + WaterPerBananaSmoothie \\times BananaSmoothies \\right)"", ""code"": {""gurobipy"": ""model.setObjective(WaterPerAcaiSmoothie * AcaiSmoothies + WaterPerBananaSmoothie * BananaSmoothies, GRB.MINIMIZE)""}}}","{""AcaiBerriesAvailable"": 3500, ""BananaChocolateAvailable"": 3200, ""AcaiBerriesPerAcaiSmoothie"": 7, ""WaterPerAcaiSmoothie"": 3, ""BananaChocolatePerBananaSmoothie"": 6, ""WaterPerBananaSmoothie"": 4, ""MinAcaiProportion"": 0.35}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A smoothie shop produces AcaiSmoothies and BananaSmoothies. Each AcaiSmoothie
requires AcaiBerriesPerAcaiSmoothie units of acai berries and
WaterPerAcaiSmoothie units of water. Each BananaSmoothie requires
BananaChocolatePerBananaSmoothie units of banana chocolate and
WaterPerBananaSmoothie units of water. The number of BananaSmoothies produced
must be greater than the number of AcaiSmoothies produced. At least
MinAcaiProportion proportion of the total smoothies made must be AcaiSmoothies.
The shop has AcaiBerriesAvailable units of acai berries and
BananaChocolateAvailable units of banana chocolate available. The objective is
to minimize the total amount of water used.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/256/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter AcaiBerriesAvailable @Def: Total units of acai berries available @Shape: [] 
AcaiBerriesAvailable = data['AcaiBerriesAvailable']
# @Parameter BananaChocolateAvailable @Def: Total units of banana chocolate available @Shape: [] 
BananaChocolateAvailable = data['BananaChocolateAvailable']
# @Parameter AcaiBerriesPerAcaiSmoothie @Def: Units of acai berries required per acai berry smoothie @Shape: [] 
AcaiBerriesPerAcaiSmoothie = data['AcaiBerriesPerAcaiSmoothie']
# @Parameter WaterPerAcaiSmoothie @Def: Units of water required per acai berry smoothie @Shape: [] 
WaterPerAcaiSmoothie = data['WaterPerAcaiSmoothie']
# @Parameter BananaChocolatePerBananaSmoothie @Def: Units of banana chocolate required per banana chocolate smoothie @Shape: [] 
BananaChocolatePerBananaSmoothie = data['BananaChocolatePerBananaSmoothie']
# @Parameter WaterPerBananaSmoothie @Def: Units of water required per banana chocolate smoothie @Shape: [] 
WaterPerBananaSmoothie = data['WaterPerBananaSmoothie']
# @Parameter MinAcaiProportion @Def: Minimum proportion of smoothies that must be acai berry smoothies @Shape: [] 
MinAcaiProportion = data['MinAcaiProportion']

# Variables 
# @Variable AcaiSmoothies @Def: The number of AcaiSmoothies produced @Shape: [] 
AcaiSmoothies = model.addVar(vtype=GRB.CONTINUOUS, name=""AcaiSmoothies"")
# @Variable BananaSmoothies @Def: The number of BananaSmoothies produced @Shape: [] 
BananaSmoothies = model.addVar(vtype=GRB.CONTINUOUS, name=""BananaSmoothies"")

# Constraints 
# @Constraint Constr_1 @Def: The total units of acai berries used for AcaiSmoothies cannot exceed AcaiBerriesAvailable.
model.addConstr(AcaiBerriesPerAcaiSmoothie * AcaiSmoothies <= AcaiBerriesAvailable)
# @Constraint Constr_2 @Def: The total units of banana chocolate used for BananaSmoothies cannot exceed BananaChocolateAvailable.
model.addConstr(BananaChocolatePerBananaSmoothie * BananaSmoothies <= BananaChocolateAvailable)
# @Constraint Constr_3 @Def: The number of BananaSmoothies produced must be greater than the number of AcaiSmoothies produced.
model.addConstr(BananaSmoothies - AcaiSmoothies >= 0)
# @Constraint Constr_4 @Def: At least MinAcaiProportion proportion of the total smoothies made must be AcaiSmoothies.
model.addConstr(AcaiSmoothies >= MinAcaiProportion * (AcaiSmoothies + BananaSmoothies))

# Objective 
# @Objective Objective @Def: Minimize the total amount of water used, which is the sum of the water used by AcaiSmoothies and BananaSmoothies.
model.setObjective(WaterPerAcaiSmoothie * AcaiSmoothies + WaterPerBananaSmoothie * BananaSmoothies, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['AcaiSmoothies'] = AcaiSmoothies.x
variables['BananaSmoothies'] = BananaSmoothies.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A handmade sports equipment manufacturing company makes basketballs and footballs. Basketballs require 5 units of materials and 1 hour to make whereas footballs require 3 units of materials and 2 hours to make. The manufacturing company has available 1500 units of materials and their workers working at max capacity can work for at most 750 hours. Since basketballs sell better, there must be at least three times as many basketballs as footballs but the manufacturing company would like at least 50 footballs. How many of each should the manufacturing company make to maximize the total number of sports equipment produced?","{""variables"": {""ProductionQuantity"": {""0"": 107.14285714285714, ""1"": 321.42857142857144}, ""ProductionQuantityBasketballs"": 150.0, ""ProductionQuantityFootballs"": 50.0}, ""objective"": 428.57142857142856}","{""parametrized_description"": ""A manufacturing company produces NumProducts different types of sports equipment. Each product requires MaterialRequirement units of materials and TimeRequirement hours to produce. The company has a total of TotalMaterialsAvailable units of materials and TotalLaborHoursAvailable labor hours available. The production must ensure that the number of basketballs is at least MinBasketballToFootballRatio times the number of footballs and that at least MinimumFootballs footballs are produced. The objective is to maximize the total number of sports equipment produced."", ""keywords"": [""N.A.""], ""parameters"": {""NumProducts"": {""description"": ""Number of different sports equipment produced"", ""shape"": []}, ""MaterialRequirement"": {""description"": ""Amount of materials required to produce one unit of each sports equipment"", ""shape"": [""NumProducts""]}, ""TimeRequirement"": {""description"": ""Amount of labor hours required to produce one unit of each sports equipment"", ""shape"": [""NumProducts""]}, ""TotalMaterialsAvailable"": {""description"": ""Total units of materials available for production"", ""shape"": []}, ""TotalLaborHoursAvailable"": {""description"": ""Total labor hours available for production"", ""shape"": []}, ""MinBasketballToFootballRatio"": {""description"": ""Minimum ratio of basketballs to footballs production"", ""shape"": []}, ""MinimumFootballs"": {""description"": ""Minimum number of footballs to produce"", ""shape"": []}}, ""variables"": {""ProductionQuantity"": {""description"": ""The number of each sports equipment produced"", ""type"": ""continuous"", ""shape"": [""NumProducts""]}, ""ProductionQuantityBasketballs"": {""description"": ""The number of basketballs produced"", ""type"": ""continuous"", ""shape"": []}, ""ProductionQuantityFootballs"": {""description"": ""The number of footballs produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total materials used to produce all sports equipment cannot exceed TotalMaterialsAvailable units."", ""formulation"": ""\\sum_{i=1}^{\\text{NumProducts}} \\text{MaterialRequirement}_i \\cdot \\text{ProductionQuantity}_i \\leq \\text{TotalMaterialsAvailable}"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(MaterialRequirement[i] * ProductionQuantity[i] for i in range(NumProducts)) <= TotalMaterialsAvailable)""}}, {""description"": ""The total labor hours used to produce all sports equipment cannot exceed TotalLaborHoursAvailable labor hours."", ""formulation"": ""\\sum_{i=1}^{NumProducts} TimeRequirement_i \\cdot ProductionQuantity_i \\leq TotalLaborHoursAvailable"", ""code"": {""gurobipy"": ""model.addConstr(quicksum(TimeRequirement[i] * ProductionQuantity[i] for i in range(NumProducts)) <= TotalLaborHoursAvailable)""}}, {""description"": ""The number of basketballs produced must be at least MinBasketballToFootballRatio times the number of footballs produced."", ""formulation"": ""ProductionQuantityBasketballs \\geq MinBasketballToFootballRatio \\times ProductionQuantityFootballs"", ""code"": {""gurobipy"": ""model.addConstr(ProductionQuantityBasketballs >= MinBasketballToFootballRatio * ProductionQuantityFootballs)""}}, {""description"": ""At least MinimumFootballs footballs must be produced."", ""formulation"": ""ProductionQuantityFootballs \\geq MinimumFootballs"", ""code"": {""gurobipy"": ""model.addConstr(ProductionQuantityFootballs >= MinimumFootballs)""}}], ""objective"": {""description"": ""Maximize the total number of sports equipment produced."", ""formulation"": ""Max \\sum_{k=1}^{NumProducts} ProductionQuantity_k"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ProductionQuantity[k] for k in range(NumProducts)), GRB.MAXIMIZE)""}}}","{""NumProducts"": 2, ""MaterialRequirement"": [5, 3], ""TimeRequirement"": [1, 2], ""TotalMaterialsAvailable"": 1500, ""TotalLaborHoursAvailable"": 750, ""MinBasketballToFootballRatio"": 3, ""MinimumFootballs"": 50}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A manufacturing company produces NumProducts different types of sports
equipment. Each product requires MaterialRequirement units of materials and
TimeRequirement hours to produce. The company has a total of
TotalMaterialsAvailable units of materials and TotalLaborHoursAvailable labor
hours available. The production must ensure that the number of basketballs is at
least MinBasketballToFootballRatio times the number of footballs and that at
least MinimumFootballs footballs are produced. The objective is to maximize the
total number of sports equipment produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/257/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumProducts @Def: Number of different sports equipment produced @Shape: [] 
NumProducts = data['NumProducts']
# @Parameter MaterialRequirement @Def: Amount of materials required to produce one unit of each sports equipment @Shape: ['NumProducts'] 
MaterialRequirement = data['MaterialRequirement']
# @Parameter TimeRequirement @Def: Amount of labor hours required to produce one unit of each sports equipment @Shape: ['NumProducts'] 
TimeRequirement = data['TimeRequirement']
# @Parameter TotalMaterialsAvailable @Def: Total units of materials available for production @Shape: [] 
TotalMaterialsAvailable = data['TotalMaterialsAvailable']
# @Parameter TotalLaborHoursAvailable @Def: Total labor hours available for production @Shape: [] 
TotalLaborHoursAvailable = data['TotalLaborHoursAvailable']
# @Parameter MinBasketballToFootballRatio @Def: Minimum ratio of basketballs to footballs production @Shape: [] 
MinBasketballToFootballRatio = data['MinBasketballToFootballRatio']
# @Parameter MinimumFootballs @Def: Minimum number of footballs to produce @Shape: [] 
MinimumFootballs = data['MinimumFootballs']

# Variables 
# @Variable ProductionQuantity @Def: The number of each sports equipment produced @Shape: ['NumProducts'] 
ProductionQuantity = model.addVars(NumProducts, vtype=GRB.CONTINUOUS, name=""ProductionQuantity"")
# @Variable ProductionQuantityBasketballs @Def: The number of basketballs produced @Shape: [] 
ProductionQuantityBasketballs = model.addVar(vtype=GRB.CONTINUOUS, name=""ProductionQuantityBasketballs"")
# @Variable ProductionQuantityFootballs @Def: The number of footballs produced @Shape: [] 
ProductionQuantityFootballs = model.addVar(vtype=GRB.CONTINUOUS, lb=MinimumFootballs, name=""ProductionQuantityFootballs"")

# Constraints 
# @Constraint Constr_1 @Def: The total materials used to produce all sports equipment cannot exceed TotalMaterialsAvailable units.
model.addConstr(quicksum(MaterialRequirement[i] * ProductionQuantity[i] for i in range(NumProducts)) <= TotalMaterialsAvailable)
# @Constraint Constr_2 @Def: The total labor hours used to produce all sports equipment cannot exceed TotalLaborHoursAvailable labor hours.
model.addConstr(quicksum(TimeRequirement[i] * ProductionQuantity[i] for i in range(NumProducts)) <= TotalLaborHoursAvailable)
# @Constraint Constr_3 @Def: The number of basketballs produced must be at least MinBasketballToFootballRatio times the number of footballs produced.
model.addConstr(ProductionQuantityBasketballs >= MinBasketballToFootballRatio * ProductionQuantityFootballs)
# @Constraint Constr_4 @Def: At least MinimumFootballs footballs must be produced.
model.addConstr(ProductionQuantityFootballs >= MinimumFootballs)

# Objective 
# @Objective Objective @Def: Maximize the total number of sports equipment produced.
model.setObjective(quicksum(ProductionQuantity[k] for k in range(NumProducts)), GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['ProductionQuantity'] = model.getAttr('X', ProductionQuantity)
variables['ProductionQuantityBasketballs'] = ProductionQuantityBasketballs.x
variables['ProductionQuantityFootballs'] = ProductionQuantityFootballs.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A researcher must perform two types of experiments, in-vivo and ex-vivo. In-vivo experiments requires 30 minutes to prepare and 60 minutes to execute. Ex-vivo experiments require 45 minutes to prepare and 30 minutes to execute. In addition, in-vivo experiments gives the researcher 2 units of radiation while ex-vivo experiments give the researcher 3 unites of radiation. At most 400 minutes can be used for preparation and 500 minutes for execution of the experiment. How many of each experiment should be scheduled by the researcher to minimize the total radiation received by the researcher?","{""variables"": {""NumberOfInVivoExperiments"": 0.0, ""NumberOfExVivoExperiments"": -0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A researcher needs to perform two types of experiments: in-vivo and ex-vivo. Each in-vivo experiment requires PrepTimeInVivo for preparation and ExecTimeInVivo for execution, and yields RadiationInVivo radiation. Each ex-vivo experiment requires PrepTimeExVivo for preparation and ExecTimeExVivo for execution, and yields RadiationExVivo radiation. The total preparation time must not exceed MaxPrepTime, and the total execution time must not exceed MaxExecTime. The researcher aims to determine the number of in-vivo and ex-vivo experiments to schedule in order to minimize the total radiation received."", ""keywords"": [""N.A.""], ""parameters"": {""PrepTimeInVivo"": {""description"": ""Preparation time required for in-vivo experiments"", ""shape"": []}, ""ExecTimeInVivo"": {""description"": ""Execution time required for in-vivo experiments"", ""shape"": []}, ""RadiationInVivo"": {""description"": ""Radiation units received from in-vivo experiments"", ""shape"": []}, ""PrepTimeExVivo"": {""description"": ""Preparation time required for ex-vivo experiments"", ""shape"": []}, ""ExecTimeExVivo"": {""description"": ""Execution time required for ex-vivo experiments"", ""shape"": []}, ""RadiationExVivo"": {""description"": ""Radiation units received from ex-vivo experiments"", ""shape"": []}, ""MaxPrepTime"": {""description"": ""Maximum available preparation time"", ""shape"": []}, ""MaxExecTime"": {""description"": ""Maximum available execution time"", ""shape"": []}}, ""variables"": {""NumberOfInVivoExperiments"": {""description"": ""The number of in-vivo experiments"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfExVivoExperiments"": {""description"": ""The number of ex-vivo experiments"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total preparation time for in-vivo and ex-vivo experiments must not exceed MaxPrepTime."", ""formulation"": ""NumberOfInVivoExperiments \\times PrepTimeInVivo + NumberOfExVivoExperiments \\times PrepTimeExVivo \\leq MaxPrepTime"", ""code"": {""gurobipy"": ""model.addConstr(PrepTimeInVivo * NumberOfInVivoExperiments + PrepTimeExVivo * NumberOfExVivoExperiments <= MaxPrepTime)""}}, {""description"": ""The total execution time for in-vivo and ex-vivo experiments must not exceed MaxExecTime."", ""formulation"": ""ExecTimeInVivo \\times NumberOfInVivoExperiments + ExecTimeExVivo \\times NumberOfExVivoExperiments \\leq MaxExecTime"", ""code"": {""gurobipy"": ""model.addConstr(ExecTimeInVivo * NumberOfInVivoExperiments + ExecTimeExVivo * NumberOfExVivoExperiments <= MaxExecTime)""}}], ""objective"": {""description"": ""Minimize the total radiation received, which is the sum of RadiationInVivo multiplied by the number of in-vivo experiments and RadiationExVivo multiplied by the number of ex-vivo experiments."", ""formulation"": ""Min \\ RadiationInVivo \\cdot NumberOfInVivoExperiments + RadiationExVivo \\cdot NumberOfExVivoExperiments"", ""code"": {""gurobipy"": ""model.setObjective(RadiationInVivo * NumberOfInVivoExperiments + RadiationExVivo * NumberOfExVivoExperiments, GRB.MINIMIZE)""}}}","{""PrepTimeInVivo"": 30, ""ExecTimeInVivo"": 60, ""RadiationInVivo"": 2, ""PrepTimeExVivo"": 45, ""ExecTimeExVivo"": 30, ""RadiationExVivo"": 3, ""MaxPrepTime"": 400, ""MaxExecTime"": 500}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A researcher needs to perform two types of experiments: in-vivo and ex-vivo.
Each in-vivo experiment requires PrepTimeInVivo for preparation and
ExecTimeInVivo for execution, and yields RadiationInVivo radiation. Each ex-vivo
experiment requires PrepTimeExVivo for preparation and ExecTimeExVivo for
execution, and yields RadiationExVivo radiation. The total preparation time must
not exceed MaxPrepTime, and the total execution time must not exceed
MaxExecTime. The researcher aims to determine the number of in-vivo and ex-vivo
experiments to schedule in order to minimize the total radiation received.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/258/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter PrepTimeInVivo @Def: Preparation time required for in-vivo experiments @Shape: [] 
PrepTimeInVivo = data['PrepTimeInVivo']
# @Parameter ExecTimeInVivo @Def: Execution time required for in-vivo experiments @Shape: [] 
ExecTimeInVivo = data['ExecTimeInVivo']
# @Parameter RadiationInVivo @Def: Radiation units received from in-vivo experiments @Shape: [] 
RadiationInVivo = data['RadiationInVivo']
# @Parameter PrepTimeExVivo @Def: Preparation time required for ex-vivo experiments @Shape: [] 
PrepTimeExVivo = data['PrepTimeExVivo']
# @Parameter ExecTimeExVivo @Def: Execution time required for ex-vivo experiments @Shape: [] 
ExecTimeExVivo = data['ExecTimeExVivo']
# @Parameter RadiationExVivo @Def: Radiation units received from ex-vivo experiments @Shape: [] 
RadiationExVivo = data['RadiationExVivo']
# @Parameter MaxPrepTime @Def: Maximum available preparation time @Shape: [] 
MaxPrepTime = data['MaxPrepTime']
# @Parameter MaxExecTime @Def: Maximum available execution time @Shape: [] 
MaxExecTime = data['MaxExecTime']

# Variables 
# @Variable NumberOfInVivoExperiments @Def: The number of in-vivo experiments @Shape: [] 
NumberOfInVivoExperiments = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberOfInVivoExperiments"")
# @Variable NumberOfExVivoExperiments @Def: The number of ex-vivo experiments @Shape: [] 
NumberOfExVivoExperiments = model.addVar(vtype=GRB.INTEGER, name='NumberOfExVivoExperiments')

# Constraints 
# @Constraint Constr_1 @Def: The total preparation time for in-vivo and ex-vivo experiments must not exceed MaxPrepTime.
model.addConstr(PrepTimeInVivo * NumberOfInVivoExperiments + PrepTimeExVivo * NumberOfExVivoExperiments <= MaxPrepTime)
# @Constraint Constr_2 @Def: The total execution time for in-vivo and ex-vivo experiments must not exceed MaxExecTime.
model.addConstr(ExecTimeInVivo * NumberOfInVivoExperiments + ExecTimeExVivo * NumberOfExVivoExperiments <= MaxExecTime)

# Objective 
# @Objective Objective @Def: Minimize the total radiation received, which is the sum of RadiationInVivo multiplied by the number of in-vivo experiments and RadiationExVivo multiplied by the number of ex-vivo experiments.
model.setObjective(RadiationInVivo * NumberOfInVivoExperiments + RadiationExVivo * NumberOfExVivoExperiments, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfInVivoExperiments'] = NumberOfInVivoExperiments.x
variables['NumberOfExVivoExperiments'] = NumberOfExVivoExperiments.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A village delivers mail to nearby villages either by runners or canoers. Runners can carry three bags of mail each time and takes 4 hours. Canoers can carry ten bags of mail each time and takes 2 hours. At most 33% of deliveries can be by canoe. Additionally, the village can spare at most 200 total hours and at least 4 runners must be used. How many of each way to deliver must be used to maximize the total amount of mail that can be delivered?","{""variables"": {""NumRunnerTrips"": 47.0, ""NumCanoeTrips"": 6.0, ""NumberOfRunners"": 4.0}, ""objective"": 201.0}","{""parametrized_description"": ""A village delivers mail to nearby villages either by runners or canoeers. Runners can carry RunnerCapacity bags of mail each trip and take RunnerTime hours. Canoeers can carry CanoeCapacity bags of mail each trip and take CanoeTime hours. At most MaxCanoePercentage of deliveries can be made by canoe. Additionally, the village can spare at most MaxTotalHours total hours for deliveries and must use at least MinRunners runners. The objective is to determine the number of trips by runners and canoeers to maximize the total amount of mail delivered."", ""keywords"": [""N.A.""], ""parameters"": {""RunnerCapacity"": {""description"": ""Number of bags a runner can carry each trip"", ""shape"": []}, ""RunnerTime"": {""description"": ""Time a runner takes per trip (in hours)"", ""shape"": []}, ""CanoeCapacity"": {""description"": ""Number of bags a canoeer can carry each trip"", ""shape"": []}, ""CanoeTime"": {""description"": ""Time a canoeer takes per trip (in hours)"", ""shape"": []}, ""MaxCanoePercentage"": {""description"": ""Maximum fraction of total deliveries that can be made by canoe"", ""shape"": []}, ""MaxTotalHours"": {""description"": ""Maximum total hours the village can spare for deliveries"", ""shape"": []}, ""MinRunners"": {""description"": ""Minimum number of runners that must be used"", ""shape"": []}}, ""variables"": {""NumRunnerTrips"": {""description"": ""Number of trips made by runners"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumCanoeTrips"": {""description"": ""Number of trips made by canoeers"", ""type"": ""continuous"", ""shape"": [""Integer""]}, ""NumberOfRunners"": {""description"": ""The number of runners used for deliveries"", ""type"": ""continuous"", ""shape"": [""Integer""]}}, ""constraints"": [{""description"": ""The total hours spent on deliveries by runners and canoeers must not exceed MaxTotalHours."", ""formulation"": ""RunnerTime \\times NumRunnerTrips + CanoeTime \\times NumCanoeTrips \\leq MaxTotalHours"", ""code"": {""gurobipy"": ""model.addConstr(RunnerTime * NumRunnerTrips + CanoeTime * NumCanoeTrips <= MaxTotalHours)""}}, {""description"": ""No more than MaxCanoePercentage of the total mail delivered can be delivered by canoeers."", ""formulation"": ""NumCanoeTrips \\times CanoeCapacity \\leq MaxCanoePercentage \\times \\left( NumRunnerTrips \\times RunnerCapacity + NumCanoeTrips \\times CanoeCapacity \\right)"", ""code"": {""gurobipy"": ""model.addConstr(NumCanoeTrips * CanoeCapacity <= MaxCanoePercentage * (NumRunnerTrips * RunnerCapacity + NumCanoeTrips * CanoeCapacity))""}}, {""description"": ""At least MinRunners runners must be used for deliveries."", ""formulation"": ""NumberOfRunners \\geq MinRunners"", ""code"": {""gurobipy"": ""model.addConstr(NumberOfRunners >= MinRunners)""}}], ""objective"": {""description"": ""Maximize the total amount of mail delivered by runners and canoeers within the given time, capacity, and usage constraints."", ""formulation"": ""Max \\left( NumRunnerTrips \\times RunnerCapacity + NumCanoeTrips \\times CanoeCapacity \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumRunnerTrips * RunnerCapacity + NumCanoeTrips * CanoeCapacity, GRB.MAXIMIZE)""}}}","{""RunnerCapacity"": 3, ""RunnerTime"": 4, ""CanoeCapacity"": 10, ""CanoeTime"": 2, ""MaxCanoePercentage"": 0.33, ""MaxTotalHours"": 200, ""MinRunners"": 4}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A village delivers mail to nearby villages either by runners or canoeers.
Runners can carry RunnerCapacity bags of mail each trip and take RunnerTime
hours. Canoeers can carry CanoeCapacity bags of mail each trip and take
CanoeTime hours. At most MaxCanoePercentage of deliveries can be made by canoe.
Additionally, the village can spare at most MaxTotalHours total hours for
deliveries and must use at least MinRunners runners. The objective is to
determine the number of trips by runners and canoeers to maximize the total
amount of mail delivered.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/259/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter RunnerCapacity @Def: Number of bags a runner can carry each trip @Shape: [] 
RunnerCapacity = data['RunnerCapacity']
# @Parameter RunnerTime @Def: Time a runner takes per trip (in hours) @Shape: [] 
RunnerTime = data['RunnerTime']
# @Parameter CanoeCapacity @Def: Number of bags a canoeer can carry each trip @Shape: [] 
CanoeCapacity = data['CanoeCapacity']
# @Parameter CanoeTime @Def: Time a canoeer takes per trip (in hours) @Shape: [] 
CanoeTime = data['CanoeTime']
# @Parameter MaxCanoePercentage @Def: Maximum fraction of total deliveries that can be made by canoe @Shape: [] 
MaxCanoePercentage = data['MaxCanoePercentage']
# @Parameter MaxTotalHours @Def: Maximum total hours the village can spare for deliveries @Shape: [] 
MaxTotalHours = data['MaxTotalHours']
# @Parameter MinRunners @Def: Minimum number of runners that must be used @Shape: [] 
MinRunners = data['MinRunners']

# Variables 
# @Variable NumRunnerTrips @Def: Number of trips made by runners @Shape: ['Integer'] 
NumRunnerTrips = model.addVar(vtype=GRB.INTEGER, name=""NumRunnerTrips"")
# @Variable NumCanoeTrips @Def: Number of trips made by canoeers @Shape: ['Integer'] 
NumCanoeTrips = model.addVar(vtype=GRB.INTEGER, name=""NumCanoeTrips"")
# @Variable NumberOfRunners @Def: The number of runners used for deliveries @Shape: ['Integer'] 
NumberOfRunners = model.addVar(vtype=GRB.INTEGER, lb=MinRunners, name=""NumberOfRunners"")

# Constraints 
# @Constraint Constr_1 @Def: The total hours spent on deliveries by runners and canoeers must not exceed MaxTotalHours.
model.addConstr(RunnerTime * NumRunnerTrips + CanoeTime * NumCanoeTrips <= MaxTotalHours)
# @Constraint Constr_2 @Def: No more than MaxCanoePercentage of the total mail delivered can be delivered by canoeers.
model.addConstr(NumCanoeTrips * CanoeCapacity <= MaxCanoePercentage * (NumRunnerTrips * RunnerCapacity + NumCanoeTrips * CanoeCapacity))
# @Constraint Constr_3 @Def: At least MinRunners runners must be used for deliveries.
model.addConstr(NumberOfRunners >= MinRunners)

# Objective 
# @Objective Objective @Def: Maximize the total amount of mail delivered by runners and canoeers within the given time, capacity, and usage constraints.
model.setObjective(NumRunnerTrips * RunnerCapacity + NumCanoeTrips * CanoeCapacity, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumRunnerTrips'] = NumRunnerTrips.x
variables['NumCanoeTrips'] = NumCanoeTrips.x
variables['NumberOfRunners'] = NumberOfRunners.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A woman on a diet needs to eat two types of meal preps, a smoothie and a protein bar. Each smoothie contains 2 units of protein and 300 calories. Each protein bar contains 7 units of protein and 250 calories. The woman must eat 2 times more protein bars than smoothies. If the woman can consume at most 2000 calories, how many of each should she eat or drink to maximize her protein intake?","{""variables"": {""NumberSmoothies"": 2.0, ""NumberProteinBars"": 4.0}, ""objective"": 32.0}","{""parametrized_description"": ""A woman must consume two types of meal preps: Smoothies and Protein Bars. Each Smoothie provides ProteinPerSmoothie units of protein and CaloriesPerSmoothie calories. Each Protein Bar provides ProteinPerBar units of protein and CaloriesPerBar calories. The number of Protein Bars consumed must be BarToSmoothieRatio times the number of Smoothies. The total calorie intake must not exceed MaxCalories. Determine the quantities of Smoothies and Protein Bars to maximize total protein intake."", ""keywords"": [""N.A.""], ""parameters"": {""ProteinPerSmoothie"": {""description"": ""Amount of protein per smoothie"", ""shape"": []}, ""CaloriesPerSmoothie"": {""description"": ""Amount of calories per smoothie"", ""shape"": []}, ""ProteinPerBar"": {""description"": ""Amount of protein per protein bar"", ""shape"": []}, ""CaloriesPerBar"": {""description"": ""Amount of calories per protein bar"", ""shape"": []}, ""BarToSmoothieRatio"": {""description"": ""Ratio of protein bars to smoothies"", ""shape"": []}, ""MaxCalories"": {""description"": ""Maximum allowable total calories"", ""shape"": []}}, ""variables"": {""NumberSmoothies"": {""description"": ""The number of smoothies selected"", ""type"": ""continuous"", ""shape"": []}, ""NumberProteinBars"": {""description"": ""The number of protein bars selected"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total calorie intake from Smoothies and Protein Bars must not exceed MaxCalories."", ""formulation"": ""CaloriesPerSmoothie \\cdot NumberSmoothies + CaloriesPerBar \\cdot NumberProteinBars \\leq MaxCalories"", ""code"": {""gurobipy"": ""model.addConstr(CaloriesPerSmoothie * NumberSmoothies + CaloriesPerBar * NumberProteinBars <= MaxCalories)""}}, {""description"": ""The number of Protein Bars consumed must be BarToSmoothieRatio times the number of Smoothies."", ""formulation"": ""NumberProteinBars = BarToSmoothieRatio \\times NumberSmoothies"", ""code"": {""gurobipy"": ""model.addConstr(NumberProteinBars == BarToSmoothieRatio * NumberSmoothies)""}}], ""objective"": {""description"": ""Maximize the total protein intake, which is the sum of the protein from Smoothies and Protein Bars."", ""formulation"": ""Max \\ ProteinPerSmoothie \\times NumberSmoothies + ProteinPerBar \\times NumberProteinBars"", ""code"": {""gurobipy"": ""model.setObjective(ProteinPerSmoothie * NumberSmoothies + ProteinPerBar * NumberProteinBars, GRB.MAXIMIZE)""}}}","{""ProteinPerSmoothie"": 2, ""CaloriesPerSmoothie"": 300, ""ProteinPerBar"": 7, ""CaloriesPerBar"": 250, ""BarToSmoothieRatio"": 2, ""MaxCalories"": 2000}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A woman must consume two types of meal preps: Smoothies and Protein Bars. Each
Smoothie provides ProteinPerSmoothie units of protein and CaloriesPerSmoothie
calories. Each Protein Bar provides ProteinPerBar units of protein and
CaloriesPerBar calories. The number of Protein Bars consumed must be
BarToSmoothieRatio times the number of Smoothies. The total calorie intake must
not exceed MaxCalories. Determine the quantities of Smoothies and Protein Bars
to maximize total protein intake.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/260/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter ProteinPerSmoothie @Def: Amount of protein per smoothie @Shape: [] 
ProteinPerSmoothie = data['ProteinPerSmoothie']
# @Parameter CaloriesPerSmoothie @Def: Amount of calories per smoothie @Shape: [] 
CaloriesPerSmoothie = data['CaloriesPerSmoothie']
# @Parameter ProteinPerBar @Def: Amount of protein per protein bar @Shape: [] 
ProteinPerBar = data['ProteinPerBar']
# @Parameter CaloriesPerBar @Def: Amount of calories per protein bar @Shape: [] 
CaloriesPerBar = data['CaloriesPerBar']
# @Parameter BarToSmoothieRatio @Def: Ratio of protein bars to smoothies @Shape: [] 
BarToSmoothieRatio = data['BarToSmoothieRatio']
# @Parameter MaxCalories @Def: Maximum allowable total calories @Shape: [] 
MaxCalories = data['MaxCalories']

# Variables 
# @Variable NumberSmoothies @Def: The number of smoothies selected @Shape: [] 
NumberSmoothies = model.addVar(vtype=GRB.INTEGER, name=""NumberSmoothies"")
# @Variable NumberProteinBars @Def: The number of protein bars selected @Shape: [] 
NumberProteinBars = model.addVar(vtype=GRB.INTEGER, name=""NumberProteinBars"")

# Constraints 
# @Constraint Constr_1 @Def: The total calorie intake from Smoothies and Protein Bars must not exceed MaxCalories.
model.addConstr(CaloriesPerSmoothie * NumberSmoothies + CaloriesPerBar * NumberProteinBars <= MaxCalories)
# @Constraint Constr_2 @Def: The number of Protein Bars consumed must be BarToSmoothieRatio times the number of Smoothies.
model.addConstr(NumberProteinBars == BarToSmoothieRatio * NumberSmoothies)

# Objective 
# @Objective Objective @Def: Maximize the total protein intake, which is the sum of the protein from Smoothies and Protein Bars.
model.setObjective(ProteinPerSmoothie * NumberSmoothies + ProteinPerBar * NumberProteinBars, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberSmoothies'] = NumberSmoothies.x
variables['NumberProteinBars'] = NumberProteinBars.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A clinical firm has two factories, a northern factory and a western factory, where they make expensive anti-itch injections and topical cream. Every hour, the northern factory makes 800 g of anti-itch injections and 700 g of topical cream. Every hour, the western factory makes 650 g of anti-itch injections and 750 g of topical cream. The northern factory requires 40 units of plastic per hour while the western factory requires 35 units of plastic to manufacture the packaging. The clinical firm has available 60,000 units of plastic. Further, they must make at least 800,000 g of anti-itch injections and 700,000 g of topical cream. How many hours should each factory be run to minimize the total time needed?",{},"{""parametrized_description"": ""A clinical firm operates two factories, northern and western. The firm decides the number of hours to run each factory. The northern factory produces NorthernFactoryAntiItchRate grams of anti-itch injections and NorthernFactoryTopicalCreamRate grams of topical cream per hour. The western factory produces WesternFactoryAntiItchRate grams of anti-itch injections and WesternFactoryTopicalCreamRate grams of topical cream per hour. The northern factory uses NorthernFactoryPlasticUsage units of plastic per hour, and the western factory uses WesternFactoryPlasticUsage units of plastic per hour. The total plastic available is TotalPlasticAvailable units. The firm must produce at least MinimumAntiItchProduction grams of anti-itch injections and MinimumTopicalCreamProduction grams of topical cream. The objective is to minimize the total time the factories are run."", ""keywords"": [""N.A.""], ""parameters"": {""NorthernFactoryAntiItchRate"": {""description"": ""Production rate of anti-itch injections per hour at the northern factory"", ""shape"": []}, ""NorthernFactoryTopicalCreamRate"": {""description"": ""Production rate of topical cream per hour at the northern factory"", ""shape"": []}, ""WesternFactoryAntiItchRate"": {""description"": ""Production rate of anti-itch injections per hour at the western factory"", ""shape"": []}, ""WesternFactoryTopicalCreamRate"": {""description"": ""Production rate of topical cream per hour at the western factory"", ""shape"": []}, ""NorthernFactoryPlasticUsage"": {""description"": ""Units of plastic required per hour at the northern factory"", ""shape"": []}, ""WesternFactoryPlasticUsage"": {""description"": ""Units of plastic required per hour at the western factory"", ""shape"": []}, ""TotalPlasticAvailable"": {""description"": ""Total units of plastic available"", ""shape"": []}, ""MinimumAntiItchProduction"": {""description"": ""Minimum grams of anti-itch injections to produce"", ""shape"": []}, ""MinimumTopicalCreamProduction"": {""description"": ""Minimum grams of topical cream to produce"", ""shape"": []}}, ""variables"": {""NorthernFactoryAntiItchProduction"": {""description"": ""The production quantity of anti-itch injections at the Northern factory"", ""type"": ""continuous"", ""shape"": []}, ""NorthernFactoryTopicalCreamProduction"": {""description"": ""The production quantity of topical cream at the Northern factory"", ""type"": ""continuous"", ""shape"": []}, ""WesternFactoryAntiItchProduction"": {""description"": ""The production quantity of anti-itch injections at the Western factory"", ""type"": ""continuous"", ""shape"": []}, ""WesternFactoryTopicalCreamProduction"": {""description"": ""The production quantity of topical cream at the Western factory"", ""type"": ""continuous"", ""shape"": []}, ""NorthernRunTime"": {""description"": ""The run time of the Northern factory in hours"", ""type"": ""continuous"", ""shape"": []}, ""WesternRunTime"": {""description"": ""The run time of the Western factory in hours"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total plastic used by the northern and western factories cannot exceed TotalPlasticAvailable units."", ""formulation"": ""\\frac{NorthernFactoryPlasticUsage}{NorthernFactoryAntiItchRate} \\cdot NorthernFactoryAntiItchProduction + \\frac{NorthernFactoryPlasticUsage}{NorthernFactoryTopicalCreamRate} \\cdot NorthernFactoryTopicalCreamProduction + \\frac{WesternFactoryPlasticUsage}{WesternFactoryAntiItchRate} \\cdot WesternFactoryAntiItchProduction + \\frac{WesternFactoryPlasticUsage}{WesternFactoryTopicalCreamRate} \\cdot WesternFactoryTopicalCreamProduction \\leq TotalPlasticAvailable"", ""code"": {""gurobipy"": ""model.addConstr((NorthernFactoryPlasticUsage / NorthernFactoryAntiItchRate) * NorthernFactoryAntiItchProduction + (NorthernFactoryPlasticUsage / NorthernFactoryTopicalCreamRate) * NorthernFactoryTopicalCreamProduction + (WesternFactoryPlasticUsage / WesternFactoryAntiItchRate) * WesternFactoryAntiItchProduction + (WesternFactoryPlasticUsage / WesternFactoryTopicalCreamRate) * WesternFactoryTopicalCreamProduction <= TotalPlasticAvailable)""}}, {""description"": ""The production of anti-itch injections by the northern and western factories must be at least MinimumAntiItchProduction grams."", ""formulation"": ""NorthernFactoryAntiItchProduction + WesternFactoryAntiItchProduction \\geq MinimumAntiItchProduction"", ""code"": {""gurobipy"": ""model.addConstr(NorthernFactoryAntiItchProduction + WesternFactoryAntiItchProduction >= MinimumAntiItchProduction)""}}, {""description"": ""The production of topical cream by the northern and western factories must be at least MinimumTopicalCreamProduction grams."", ""formulation"": ""NorthernFactoryTopicalCreamProduction + WesternFactoryTopicalCreamProduction \\geq MinimumTopicalCreamProduction"", ""code"": {""gurobipy"": ""model.addConstr(NorthernFactoryTopicalCreamProduction + WesternFactoryTopicalCreamProduction >= MinimumTopicalCreamProduction)""}}], ""objective"": {""description"": ""The objective is to minimize the total time the northern and western factories are run."", ""formulation"": ""Min \\ NorthernRunTime + WesternRunTime"", ""code"": {""gurobipy"": ""model.setObjective(NorthernRunTime + WesternRunTime, GRB.MINIMIZE)""}}}","{""NorthernFactoryAntiItchRate"": 800, ""NorthernFactoryTopicalCreamRate"": 700, ""WesternFactoryAntiItchRate"": 650, ""WesternFactoryTopicalCreamRate"": 750, ""NorthernFactoryPlasticUsage"": 40, ""WesternFactoryPlasticUsage"": 35, ""TotalPlasticAvailable"": 60000, ""MinimumAntiItchProduction"": 800000, ""MinimumTopicalCreamProduction"": 700000}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A clinical firm operates two factories, northern and western. The firm decides
the number of hours to run each factory. The northern factory produces
NorthernFactoryAntiItchRate grams of anti-itch injections and
NorthernFactoryTopicalCreamRate grams of topical cream per hour. The western
factory produces WesternFactoryAntiItchRate grams of anti-itch injections and
WesternFactoryTopicalCreamRate grams of topical cream per hour. The northern
factory uses NorthernFactoryPlasticUsage units of plastic per hour, and the
western factory uses WesternFactoryPlasticUsage units of plastic per hour. The
total plastic available is TotalPlasticAvailable units. The firm must produce at
least MinimumAntiItchProduction grams of anti-itch injections and
MinimumTopicalCreamProduction grams of topical cream. The objective is to
minimize the total time the factories are run.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/261/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NorthernFactoryAntiItchRate @Def: Production rate of anti-itch injections per hour at the northern factory @Shape: [] 
NorthernFactoryAntiItchRate = data['NorthernFactoryAntiItchRate']
# @Parameter NorthernFactoryTopicalCreamRate @Def: Production rate of topical cream per hour at the northern factory @Shape: [] 
NorthernFactoryTopicalCreamRate = data['NorthernFactoryTopicalCreamRate']
# @Parameter WesternFactoryAntiItchRate @Def: Production rate of anti-itch injections per hour at the western factory @Shape: [] 
WesternFactoryAntiItchRate = data['WesternFactoryAntiItchRate']
# @Parameter WesternFactoryTopicalCreamRate @Def: Production rate of topical cream per hour at the western factory @Shape: [] 
WesternFactoryTopicalCreamRate = data['WesternFactoryTopicalCreamRate']
# @Parameter NorthernFactoryPlasticUsage @Def: Units of plastic required per hour at the northern factory @Shape: [] 
NorthernFactoryPlasticUsage = data['NorthernFactoryPlasticUsage']
# @Parameter WesternFactoryPlasticUsage @Def: Units of plastic required per hour at the western factory @Shape: [] 
WesternFactoryPlasticUsage = data['WesternFactoryPlasticUsage']
# @Parameter TotalPlasticAvailable @Def: Total units of plastic available @Shape: [] 
TotalPlasticAvailable = data['TotalPlasticAvailable']
# @Parameter MinimumAntiItchProduction @Def: Minimum grams of anti-itch injections to produce @Shape: [] 
MinimumAntiItchProduction = data['MinimumAntiItchProduction']
# @Parameter MinimumTopicalCreamProduction @Def: Minimum grams of topical cream to produce @Shape: [] 
MinimumTopicalCreamProduction = data['MinimumTopicalCreamProduction']

# Variables 
# @Variable NorthernFactoryAntiItchProduction @Def: The production quantity of anti-itch injections at the Northern factory @Shape: [] 
NorthernFactoryAntiItchProduction = model.addVar(vtype=GRB.CONTINUOUS, name=""NorthernFactoryAntiItchProduction"")
# @Variable NorthernFactoryTopicalCreamProduction @Def: The production quantity of topical cream at the Northern factory @Shape: [] 
NorthernFactoryTopicalCreamProduction = model.addVar(vtype=GRB.CONTINUOUS, name=""NorthernFactoryTopicalCreamProduction"")
# @Variable WesternFactoryAntiItchProduction @Def: The production quantity of anti-itch injections at the Western factory @Shape: [] 
WesternFactoryAntiItchProduction = model.addVar(vtype=GRB.CONTINUOUS, name=""WesternFactoryAntiItchProduction"")
# @Variable WesternFactoryTopicalCreamProduction @Def: The production quantity of topical cream at the Western factory @Shape: [] 
WesternFactoryTopicalCreamProduction = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=""WesternFactoryTopicalCreamProduction"")
# @Variable NorthernRunTime @Def: The run time of the Northern factory in hours @Shape: [] 
NorthernRunTime = model.addVar(vtype=GRB.CONTINUOUS, name=""NorthernRunTime"")
# @Variable WesternRunTime @Def: The run time of the Western factory in hours @Shape: [] 
WesternRunTime = model.addVar(vtype=GRB.CONTINUOUS, name=""WesternRunTime"")

# Constraints 
# @Constraint Constr_1 @Def: The total plastic used by the northern and western factories cannot exceed TotalPlasticAvailable units.
model.addConstr((NorthernFactoryPlasticUsage / NorthernFactoryAntiItchRate) * NorthernFactoryAntiItchProduction + (NorthernFactoryPlasticUsage / NorthernFactoryTopicalCreamRate) * NorthernFactoryTopicalCreamProduction + (WesternFactoryPlasticUsage / WesternFactoryAntiItchRate) * WesternFactoryAntiItchProduction + (WesternFactoryPlasticUsage / WesternFactoryTopicalCreamRate) * WesternFactoryTopicalCreamProduction <= TotalPlasticAvailable)
# @Constraint Constr_2 @Def: The production of anti-itch injections by the northern and western factories must be at least MinimumAntiItchProduction grams.
model.addConstr(NorthernFactoryAntiItchProduction + WesternFactoryAntiItchProduction >= MinimumAntiItchProduction)
# @Constraint Constr_3 @Def: The production of topical cream by the northern and western factories must be at least MinimumTopicalCreamProduction grams.
model.addConstr(NorthernFactoryTopicalCreamProduction + WesternFactoryTopicalCreamProduction >= MinimumTopicalCreamProduction)

# Objective 
# @Objective Objective @Def: The objective is to minimize the total time the northern and western factories are run.
model.setObjective(NorthernRunTime + WesternRunTime, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NorthernFactoryAntiItchProduction'] = NorthernFactoryAntiItchProduction.x
variables['NorthernFactoryTopicalCreamProduction'] = NorthernFactoryTopicalCreamProduction.x
variables['WesternFactoryAntiItchProduction'] = WesternFactoryAntiItchProduction.x
variables['WesternFactoryTopicalCreamProduction'] = WesternFactoryTopicalCreamProduction.x
variables['NorthernRunTime'] = NorthernRunTime.x
variables['WesternRunTime'] = WesternRunTime.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A hospital prepares batches of medication patches and anti-biotic creams. Each medication patch requires 3 minutes to prepare and 5 units of materials. Each anti-biotic cream requires 5 minutes to prepare and 6 units of materials. Since anti-biotic creams are used more often, there must be at least twice as many anti-biotic creams as medication patches. Due to storage reasons, the hospital can make at most 100 batches of medication patches and anti-biotic creams in total. The hospital has available 400 minutes of staff to spare and 530 units of materials. If each batch of medication patches can treat 3 people and each batch of anti-biotic cream can treat 2 people, how many batches of each should be made to maximize the number of people that can be treated?","{""variables"": {""NumBatchesAntiBioticCream"": 62.0, ""NumBatchesMedicationPatch"": 30.0}, ""objective"": 214.0}","{""parametrized_description"": ""A hospital prepares two types of medication: medication patches and anti-biotic creams. Each batch of medication patches requires PreparationTimeMedicationPatch minutes to prepare and MaterialRequiredMedicationPatch units of materials. Each batch of anti-biotic creams requires PreparationTimeAntiBioticCream minutes to prepare and MaterialRequiredAntiBioticCream units of materials. Since anti-biotic creams are used more often, the number of batches of anti-biotic creams must be at least MinRatioAntiBioticCreamToMedicationPatch times the number of batches of medication patches. Due to storage constraints, the total number of batches of medication patches and anti-biotic creams cannot exceed MaxTotalBatches. The hospital has AvailableStaffTime minutes of staff time available and AvailableMaterials units of materials. Each batch of medication patches can treat TreatmentPerBatchMedicationPatch people, and each batch of anti-biotic creams can treat TreatmentPerBatchAntiBioticCream people. The hospital aims to determine the number of batches of each product to maximize the number of people that can be treated."", ""keywords"": [""N.A.""], ""parameters"": {""PreparationTimeMedicationPatch"": {""description"": ""Preparation time per batch of medication patches"", ""shape"": []}, ""PreparationTimeAntiBioticCream"": {""description"": ""Preparation time per batch of anti-biotic creams"", ""shape"": []}, ""MaterialRequiredMedicationPatch"": {""description"": ""Material required per batch of medication patches"", ""shape"": []}, ""MaterialRequiredAntiBioticCream"": {""description"": ""Material required per batch of anti-biotic creams"", ""shape"": []}, ""MinRatioAntiBioticCreamToMedicationPatch"": {""description"": ""Minimum ratio of anti-biotic creams to medication patches"", ""shape"": []}, ""MaxTotalBatches"": {""description"": ""Maximum total number of batches"", ""shape"": []}, ""AvailableStaffTime"": {""description"": ""Available staff time in minutes"", ""shape"": []}, ""AvailableMaterials"": {""description"": ""Available units of materials"", ""shape"": []}, ""TreatmentPerBatchMedicationPatch"": {""description"": ""Number of people treated by each batch of medication patches"", ""shape"": []}, ""TreatmentPerBatchAntiBioticCream"": {""description"": ""Number of people treated by each batch of anti-biotic creams"", ""shape"": []}}, ""variables"": {""NumBatchesAntiBioticCream"": {""description"": ""The number of batches of anti-biotic creams"", ""type"": ""continuous"", ""shape"": []}, ""NumBatchesMedicationPatch"": {""description"": ""The number of batches of medication patches"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of batches of anti-biotic creams must be at least MinRatioAntiBioticCreamToMedicationPatch times the number of batches of medication patches."", ""formulation"": ""NumBatchesAntiBioticCream \\geq MinRatioAntiBioticCreamToMedicationPatch \\times NumBatchesMedicationPatch"", ""code"": {""gurobipy"": ""model.addConstr(NumBatchesAntiBioticCream >= MinRatioAntiBioticCreamToMedicationPatch * NumBatchesMedicationPatch)""}}, {""description"": ""The total number of batches of medication patches and anti-biotic creams cannot exceed MaxTotalBatches."", ""formulation"": ""NumBatchesAntiBioticCream + NumBatchesMedicationPatch \\leq MaxTotalBatches"", ""code"": {""gurobipy"": ""model.addConstr(NumBatchesAntiBioticCream + NumBatchesMedicationPatch <= MaxTotalBatches)""}}, {""description"": ""The total preparation time for medication patches and anti-biotic creams must not exceed AvailableStaffTime minutes."", ""formulation"": ""PreparationTimeMedicationPatch \\times NumBatchesMedicationPatch + PreparationTimeAntiBioticCream \\times NumBatchesAntiBioticCream \\leq AvailableStaffTime"", ""code"": {""gurobipy"": ""model.addConstr(PreparationTimeMedicationPatch * NumBatchesMedicationPatch + PreparationTimeAntiBioticCream * NumBatchesAntiBioticCream <= AvailableStaffTime)""}}, {""description"": ""The total materials required for medication patches and anti-biotic creams must not exceed AvailableMaterials units."", ""formulation"": ""NumBatchesMedicationPatch \\times MaterialRequiredMedicationPatch + NumBatchesAntiBioticCream \\times MaterialRequiredAntiBioticCream \\leq AvailableMaterials"", ""code"": {""gurobipy"": ""model.addConstr(NumBatchesMedicationPatch * MaterialRequiredMedicationPatch + NumBatchesAntiBioticCream * MaterialRequiredAntiBioticCream <= AvailableMaterials)""}}], ""objective"": {""description"": ""Maximize the total number of people treated, which is calculated as (TreatmentPerBatchMedicationPatch * number of medication patch batches) plus (TreatmentPerBatchAntiBioticCream * number of anti-biotic cream batches)."", ""formulation"": ""Max \\left( TreatmentPerBatchMedicationPatch \\cdot NumBatchesMedicationPatch + TreatmentPerBatchAntiBioticCream \\cdot NumBatchesAntiBioticCream \\right )"", ""code"": {""gurobipy"": ""model.setObjective(TreatmentPerBatchMedicationPatch * NumBatchesMedicationPatch + TreatmentPerBatchAntiBioticCream * NumBatchesAntiBioticCream, GRB.MAXIMIZE)""}}}","{""PreparationTimeMedicationPatch"": 3, ""PreparationTimeAntiBioticCream"": 5, ""MaterialRequiredMedicationPatch"": 5, ""MaterialRequiredAntiBioticCream"": 6, ""MinRatioAntiBioticCreamToMedicationPatch"": 2, ""MaxTotalBatches"": 100, ""AvailableStaffTime"": 400, ""AvailableMaterials"": 530, ""TreatmentPerBatchMedicationPatch"": 3, ""TreatmentPerBatchAntiBioticCream"": 2}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A hospital prepares two types of medication: medication patches and anti-biotic
creams. Each batch of medication patches requires PreparationTimeMedicationPatch
minutes to prepare and MaterialRequiredMedicationPatch units of materials. Each
batch of anti-biotic creams requires PreparationTimeAntiBioticCream minutes to
prepare and MaterialRequiredAntiBioticCream units of materials. Since anti-
biotic creams are used more often, the number of batches of anti-biotic creams
must be at least MinRatioAntiBioticCreamToMedicationPatch times the number of
batches of medication patches. Due to storage constraints, the total number of
batches of medication patches and anti-biotic creams cannot exceed
MaxTotalBatches. The hospital has AvailableStaffTime minutes of staff time
available and AvailableMaterials units of materials. Each batch of medication
patches can treat TreatmentPerBatchMedicationPatch people, and each batch of
anti-biotic creams can treat TreatmentPerBatchAntiBioticCream people. The
hospital aims to determine the number of batches of each product to maximize the
number of people that can be treated.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/262/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter PreparationTimeMedicationPatch @Def: Preparation time per batch of medication patches @Shape: [] 
PreparationTimeMedicationPatch = data['PreparationTimeMedicationPatch']
# @Parameter PreparationTimeAntiBioticCream @Def: Preparation time per batch of anti-biotic creams @Shape: [] 
PreparationTimeAntiBioticCream = data['PreparationTimeAntiBioticCream']
# @Parameter MaterialRequiredMedicationPatch @Def: Material required per batch of medication patches @Shape: [] 
MaterialRequiredMedicationPatch = data['MaterialRequiredMedicationPatch']
# @Parameter MaterialRequiredAntiBioticCream @Def: Material required per batch of anti-biotic creams @Shape: [] 
MaterialRequiredAntiBioticCream = data['MaterialRequiredAntiBioticCream']
# @Parameter MinRatioAntiBioticCreamToMedicationPatch @Def: Minimum ratio of anti-biotic creams to medication patches @Shape: [] 
MinRatioAntiBioticCreamToMedicationPatch = data['MinRatioAntiBioticCreamToMedicationPatch']
# @Parameter MaxTotalBatches @Def: Maximum total number of batches @Shape: [] 
MaxTotalBatches = data['MaxTotalBatches']
# @Parameter AvailableStaffTime @Def: Available staff time in minutes @Shape: [] 
AvailableStaffTime = data['AvailableStaffTime']
# @Parameter AvailableMaterials @Def: Available units of materials @Shape: [] 
AvailableMaterials = data['AvailableMaterials']
# @Parameter TreatmentPerBatchMedicationPatch @Def: Number of people treated by each batch of medication patches @Shape: [] 
TreatmentPerBatchMedicationPatch = data['TreatmentPerBatchMedicationPatch']
# @Parameter TreatmentPerBatchAntiBioticCream @Def: Number of people treated by each batch of anti-biotic creams @Shape: [] 
TreatmentPerBatchAntiBioticCream = data['TreatmentPerBatchAntiBioticCream']

# Variables 
# @Variable NumBatchesAntiBioticCream @Def: The number of batches of anti-biotic creams @Shape: [] 
NumBatchesAntiBioticCream = model.addVar(vtype=GRB.INTEGER, name=""NumBatchesAntiBioticCream"")
# @Variable NumBatchesMedicationPatch @Def: The number of batches of medication patches @Shape: [] 
NumBatchesMedicationPatch = model.addVar(vtype=GRB.INTEGER, name=""NumBatchesMedicationPatch"")

# Constraints 
# @Constraint Constr_1 @Def: The number of batches of anti-biotic creams must be at least MinRatioAntiBioticCreamToMedicationPatch times the number of batches of medication patches.
model.addConstr(NumBatchesAntiBioticCream >= MinRatioAntiBioticCreamToMedicationPatch * NumBatchesMedicationPatch)
# @Constraint Constr_2 @Def: The total number of batches of medication patches and anti-biotic creams cannot exceed MaxTotalBatches.
model.addConstr(NumBatchesAntiBioticCream + NumBatchesMedicationPatch <= MaxTotalBatches)
# @Constraint Constr_3 @Def: The total preparation time for medication patches and anti-biotic creams must not exceed AvailableStaffTime minutes.
model.addConstr(PreparationTimeMedicationPatch * NumBatchesMedicationPatch + PreparationTimeAntiBioticCream * NumBatchesAntiBioticCream <= AvailableStaffTime)
# @Constraint Constr_4 @Def: The total materials required for medication patches and anti-biotic creams must not exceed AvailableMaterials units.
model.addConstr(NumBatchesMedicationPatch * MaterialRequiredMedicationPatch + NumBatchesAntiBioticCream * MaterialRequiredAntiBioticCream <= AvailableMaterials)

# Objective 
# @Objective Objective @Def: Maximize the total number of people treated, which is calculated as (TreatmentPerBatchMedicationPatch * number of medication patch batches) plus (TreatmentPerBatchAntiBioticCream * number of anti-biotic cream batches).
model.setObjective(TreatmentPerBatchMedicationPatch * NumBatchesMedicationPatch + TreatmentPerBatchAntiBioticCream * NumBatchesAntiBioticCream, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumBatchesAntiBioticCream'] = NumBatchesAntiBioticCream.x
variables['NumBatchesMedicationPatch'] = NumBatchesMedicationPatch.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A company in the desert can transport goods to rural cities either by camel caravans or desert trucks. A camel caravan can deliver 50 units of goods per trip and takes 12 hours. A desert truck can deliver 150 units of goods per trip and takes 5 hours. However, due to the cost of fuel, the company prefers to have more camel caravans than desert trucks.  If the company needs to deliver 1500 units of goods, how many of each method of transportation should the company organize to minimize the total number of hours required?","{""variables"": {""NumberCamelCaravans"": -0.0, ""NumberDesertTrucks"": 10.0}, ""objective"": 50.0}","{""parametrized_description"": ""A company uses camel caravans and desert trucks to transport goods to rural cities. Each camel caravan can deliver CamelCaravanCapacity units of goods per trip and takes CamelCaravanTime hours per trip. Each desert truck can deliver DesertTruckCapacity units of goods per trip and takes DesertTruckTime hours per trip. The company needs to deliver TotalGoodsToDeliver units of goods and prefers to have more camel caravans than desert trucks. The objective is to minimize the total number of hours required."", ""keywords"": [""N.A.""], ""parameters"": {""CamelCaravanCapacity"": {""description"": ""Amount of goods delivered per trip by a camel caravan"", ""shape"": []}, ""CamelCaravanTime"": {""description"": ""Time taken for one trip by a camel caravan"", ""shape"": []}, ""DesertTruckCapacity"": {""description"": ""Amount of goods delivered per trip by a desert truck"", ""shape"": []}, ""DesertTruckTime"": {""description"": ""Time taken for one trip by a desert truck"", ""shape"": []}, ""TotalGoodsToDeliver"": {""description"": ""Total amount of goods to be delivered"", ""shape"": []}}, ""variables"": {""NumberCamelCaravans"": {""description"": ""The number of camel caravans used"", ""type"": ""continuous"", ""shape"": []}, ""NumberDesertTrucks"": {""description"": ""The number of desert trucks used"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The combined delivery capacity of all camel caravans and desert trucks must be at least TotalGoodsToDeliver units."", ""formulation"": ""CamelCaravanCapacity \\cdot NumberCamelCaravans + DesertTruckCapacity \\cdot NumberDesertTrucks \\geq TotalGoodsToDeliver"", ""code"": {""gurobipy"": ""model.addConstr(CamelCaravanCapacity * NumberCamelCaravans + DesertTruckCapacity * NumberDesertTrucks >= TotalGoodsToDeliver)""}}], ""objective"": {""description"": ""Minimize the total number of hours required, calculated as (Number of Camel Caravans \u00d7 CamelCaravanTime) + (Number of Desert Trucks \u00d7 DesertTruckTime), while preferring to use more camel caravans than desert trucks."", ""formulation"": ""Min \\left( \\text{NumberCamelCaravans} \\times \\text{CamelCaravanTime} + \\text{NumberDesertTrucks} \\times \\text{DesertTruckTime} - \\epsilon \\times \\text{NumberCamelCaravans} \\right)"", ""code"": {""gurobipy"": ""epsilon = 1e-5\nmodel.setObjective(NumberCamelCaravans * CamelCaravanTime + NumberDesertTrucks * DesertTruckTime - epsilon * NumberCamelCaravans, GRB.MINIMIZE)""}}}","{""CamelCaravanCapacity"": 50, ""CamelCaravanTime"": 12, ""DesertTruckCapacity"": 150, ""DesertTruckTime"": 5, ""TotalGoodsToDeliver"": 1500}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A company uses camel caravans and desert trucks to transport goods to rural
cities. Each camel caravan can deliver CamelCaravanCapacity units of goods per
trip and takes CamelCaravanTime hours per trip. Each desert truck can deliver
DesertTruckCapacity units of goods per trip and takes DesertTruckTime hours per
trip. The company needs to deliver TotalGoodsToDeliver units of goods and
prefers to have more camel caravans than desert trucks. The objective is to
minimize the total number of hours required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/263/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter CamelCaravanCapacity @Def: Amount of goods delivered per trip by a camel caravan @Shape: [] 
CamelCaravanCapacity = data['CamelCaravanCapacity']
# @Parameter CamelCaravanTime @Def: Time taken for one trip by a camel caravan @Shape: [] 
CamelCaravanTime = data['CamelCaravanTime']
# @Parameter DesertTruckCapacity @Def: Amount of goods delivered per trip by a desert truck @Shape: [] 
DesertTruckCapacity = data['DesertTruckCapacity']
# @Parameter DesertTruckTime @Def: Time taken for one trip by a desert truck @Shape: [] 
DesertTruckTime = data['DesertTruckTime']
# @Parameter TotalGoodsToDeliver @Def: Total amount of goods to be delivered @Shape: [] 
TotalGoodsToDeliver = data['TotalGoodsToDeliver']

# Variables 
# @Variable NumberCamelCaravans @Def: The number of camel caravans used @Shape: [] 
NumberCamelCaravans = model.addVar(vtype=GRB.INTEGER, name=""NumberCamelCaravans"")
# @Variable NumberDesertTrucks @Def: The number of desert trucks used @Shape: [] 
NumberDesertTrucks = model.addVar(vtype=GRB.INTEGER, name=""NumberDesertTrucks"")

# Constraints 
# @Constraint Constr_1 @Def: The combined delivery capacity of all camel caravans and desert trucks must be at least TotalGoodsToDeliver units.
model.addConstr(CamelCaravanCapacity * NumberCamelCaravans + DesertTruckCapacity * NumberDesertTrucks >= TotalGoodsToDeliver)

# Objective 
# @Objective Objective @Def: Minimize the total number of hours required, calculated as (Number of Camel Caravans × CamelCaravanTime) + (Number of Desert Trucks × DesertTruckTime), while preferring to use more camel caravans than desert trucks.
epsilon = 1e-5
model.setObjective(NumberCamelCaravans * CamelCaravanTime + NumberDesertTrucks * DesertTruckTime - epsilon * NumberCamelCaravans, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberCamelCaravans'] = NumberCamelCaravans.x
variables['NumberDesertTrucks'] = NumberDesertTrucks.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A biotechnology company has 35,000 units of antibiotics available which is important to the process of making a first-dose and second-dose of vaccines. The first-dose vaccine requires 30 units of antibiotics and 20 mg of gelatine whereas the second-dose vaccine requires 65 units of antibiotics and 60 mg of gelatine. Since the first-dose vaccine is required before the second-dose vaccine, there must be more first-dose than second-dose vaccines manufactured. However, at least 40 second-dose vaccines must be made. How many of each vaccine should be made to minimize the amount of gelatine used?","{""variables"": {""FirstDoseVaccines"": 40.0, ""SecondDoseVaccines"": 40.0}, ""objective"": 3200.0}","{""parametrized_description"": ""A biotechnology company has TotalAntibiotics units of antibiotics available, which are essential for producing first-dose and second-dose vaccines. The first-dose vaccine requires AntibioticsFirstDose units of antibiotics and GelatineFirstDose mg of gelatine per unit, while the second-dose vaccine requires AntibioticsSecondDose units of antibiotics and GelatineSecondDose mg of gelatine per unit. The production of first-dose vaccines must exceed the production of second-dose vaccines, and at least MinimumSecondDose second-dose vaccines must be produced. The objective is to determine the number of first-dose and second-dose vaccines to manufacture in order to minimize the total gelatine usage."", ""keywords"": [""N.A.""], ""parameters"": {""TotalAntibiotics"": {""description"": ""Total number of antibiotics available"", ""shape"": []}, ""AntibioticsFirstDose"": {""description"": ""Antibiotics required for one first-dose vaccine"", ""shape"": []}, ""GelatineFirstDose"": {""description"": ""Gelatine required for one first-dose vaccine"", ""shape"": []}, ""AntibioticsSecondDose"": {""description"": ""Antibiotics required for one second-dose vaccine"", ""shape"": []}, ""GelatineSecondDose"": {""description"": ""Gelatine required for one second-dose vaccine"", ""shape"": []}, ""MinimumSecondDose"": {""description"": ""Minimum number of second-dose vaccines required"", ""shape"": []}}, ""variables"": {""FirstDoseVaccines"": {""description"": ""The number of first-dose vaccines administered"", ""type"": ""continuous"", ""shape"": []}, ""SecondDoseVaccines"": {""description"": ""The number of second-dose vaccines administered"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total antibiotics used for first-dose and second-dose vaccines must not exceed TotalAntibiotics units."", ""formulation"": ""AntibioticsFirstDose \\cdot FirstDoseVaccines + AntibioticsSecondDose \\cdot SecondDoseVaccines \\leq TotalAntibiotics"", ""code"": {""gurobipy"": ""model.addConstr(AntibioticsFirstDose * FirstDoseVaccines + AntibioticsSecondDose * SecondDoseVaccines <= TotalAntibiotics)""}}, {""description"": ""The number of first-dose vaccines produced must be greater than the number of second-dose vaccines produced."", ""formulation"": ""FirstDoseVaccines \\geq SecondDoseVaccines"", ""code"": {""gurobipy"": ""model.addConstr(FirstDoseVaccines >= SecondDoseVaccines)""}}, {""description"": ""At least MinimumSecondDose second-dose vaccines must be produced."", ""formulation"": ""SecondDoseVaccines \\geq MinimumSecondDose"", ""code"": {""gurobipy"": ""model.addConstr(SecondDoseVaccines >= MinimumSecondDose)""}}], ""objective"": {""description"": ""Minimize the total gelatine usage, which is the sum of GelatineFirstDose multiplied by the number of first-dose vaccines and GelatineSecondDose multiplied by the number of second-dose vaccines."", ""formulation"": ""Min GelatineFirstDose \\times FirstDoseVaccines + GelatineSecondDose \\times SecondDoseVaccines"", ""code"": {""gurobipy"": ""model.setObjective(GelatineFirstDose * FirstDoseVaccines + GelatineSecondDose * SecondDoseVaccines, GRB.MINIMIZE)""}}}","{""TotalAntibiotics"": 35000, ""AntibioticsFirstDose"": 30, ""GelatineFirstDose"": 20, ""AntibioticsSecondDose"": 65, ""GelatineSecondDose"": 60, ""MinimumSecondDose"": 40}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A biotechnology company has TotalAntibiotics units of antibiotics available,
which are essential for producing first-dose and second-dose vaccines. The
first-dose vaccine requires AntibioticsFirstDose units of antibiotics and
GelatineFirstDose mg of gelatine per unit, while the second-dose vaccine
requires AntibioticsSecondDose units of antibiotics and GelatineSecondDose mg of
gelatine per unit. The production of first-dose vaccines must exceed the
production of second-dose vaccines, and at least MinimumSecondDose second-dose
vaccines must be produced. The objective is to determine the number of first-
dose and second-dose vaccines to manufacture in order to minimize the total
gelatine usage.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/264/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TotalAntibiotics @Def: Total number of antibiotics available @Shape: [] 
TotalAntibiotics = data['TotalAntibiotics']
# @Parameter AntibioticsFirstDose @Def: Antibiotics required for one first-dose vaccine @Shape: [] 
AntibioticsFirstDose = data['AntibioticsFirstDose']
# @Parameter GelatineFirstDose @Def: Gelatine required for one first-dose vaccine @Shape: [] 
GelatineFirstDose = data['GelatineFirstDose']
# @Parameter AntibioticsSecondDose @Def: Antibiotics required for one second-dose vaccine @Shape: [] 
AntibioticsSecondDose = data['AntibioticsSecondDose']
# @Parameter GelatineSecondDose @Def: Gelatine required for one second-dose vaccine @Shape: [] 
GelatineSecondDose = data['GelatineSecondDose']
# @Parameter MinimumSecondDose @Def: Minimum number of second-dose vaccines required @Shape: [] 
MinimumSecondDose = data['MinimumSecondDose']

# Variables 
# @Variable FirstDoseVaccines @Def: The number of first-dose vaccines administered @Shape: [] 
FirstDoseVaccines = model.addVar(vtype=GRB.CONTINUOUS, name=""FirstDoseVaccines"")
# @Variable SecondDoseVaccines @Def: The number of second-dose vaccines administered @Shape: [] 
SecondDoseVaccines = model.addVar(vtype=GRB.CONTINUOUS, name=""SecondDoseVaccines"")

# Constraints 
# @Constraint Constr_1 @Def: The total antibiotics used for first-dose and second-dose vaccines must not exceed TotalAntibiotics units.
model.addConstr(AntibioticsFirstDose * FirstDoseVaccines + AntibioticsSecondDose * SecondDoseVaccines <= TotalAntibiotics)
# @Constraint Constr_2 @Def: The number of first-dose vaccines produced must be greater than the number of second-dose vaccines produced.
model.addConstr(FirstDoseVaccines >= SecondDoseVaccines)
# @Constraint Constr_3 @Def: At least MinimumSecondDose second-dose vaccines must be produced.
model.addConstr(SecondDoseVaccines >= MinimumSecondDose)

# Objective 
# @Objective Objective @Def: Minimize the total gelatine usage, which is the sum of GelatineFirstDose multiplied by the number of first-dose vaccines and GelatineSecondDose multiplied by the number of second-dose vaccines.
model.setObjective(GelatineFirstDose * FirstDoseVaccines + GelatineSecondDose * SecondDoseVaccines, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['FirstDoseVaccines'] = FirstDoseVaccines.x
variables['SecondDoseVaccines'] = SecondDoseVaccines.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"Both chemical A and chemical B need to be added to a mixer for making bread. One unit of chemical A takes 30 seconds to be effective while one unit of chemical B takes 45 seconds to be effective. Because chemical A can be dangerous, there has to be at most a third as much chemical A as chemical B in the mixer. If there has to be at least 300 units of chemical A in the mixer and at least 1500 units of total chemicals in the mixer, how many units of each should be added to minimize the total time it takes for the mixed bread to be ready?","{""variables"": {""QuantityChemicalA"": 375.0, ""QuantityChemicalB"": 1125.0}, ""objective"": 61875.0}","{""parametrized_description"": ""Determine the number of units of chemical A and chemical B to add to the mixer to minimize the total time for the mixed bread to be ready. Each unit of chemical A takes TimeChemicalA to become effective, and each unit of chemical B takes TimeChemicalB to become effective. The number of units of chemical A must be at least MinChemicalA, the total number of units of chemicals A and B must be at least MinTotalChemicals, and the number of units of chemical A must not exceed MaxRatioAtoB times the number of units of chemical B."", ""keywords"": [""N.A.""], ""parameters"": {""TimeChemicalA"": {""description"": ""Time for one unit of chemical A to become effective"", ""shape"": []}, ""TimeChemicalB"": {""description"": ""Time for one unit of chemical B to become effective"", ""shape"": []}, ""MaxRatioAtoB"": {""description"": ""Maximum ratio of chemical A to chemical B"", ""shape"": []}, ""MinChemicalA"": {""description"": ""Minimum units of chemical A required"", ""shape"": []}, ""MinTotalChemicals"": {""description"": ""Minimum total units of chemicals in the mixer"", ""shape"": []}}, ""variables"": {""QuantityChemicalA"": {""description"": ""The number of units of chemical A"", ""type"": ""continuous"", ""shape"": []}, ""QuantityChemicalB"": {""description"": ""The number of units of chemical B"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of units of chemical A must be at least MinChemicalA."", ""formulation"": ""QuantityChemicalA \\geq MinChemicalA"", ""code"": {""gurobipy"": ""model.addConstr(QuantityChemicalA >= MinChemicalA)""}}, {""description"": ""The total number of units of chemicals A and B must be at least MinTotalChemicals."", ""formulation"": ""QuantityChemicalA + QuantityChemicalB \\geq MinTotalChemicals"", ""code"": {""gurobipy"": ""model.addConstr(QuantityChemicalA + QuantityChemicalB >= MinTotalChemicals)""}}, {""description"": ""The number of units of chemical A must not exceed MaxRatioAtoB times the number of units of chemical B."", ""formulation"": ""QuantityChemicalA \\leq MaxRatioAtoB \\times QuantityChemicalB"", ""code"": {""gurobipy"": ""model.addConstr(QuantityChemicalA <= MaxRatioAtoB * QuantityChemicalB)""}}], ""objective"": {""description"": ""Minimize the total time for the mixed bread to be ready, calculated as (TimeChemicalA * Units of Chemical A) + (TimeChemicalB * Units of Chemical B)."", ""formulation"": ""Min \\left(TimeChemicalA \\cdot QuantityChemicalA + TimeChemicalB \\cdot QuantityChemicalB\\right)"", ""code"": {""gurobipy"": ""model.setObjective(TimeChemicalA * QuantityChemicalA + TimeChemicalB * QuantityChemicalB, GRB.MINIMIZE)""}}}","{""TimeChemicalA"": 30, ""TimeChemicalB"": 45, ""MaxRatioAtoB"": 0.3333333333333333, ""MinChemicalA"": 300, ""MinTotalChemicals"": 1500}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Determine the number of units of chemical A and chemical B to add to the mixer
to minimize the total time for the mixed bread to be ready. Each unit of
chemical A takes TimeChemicalA to become effective, and each unit of chemical B
takes TimeChemicalB to become effective. The number of units of chemical A must
be at least MinChemicalA, the total number of units of chemicals A and B must be
at least MinTotalChemicals, and the number of units of chemical A must not
exceed MaxRatioAtoB times the number of units of chemical B.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/265/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter TimeChemicalA @Def: Time for one unit of chemical A to become effective @Shape: [] 
TimeChemicalA = data['TimeChemicalA']
# @Parameter TimeChemicalB @Def: Time for one unit of chemical B to become effective @Shape: [] 
TimeChemicalB = data['TimeChemicalB']
# @Parameter MaxRatioAtoB @Def: Maximum ratio of chemical A to chemical B @Shape: [] 
MaxRatioAtoB = data['MaxRatioAtoB']
# @Parameter MinChemicalA @Def: Minimum units of chemical A required @Shape: [] 
MinChemicalA = data['MinChemicalA']
# @Parameter MinTotalChemicals @Def: Minimum total units of chemicals in the mixer @Shape: [] 
MinTotalChemicals = data['MinTotalChemicals']

# Variables 
# @Variable QuantityChemicalA @Def: The number of units of chemical A @Shape: [] 
QuantityChemicalA = model.addVar(vtype=GRB.CONTINUOUS, lb=MinChemicalA, name=""QuantityChemicalA"")
# @Variable QuantityChemicalB @Def: The number of units of chemical B @Shape: [] 
QuantityChemicalB = model.addVar(vtype=GRB.CONTINUOUS, name=""QuantityChemicalB"")

# Constraints 
# @Constraint Constr_1 @Def: The number of units of chemical A must be at least MinChemicalA.
model.addConstr(QuantityChemicalA >= MinChemicalA)
# @Constraint Constr_2 @Def: The total number of units of chemicals A and B must be at least MinTotalChemicals.
model.addConstr(QuantityChemicalA + QuantityChemicalB >= MinTotalChemicals)
# @Constraint Constr_3 @Def: The number of units of chemical A must not exceed MaxRatioAtoB times the number of units of chemical B.
model.addConstr(QuantityChemicalA <= MaxRatioAtoB * QuantityChemicalB)

# Objective 
# @Objective Objective @Def: Minimize the total time for the mixed bread to be ready, calculated as (TimeChemicalA * Units of Chemical A) + (TimeChemicalB * Units of Chemical B).
model.setObjective(TimeChemicalA * QuantityChemicalA + TimeChemicalB * QuantityChemicalB, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['QuantityChemicalA'] = QuantityChemicalA.x
variables['QuantityChemicalB'] = QuantityChemicalB.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A senior home has snacks of spinach and soybeans to increase their intake of iron. A cup of spinach contains 100 units of fibre and 5 mg of iron. A cup of soybeans contains 80 units of fibre and 12 mg of iron. Due to other nutritional requirements, the nurses decided that the number of cups of spinach must exceed the number of cups of soybeans. Furthermore, a cup of spinach contains 30 calories while a cup of soybeans contains 100 calories. If they schedule that the elderly need in total at least 12000 units of fibre and 300 mg of iron, how many cups of each should the nurses schedule to maximize the seniors’ total caloric intake?",{},"{""parametrized_description"": ""Maximize the total caloric intake by selecting the number of cups of spinach and soybeans. This involves maximizing CaloriesSpinach multiplied by the number of cups of spinach plus CaloriesSoybeans multiplied by the number of cups of soybeans. The selection must satisfy the following constraints: FiberSpinach multiplied by the number of cups of spinach plus FiberSoybeans multiplied by the number of cups of soybeans is at least MinFiber, IronSpinach multiplied by the number of cups of spinach plus IronSoybeans multiplied by the number of cups of soybeans is at least MinIron, and the number of cups of spinach exceeds the number of cups of soybeans."", ""keywords"": [""N.A.""], ""parameters"": {""FiberSpinach"": {""description"": ""Number of units of fiber in one cup of spinach"", ""shape"": []}, ""IronSpinach"": {""description"": ""Amount of iron (mg) in one cup of spinach"", ""shape"": []}, ""CaloriesSpinach"": {""description"": ""Number of calories in one cup of spinach"", ""shape"": []}, ""FiberSoybeans"": {""description"": ""Number of units of fiber in one cup of soybeans"", ""shape"": []}, ""IronSoybeans"": {""description"": ""Amount of iron (mg) in one cup of soybeans"", ""shape"": []}, ""CaloriesSoybeans"": {""description"": ""Number of calories in one cup of soybeans"", ""shape"": []}, ""MinFiber"": {""description"": ""Minimum total units of fiber required"", ""shape"": []}, ""MinIron"": {""description"": ""Minimum total amount of iron required (mg)"", ""shape"": []}}, ""variables"": {""CupsSpinach"": {""description"": ""The number of cups of spinach"", ""type"": ""continuous"", ""shape"": []}, ""CupsSoybeans"": {""description"": ""The number of cups of soybeans"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""FiberSpinach multiplied by the number of cups of spinach plus FiberSoybeans multiplied by the number of cups of soybeans is at least MinFiber."", ""formulation"": ""FiberSpinach \\cdot CupsSpinach + FiberSoybeans \\cdot CupsSoybeans \\geq MinFiber"", ""code"": {""gurobipy"": ""model.addConstr(FiberSpinach * CupsSpinach + FiberSoybeans * CupsSoybeans >= MinFiber)""}}, {""description"": ""IronSpinach multiplied by the number of cups of spinach plus IronSoybeans multiplied by the number of cups of soybeans is at least MinIron."", ""formulation"": ""IronSpinach \\cdot CupsSpinach + IronSoybeans \\cdot CupsSoybeans \\geq MinIron"", ""code"": {""gurobipy"": ""model.addConstr(IronSpinach * CupsSpinach + IronSoybeans * CupsSoybeans >= MinIron)""}}, {""description"": ""The number of cups of spinach exceeds the number of cups of soybeans."", ""formulation"": ""CupsSpinach \\geq CupsSoybeans"", ""code"": {""gurobipy"": ""model.addConstr(CupsSpinach >= CupsSoybeans)""}}], ""objective"": {""description"": ""Total caloric intake is CaloriesSpinach multiplied by the number of cups of spinach plus CaloriesSoybeans multiplied by the number of cups of soybeans. The objective is to maximize the total caloric intake."", ""formulation"": ""Max \\quad CaloriesSpinach \\times CupsSpinach + CaloriesSoybeans \\times CupsSoybeans"", ""code"": {""gurobipy"": ""model.setObjective(CaloriesSpinach * CupsSpinach + CaloriesSoybeans * CupsSoybeans, GRB.MAXIMIZE)""}}}","{""FiberSpinach"": 100, ""IronSpinach"": 5, ""CaloriesSpinach"": 30, ""FiberSoybeans"": 80, ""IronSoybeans"": 12, ""CaloriesSoybeans"": 100, ""MinFiber"": 12000, ""MinIron"": 300}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
Maximize the total caloric intake by selecting the number of cups of spinach and
soybeans. This involves maximizing CaloriesSpinach multiplied by the number of
cups of spinach plus CaloriesSoybeans multiplied by the number of cups of
soybeans. The selection must satisfy the following constraints: FiberSpinach
multiplied by the number of cups of spinach plus FiberSoybeans multiplied by the
number of cups of soybeans is at least MinFiber, IronSpinach multiplied by the
number of cups of spinach plus IronSoybeans multiplied by the number of cups of
soybeans is at least MinIron, and the number of cups of spinach exceeds the
number of cups of soybeans.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/266/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter FiberSpinach @Def: Number of units of fiber in one cup of spinach @Shape: [] 
FiberSpinach = data['FiberSpinach']
# @Parameter IronSpinach @Def: Amount of iron (mg) in one cup of spinach @Shape: [] 
IronSpinach = data['IronSpinach']
# @Parameter CaloriesSpinach @Def: Number of calories in one cup of spinach @Shape: [] 
CaloriesSpinach = data['CaloriesSpinach']
# @Parameter FiberSoybeans @Def: Number of units of fiber in one cup of soybeans @Shape: [] 
FiberSoybeans = data['FiberSoybeans']
# @Parameter IronSoybeans @Def: Amount of iron (mg) in one cup of soybeans @Shape: [] 
IronSoybeans = data['IronSoybeans']
# @Parameter CaloriesSoybeans @Def: Number of calories in one cup of soybeans @Shape: [] 
CaloriesSoybeans = data['CaloriesSoybeans']
# @Parameter MinFiber @Def: Minimum total units of fiber required @Shape: [] 
MinFiber = data['MinFiber']
# @Parameter MinIron @Def: Minimum total amount of iron required (mg) @Shape: [] 
MinIron = data['MinIron']

# Variables 
# @Variable CupsSpinach @Def: The number of cups of spinach @Shape: [] 
CupsSpinach = model.addVar(vtype=GRB.CONTINUOUS, name=""CupsSpinach"")
# @Variable CupsSoybeans @Def: The number of cups of soybeans @Shape: [] 
CupsSoybeans = model.addVar(vtype=GRB.CONTINUOUS, name=""CupsSoybeans"")

# Constraints 
# @Constraint Constr_1 @Def: FiberSpinach multiplied by the number of cups of spinach plus FiberSoybeans multiplied by the number of cups of soybeans is at least MinFiber.
model.addConstr(FiberSpinach * CupsSpinach + FiberSoybeans * CupsSoybeans >= MinFiber)
# @Constraint Constr_2 @Def: IronSpinach multiplied by the number of cups of spinach plus IronSoybeans multiplied by the number of cups of soybeans is at least MinIron.
model.addConstr(IronSpinach * CupsSpinach + IronSoybeans * CupsSoybeans >= MinIron)
# @Constraint Constr_3 @Def: The number of cups of spinach exceeds the number of cups of soybeans.
model.addConstr(CupsSpinach >= CupsSoybeans)

# Objective 
# @Objective Objective @Def: Total caloric intake is CaloriesSpinach multiplied by the number of cups of spinach plus CaloriesSoybeans multiplied by the number of cups of soybeans. The objective is to maximize the total caloric intake.
model.setObjective(CaloriesSpinach * CupsSpinach + CaloriesSoybeans * CupsSoybeans, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['CupsSpinach'] = CupsSpinach.x
variables['CupsSoybeans'] = CupsSoybeans.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A keyboard manufacturer makes mechanical and standard keyboards. Mechanical keyboards are becoming more popular and thus the manufacturer aims to have five times as many mechanical than standard keyboards. A mechanical keyboard costs five units of plastic and two units of solder whereas a standard keyboard costs two units of plastic and one unit of solder. There are still customers that prefer a less noisy alternative. Therefore, there must be at least 30 standard keyboards. If the company has available 1000 units of plastic and 250 units of solder, how many of each type should be manufactured to maximize the total number of keyboards?",{},"{""parametrized_description"": ""A manufacturer produces two types of keyboards: mechanical and standard. The number of mechanical keyboards should be MechanicalToStandardRatio times the number of standard keyboards. Each mechanical keyboard requires PlasticCostMechanical units of plastic and SolderCostMechanical units of solder, while each standard keyboard requires PlasticCostStandard units of plastic and SolderCostStandard units of solder. The total available plastic is TotalPlasticAvailable units and the total available solder is TotalSolderAvailable units. Additionally, the production of standard keyboards must be at least MinimumStandardKeyboards units. The objective is to maximize the total number of keyboards produced."", ""keywords"": [""N.A.""], ""parameters"": {""NumProductTypes"": {""description"": ""Number of different product types"", ""shape"": []}, ""PlasticCostMechanical"": {""description"": ""Units of plastic required to produce one mechanical keyboard"", ""shape"": []}, ""PlasticCostStandard"": {""description"": ""Units of plastic required to produce one standard keyboard"", ""shape"": []}, ""SolderCostMechanical"": {""description"": ""Units of solder required to produce one mechanical keyboard"", ""shape"": []}, ""SolderCostStandard"": {""description"": ""Units of solder required to produce one standard keyboard"", ""shape"": []}, ""MechanicalToStandardRatio"": {""description"": ""Desired ratio of mechanical keyboards to standard keyboards"", ""shape"": []}, ""MinimumStandardKeyboards"": {""description"": ""Minimum number of standard keyboards to be produced"", ""shape"": []}, ""TotalPlasticAvailable"": {""description"": ""Total units of plastic available"", ""shape"": []}, ""TotalSolderAvailable"": {""description"": ""Total units of solder available"", ""shape"": []}}, ""variables"": {""NumberMechanicalKeyboards"": {""description"": ""The number of mechanical keyboards"", ""type"": ""continuous"", ""shape"": []}, ""NumberStandardKeyboards"": {""description"": ""The number of standard keyboards"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of mechanical keyboards is equal to MechanicalToStandardRatio times the number of standard keyboards."", ""formulation"": ""NumberMechanicalKeyboards = MechanicalToStandardRatio \\times NumberStandardKeyboards"", ""code"": {""gurobipy"": ""model.addConstr(NumberMechanicalKeyboards == MechanicalToStandardRatio * NumberStandardKeyboards)""}}, {""description"": ""PlasticCostMechanical multiplied by the number of mechanical keyboards plus PlasticCostStandard multiplied by the number of standard keyboards does not exceed TotalPlasticAvailable units of plastic."", ""formulation"": ""PlasticCostMechanical \\cdot NumberMechanicalKeyboards + PlasticCostStandard \\cdot NumberStandardKeyboards \\leq TotalPlasticAvailable"", ""code"": {""gurobipy"": ""model.addConstr(PlasticCostMechanical * NumberMechanicalKeyboards + PlasticCostStandard * NumberStandardKeyboards <= TotalPlasticAvailable)""}}, {""description"": ""SolderCostMechanical multiplied by the number of mechanical keyboards plus SolderCostStandard multiplied by the number of standard keyboards does not exceed TotalSolderAvailable units of solder."", ""formulation"": ""SolderCostMechanical \\cdot NumberMechanicalKeyboards + SolderCostStandard \\cdot NumberStandardKeyboards \\leq TotalSolderAvailable"", ""code"": {""gurobipy"": ""model.addConstr(SolderCostMechanical * NumberMechanicalKeyboards + SolderCostStandard * NumberStandardKeyboards <= TotalSolderAvailable)""}}, {""description"": ""The number of standard keyboards produced is at least MinimumStandardKeyboards."", ""formulation"": ""NumberStandardKeyboards \\geq MinimumStandardKeyboards"", ""code"": {""gurobipy"": ""model.addConstr(NumberStandardKeyboards >= MinimumStandardKeyboards)""}}], ""objective"": {""description"": ""Maximize the total number of keyboards produced."", ""formulation"": ""Max\\left(NumberMechanicalKeyboards + NumberStandardKeyboards\\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumberMechanicalKeyboards + NumberStandardKeyboards, GRB.MAXIMIZE)""}}}","{""NumProductTypes"": 2, ""PlasticCostMechanical"": 5, ""PlasticCostStandard"": 2, ""SolderCostMechanical"": 2, ""SolderCostStandard"": 1, ""MechanicalToStandardRatio"": 5, ""MinimumStandardKeyboards"": 30, ""TotalPlasticAvailable"": 1000, ""TotalSolderAvailable"": 250}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A manufacturer produces two types of keyboards: mechanical and standard. The
number of mechanical keyboards should be MechanicalToStandardRatio times the
number of standard keyboards. Each mechanical keyboard requires
PlasticCostMechanical units of plastic and SolderCostMechanical units of solder,
while each standard keyboard requires PlasticCostStandard units of plastic and
SolderCostStandard units of solder. The total available plastic is
TotalPlasticAvailable units and the total available solder is
TotalSolderAvailable units. Additionally, the production of standard keyboards
must be at least MinimumStandardKeyboards units. The objective is to maximize
the total number of keyboards produced.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/267/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter NumProductTypes @Def: Number of different product types @Shape: [] 
NumProductTypes = data['NumProductTypes']
# @Parameter PlasticCostMechanical @Def: Units of plastic required to produce one mechanical keyboard @Shape: [] 
PlasticCostMechanical = data['PlasticCostMechanical']
# @Parameter PlasticCostStandard @Def: Units of plastic required to produce one standard keyboard @Shape: [] 
PlasticCostStandard = data['PlasticCostStandard']
# @Parameter SolderCostMechanical @Def: Units of solder required to produce one mechanical keyboard @Shape: [] 
SolderCostMechanical = data['SolderCostMechanical']
# @Parameter SolderCostStandard @Def: Units of solder required to produce one standard keyboard @Shape: [] 
SolderCostStandard = data['SolderCostStandard']
# @Parameter MechanicalToStandardRatio @Def: Desired ratio of mechanical keyboards to standard keyboards @Shape: [] 
MechanicalToStandardRatio = data['MechanicalToStandardRatio']
# @Parameter MinimumStandardKeyboards @Def: Minimum number of standard keyboards to be produced @Shape: [] 
MinimumStandardKeyboards = data['MinimumStandardKeyboards']
# @Parameter TotalPlasticAvailable @Def: Total units of plastic available @Shape: [] 
TotalPlasticAvailable = data['TotalPlasticAvailable']
# @Parameter TotalSolderAvailable @Def: Total units of solder available @Shape: [] 
TotalSolderAvailable = data['TotalSolderAvailable']

# Variables 
# @Variable NumberMechanicalKeyboards @Def: The number of mechanical keyboards @Shape: [] 
NumberMechanicalKeyboards = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberMechanicalKeyboards"")
# @Variable NumberStandardKeyboards @Def: The number of standard keyboards @Shape: [] 
NumberStandardKeyboards = model.addVar(vtype=GRB.CONTINUOUS, name=""NumberStandardKeyboards"")

# Constraints 
# @Constraint Constr_1 @Def: The number of mechanical keyboards is equal to MechanicalToStandardRatio times the number of standard keyboards.
model.addConstr(NumberMechanicalKeyboards == MechanicalToStandardRatio * NumberStandardKeyboards)
# @Constraint Constr_2 @Def: PlasticCostMechanical multiplied by the number of mechanical keyboards plus PlasticCostStandard multiplied by the number of standard keyboards does not exceed TotalPlasticAvailable units of plastic.
model.addConstr(PlasticCostMechanical * NumberMechanicalKeyboards + PlasticCostStandard * NumberStandardKeyboards <= TotalPlasticAvailable)
# @Constraint Constr_3 @Def: SolderCostMechanical multiplied by the number of mechanical keyboards plus SolderCostStandard multiplied by the number of standard keyboards does not exceed TotalSolderAvailable units of solder.
model.addConstr(SolderCostMechanical * NumberMechanicalKeyboards + SolderCostStandard * NumberStandardKeyboards <= TotalSolderAvailable)
# @Constraint Constr_4 @Def: The number of standard keyboards produced is at least MinimumStandardKeyboards.
model.addConstr(NumberStandardKeyboards >= MinimumStandardKeyboards)

# Objective 
# @Objective Objective @Def: Maximize the total number of keyboards produced.
model.setObjective(NumberMechanicalKeyboards + NumberStandardKeyboards, GRB.MAXIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberMechanicalKeyboards'] = NumberMechanicalKeyboards.x
variables['NumberStandardKeyboards'] = NumberStandardKeyboards.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A tourism company can buy sedans or buses to add to their fleet of vehicles to increase their capacity for more tourists. A sedan can seat 50 tourists per day but results in 10 units of pollution. A bus can seat 250 tourists per day but results in 40 units of pollution. The city has limited this tourism company to producing at most 800 units of pollutants per day. To make a profit, this tourism company must take care of at least 4600 customers per day. Planning to make a profit, how many sedans and how many buses should this tourism company purchase to decrease the total number of vehicles needed?","{""variables"": {""NumberOfSedans"": 0.0, ""NumberOfBuses"": 19.0}, ""objective"": 19.0}","{""parametrized_description"": ""A tourism company can purchase sedans and buses. Each sedan seats SedanCapacity tourists per day and produces SedanPollution units of pollution per day. Each bus seats BusCapacity tourists per day and produces BusPollution units of pollution per day. The company is limited to a maximum of MaxPollution units of pollution per day. To be profitable, the company must serve at least MinCustomers customers per day. The goal is to determine the number of sedans and buses to purchase in order to minimize the total number of vehicles needed."", ""keywords"": [""N.A.""], ""parameters"": {""SedanCapacity"": {""description"": ""Number of tourists that a sedan can seat per day"", ""shape"": []}, ""SedanPollution"": {""description"": ""Units of pollution resulting from one sedan per day"", ""shape"": []}, ""BusCapacity"": {""description"": ""Number of tourists that a bus can seat per day"", ""shape"": []}, ""BusPollution"": {""description"": ""Units of pollution resulting from one bus per day"", ""shape"": []}, ""MaxPollution"": {""description"": ""Maximum units of pollution allowed per day"", ""shape"": []}, ""MinCustomers"": {""description"": ""Minimum number of customers required per day"", ""shape"": []}}, ""variables"": {""NumberOfSedans"": {""description"": ""The number of sedans used per day"", ""type"": ""continuous"", ""shape"": []}, ""NumberOfBuses"": {""description"": ""The number of buses used per day"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The total pollution produced by the vehicles cannot exceed MaxPollution units per day. This is calculated as SedanPollution multiplied by the number of sedans plus BusPollution multiplied by the number of buses."", ""formulation"": ""SedanPollution \\cdot NumberOfSedans + BusPollution \\cdot NumberOfBuses \\leq MaxPollution"", ""code"": {""gurobipy"": ""model.addConstr(SedanPollution * NumberOfSedans + BusPollution * NumberOfBuses <= MaxPollution)""}}, {""description"": ""The company must serve at least MinCustomers customers per day. This is achieved by ensuring that SedanCapacity multiplied by the number of sedans plus BusCapacity multiplied by the number of buses is at least MinCustomers."", ""formulation"": ""SedanCapacity \\times NumberOfSedans + BusCapacity \\times NumberOfBuses \\geq MinCustomers"", ""code"": {""gurobipy"": ""model.addConstr(SedanCapacity * NumberOfSedans + BusCapacity * NumberOfBuses >= MinCustomers)""}}], ""objective"": {""description"": ""Minimize the total number of vehicles needed, which is the sum of the number of sedans and the number of buses purchased."", ""formulation"": ""Min \\left( NumberOfSedans + NumberOfBuses \\right)"", ""code"": {""gurobipy"": ""model.setObjective(NumberOfSedans + NumberOfBuses, GRB.MINIMIZE)""}}}","{""SedanCapacity"": 50, ""SedanPollution"": 10, ""BusCapacity"": 250, ""BusPollution"": 40, ""MaxPollution"": 800, ""MinCustomers"": 4600}","# Code automatically generated from OptiMUS

# Problem type: MIP        
# Problem description
'''
A tourism company can purchase sedans and buses. Each sedan seats SedanCapacity
tourists per day and produces SedanPollution units of pollution per day. Each
bus seats BusCapacity tourists per day and produces BusPollution units of
pollution per day. The company is limited to a maximum of MaxPollution units of
pollution per day. To be profitable, the company must serve at least
MinCustomers customers per day. The goal is to determine the number of sedans
and buses to purchase in order to minimize the total number of vehicles needed.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/268/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target
        
# Parameters 
# @Parameter SedanCapacity @Def: Number of tourists that a sedan can seat per day @Shape: [] 
SedanCapacity = data['SedanCapacity']
# @Parameter SedanPollution @Def: Units of pollution resulting from one sedan per day @Shape: [] 
SedanPollution = data['SedanPollution']
# @Parameter BusCapacity @Def: Number of tourists that a bus can seat per day @Shape: [] 
BusCapacity = data['BusCapacity']
# @Parameter BusPollution @Def: Units of pollution resulting from one bus per day @Shape: [] 
BusPollution = data['BusPollution']
# @Parameter MaxPollution @Def: Maximum units of pollution allowed per day @Shape: [] 
MaxPollution = data['MaxPollution']
# @Parameter MinCustomers @Def: Minimum number of customers required per day @Shape: [] 
MinCustomers = data['MinCustomers']

# Variables 
# @Variable NumberOfSedans @Def: The number of sedans used per day @Shape: [] 
NumberOfSedans = model.addVar(vtype=GRB.INTEGER, name=""NumberOfSedans"")
# @Variable NumberOfBuses @Def: The number of buses used per day @Shape: [] 
NumberOfBuses = model.addVar(vtype=GRB.INTEGER, name=""NumberOfBuses"")

# Constraints 
# @Constraint Constr_1 @Def: The total pollution produced by the vehicles cannot exceed MaxPollution units per day. This is calculated as SedanPollution multiplied by the number of sedans plus BusPollution multiplied by the number of buses.
model.addConstr(SedanPollution * NumberOfSedans + BusPollution * NumberOfBuses <= MaxPollution)
# @Constraint Constr_2 @Def: The company must serve at least MinCustomers customers per day. This is achieved by ensuring that SedanCapacity multiplied by the number of sedans plus BusCapacity multiplied by the number of buses is at least MinCustomers.
model.addConstr(SedanCapacity * NumberOfSedans + BusCapacity * NumberOfBuses >= MinCustomers)

# Objective 
# @Objective Objective @Def: Minimize the total number of vehicles needed, which is the sum of the number of sedans and the number of buses purchased.
model.setObjective(NumberOfSedans + NumberOfBuses, GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['NumberOfSedans'] = NumberOfSedans.x
variables['NumberOfBuses'] = NumberOfBuses.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
"A dessert shop is popular for their only two desserts - matcha ice cream and orange sorbet. Two units of flavouring and four units of ice cream is required to make one order of matcha ice cream. Four units of flavouring and three units of water is required to make an order of orange sorbet. The dessert shop has recently been getting more orders online for orange sorbet and therefore, there should be more orange sorbet made than matcha ice cream. However, at least fifteen percent of desserts made must be matcha ice cream. The dessert shop has available 600 units of ice cream and 550 units of water. How many of each dessert should the shop make to minimize the total amount of flavouring needed?","{""variables"": {""MatchaIceCream"": 0.0, ""OrangeSorbet"": 0.0}, ""objective"": 0.0}","{""parametrized_description"": ""A dessert shop produces NumDessertTypes different desserts using NumIngredients different ingredients. The ResourceUsage matrix specifies the amount of each ingredient required per dessert. The shop must produce more of one dessert type than another and ensure that at least a proportion MinMatchaProportion of the total desserts are of a specific type. The total usage of each ingredient must not exceed AvailableIngredients. The objective is to minimize the total amount of flavouring required."", ""keywords"": [""N.A.""], ""parameters"": {""NumDessertTypes"": {""description"": ""Number of different dessert types"", ""shape"": []}, ""NumIngredients"": {""description"": ""Number of different ingredients"", ""shape"": []}, ""ResourceUsage"": {""description"": ""Amount of each ingredient required to produce one unit of each dessert"", ""shape"": [""NumIngredients"", ""NumDessertTypes""]}, ""AvailableIngredients"": {""description"": ""Total available units of each ingredient"", ""shape"": [""NumIngredients""]}, ""MinMatchaProportion"": {""description"": ""Minimum proportion of desserts that must be matcha ice cream"", ""shape"": []}}, ""variables"": {""MatchaIceCream"": {""description"": ""The number of matcha ice cream desserts produced"", ""type"": ""continuous"", ""shape"": []}, ""OrangeSorbet"": {""description"": ""The number of orange sorbet desserts produced"", ""type"": ""continuous"", ""shape"": []}}, ""constraints"": [{""description"": ""The number of matcha ice cream desserts produced must be greater than the number of orange sorbet desserts produced."", ""formulation"": ""MatchaIceCream \\geq OrangeSorbet"", ""code"": {""gurobipy"": ""model.addConstr(MatchaIceCream >= OrangeSorbet)""}}, {""description"": ""At least a proportion MinMatchaProportion of the total desserts must be matcha ice cream."", ""formulation"": ""MatchaIceCream \\geq MinMatchaProportion \\times (MatchaIceCream + OrangeSorbet)"", ""code"": {""gurobipy"": ""model.addConstr(MatchaIceCream >= MinMatchaProportion * (MatchaIceCream + OrangeSorbet))""}}, {""description"": ""The total usage of each ingredient must not exceed AvailableIngredients."", ""formulation"": ""\\text{ResourceUsage}_{i,1} \\times \\text{MatchaIceCream} + \\text{ResourceUsage}_{i,2} \\times \\text{OrangeSorbet} \\leq \\text{AvailableIngredients}_i, \\quad \\forall i \\in \\{1, \\dots, \\text{NumIngredients}\\}"", ""code"": {""gurobipy"": ""for i in range(NumIngredients):\n    model.addConstr(ResourceUsage[i][0] * MatchaIceCream + ResourceUsage[i][1] * OrangeSorbet <= AvailableIngredients[i])""}}], ""objective"": {""description"": ""The objective is to minimize the total amount of flavouring required."", ""formulation"": ""Min \\sum_{i=1}^{NumIngredients} \\left( ResourceUsage_{i, \\text{MatchaIceCream}} \\cdot \\text{MatchaIceCream} + ResourceUsage_{i, \\text{OrangeSorbet}} \\cdot \\text{OrangeSorbet} \\right)"", ""code"": {""gurobipy"": ""model.setObjective(quicksum(ResourceUsage[i, 0] * MatchaIceCream + ResourceUsage[i, 1] * OrangeSorbet for i in range(NumIngredients)), GRB.MINIMIZE)""}}}","{""NumDessertTypes"": 2, ""NumIngredients"": 2, ""ResourceUsage"": [[4, 0], [0, 3]], ""AvailableIngredients"": [600, 550], ""MinMatchaProportion"": 0.15}","# Code automatically generated from OptiMUS

# Problem type: LP        
# Problem description
'''
A dessert shop produces NumDessertTypes different desserts using NumIngredients
different ingredients. The ResourceUsage matrix specifies the amount of each
ingredient required per dessert. The shop must produce more of one dessert type
than another and ensure that at least a proportion MinMatchaProportion of the
total desserts are of a specific type. The total usage of each ingredient must
not exceed AvailableIngredients. The objective is to minimize the total amount
of flavouring required.
'''
# Import necessary libraries
import json
from gurobipy import *
     
# Create a new model
model = Model()

# Load data 
with open(""/Users/gaowenzhi/Desktop/optimus-OR-paper/data/new_dataset/sample_datasets/269/parameters.json"", ""r"") as f:
    data = json.load(f)
    
# @Def: definition of a target
# @Shape: shape of a target        
        
# Parameters 
# @Parameter NumDessertTypes @Def: Number of different dessert types @Shape: [] 
NumDessertTypes = data['NumDessertTypes']
# @Parameter NumIngredients @Def: Number of different ingredients @Shape: [] 
NumIngredients = data['NumIngredients']
# @Parameter ResourceUsage @Def: Amount of each ingredient required to produce one unit of each dessert @Shape: ['NumIngredients', 'NumDessertTypes'] 
ResourceUsage = data['ResourceUsage']
# @Parameter AvailableIngredients @Def: Total available units of each ingredient @Shape: ['NumIngredients'] 
AvailableIngredients = data['AvailableIngredients']
# @Parameter MinMatchaProportion @Def: Minimum proportion of desserts that must be matcha ice cream @Shape: [] 
MinMatchaProportion = data['MinMatchaProportion']

# Variables 
# @Variable MatchaIceCream @Def: The number of matcha ice cream desserts produced @Shape: [] 
MatchaIceCream = model.addVar(vtype=GRB.CONTINUOUS, name=""MatchaIceCream"")
# @Variable OrangeSorbet @Def: The number of orange sorbet desserts produced @Shape: [] 
OrangeSorbet = model.addVar(vtype=GRB.CONTINUOUS, name=""OrangeSorbet"")

# Constraints 
# @Constraint Constr_1 @Def: The number of matcha ice cream desserts produced must be greater than the number of orange sorbet desserts produced.
model.addConstr(MatchaIceCream >= OrangeSorbet)
# @Constraint Constr_2 @Def: At least a proportion MinMatchaProportion of the total desserts must be matcha ice cream.
model.addConstr(MatchaIceCream >= MinMatchaProportion * (MatchaIceCream + OrangeSorbet))
# @Constraint Constr_3 @Def: The total usage of each ingredient must not exceed AvailableIngredients.
for i in range(NumIngredients):
    model.addConstr(ResourceUsage[i][0] * MatchaIceCream + ResourceUsage[i][1] * OrangeSorbet <= AvailableIngredients[i])

# Objective 
# @Objective Objective @Def: The objective is to minimize the total amount of flavouring required.
model.setObjective(quicksum(ResourceUsage[i][0] * MatchaIceCream + ResourceUsage[i][1] * OrangeSorbet for i in range(NumIngredients)), GRB.MINIMIZE)

# Solve 
model.optimize()

# Extract solution 
solution = {}
variables = {}
objective = []
variables['MatchaIceCream'] = MatchaIceCream.x
variables['OrangeSorbet'] = OrangeSorbet.x
solution['variables'] = variables
solution['objective'] = model.objVal
with open('solution.json', 'w') as f:
    json.dump(solution, f, indent=4)
"
